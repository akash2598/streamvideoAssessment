{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _TextTrackInfo = require('../vo/TextTrackInfo');\n\nvar _TextTrackInfo2 = _interopRequireDefault(_TextTrackInfo);\n\nvar _BoxParser = require('../utils/BoxParser');\n\nvar _BoxParser2 = _interopRequireDefault(_BoxParser);\n\nvar _CustomTimeRanges = require('../utils/CustomTimeRanges');\n\nvar _CustomTimeRanges2 = _interopRequireDefault(_CustomTimeRanges);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _TextTracks = require('./TextTracks');\n\nvar _TextTracks2 = _interopRequireDefault(_TextTracks);\n\nvar _EmbeddedTextHtmlRender = require('./EmbeddedTextHtmlRender');\n\nvar _EmbeddedTextHtmlRender2 = _interopRequireDefault(_EmbeddedTextHtmlRender);\n\nvar _codemIsoboxer = require('codem-isoboxer');\n\nvar _codemIsoboxer2 = _interopRequireDefault(_codemIsoboxer);\n\nvar _cea608Parser = require('../../../externals/cea608-parser');\n\nvar _cea608Parser2 = _interopRequireDefault(_cea608Parser);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _DashJSError = require('../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Errors = require('../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction TextSourceBuffer() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var embeddedInitialized = false;\n  var instance = void 0,\n      logger = void 0,\n      boxParser = void 0,\n      errHandler = void 0,\n      adapter = void 0,\n      manifestModel = void 0,\n      mediaController = void 0,\n      parser = void 0,\n      vttParser = void 0,\n      ttmlParser = void 0,\n      mediaInfos = void 0,\n      textTracks = void 0,\n      fragmentedFragmentModel = void 0,\n      initializationSegmentReceived = void 0,\n      timescale = void 0,\n      fragmentedTracks = void 0,\n      videoModel = void 0,\n      streamController = void 0,\n      firstFragmentedSubtitleStart = void 0,\n      currFragmentedTrackIdx = void 0,\n      embeddedTracks = void 0,\n      embeddedTimescale = void 0,\n      embeddedLastSequenceNumber = void 0,\n      embeddedCea608FieldParsers = void 0,\n      embeddedTextHtmlRender = void 0,\n      mseTimeOffset = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n  }\n\n  function resetFragmented() {\n    fragmentedFragmentModel = null;\n    timescale = NaN;\n    fragmentedTracks = [];\n    firstFragmentedSubtitleStart = null;\n    initializationSegmentReceived = false;\n  }\n\n  function resetInitialSettings() {\n    resetFragmented();\n    mediaInfos = [];\n    parser = null;\n  }\n\n  function initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n    if (!embeddedInitialized) {\n      initEmbedded();\n    }\n\n    textTracks.setConfig({\n      videoModel: videoModel\n    });\n    textTracks.initialize();\n\n    if (!boxParser) {\n      boxParser = (0, _BoxParser2.default)(context).getInstance();\n    }\n\n    addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n  }\n\n  function addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n    var isFragmented = !adapter.getIsTextTrack(mimeType);\n    mediaInfos = mediaInfos.concat(mediaInfoArr);\n\n    if (isFragmented) {\n      fragmentedFragmentModel = fragmentModel;\n      instance.buffered = (0, _CustomTimeRanges2.default)(context).create();\n      fragmentedTracks = mediaController.getTracksFor(_Constants2.default.FRAGMENTED_TEXT, streamInfo);\n      var currFragTrack = mediaController.getCurrentTrackFor(_Constants2.default.FRAGMENTED_TEXT, streamInfo);\n\n      for (var i = 0; i < fragmentedTracks.length; i++) {\n        if (fragmentedTracks[i] === currFragTrack) {\n          setCurrentFragmentedTrackIdx(i);\n          break;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < mediaInfos.length; _i++) {\n      createTextTrackFromMediaInfo(null, mediaInfos[_i]);\n    }\n  }\n\n  function abort() {\n    textTracks.deleteAllTextTracks();\n    resetFragmented();\n    boxParser = null;\n    mediaInfos = [];\n  }\n\n  function reset() {\n    resetInitialSettings();\n    streamController = null;\n    videoModel = null;\n    textTracks = null;\n  }\n\n  function onVideoChunkReceived(e) {\n    var chunk = e.chunk;\n\n    if (chunk.mediaInfo.embeddedCaptions) {\n      append(chunk.bytes, chunk);\n    }\n  }\n\n  function initEmbedded() {\n    embeddedTracks = [];\n    textTracks = (0, _TextTracks2.default)(context).getInstance();\n    textTracks.setConfig({\n      videoModel: videoModel\n    });\n    textTracks.initialize();\n    boxParser = (0, _BoxParser2.default)(context).getInstance();\n    currFragmentedTrackIdx = null;\n    embeddedTimescale = 0;\n    embeddedCea608FieldParsers = [];\n    embeddedLastSequenceNumber = null;\n    embeddedInitialized = true;\n    embeddedTextHtmlRender = (0, _EmbeddedTextHtmlRender2.default)(context).getInstance();\n    var streamProcessors = streamController.getActiveStreamProcessors();\n\n    for (var i in streamProcessors) {\n      if (streamProcessors[i].getType() === 'video') {\n        mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset;\n        break;\n      }\n    }\n\n    eventBus.on(_Events2.default.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n    eventBus.on(_Events2.default.BUFFER_CLEARED, onVideoBufferCleared, this);\n  }\n\n  function resetEmbedded() {\n    eventBus.off(_Events2.default.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n    eventBus.off(_Events2.default.BUFFER_CLEARED, onVideoBufferCleared, this);\n\n    if (textTracks) {\n      textTracks.deleteAllTextTracks();\n    }\n\n    embeddedInitialized = false;\n    embeddedTracks = [];\n    embeddedCea608FieldParsers = [null, null];\n    embeddedLastSequenceNumber = null;\n  }\n\n  function addEmbeddedTrack(mediaInfo) {\n    if (!embeddedInitialized) {\n      initEmbedded();\n    }\n\n    if (mediaInfo) {\n      if (mediaInfo.id === _Constants2.default.CC1 || mediaInfo.id === _Constants2.default.CC3) {\n        for (var i = 0; i < embeddedTracks.length; i++) {\n          if (embeddedTracks[i].id === mediaInfo.id) {\n            return;\n          }\n        }\n\n        embeddedTracks.push(mediaInfo);\n      } else {\n        logger.warn('Embedded track ' + mediaInfo.id + ' not supported!');\n      }\n    }\n  }\n\n  function setConfig(config) {\n    if (!config) {\n      return;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.manifestModel) {\n      manifestModel = config.manifestModel;\n    }\n\n    if (config.mediaController) {\n      mediaController = config.mediaController;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.textTracks) {\n      textTracks = config.textTracks;\n    }\n\n    if (config.vttParser) {\n      vttParser = config.vttParser;\n    }\n\n    if (config.ttmlParser) {\n      ttmlParser = config.ttmlParser;\n    }\n  }\n\n  function getConfig() {\n    var config = {\n      fragmentModel: fragmentedFragmentModel,\n      fragmentedTracks: fragmentedTracks,\n      videoModel: videoModel\n    };\n    return config;\n  }\n\n  function setCurrentFragmentedTrackIdx(idx) {\n    currFragmentedTrackIdx = idx;\n  }\n\n  function createTextTrackFromMediaInfo(captionData, mediaInfo) {\n    var textTrackInfo = new _TextTrackInfo2.default();\n    var trackKindMap = {\n      subtitle: 'subtitles',\n      caption: 'captions'\n    }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n\n    var getKind = function getKind() {\n      var kind = mediaInfo.roles.length > 0 ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n      kind = kind === trackKindMap.caption || kind === trackKindMap.subtitle ? kind : trackKindMap.caption;\n      return kind;\n    };\n\n    var checkTTML = function checkTTML() {\n      var ttml = false;\n\n      if (mediaInfo.codec && mediaInfo.codec.search(_Constants2.default.STPP) >= 0) {\n        ttml = true;\n      }\n\n      if (mediaInfo.mimeType && mediaInfo.mimeType.search(_Constants2.default.TTML) >= 0) {\n        ttml = true;\n      }\n\n      return ttml;\n    };\n\n    textTrackInfo.captionData = captionData;\n    textTrackInfo.lang = mediaInfo.lang;\n    textTrackInfo.labels = mediaInfo.labels;\n    textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index\n\n    textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest\n\n    textTrackInfo.isTTML = checkTTML();\n    textTrackInfo.defaultTrack = getIsDefault(mediaInfo);\n    textTrackInfo.isFragmented = !adapter.getIsTextTrack(mediaInfo.mimeType);\n    textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false;\n    textTrackInfo.kind = getKind();\n    textTrackInfo.roles = mediaInfo.roles;\n    textTrackInfo.accessibility = mediaInfo.accessibility;\n    var totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length;\n    textTracks.addTextTrack(textTrackInfo, totalNrTracks);\n  }\n\n  function append(bytes, chunk) {\n    var result = void 0,\n        sampleList = void 0,\n        i = void 0,\n        j = void 0,\n        k = void 0,\n        samplesInfo = void 0,\n        ccContent = void 0;\n    var mediaInfo = chunk.mediaInfo;\n    var mediaType = mediaInfo.type;\n    var mimeType = mediaInfo.mimeType;\n    var codecType = mediaInfo.codec || mimeType;\n\n    if (!codecType) {\n      logger.error('No text type defined');\n      return;\n    }\n\n    if (mediaType === _Constants2.default.FRAGMENTED_TEXT) {\n      if (!initializationSegmentReceived && chunk.segmentType === 'InitializationSegment') {\n        initializationSegmentReceived = true;\n        timescale = boxParser.getMediaTimescaleFromMoov(bytes);\n      } else {\n        if (!initializationSegmentReceived) {\n          return;\n        }\n\n        samplesInfo = boxParser.getSamplesInfo(bytes);\n        sampleList = samplesInfo.sampleList;\n\n        if (firstFragmentedSubtitleStart === null && sampleList.length > 0) {\n          firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale;\n        }\n\n        if (codecType.search(_Constants2.default.STPP) >= 0) {\n          parser = parser !== null ? parser : getParser(codecType);\n\n          for (i = 0; i < sampleList.length; i++) {\n            var sample = sampleList[i];\n            var sampleStart = sample.cts;\n            var sampleRelStart = sampleStart - firstFragmentedSubtitleStart;\n            this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale);\n            var dataView = new DataView(bytes, sample.offset, sample.subSizes[0]);\n            ccContent = _codemIsoboxer2.default.Utils.dataViewToString(dataView, _Constants2.default.UTF8);\n            var images = [];\n            var subOffset = sample.offset + sample.subSizes[0];\n\n            for (j = 1; j < sample.subSizes.length; j++) {\n              var inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]);\n              var raw = String.fromCharCode.apply(null, inData);\n              images.push(raw);\n              subOffset += sample.subSizes[j];\n            }\n\n            try {\n              // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset.\n              var manifest = manifestModel.getValue();\n              var offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0;\n              result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images);\n              textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result);\n            } catch (e) {\n              fragmentedFragmentModel.removeExecutedRequestsBeforeTime();\n              this.remove();\n              logger.error('TTML parser error: ' + e.message);\n            }\n          }\n        } else {\n          // WebVTT case\n          var captionArray = [];\n\n          for (i = 0; i < sampleList.length; i++) {\n            var _sample = sampleList[i];\n            _sample.cts -= firstFragmentedSubtitleStart;\n            this.buffered.add(_sample.cts / timescale, (_sample.cts + _sample.duration) / timescale);\n            var sampleData = bytes.slice(_sample.offset, _sample.offset + _sample.size); // There are boxes inside the sampleData, so we need a ISOBoxer to get at it.\n\n            var sampleBoxes = _codemIsoboxer2.default.parseBuffer(sampleData);\n\n            for (j = 0; j < sampleBoxes.boxes.length; j++) {\n              var box1 = sampleBoxes.boxes[j];\n              logger.debug('VTT box1: ' + box1.type);\n\n              if (box1.type === 'vtte') {\n                continue; //Empty box\n              }\n\n              if (box1.type === 'vttc') {\n                logger.debug('VTT vttc boxes.length = ' + box1.boxes.length);\n\n                for (k = 0; k < box1.boxes.length; k++) {\n                  var box2 = box1.boxes[k];\n                  logger.debug('VTT box2: ' + box2.type);\n\n                  if (box2.type === 'payl') {\n                    var cue_text = box2.cue_text;\n                    logger.debug('VTT cue_text = ' + cue_text);\n                    var start_time = _sample.cts / timescale;\n                    var end_time = (_sample.cts + _sample.duration) / timescale;\n                    captionArray.push({\n                      start: start_time,\n                      end: end_time,\n                      data: cue_text,\n                      styles: {}\n                    });\n                    logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text);\n                  }\n                }\n              }\n            }\n          }\n\n          if (captionArray.length > 0) {\n            textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray);\n          }\n        }\n      }\n    } else if (mediaType === _Constants2.default.TEXT) {\n      var _dataView = new DataView(bytes, 0, bytes.byteLength);\n\n      ccContent = _codemIsoboxer2.default.Utils.dataViewToString(_dataView, _Constants2.default.UTF8);\n\n      try {\n        result = getParser(codecType).parse(ccContent, 0);\n        textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result);\n      } catch (e) {\n        errHandler.error(new _DashJSError2.default(_Errors2.default.TIMED_TEXT_ERROR_ID_PARSE_CODE, _Errors2.default.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent));\n      }\n    } else if (mediaType === _Constants2.default.VIDEO) {\n      //embedded text\n      if (chunk.segmentType === _HTTPRequest.HTTPRequest.INIT_SEGMENT_TYPE) {\n        if (embeddedTimescale === 0) {\n          embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes);\n\n          for (i = 0; i < embeddedTracks.length; i++) {\n            createTextTrackFromMediaInfo(null, embeddedTracks[i]);\n          }\n        }\n      } else {\n        // MediaSegment\n        if (embeddedTimescale === 0) {\n          logger.warn('CEA-608: No timescale for embeddedTextTrack yet');\n          return;\n        }\n\n        var makeCueAdderForIndex = function makeCueAdderForIndex(self, trackIndex) {\n          function newCue(startTime, endTime, captionScreen) {\n            var captionsArray = null;\n\n            if (videoModel.getTTMLRenderingDiv()) {\n              captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen);\n            } else {\n              var text = captionScreen.getDisplayText();\n              captionsArray = [{\n                start: startTime,\n                end: endTime,\n                data: text,\n                styles: {}\n              }];\n            }\n\n            if (captionsArray) {\n              textTracks.addCaptions(trackIndex, 0, captionsArray);\n            }\n          }\n\n          return newCue;\n        };\n\n        samplesInfo = boxParser.getSamplesInfo(bytes);\n        var sequenceNumber = samplesInfo.lastSequenceNumber;\n\n        if (!embeddedCea608FieldParsers[0] && !embeddedCea608FieldParsers[1]) {\n          // Time to setup the CEA-608 parsing\n          var field = void 0,\n              handler = void 0,\n              trackIdx = void 0;\n\n          for (i = 0; i < embeddedTracks.length; i++) {\n            if (embeddedTracks[i].id === _Constants2.default.CC1) {\n              field = 0;\n              trackIdx = textTracks.getTrackIdxForId(_Constants2.default.CC1);\n            } else if (embeddedTracks[i].id === _Constants2.default.CC3) {\n              field = 1;\n              trackIdx = textTracks.getTrackIdxForId(_Constants2.default.CC3);\n            }\n\n            if (trackIdx === -1) {\n              logger.warn('CEA-608: data before track is ready.');\n              return;\n            }\n\n            handler = makeCueAdderForIndex(this, trackIdx);\n            embeddedCea608FieldParsers[i] = new _cea608Parser2.default.Cea608Parser(i + 1, {\n              'newCue': handler\n            }, null);\n          }\n        }\n\n        if (embeddedTimescale) {\n          if (embeddedLastSequenceNumber !== null && sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) {\n            for (i = 0; i < embeddedCea608FieldParsers.length; i++) {\n              if (embeddedCea608FieldParsers[i]) {\n                embeddedCea608FieldParsers[i].reset();\n              }\n            }\n          }\n\n          var allCcData = extractCea608Data(bytes, samplesInfo.sampleList);\n\n          for (var fieldNr = 0; fieldNr < embeddedCea608FieldParsers.length; fieldNr++) {\n            var ccData = allCcData.fields[fieldNr];\n            var fieldParser = embeddedCea608FieldParsers[fieldNr];\n\n            if (fieldParser) {\n              for (i = 0; i < ccData.length; i++) {\n                fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]);\n              }\n            }\n          }\n\n          embeddedLastSequenceNumber = sequenceNumber;\n        }\n      }\n    }\n  }\n  /**\n  * Extract CEA-608 data from a buffer of data.\n  * @param {ArrayBuffer} data\n  * @param {Array} samples cue information\n  * @returns {Object|null} ccData corresponding to one segment.\n  */\n\n\n  function extractCea608Data(data, samples) {\n    if (samples.length === 0) {\n      return null;\n    }\n\n    var allCcData = {\n      splits: [],\n      fields: [[], []]\n    };\n    var raw = new DataView(data);\n\n    for (var i = 0; i < samples.length; i++) {\n      var sample = samples[i];\n\n      var cea608Ranges = _cea608Parser2.default.findCea608Nalus(raw, sample.offset, sample.size);\n\n      var lastSampleTime = null;\n      var idx = 0;\n\n      for (var j = 0; j < cea608Ranges.length; j++) {\n        var ccData = _cea608Parser2.default.extractCea608DataFromRange(raw, cea608Ranges[j]);\n\n        for (var k = 0; k < 2; k++) {\n          if (ccData[k].length > 0) {\n            if (sample.cts !== lastSampleTime) {\n              idx = 0;\n            } else {\n              idx += 1;\n            }\n\n            allCcData.fields[k].push([sample.cts + mseTimeOffset * embeddedTimescale, ccData[k], idx]);\n            lastSampleTime = sample.cts;\n          }\n        }\n      }\n    } // Sort by sampleTime ascending order\n    // If two packets have the same sampleTime, use them in the order\n    // they were received\n\n\n    allCcData.fields.forEach(function sortField(field) {\n      field.sort(function (a, b) {\n        if (a[0] === b[0]) {\n          return a[2] - b[2];\n        }\n\n        return a[0] - b[0];\n      });\n    });\n    return allCcData;\n  }\n\n  function getIsDefault(mediaInfo) {\n    //TODO How to tag default. currently same order as listed in manifest.\n    // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND\n    // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet.\n    var isDefault = false;\n\n    if (embeddedTracks.length > 1 && mediaInfo.isEmbedded) {\n      isDefault = mediaInfo.id && mediaInfo.id === _Constants2.default.CC1; // CC1 if both CC1 and CC3 exist\n    } else if (embeddedTracks.length === 1) {\n      if (mediaInfo.id && typeof mediaInfo.id === 'string' && mediaInfo.id.substring(0, 2) === 'CC') {\n        // Either CC1 or CC3\n        isDefault = true;\n      }\n    } else if (embeddedTracks.length === 0) {\n      isDefault = mediaInfo.index === mediaInfos[0].index;\n    }\n\n    return isDefault;\n  }\n\n  function getParser(codecType) {\n    var parser = void 0;\n\n    if (codecType.search(_Constants2.default.VTT) >= 0) {\n      parser = vttParser;\n    } else if (codecType.search(_Constants2.default.TTML) >= 0 || codecType.search(_Constants2.default.STPP) >= 0) {\n      parser = ttmlParser;\n    }\n\n    return parser;\n  }\n\n  function remove(start, end) {\n    //if start and end are not defined, remove all\n    if (start === undefined && start === end) {\n      start = this.buffered.start(0);\n      end = this.buffered.end(this.buffered.length - 1);\n    }\n\n    this.buffered.remove(start, end);\n  }\n\n  function onVideoBufferCleared(e) {\n    embeddedTracks.forEach(function (track) {\n      var trackIdx = textTracks.getTrackIdxForId(track.id);\n\n      if (trackIdx >= 0) {\n        textTracks.deleteCuesFromTrackIdx(trackIdx, e.from, e.to);\n      }\n    });\n  }\n\n  instance = {\n    initialize: initialize,\n    append: append,\n    abort: abort,\n    addEmbeddedTrack: addEmbeddedTrack,\n    resetEmbedded: resetEmbedded,\n    setConfig: setConfig,\n    getConfig: getConfig,\n    setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx,\n    remove: remove,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nTextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer';\nexports.default = _FactoryMaker2.default.getSingletonFactory(TextSourceBuffer);","map":{"version":3,"sources":["../../../../../src/streaming/text/TextSourceBuffer.js"],"names":["context","eventBus","embeddedInitialized","instance","logger","boxParser","errHandler","adapter","manifestModel","mediaController","parser","vttParser","ttmlParser","mediaInfos","textTracks","fragmentedFragmentModel","initializationSegmentReceived","timescale","fragmentedTracks","videoModel","streamController","firstFragmentedSubtitleStart","currFragmentedTrackIdx","embeddedTracks","embeddedTimescale","embeddedLastSequenceNumber","embeddedCea608FieldParsers","embeddedTextHtmlRender","mseTimeOffset","resetInitialSettings","resetFragmented","initEmbedded","addMediaInfos","isFragmented","Constants","currFragTrack","i","setCurrentFragmentedTrackIdx","createTextTrackFromMediaInfo","chunk","e","append","streamProcessors","Events","mediaInfo","config","fragmentModel","textTrackInfo","TextTrackInfo","trackKindMap","subtitle","caption","getKind","kind","checkTTML","ttml","getIsDefault","totalNrTracks","result","sampleList","j","k","samplesInfo","ccContent","mediaType","mimeType","codecType","getParser","sample","sampleStart","sampleRelStart","dataView","ISOBoxer","images","subOffset","inData","raw","String","manifest","offsetTime","captionArray","sampleData","bytes","sampleBoxes","box1","box2","cue_text","start_time","end_time","start","end","data","styles","DashJSError","Errors","HTTPRequest","makeCueAdderForIndex","captionsArray","text","captionScreen","sequenceNumber","field","handler","trackIdx","cea608parser","allCcData","extractCea608Data","fieldNr","ccData","fieldParser","samples","splits","fields","cea608Ranges","lastSampleTime","idx","a","b","isDefault","track","initialize","abort","addEmbeddedTrack","resetEmbedded","setConfig","getConfig","remove","reset","setup","TextSourceBuffer","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport { HTTPRequest } from '../vo/metrics/HTTPRequest';\nimport TextTrackInfo from '../vo/TextTrackInfo';\nimport BoxParser from '../utils/BoxParser';\nimport CustomTimeRanges from '../utils/CustomTimeRanges';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport TextTracks from './TextTracks';\nimport EmbeddedTextHtmlRender from './EmbeddedTextHtmlRender';\nimport ISOBoxer from 'codem-isoboxer';\nimport cea608parser from '../../../externals/cea608-parser';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport DashJSError from '../vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nfunction TextSourceBuffer() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    let embeddedInitialized = false;\n\n    let instance,\n        logger,\n        boxParser,\n        errHandler,\n        adapter,\n        manifestModel,\n        mediaController,\n        parser,\n        vttParser,\n        ttmlParser,\n        mediaInfos,\n        textTracks,\n        fragmentedFragmentModel,\n        initializationSegmentReceived,\n        timescale,\n        fragmentedTracks,\n        videoModel,\n        streamController,\n        firstFragmentedSubtitleStart,\n        currFragmentedTrackIdx,\n        embeddedTracks,\n        embeddedTimescale,\n        embeddedLastSequenceNumber,\n        embeddedCea608FieldParsers,\n        embeddedTextHtmlRender,\n        mseTimeOffset;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        resetInitialSettings();\n    }\n\n    function resetFragmented () {\n        fragmentedFragmentModel = null;\n        timescale = NaN;\n        fragmentedTracks = [];\n        firstFragmentedSubtitleStart = null;\n        initializationSegmentReceived = false;\n    }\n\n    function resetInitialSettings() {\n        resetFragmented();\n\n        mediaInfos = [];\n        parser = null;\n    }\n\n    function initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n\n        if (!boxParser) {\n            boxParser = BoxParser(context).getInstance();\n        }\n\n        addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n    }\n\n    function addMediaInfos(mimeType, streamInfo, mediaInfoArr, fragmentModel) {\n        const isFragmented = !adapter.getIsTextTrack(mimeType);\n\n        mediaInfos = mediaInfos.concat(mediaInfoArr);\n\n        if (isFragmented) {\n            fragmentedFragmentModel = fragmentModel;\n            instance.buffered = CustomTimeRanges(context).create();\n            fragmentedTracks = mediaController.getTracksFor(Constants.FRAGMENTED_TEXT, streamInfo);\n            const currFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamInfo);\n            for (let i = 0; i < fragmentedTracks.length; i++) {\n                if (fragmentedTracks[i] === currFragTrack) {\n                    setCurrentFragmentedTrackIdx(i);\n                    break;\n                }\n            }\n        }\n\n        for (let i = 0; i < mediaInfos.length; i++) {\n            createTextTrackFromMediaInfo(null, mediaInfos[i]);\n        }\n    }\n\n    function abort() {\n        textTracks.deleteAllTextTracks();\n        resetFragmented();\n        boxParser = null;\n        mediaInfos = [];\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        streamController = null;\n        videoModel = null;\n        textTracks = null;\n    }\n\n    function onVideoChunkReceived(e) {\n        const chunk = e.chunk;\n\n        if (chunk.mediaInfo.embeddedCaptions) {\n            append(chunk.bytes, chunk);\n        }\n    }\n\n    function initEmbedded() {\n        embeddedTracks = [];\n        textTracks = TextTracks(context).getInstance();\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n        boxParser = BoxParser(context).getInstance();\n        currFragmentedTrackIdx = null;\n        embeddedTimescale = 0;\n        embeddedCea608FieldParsers = [];\n        embeddedLastSequenceNumber = null;\n        embeddedInitialized = true;\n        embeddedTextHtmlRender = EmbeddedTextHtmlRender(context).getInstance();\n\n        const streamProcessors = streamController.getActiveStreamProcessors();\n        for (const i in streamProcessors) {\n            if (streamProcessors[i].getType() === 'video') {\n                mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset;\n                break;\n            }\n        }\n\n        eventBus.on(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        eventBus.on(Events.BUFFER_CLEARED, onVideoBufferCleared, this);\n    }\n\n    function resetEmbedded() {\n        eventBus.off(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        eventBus.off(Events.BUFFER_CLEARED, onVideoBufferCleared, this);\n        if (textTracks) {\n            textTracks.deleteAllTextTracks();\n        }\n        embeddedInitialized = false;\n        embeddedTracks = [];\n        embeddedCea608FieldParsers = [null, null];\n        embeddedLastSequenceNumber = null;\n    }\n\n    function addEmbeddedTrack(mediaInfo) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n        if (mediaInfo) {\n            if (mediaInfo.id === Constants.CC1 || mediaInfo.id === Constants.CC3) {\n                for (let i = 0; i < embeddedTracks.length; i++) {\n                    if (embeddedTracks[i].id === mediaInfo.id) {\n                        return;\n                    }\n                }\n                embeddedTracks.push(mediaInfo);\n            } else {\n                logger.warn('Embedded track ' + mediaInfo.id + ' not supported!');\n            }\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.mediaController) {\n            mediaController = config.mediaController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.textTracks) {\n            textTracks = config.textTracks;\n        }\n        if (config.vttParser) {\n            vttParser = config.vttParser;\n        }\n        if (config.ttmlParser) {\n            ttmlParser = config.ttmlParser;\n        }\n    }\n\n    function getConfig() {\n        const config = {\n            fragmentModel: fragmentedFragmentModel,\n            fragmentedTracks: fragmentedTracks,\n            videoModel: videoModel\n        };\n\n        return config;\n    }\n\n    function setCurrentFragmentedTrackIdx(idx) {\n        currFragmentedTrackIdx = idx;\n    }\n\n    function createTextTrackFromMediaInfo(captionData, mediaInfo) {\n        const textTrackInfo = new TextTrackInfo();\n        const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n        const getKind = function () {\n            let kind = (mediaInfo.roles.length > 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n            kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption;\n            return kind;\n        };\n\n        const checkTTML = function () {\n            let ttml = false;\n            if (mediaInfo.codec && mediaInfo.codec.search(Constants.STPP) >= 0) {\n                ttml = true;\n            }\n            if (mediaInfo.mimeType && mediaInfo.mimeType.search(Constants.TTML) >= 0) {\n                ttml = true;\n            }\n            return ttml;\n        };\n\n        textTrackInfo.captionData = captionData;\n        textTrackInfo.lang = mediaInfo.lang;\n        textTrackInfo.labels = mediaInfo.labels;\n        textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index\n        textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest\n        textTrackInfo.isTTML = checkTTML();\n        textTrackInfo.defaultTrack = getIsDefault(mediaInfo);\n        textTrackInfo.isFragmented = !adapter.getIsTextTrack(mediaInfo.mimeType);\n        textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false;\n        textTrackInfo.kind = getKind();\n        textTrackInfo.roles = mediaInfo.roles;\n        textTrackInfo.accessibility = mediaInfo.accessibility;\n        const totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length;\n        textTracks.addTextTrack(textTrackInfo, totalNrTracks);\n    }\n\n    function append(bytes, chunk) {\n        let result,\n            sampleList,\n            i, j, k,\n            samplesInfo,\n            ccContent;\n        const mediaInfo = chunk.mediaInfo;\n        const mediaType = mediaInfo.type;\n        const mimeType = mediaInfo.mimeType;\n        const codecType = mediaInfo.codec || mimeType;\n        if (!codecType) {\n            logger.error('No text type defined');\n            return;\n        }\n\n        if (mediaType === Constants.FRAGMENTED_TEXT) {\n            if (!initializationSegmentReceived && chunk.segmentType === 'InitializationSegment') {\n                initializationSegmentReceived = true;\n                timescale = boxParser.getMediaTimescaleFromMoov(bytes);\n            } else {\n                if (!initializationSegmentReceived) {\n                    return;\n                }\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n                sampleList = samplesInfo.sampleList;\n                if (firstFragmentedSubtitleStart === null && sampleList.length > 0) {\n                    firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale;\n                }\n                if (codecType.search(Constants.STPP) >= 0) {\n                    parser = parser !== null ? parser : getParser(codecType);\n                    for (i = 0; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        const sampleStart = sample.cts;\n                        const sampleRelStart = sampleStart - firstFragmentedSubtitleStart;\n                        this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale);\n                        const dataView = new DataView(bytes, sample.offset, sample.subSizes[0]);\n                        ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n                        const images = [];\n                        let subOffset = sample.offset + sample.subSizes[0];\n                        for (j = 1; j < sample.subSizes.length; j++) {\n                            const inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]);\n                            const raw = String.fromCharCode.apply(null, inData);\n                            images.push(raw);\n                            subOffset += sample.subSizes[j];\n                        }\n                        try {\n                            // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset.\n                            const manifest = manifestModel.getValue();\n                            const offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0;\n                            result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images);\n                            textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result);\n                        } catch (e) {\n                            fragmentedFragmentModel.removeExecutedRequestsBeforeTime();\n                            this.remove();\n                            logger.error('TTML parser error: ' + e.message);\n                        }\n                    }\n                } else {\n                    // WebVTT case\n                    const captionArray = [];\n                    for (i = 0 ; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        sample.cts -= firstFragmentedSubtitleStart;\n                        this.buffered.add(sample.cts / timescale, (sample.cts + sample.duration) / timescale);\n                        const sampleData = bytes.slice(sample.offset, sample.offset + sample.size);\n                        // There are boxes inside the sampleData, so we need a ISOBoxer to get at it.\n                        const sampleBoxes = ISOBoxer.parseBuffer(sampleData);\n\n                        for (j = 0 ; j < sampleBoxes.boxes.length; j++) {\n                            const box1 = sampleBoxes.boxes[j];\n                            logger.debug('VTT box1: ' + box1.type);\n                            if (box1.type === 'vtte') {\n                                continue; //Empty box\n                            }\n                            if (box1.type === 'vttc') {\n                                logger.debug('VTT vttc boxes.length = ' + box1.boxes.length);\n                                for (k = 0 ; k < box1.boxes.length; k++) {\n                                    const box2 = box1.boxes[k];\n                                    logger.debug('VTT box2: ' + box2.type);\n                                    if (box2.type === 'payl') {\n                                        const cue_text = box2.cue_text;\n                                        logger.debug('VTT cue_text = ' + cue_text);\n                                        const start_time = sample.cts / timescale;\n                                        const end_time = (sample.cts + sample.duration) / timescale;\n                                        captionArray.push({\n                                            start: start_time,\n                                            end: end_time,\n                                            data: cue_text,\n                                            styles: {}\n                                        });\n                                        logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (captionArray.length > 0) {\n                        textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray);\n                    }\n                }\n            }\n        } else if (mediaType === Constants.TEXT) {\n            const dataView = new DataView(bytes, 0, bytes.byteLength);\n            ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n\n            try {\n                result = getParser(codecType).parse(ccContent, 0);\n                textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result);\n            } catch (e) {\n                errHandler.error(new DashJSError(Errors.TIMED_TEXT_ERROR_ID_PARSE_CODE, Errors.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent));\n            }\n        } else if (mediaType === Constants.VIDEO) { //embedded text\n            if (chunk.segmentType === HTTPRequest.INIT_SEGMENT_TYPE) {\n                if (embeddedTimescale === 0) {\n                    embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes);\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        createTextTrackFromMediaInfo(null, embeddedTracks[i]);\n                    }\n                }\n            } else { // MediaSegment\n                if (embeddedTimescale === 0) {\n                    logger.warn('CEA-608: No timescale for embeddedTextTrack yet');\n                    return;\n                }\n                const makeCueAdderForIndex = function (self, trackIndex) {\n                    function newCue(startTime, endTime, captionScreen) {\n                        let captionsArray = null;\n                        if (videoModel.getTTMLRenderingDiv()) {\n                            captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen);\n                        } else {\n                            const text = captionScreen.getDisplayText();\n                            captionsArray = [{\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: {}\n                            }];\n                        }\n                        if (captionsArray) {\n                            textTracks.addCaptions(trackIndex, 0, captionsArray);\n                        }\n                    }\n                    return newCue;\n                };\n\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n\n                const sequenceNumber = samplesInfo.lastSequenceNumber;\n\n                if (!embeddedCea608FieldParsers[0] && !embeddedCea608FieldParsers[1]) {\n                    // Time to setup the CEA-608 parsing\n                    let field, handler, trackIdx;\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        if (embeddedTracks[i].id === Constants.CC1) {\n                            field = 0;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC1);\n                        } else if (embeddedTracks[i].id === Constants.CC3) {\n                            field = 1;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC3);\n                        }\n                        if (trackIdx === -1) {\n                            logger.warn('CEA-608: data before track is ready.');\n                            return;\n                        }\n                        handler = makeCueAdderForIndex(this, trackIdx);\n                        embeddedCea608FieldParsers[i] = new cea608parser.Cea608Parser(i + 1, {\n                            'newCue': handler\n                        }, null);\n                    }\n                }\n\n                if (embeddedTimescale) {\n                    if (embeddedLastSequenceNumber !== null && sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) {\n                        for (i = 0; i < embeddedCea608FieldParsers.length; i++) {\n                            if (embeddedCea608FieldParsers[i]) {\n                                embeddedCea608FieldParsers[i].reset();\n                            }\n                        }\n                    }\n\n                    const allCcData = extractCea608Data(bytes, samplesInfo.sampleList);\n\n                    for (let fieldNr = 0; fieldNr < embeddedCea608FieldParsers.length; fieldNr++) {\n                        const ccData = allCcData.fields[fieldNr];\n                        const fieldParser = embeddedCea608FieldParsers[fieldNr];\n                        if (fieldParser) {\n                            for (i = 0; i < ccData.length; i++) {\n                                fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]);\n                            }\n                        }\n                    }\n                    embeddedLastSequenceNumber = sequenceNumber;\n                }\n            }\n        }\n    }\n    /**\n     * Extract CEA-608 data from a buffer of data.\n     * @param {ArrayBuffer} data\n     * @param {Array} samples cue information\n     * @returns {Object|null} ccData corresponding to one segment.\n     */\n    function extractCea608Data(data, samples) {\n        if (samples.length === 0) {\n            return null;\n        }\n\n        const allCcData = {\n            splits: [],\n            fields: [[], []]\n        };\n        const raw = new DataView(data);\n        for (let i = 0; i < samples.length; i++) {\n            const sample = samples[i];\n            const cea608Ranges = cea608parser.findCea608Nalus(raw, sample.offset, sample.size);\n            let lastSampleTime = null;\n            let idx = 0;\n            for (let j = 0; j < cea608Ranges.length; j++) {\n                const ccData = cea608parser.extractCea608DataFromRange(raw, cea608Ranges[j]);\n                for (let k = 0; k < 2; k++) {\n                    if (ccData[k].length > 0) {\n                        if (sample.cts !== lastSampleTime) {\n                            idx = 0;\n                        } else {\n                            idx += 1;\n                        }\n                        allCcData.fields[k].push([sample.cts + (mseTimeOffset * embeddedTimescale), ccData[k], idx]);\n                        lastSampleTime = sample.cts;\n                    }\n                }\n            }\n        }\n\n        // Sort by sampleTime ascending order\n        // If two packets have the same sampleTime, use them in the order\n        // they were received\n        allCcData.fields.forEach(function sortField(field) {\n            field.sort(function (a, b) {\n                if (a[0] === b[0]) {\n                    return a[2] - b[2];\n                }\n                return a[0] - b[0];\n            });\n        });\n\n        return allCcData;\n    }\n\n    function getIsDefault(mediaInfo) {\n        //TODO How to tag default. currently same order as listed in manifest.\n        // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND\n        // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet.\n        let isDefault = false;\n        if (embeddedTracks.length > 1 && mediaInfo.isEmbedded) {\n            isDefault = (mediaInfo.id && mediaInfo.id === Constants.CC1); // CC1 if both CC1 and CC3 exist\n        } else if (embeddedTracks.length === 1) {\n            if (mediaInfo.id && typeof mediaInfo.id === 'string' && mediaInfo.id.substring(0, 2) === 'CC') { // Either CC1 or CC3\n                isDefault = true;\n            }\n        } else if (embeddedTracks.length === 0) {\n            isDefault = (mediaInfo.index === mediaInfos[0].index);\n        }\n        return isDefault;\n    }\n\n    function getParser(codecType) {\n        let parser;\n        if (codecType.search(Constants.VTT) >= 0) {\n            parser = vttParser;\n        } else if (codecType.search(Constants.TTML) >= 0 || codecType.search(Constants.STPP) >= 0) {\n            parser = ttmlParser;\n        }\n        return parser;\n    }\n\n    function remove(start, end) {\n        //if start and end are not defined, remove all\n        if ((start === undefined) && (start === end)) {\n            start = this.buffered.start(0);\n            end = this.buffered.end(this.buffered.length - 1);\n        }\n        this.buffered.remove(start, end);\n    }\n\n    function onVideoBufferCleared(e) {\n        embeddedTracks.forEach(function (track) {\n            const trackIdx = textTracks.getTrackIdxForId(track.id);\n            if (trackIdx >= 0) {\n                textTracks.deleteCuesFromTrackIdx(trackIdx, e.from, e.to);\n            }\n        });\n    }\n\n    instance = {\n        initialize: initialize,\n        append: append,\n        abort: abort,\n        addEmbeddedTrack: addEmbeddedTrack,\n        resetEmbedded: resetEmbedded,\n        setConfig: setConfig,\n        getConfig: getConfig,\n        setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx,\n        remove: remove,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer';\nexport default FactoryMaker.getSingletonFactory(TextSourceBuffer);\n"]},"metadata":{},"sourceType":"script"}