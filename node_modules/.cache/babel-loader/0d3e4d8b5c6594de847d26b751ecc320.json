{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('./constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _StreamProcessor = require('./StreamProcessor');\n\nvar _StreamProcessor2 = _interopRequireDefault(_StreamProcessor);\n\nvar _FragmentController = require('./controllers/FragmentController');\n\nvar _FragmentController2 = _interopRequireDefault(_FragmentController);\n\nvar _ThumbnailController = require('./thumbnail/ThumbnailController');\n\nvar _ThumbnailController2 = _interopRequireDefault(_ThumbnailController);\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashJSError = require('./vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _BoxParser = require('./utils/BoxParser');\n\nvar _BoxParser2 = _interopRequireDefault(_BoxParser);\n\nvar _URLUtils = require('./utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction Stream(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var manifestModel = config.manifestModel;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var manifestUpdater = config.manifestUpdater;\n  var adapter = config.adapter;\n  var capabilities = config.capabilities;\n  var capabilitiesFilter = config.capabilitiesFilter;\n  var errHandler = config.errHandler;\n  var timelineConverter = config.timelineConverter;\n  var dashMetrics = config.dashMetrics;\n  var abrController = config.abrController;\n  var playbackController = config.playbackController;\n  var eventController = config.eventController;\n  var mediaController = config.mediaController;\n  var textController = config.textController;\n  var protectionController = config.protectionController;\n  var videoModel = config.videoModel;\n  var settings = config.settings;\n  var streamInfo = config.streamInfo;\n  var instance = void 0,\n      logger = void 0,\n      streamProcessors = void 0,\n      isStreamInitialized = void 0,\n      isStreamActivated = void 0,\n      isMediaInitialized = void 0,\n      hasVideoTrack = void 0,\n      hasAudioTrack = void 0,\n      updateError = void 0,\n      isUpdating = void 0,\n      fragmentController = void 0,\n      thumbnailController = void 0,\n      preloaded = void 0,\n      boxParser = void 0,\n      preloadingScheduled = void 0,\n      debug = void 0,\n      isEndedEventSignaled = void 0,\n      trackChangedEvent = void 0;\n\n  function setup() {\n    debug = (0, _Debug2.default)(context).getInstance();\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n    boxParser = (0, _BoxParser2.default)(context).getInstance();\n    fragmentController = (0, _FragmentController2.default)(context).create({\n      streamInfo: streamInfo,\n      mediaPlayerModel: mediaPlayerModel,\n      dashMetrics: dashMetrics,\n      errHandler: errHandler,\n      settings: settings,\n      boxParser: boxParser,\n      dashConstants: _DashConstants2.default,\n      urlUtils: urlUtils\n    });\n  }\n\n  function initialize() {\n    registerEvents();\n    registerProtectionEvents();\n    eventBus.trigger(_Events2.default.STREAM_UPDATED, {\n      streamInfo: streamInfo\n    });\n  }\n\n  function registerEvents() {\n    eventBus.on(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.on(_Events2.default.INBAND_EVENTS, onInbandEvents, instance);\n  }\n\n  function unRegisterEvents() {\n    eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.off(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n    eventBus.off(_Events2.default.INBAND_EVENTS, onInbandEvents, instance);\n  }\n\n  function registerProtectionEvents() {\n    if (protectionController) {\n      eventBus.on(_Events2.default.KEY_ERROR, onProtectionError, instance);\n      eventBus.on(_Events2.default.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n      eventBus.on(_Events2.default.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n      eventBus.on(_Events2.default.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n      eventBus.on(_Events2.default.KEY_SESSION_CREATED, onProtectionError, instance);\n      eventBus.on(_Events2.default.KEY_STATUSES_CHANGED, onProtectionError, instance);\n    }\n  }\n\n  function unRegisterProtectionEvents() {\n    if (protectionController) {\n      eventBus.off(_Events2.default.KEY_ERROR, onProtectionError, instance);\n      eventBus.off(_Events2.default.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n      eventBus.off(_Events2.default.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n      eventBus.off(_Events2.default.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n      eventBus.off(_Events2.default.KEY_SESSION_CREATED, onProtectionError, instance);\n      eventBus.off(_Events2.default.KEY_STATUSES_CHANGED, onProtectionError, instance);\n    }\n  }\n\n  function getStreamId() {\n    return streamInfo ? streamInfo.id : null;\n  }\n  /**\n  * Activates Stream by re-initializing some of its components\n  * @param {MediaSource} mediaSource\n  * @memberof Stream#\n  * @param {SourceBuffer} previousBuffers\n  */\n\n\n  function activate(mediaSource, previousBuffers) {\n    if (!isStreamActivated) {\n      var result = void 0;\n      eventBus.on(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n\n      if (!getPreloaded()) {\n        result = initializeMedia(mediaSource, previousBuffers);\n      } else {\n        initializeAfterPreload();\n        result = previousBuffers;\n      }\n\n      isStreamActivated = true;\n      return result;\n    }\n\n    return previousBuffers;\n  }\n  /**\n  * Partially resets some of the Stream elements\n  * @memberof Stream#\n  * @param {boolean} keepBuffers\n  */\n\n\n  function deactivate(keepBuffers) {\n    var ln = streamProcessors ? streamProcessors.length : 0;\n    var errored = false;\n\n    for (var i = 0; i < ln; i++) {\n      var fragmentModel = streamProcessors[i].getFragmentModel();\n      fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n      streamProcessors[i].reset(errored, keepBuffers);\n    }\n\n    streamProcessors = [];\n    isStreamActivated = false;\n    isMediaInitialized = false;\n    setPreloaded(false);\n    eventBus.off(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n  }\n\n  function isActive() {\n    return isStreamActivated;\n  }\n\n  function setMediaSource(mediaSource) {\n    for (var i = 0; i < streamProcessors.length;) {\n      if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n        streamProcessors[i].setMediaSource(mediaSource);\n        i++;\n      } else {\n        streamProcessors[i].reset();\n        streamProcessors.splice(i, 1);\n      }\n    }\n\n    for (var _i = 0; _i < streamProcessors.length; _i++) {\n      //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n      //so do this after the buffers are created above.\n      streamProcessors[_i].dischargePreBuffer();\n    }\n\n    if (streamProcessors.length === 0) {\n      var msg = 'No streams to play.';\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg + 'nostreams', manifestModel.getValue()));\n      logger.fatal(msg);\n    }\n  }\n\n  function resetInitialSettings() {\n    deactivate();\n    isStreamInitialized = false;\n    hasVideoTrack = false;\n    hasAudioTrack = false;\n    updateError = {};\n    isUpdating = false;\n    preloadingScheduled = false;\n    isEndedEventSignaled = false;\n  }\n\n  function reset() {\n    if (playbackController) {\n      playbackController.pause();\n    }\n\n    if (fragmentController) {\n      fragmentController.reset();\n      fragmentController = null;\n    }\n\n    streamInfo = null;\n    resetInitialSettings();\n    unRegisterEvents();\n    unRegisterProtectionEvents();\n    setPreloaded(false);\n  }\n\n  function getDuration() {\n    return streamInfo ? streamInfo.duration : NaN;\n  }\n\n  function getIsEndedEventSignaled() {\n    return isEndedEventSignaled;\n  }\n\n  function setIsEndedEventSignaled(value) {\n    isEndedEventSignaled = value;\n  }\n\n  function getStartTime() {\n    return streamInfo ? streamInfo.start : NaN;\n  }\n\n  function getPreloadingScheduled() {\n    return preloadingScheduled;\n  }\n\n  function setPreloadingScheduled(value) {\n    preloadingScheduled = value;\n  }\n\n  function getLiveStartTime() {\n    if (!streamInfo.manifestInfo.isDynamic) return NaN; // Get live start time of the video stream (1st in array of streams)\n    // or audio if no video stream\n\n    for (var i = 0; i < streamProcessors.length; i++) {\n      if (streamProcessors[i].getType() === _Constants2.default.AUDIO || streamProcessors[i].getType() === _Constants2.default.VIDEO) {\n        return streamProcessors[i].getLiveStartTime();\n      }\n    }\n\n    return NaN;\n  }\n\n  function getId() {\n    return streamInfo ? streamInfo.id : null;\n  }\n\n  function getStreamInfo() {\n    return streamInfo;\n  }\n\n  function getHasAudioTrack() {\n    return hasAudioTrack;\n  }\n\n  function getHasVideoTrack() {\n    return hasVideoTrack;\n  }\n\n  function getThumbnailController() {\n    return thumbnailController;\n  }\n\n  function checkConfig() {\n    if (!videoModel || !abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n  /**\n  * @param {string} type\n  * @returns {Array}\n  * @memberof Stream#\n  */\n\n\n  function getBitrateListFor(type) {\n    checkConfig();\n\n    if (type === _Constants2.default.IMAGE) {\n      if (!thumbnailController) {\n        return [];\n      }\n\n      return thumbnailController.getBitrateList();\n    }\n\n    var mediaInfo = getMediaInfo(type);\n    return abrController.getBitrateList(mediaInfo);\n  }\n\n  function onProtectionError(event) {\n    if (event.error) {\n      errHandler.error(event.error);\n      logger.fatal(event.error.message);\n      reset();\n    }\n  }\n\n  function isMediaSupported(mediaInfo) {\n    var type = mediaInfo ? mediaInfo.type : null;\n    var codec = void 0,\n        msg = void 0;\n\n    if (type === _Constants2.default.MUXED) {\n      msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n      logger.fatal(msg);\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\n      return false;\n    }\n\n    if (type === _Constants2.default.TEXT || type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.EMBEDDED_TEXT || type === _Constants2.default.IMAGE) {\n      return true;\n    }\n\n    codec = mediaInfo.codec;\n    logger.debug(type + ' codec: ' + codec);\n\n    if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n      errHandler.error(new _DashJSError2.default(_Errors2.default.CAPABILITY_MEDIAKEYS_ERROR_CODE, _Errors2.default.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\n    } else if (!capabilities.supportsCodec(codec)) {\n      msg = type + 'Codec (' + codec + ') is not supported.';\n      logger.error(msg);\n      return false;\n    }\n\n    return true;\n  }\n\n  function onCurrentTrackChanged(e) {\n    if (!streamInfo || e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n    var mediaInfo = e.newMediaInfo;\n    var manifest = manifestModel.getValue();\n    adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\n    var processor = getProcessorForMediaInfo(mediaInfo);\n    if (!processor) return;\n    var currentTime = playbackController.getTime();\n    logger.info('Stream -  Process track changed at current time ' + currentTime);\n    logger.debug('Stream -  Update stream controller');\n\n    if (manifest.refreshManifestOnSwitchTrack) {\n      // Applies only for MSS streams\n      logger.debug('Stream -  Refreshing manifest for switch track');\n      trackChangedEvent = e;\n      manifestUpdater.refreshManifest();\n    } else {\n      processor.selectMediaInfo(mediaInfo);\n\n      if (mediaInfo.type !== _Constants2.default.FRAGMENTED_TEXT) {\n        abrController.updateTopQualityIndex(mediaInfo);\n        processor.switchTrackAsked();\n        processor.getFragmentModel().abortRequests();\n      } else {\n        processor.getScheduleController().setSeekTarget(currentTime);\n        processor.setBufferingTime(currentTime);\n        processor.resetIndexHandler();\n      }\n    }\n  }\n\n  function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n    var fragmentModel = fragmentController.getModel(mediaInfo ? mediaInfo.type : null);\n    var streamProcessor = (0, _StreamProcessor2.default)(context).create({\n      streamInfo: streamInfo,\n      type: mediaInfo ? mediaInfo.type : null,\n      mimeType: mediaInfo ? mediaInfo.mimeType : null,\n      timelineConverter: timelineConverter,\n      adapter: adapter,\n      manifestModel: manifestModel,\n      mediaPlayerModel: mediaPlayerModel,\n      fragmentModel: fragmentModel,\n      dashMetrics: config.dashMetrics,\n      baseURLController: config.baseURLController,\n      abrController: abrController,\n      playbackController: playbackController,\n      mediaController: mediaController,\n      textController: textController,\n      errHandler: errHandler,\n      settings: settings,\n      boxParser: boxParser\n    });\n    streamProcessor.initialize(mediaSource, hasVideoTrack);\n    abrController.updateTopQualityIndex(mediaInfo);\n\n    if (optionalSettings) {\n      streamProcessor.setBuffer(optionalSettings.buffer);\n      streamProcessor.setBufferingTime(optionalSettings.currentTime);\n      streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n    } else {\n      streamProcessors.push(streamProcessor);\n    }\n\n    if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n      return;\n    }\n\n    if (mediaInfo && (mediaInfo.type === _Constants2.default.TEXT || mediaInfo.type === _Constants2.default.FRAGMENTED_TEXT)) {\n      var idx = void 0;\n\n      for (var i = 0; i < allMediaForType.length; i++) {\n        if (allMediaForType[i].index === mediaInfo.index) {\n          idx = i;\n        }\n\n        streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n      }\n\n      streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n    } else {\n      streamProcessor.addMediaInfo(mediaInfo, true);\n    }\n  }\n\n  function initializeMediaForType(type, mediaSource) {\n    var allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n    var mediaInfo = null;\n    var initialMediaInfo = void 0;\n\n    if (!allMediaForType || allMediaForType.length === 0) {\n      logger.info('No ' + type + ' data.');\n      return;\n    }\n\n    if (type === _Constants2.default.VIDEO) {\n      hasVideoTrack = true;\n    }\n\n    if (type === _Constants2.default.AUDIO) {\n      hasAudioTrack = true;\n    }\n\n    for (var i = 0, ln = allMediaForType.length; i < ln; i++) {\n      mediaInfo = allMediaForType[i];\n\n      if (type === _Constants2.default.EMBEDDED_TEXT) {\n        textController.addEmbeddedTrack(mediaInfo);\n      } else {\n        if (!isMediaSupported(mediaInfo)) continue;\n        mediaController.addTrack(mediaInfo);\n      }\n    }\n\n    if (type === _Constants2.default.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n      return;\n    }\n\n    if (type === _Constants2.default.IMAGE) {\n      thumbnailController = (0, _ThumbnailController2.default)(context).create({\n        streamInfo: streamInfo,\n        adapter: adapter,\n        baseURLController: config.baseURLController,\n        timelineConverter: config.timelineConverter,\n        debug: debug,\n        eventBus: eventBus,\n        events: _Events2.default,\n        dashConstants: _DashConstants2.default\n      });\n      return;\n    }\n\n    mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n    initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n    eventBus.trigger(_Events2.default.STREAM_INITIALIZING, {\n      streamInfo: streamInfo,\n      mediaInfo: mediaInfo\n    }); // TODO : How to tell index handler live/duration?\n    // TODO : Pass to controller and then pass to each method on handler?\n\n    createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n  }\n\n  function addInlineEvents() {\n    if (eventController) {\n      var events = adapter.getEventsFor(streamInfo);\n      eventController.addInlineEvents(events);\n    }\n  }\n\n  function addInbandEvents(events) {\n    if (eventController) {\n      eventController.addInbandEvents(events);\n    }\n  }\n\n  function initializeMedia(mediaSource, previousBuffers) {\n    checkConfig();\n    var element = videoModel.getElement();\n    addInlineEvents();\n    isUpdating = true;\n    capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n    if (!element || element && /^VIDEO$/i.test(element.nodeName)) {\n      initializeMediaForType(_Constants2.default.VIDEO, mediaSource);\n    }\n\n    initializeMediaForType(_Constants2.default.AUDIO, mediaSource);\n    initializeMediaForType(_Constants2.default.TEXT, mediaSource);\n    initializeMediaForType(_Constants2.default.FRAGMENTED_TEXT, mediaSource);\n    initializeMediaForType(_Constants2.default.EMBEDDED_TEXT, mediaSource);\n    initializeMediaForType(_Constants2.default.MUXED, mediaSource);\n    initializeMediaForType(_Constants2.default.IMAGE, mediaSource); //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n\n    var buffers = createBuffers(previousBuffers);\n    isMediaInitialized = true;\n    isUpdating = false;\n\n    if (streamProcessors.length === 0) {\n      var msg = 'No streams to play.';\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n      logger.fatal(msg);\n    } else {\n      checkIfInitializationCompleted();\n    }\n\n    return buffers;\n  }\n\n  function initializeAfterPreload() {\n    isUpdating = true;\n    checkConfig();\n    capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n    isMediaInitialized = true;\n    isUpdating = false;\n\n    if (streamProcessors.length === 0) {\n      var msg = 'No streams to play.';\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n      logger.debug(msg);\n    } else {\n      checkIfInitializationCompleted();\n    }\n  }\n\n  function checkIfInitializationCompleted() {\n    var ln = streamProcessors.length;\n    var hasError = !!updateError.audio || !!updateError.video;\n    var error = hasError ? new _DashJSError2.default(_Errors2.default.DATA_UPDATE_FAILED_ERROR_CODE, _Errors2.default.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\n\n    for (var i = 0; i < ln; i++) {\n      if (streamProcessors[i].isUpdating() || isUpdating) {\n        return;\n      }\n    }\n\n    if (!isMediaInitialized) {\n      return;\n    }\n\n    if (protectionController) {\n      // Need to check if streamProcessors exists because streamProcessors\n      // could be cleared in case an error is detected while initializing DRM keysystem\n      protectionController.clearMediaInfoArrayByStreamId(getId());\n\n      for (var _i2 = 0; _i2 < ln && streamProcessors[_i2]; _i2++) {\n        var type = streamProcessors[_i2].getType();\n\n        if (type === _Constants2.default.AUDIO || type === _Constants2.default.VIDEO || type === _Constants2.default.FRAGMENTED_TEXT) {\n          var mediaInfo = streamProcessors[_i2].getMediaInfo();\n\n          if (mediaInfo) {\n            protectionController.initializeForMedia(mediaInfo);\n          }\n        }\n      }\n    }\n\n    if (error) {\n      errHandler.error(error);\n    } else if (!isStreamInitialized) {\n      isStreamInitialized = true;\n      eventBus.trigger(_Events2.default.STREAM_INITIALIZED, {\n        streamInfo: streamInfo,\n        liveStartTime: !preloaded ? getLiveStartTime() : NaN\n      });\n    } // (Re)start ScheduleController:\n    // - in case stream initialization has been completed after 'play' event (case for SegmentBase streams)\n    // - in case stream is complete but a track switch has been requested\n\n\n    for (var _i3 = 0; _i3 < ln && streamProcessors[_i3]; _i3++) {\n      streamProcessors[_i3].getScheduleController().start();\n    }\n  }\n\n  function getMediaInfo(type) {\n    var streamProcessor = null;\n\n    for (var i = 0; i < streamProcessors.length; i++) {\n      streamProcessor = streamProcessors[i];\n\n      if (streamProcessor.getType() === type) {\n        return streamProcessor.getMediaInfo();\n      }\n    }\n\n    return null;\n  }\n\n  function createBuffers(previousBuffers) {\n    var buffers = {};\n\n    for (var i = 0, ln = streamProcessors.length; i < ln; i++) {\n      var buffer = streamProcessors[i].createBuffer(previousBuffers);\n\n      if (buffer) {\n        buffers[streamProcessors[i].getType()] = buffer.getBuffer();\n      }\n    }\n\n    return buffers;\n  }\n\n  function onBufferingCompleted() {\n    var processors = getProcessors();\n    var ln = processors.length;\n\n    if (ln === 0) {\n      logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n      return;\n    } // if there is at least one buffer controller that has not completed buffering yet do nothing\n\n\n    for (var i = 0; i < ln; i++) {\n      //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n      if (!processors[i].isBufferingCompleted() && (processors[i].getType() === _Constants2.default.AUDIO || processors[i].getType() === _Constants2.default.VIDEO)) {\n        logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\n        return;\n      }\n    }\n\n    logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n    eventBus.trigger(_Events2.default.STREAM_BUFFERING_COMPLETED, {\n      streamInfo: streamInfo\n    });\n  }\n\n  function onDataUpdateCompleted(e) {\n    updateError[e.mediaType] = e.error;\n    checkIfInitializationCompleted();\n  }\n\n  function onInbandEvents(e) {\n    addInbandEvents(e.events);\n  }\n\n  function getProcessorForMediaInfo(mediaInfo) {\n    if (!mediaInfo) {\n      return null;\n    }\n\n    var processors = getProcessors();\n    return processors.filter(function (processor) {\n      return processor.getType() === mediaInfo.type;\n    })[0];\n  }\n\n  function getProcessors() {\n    var arr = [];\n    var type = void 0,\n        streamProcessor = void 0;\n\n    for (var i = 0; i < streamProcessors.length; i++) {\n      streamProcessor = streamProcessors[i];\n      type = streamProcessor.getType();\n\n      if (type === _Constants2.default.AUDIO || type === _Constants2.default.VIDEO || type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.TEXT) {\n        arr.push(streamProcessor);\n      }\n    }\n\n    return arr;\n  }\n\n  function updateData(updatedStreamInfo) {\n    logger.info('Manifest updated... updating data system wide.');\n    isStreamActivated = false;\n    isUpdating = true;\n    streamInfo = updatedStreamInfo;\n    eventBus.trigger(_Events2.default.STREAM_UPDATED, {\n      streamInfo: streamInfo\n    });\n\n    if (eventController) {\n      addInlineEvents();\n    }\n\n    capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n    for (var i = 0, ln = streamProcessors.length; i < ln; i++) {\n      var streamProcessor = streamProcessors[i];\n      streamProcessor.updateStreamInfo(streamInfo);\n      var mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType()); // Check if AdaptationSet has not been removed in MPD update\n\n      if (mediaInfo) {\n        abrController.updateTopQualityIndex(mediaInfo);\n        streamProcessor.addMediaInfo(mediaInfo, true);\n      }\n    }\n\n    if (trackChangedEvent) {\n      var _mediaInfo = trackChangedEvent.newMediaInfo;\n\n      if (_mediaInfo.type !== _Constants2.default.FRAGMENTED_TEXT) {\n        var processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n        if (!processor) return;\n        processor.switchTrackAsked();\n        trackChangedEvent = undefined;\n      }\n    }\n\n    isUpdating = false;\n    checkIfInitializationCompleted();\n  }\n\n  function isMediaCodecCompatible(newStream) {\n    var previousStream = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return compareCodecs(newStream, _Constants2.default.VIDEO, previousStream) && compareCodecs(newStream, _Constants2.default.AUDIO, previousStream);\n  }\n\n  function isProtectionCompatible(stream) {\n    var previousStream = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return compareProtectionConfig(stream, _Constants2.default.VIDEO, previousStream) && compareProtectionConfig(stream, _Constants2.default.AUDIO, previousStream);\n  }\n\n  function compareProtectionConfig(stream, type) {\n    var previousStream = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (!stream) {\n      return false;\n    }\n\n    var newStreamInfo = stream.getStreamInfo();\n    var currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n    if (!newStreamInfo || !currentStreamInfo) {\n      return false;\n    }\n\n    var newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n    var currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n    if (!newAdaptation || !currentAdaptation) {\n      // If there is no adaptation for neither the old or the new stream they're compatible\n      return !newAdaptation && !currentAdaptation;\n    } // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n\n\n    return !(!isAdaptationDrmProtected(currentAdaptation) && isAdaptationDrmProtected(newAdaptation));\n  }\n\n  function isAdaptationDrmProtected(adaptation) {\n    if (!adaptation) {\n      // If there is no adaptation for neither the old or the new stream they're compatible\n      return false;\n    } // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n\n\n    return !!(adaptation.ContentProtection || adaptation.Representation && adaptation.Representation.length > 0 && adaptation.Representation[0].ContentProtection);\n  }\n\n  function compareCodecs(newStream, type) {\n    var previousStream = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (!newStream || !newStream.hasOwnProperty('getStreamInfo')) {\n      return false;\n    }\n\n    var newStreamInfo = newStream.getStreamInfo();\n    var currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n    if (!newStreamInfo || !currentStreamInfo) {\n      return false;\n    }\n\n    var newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n    var currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n    if (!newAdaptation || !currentAdaptation) {\n      // If there is no adaptation for neither the old or the new stream they're compatible\n      return !newAdaptation && !currentAdaptation;\n    }\n\n    var sameMimeType = newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n    var oldCodecs = currentAdaptation.Representation_asArray.map(function (representation) {\n      return representation.codecs;\n    });\n    var newCodecs = newAdaptation.Representation_asArray.map(function (representation) {\n      return representation.codecs;\n    });\n    var codecMatch = newCodecs.some(function (newCodec) {\n      return oldCodecs.indexOf(newCodec) > -1;\n    });\n    var partialCodecMatch = newCodecs.some(function (newCodec) {\n      return oldCodecs.some(function (oldCodec) {\n        return capabilities.codecRootCompatibleWithCodec(oldCodec, newCodec);\n      });\n    });\n    return codecMatch || partialCodecMatch && sameMimeType;\n  }\n\n  function setPreloaded(value) {\n    preloaded = value;\n  }\n\n  function getPreloaded() {\n    return preloaded;\n  }\n\n  function preload(mediaSource, previousBuffers) {\n    if (!getPreloaded()) {\n      addInlineEvents();\n      initializeMediaForType(_Constants2.default.VIDEO, mediaSource);\n      initializeMediaForType(_Constants2.default.AUDIO, mediaSource);\n      initializeMediaForType(_Constants2.default.TEXT, mediaSource);\n      initializeMediaForType(_Constants2.default.FRAGMENTED_TEXT, mediaSource);\n      initializeMediaForType(_Constants2.default.EMBEDDED_TEXT, mediaSource);\n      initializeMediaForType(_Constants2.default.MUXED, mediaSource);\n      initializeMediaForType(_Constants2.default.IMAGE, mediaSource);\n      createBuffers(previousBuffers);\n      eventBus.on(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n\n      for (var i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n        streamProcessors[i].getScheduleController().start();\n      }\n\n      setPreloaded(true);\n    }\n  }\n\n  instance = {\n    initialize: initialize,\n    getStreamId: getStreamId,\n    activate: activate,\n    deactivate: deactivate,\n    isActive: isActive,\n    getDuration: getDuration,\n    getStartTime: getStartTime,\n    getId: getId,\n    getStreamInfo: getStreamInfo,\n    getHasAudioTrack: getHasAudioTrack,\n    getHasVideoTrack: getHasVideoTrack,\n    preload: preload,\n    getThumbnailController: getThumbnailController,\n    getBitrateListFor: getBitrateListFor,\n    updateData: updateData,\n    reset: reset,\n    getProcessors: getProcessors,\n    setMediaSource: setMediaSource,\n    isMediaCodecCompatible: isMediaCodecCompatible,\n    isProtectionCompatible: isProtectionCompatible,\n    getPreloaded: getPreloaded,\n    getPreloadingScheduled: getPreloadingScheduled,\n    setPreloadingScheduled: setPreloadingScheduled,\n    getIsEndedEventSignaled: getIsEndedEventSignaled,\n    setIsEndedEventSignaled: setIsEndedEventSignaled\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nStream.__dashjs_factory_name = 'Stream';\nexports.default = _FactoryMaker2.default.getClassFactory(Stream);","map":{"version":3,"sources":["../../../../src/streaming/Stream.js"],"names":["config","context","eventBus","urlUtils","manifestModel","mediaPlayerModel","manifestUpdater","adapter","capabilities","capabilitiesFilter","errHandler","timelineConverter","dashMetrics","abrController","playbackController","eventController","mediaController","textController","protectionController","videoModel","settings","streamInfo","instance","logger","streamProcessors","isStreamInitialized","isStreamActivated","isMediaInitialized","hasVideoTrack","hasAudioTrack","updateError","isUpdating","fragmentController","thumbnailController","preloaded","boxParser","preloadingScheduled","debug","isEndedEventSignaled","trackChangedEvent","resetInitialSettings","dashConstants","DashConstants","registerEvents","registerProtectionEvents","Events","result","getPreloaded","initializeMedia","initializeAfterPreload","ln","errored","i","fragmentModel","getStartTime","getDuration","setPreloaded","isMediaSupported","msg","DashJSError","Errors","deactivate","unRegisterEvents","unRegisterProtectionEvents","Constants","checkConfig","type","mediaInfo","getMediaInfo","event","reset","codec","e","manifest","processor","getProcessorForMediaInfo","currentTime","streamProcessor","mimeType","baseURLController","optionalSettings","idx","allMediaForType","initialMediaInfo","events","createStreamProcessor","element","addInlineEvents","initializeMediaForType","buffers","createBuffers","checkIfInitializationCompleted","hasError","error","getId","liveStartTime","getLiveStartTime","buffer","processors","getProcessors","addInbandEvents","arr","previousStream","compareCodecs","compareProtectionConfig","newStreamInfo","stream","currentStreamInfo","getStreamInfo","newAdaptation","currentAdaptation","isAdaptationDrmProtected","adaptation","newStream","sameMimeType","oldCodecs","representation","newCodecs","codecMatch","partialCodecMatch","initialize","getStreamId","activate","isActive","getHasAudioTrack","getHasVideoTrack","preload","getThumbnailController","getBitrateListFor","updateData","setMediaSource","isMediaCodecCompatible","isProtectionCompatible","getPreloadingScheduled","setPreloadingScheduled","getIsEndedEventSignaled","setIsEndedEventSignaled","setup","Stream","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport StreamProcessor from './StreamProcessor';\nimport FragmentController from './controllers/FragmentController';\nimport ThumbnailController from './thumbnail/ThumbnailController';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport Debug from '../core/Debug';\nimport Errors from '../core/errors/Errors';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashJSError from './vo/DashJSError';\nimport BoxParser from './utils/BoxParser';\nimport URLUtils from './utils/URLUtils';\n\nfunction Stream(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    const manifestModel = config.manifestModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const manifestUpdater = config.manifestUpdater;\n    const adapter = config.adapter;\n    const capabilities = config.capabilities;\n    const capabilitiesFilter = config.capabilitiesFilter;\n    const errHandler = config.errHandler;\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const eventController = config.eventController;\n    const mediaController = config.mediaController;\n    const textController = config.textController;\n    const protectionController = config.protectionController;\n    const videoModel = config.videoModel;\n    const settings = config.settings;\n    let streamInfo = config.streamInfo;\n\n    let instance,\n        logger,\n        streamProcessors,\n        isStreamInitialized,\n        isStreamActivated,\n        isMediaInitialized,\n        hasVideoTrack,\n        hasAudioTrack,\n        updateError,\n        isUpdating,\n        fragmentController,\n        thumbnailController,\n        preloaded,\n        boxParser,\n        preloadingScheduled,\n        debug,\n        isEndedEventSignaled,\n        trackChangedEvent;\n\n    function setup() {\n        debug = Debug(context).getInstance();\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n\n        boxParser = BoxParser(context).getInstance();\n\n        fragmentController = FragmentController(context).create({\n            streamInfo: streamInfo,\n            mediaPlayerModel: mediaPlayerModel,\n            dashMetrics: dashMetrics,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser,\n            dashConstants: DashConstants,\n            urlUtils: urlUtils\n        });\n    }\n\n    function initialize() {\n        registerEvents();\n        registerProtectionEvents();\n        eventBus.trigger(Events.STREAM_UPDATED, { streamInfo: streamInfo });\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.INBAND_EVENTS, onInbandEvents, instance);\n    }\n\n    function unRegisterEvents() {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.off(Events.INBAND_EVENTS, onInbandEvents, instance);\n    }\n\n    function registerProtectionEvents() {\n        if (protectionController) {\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function unRegisterProtectionEvents() {\n        if (protectionController) {\n            eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function getStreamId() {\n        return streamInfo ? streamInfo.id : null;\n    }\n\n    /**\n     * Activates Stream by re-initializing some of its components\n     * @param {MediaSource} mediaSource\n     * @memberof Stream#\n     * @param {SourceBuffer} previousBuffers\n     */\n    function activate(mediaSource, previousBuffers) {\n        if (!isStreamActivated) {\n            let result;\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            if (!getPreloaded()) {\n                result = initializeMedia(mediaSource, previousBuffers);\n            } else {\n                initializeAfterPreload();\n                result = previousBuffers;\n            }\n            isStreamActivated = true;\n            return result;\n        }\n        return previousBuffers;\n    }\n\n    /**\n     * Partially resets some of the Stream elements\n     * @memberof Stream#\n     * @param {boolean} keepBuffers\n     */\n    function deactivate(keepBuffers) {\n        let ln = streamProcessors ? streamProcessors.length : 0;\n        const errored = false;\n        for (let i = 0; i < ln; i++) {\n            let fragmentModel = streamProcessors[i].getFragmentModel();\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            streamProcessors[i].reset(errored, keepBuffers);\n        }\n        streamProcessors = [];\n        isStreamActivated = false;\n        isMediaInitialized = false;\n        setPreloaded(false);\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    }\n\n    function isActive() {\n        return isStreamActivated;\n    }\n\n    function setMediaSource(mediaSource) {\n        for (let i = 0; i < streamProcessors.length;) {\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n                streamProcessors[i].setMediaSource(mediaSource);\n                i++;\n            } else {\n                streamProcessors[i].reset();\n                streamProcessors.splice(i, 1);\n            }\n        }\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n            //so do this after the buffers are created above.\n            streamProcessors[i].dischargePreBuffer();\n        }\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg + 'nostreams', manifestModel.getValue()));\n            logger.fatal(msg);\n        }\n    }\n\n    function resetInitialSettings() {\n        deactivate();\n        isStreamInitialized = false;\n        hasVideoTrack = false;\n        hasAudioTrack = false;\n        updateError = {};\n        isUpdating = false;\n        preloadingScheduled = false;\n        isEndedEventSignaled = false;\n    }\n\n    function reset() {\n\n        if (playbackController) {\n            playbackController.pause();\n        }\n\n        if (fragmentController) {\n            fragmentController.reset();\n            fragmentController = null;\n        }\n\n        streamInfo = null;\n\n        resetInitialSettings();\n\n        unRegisterEvents();\n\n        unRegisterProtectionEvents();\n\n        setPreloaded(false);\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    function getIsEndedEventSignaled() {\n        return isEndedEventSignaled;\n    }\n\n    function setIsEndedEventSignaled(value) {\n        isEndedEventSignaled = value;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getPreloadingScheduled() {\n        return preloadingScheduled;\n    }\n\n    function setPreloadingScheduled(value) {\n        preloadingScheduled = value;\n    }\n\n    function getLiveStartTime() {\n        if (!streamInfo.manifestInfo.isDynamic) return NaN;\n        // Get live start time of the video stream (1st in array of streams)\n        // or audio if no video stream\n        for (let i = 0; i < streamProcessors.length; i++) {\n            if (streamProcessors[i].getType() === Constants.AUDIO ||\n                streamProcessors[i].getType() === Constants.VIDEO) {\n                return streamProcessors[i].getLiveStartTime();\n            }\n        }\n        return NaN;\n    }\n\n    function getId() {\n        return streamInfo ? streamInfo.id : null;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getHasAudioTrack() {\n        return hasAudioTrack;\n    }\n\n    function getHasVideoTrack() {\n        return hasVideoTrack;\n    }\n\n    function getThumbnailController() {\n        return thumbnailController;\n    }\n\n    function checkConfig() {\n        if (!videoModel || !abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Array}\n     * @memberof Stream#\n     */\n    function getBitrateListFor(type) {\n        checkConfig();\n        if (type === Constants.IMAGE) {\n            if (!thumbnailController) {\n                return [];\n            }\n            return thumbnailController.getBitrateList();\n        }\n        const mediaInfo = getMediaInfo(type);\n        return abrController.getBitrateList(mediaInfo);\n    }\n\n    function onProtectionError(event) {\n        if (event.error) {\n            errHandler.error(event.error);\n            logger.fatal(event.error.message);\n            reset();\n        }\n    }\n\n    function isMediaSupported(mediaInfo) {\n        const type = mediaInfo ? mediaInfo.type : null;\n        let codec,\n            msg;\n\n        if (type === Constants.MUXED) {\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n            logger.fatal(msg);\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\n            return false;\n        }\n\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\n            return true;\n        }\n        codec = mediaInfo.codec;\n        logger.debug(type + ' codec: ' + codec);\n\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n            errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\n        } else if (!capabilities.supportsCodec(codec)) {\n            msg = type + 'Codec (' + codec + ') is not supported.';\n            logger.error(msg);\n            return false;\n        }\n\n        return true;\n    }\n\n    function onCurrentTrackChanged(e) {\n        if (!streamInfo || e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n        let mediaInfo = e.newMediaInfo;\n        let manifest = manifestModel.getValue();\n\n        adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\n\n        let processor = getProcessorForMediaInfo(mediaInfo);\n        if (!processor) return;\n\n        let currentTime = playbackController.getTime();\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\n\n        logger.debug('Stream -  Update stream controller');\n        if (manifest.refreshManifestOnSwitchTrack) { // Applies only for MSS streams\n            logger.debug('Stream -  Refreshing manifest for switch track');\n            trackChangedEvent = e;\n            manifestUpdater.refreshManifest();\n        } else {\n            processor.selectMediaInfo(mediaInfo);\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                processor.switchTrackAsked();\n                processor.getFragmentModel().abortRequests();\n            } else {\n                processor.getScheduleController().setSeekTarget(currentTime);\n                processor.setBufferingTime(currentTime);\n                processor.resetIndexHandler();\n            }\n        }\n    }\n\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n\n        let fragmentModel = fragmentController.getModel(mediaInfo ? mediaInfo.type : null);\n\n        let streamProcessor = StreamProcessor(context).create({\n            streamInfo: streamInfo,\n            type: mediaInfo ? mediaInfo.type : null,\n            mimeType: mediaInfo ? mediaInfo.mimeType : null,\n            timelineConverter: timelineConverter,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            mediaPlayerModel: mediaPlayerModel,\n            fragmentModel: fragmentModel,\n            dashMetrics: config.dashMetrics,\n            baseURLController: config.baseURLController,\n            abrController: abrController,\n            playbackController: playbackController,\n            mediaController: mediaController,\n            textController: textController,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser\n        });\n\n        streamProcessor.initialize(mediaSource, hasVideoTrack);\n        abrController.updateTopQualityIndex(mediaInfo);\n\n        if (optionalSettings) {\n            streamProcessor.setBuffer(optionalSettings.buffer);\n            streamProcessor.setBufferingTime(optionalSettings.currentTime);\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n        } else {\n            streamProcessors.push(streamProcessor);\n        }\n\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n            return;\n        }\n\n        if (mediaInfo && (mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\n            let idx;\n            for (let i = 0; i < allMediaForType.length; i++) {\n                if (allMediaForType[i].index === mediaInfo.index) {\n                    idx = i;\n                }\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n            }\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n        } else {\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n    }\n\n    function initializeMediaForType(type, mediaSource) {\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n\n        let mediaInfo = null;\n        let initialMediaInfo;\n\n        if (!allMediaForType || allMediaForType.length === 0) {\n            logger.info('No ' + type + ' data.');\n            return;\n        }\n\n        if (type === Constants.VIDEO) {\n            hasVideoTrack = true;\n        }\n\n        if (type === Constants.AUDIO) {\n            hasAudioTrack = true;\n        }\n\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\n            mediaInfo = allMediaForType[i];\n\n            if (type === Constants.EMBEDDED_TEXT) {\n                textController.addEmbeddedTrack(mediaInfo);\n            } else {\n                if (!isMediaSupported(mediaInfo)) continue;\n                mediaController.addTrack(mediaInfo);\n            }\n        }\n\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n            return;\n        }\n\n        if (type === Constants.IMAGE) {\n            thumbnailController = ThumbnailController(context).create({\n                streamInfo: streamInfo,\n                adapter: adapter,\n                baseURLController: config.baseURLController,\n                timelineConverter: config.timelineConverter,\n                debug: debug,\n                eventBus: eventBus,\n                events: Events,\n                dashConstants: DashConstants\n            });\n            return;\n        }\n\n\n        mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n        initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n\n        eventBus.trigger(Events.STREAM_INITIALIZING, {\n            streamInfo: streamInfo,\n            mediaInfo: mediaInfo\n        });\n\n        // TODO : How to tell index handler live/duration?\n        // TODO : Pass to controller and then pass to each method on handler?\n\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n    }\n\n    function addInlineEvents() {\n        if (eventController) {\n            const events = adapter.getEventsFor(streamInfo);\n            eventController.addInlineEvents(events);\n        }\n    }\n\n    function addInbandEvents(events) {\n        if (eventController) {\n            eventController.addInbandEvents(events);\n        }\n    }\n\n    function initializeMedia(mediaSource, previousBuffers) {\n        checkConfig();\n        let element = videoModel.getElement();\n\n        addInlineEvents();\n\n        isUpdating = true;\n\n        capabilitiesFilter.filterUnsupportedFeaturesOfPeriod( streamInfo);\n\n        if (!element || (element && (/^VIDEO$/i).test(element.nodeName))) {\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n        }\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n        const buffers = createBuffers(previousBuffers);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.fatal(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n\n        return buffers;\n    }\n\n    function initializeAfterPreload() {\n        isUpdating = true;\n        checkConfig();\n        capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.debug(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n    }\n\n    function checkIfInitializationCompleted() {\n        const ln = streamProcessors.length;\n        const hasError = !!updateError.audio || !!updateError.video;\n        let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\n\n        for (let i = 0; i < ln; i++) {\n            if (streamProcessors[i].isUpdating() || isUpdating) {\n                return;\n            }\n        }\n\n        if (!isMediaInitialized) {\n            return;\n        }\n\n        if (protectionController) {\n            // Need to check if streamProcessors exists because streamProcessors\n            // could be cleared in case an error is detected while initializing DRM keysystem\n            protectionController.clearMediaInfoArrayByStreamId(getId());\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\n                const type = streamProcessors[i].getType();\n                if (type === Constants.AUDIO ||\n                    type === Constants.VIDEO ||\n                    type === Constants.FRAGMENTED_TEXT) {\n                    let mediaInfo = streamProcessors[i].getMediaInfo();\n                    if (mediaInfo) {\n                        protectionController.initializeForMedia(mediaInfo);\n                    }\n                }\n            }\n        }\n\n        if (error) {\n            errHandler.error(error);\n        } else if (!isStreamInitialized) {\n            isStreamInitialized = true;\n\n            eventBus.trigger(Events.STREAM_INITIALIZED, {\n                streamInfo: streamInfo,\n                liveStartTime: !preloaded ? getLiveStartTime() : NaN\n            });\n        }\n\n        // (Re)start ScheduleController:\n        // - in case stream initialization has been completed after 'play' event (case for SegmentBase streams)\n        // - in case stream is complete but a track switch has been requested\n        for (let i = 0; i < ln && streamProcessors[i]; i++) {\n            streamProcessors[i].getScheduleController().start();\n        }\n    }\n\n    function getMediaInfo(type) {\n        let streamProcessor = null;\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            streamProcessor = streamProcessors[i];\n\n            if (streamProcessor.getType() === type) {\n                return streamProcessor.getMediaInfo();\n            }\n        }\n\n        return null;\n    }\n\n    function createBuffers(previousBuffers) {\n        const buffers = {};\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            const buffer = streamProcessors[i].createBuffer(previousBuffers);\n            if (buffer) {\n                buffers[streamProcessors[i].getType()] = buffer.getBuffer();\n            }\n        }\n        return buffers;\n    }\n\n    function onBufferingCompleted() {\n        let processors = getProcessors();\n        const ln = processors.length;\n\n        if (ln === 0) {\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n            return;\n        }\n\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\n        for (let i = 0; i < ln; i++) {\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\n                logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\n                return;\n            }\n        }\n\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, { streamInfo: streamInfo });\n    }\n\n    function onDataUpdateCompleted(e) {\n        updateError[e.mediaType] = e.error;\n        checkIfInitializationCompleted();\n    }\n\n    function onInbandEvents(e) {\n        addInbandEvents(e.events);\n    }\n\n    function getProcessorForMediaInfo(mediaInfo) {\n        if (!mediaInfo) {\n            return null;\n        }\n\n        let processors = getProcessors();\n\n        return processors.filter(function (processor) {\n            return (processor.getType() === mediaInfo.type);\n        })[0];\n    }\n\n    function getProcessors() {\n        let arr = [];\n\n        let type,\n            streamProcessor;\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            streamProcessor = streamProcessors[i];\n            type = streamProcessor.getType();\n\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\n                arr.push(streamProcessor);\n            }\n        }\n\n        return arr;\n    }\n\n    function updateData(updatedStreamInfo) {\n        logger.info('Manifest updated... updating data system wide.');\n\n        isStreamActivated = false;\n        isUpdating = true;\n        streamInfo = updatedStreamInfo;\n\n        eventBus.trigger(Events.STREAM_UPDATED, { streamInfo: streamInfo });\n\n        if (eventController) {\n            addInlineEvents();\n        }\n\n        capabilitiesFilter.filterUnsupportedFeaturesOfPeriod(streamInfo);\n\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            let streamProcessor = streamProcessors[i];\n            streamProcessor.updateStreamInfo(streamInfo);\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\n            // Check if AdaptationSet has not been removed in MPD update\n            if (mediaInfo) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                streamProcessor.addMediaInfo(mediaInfo, true);\n            }\n        }\n\n        if (trackChangedEvent) {\n            let mediaInfo = trackChangedEvent.newMediaInfo;\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n                if (!processor) return;\n                processor.switchTrackAsked();\n                trackChangedEvent = undefined;\n            }\n        }\n\n        isUpdating = false;\n        checkIfInitializationCompleted();\n    }\n\n    function isMediaCodecCompatible(newStream, previousStream = null) {\n        return compareCodecs(newStream, Constants.VIDEO, previousStream) && compareCodecs(newStream, Constants.AUDIO, previousStream);\n    }\n\n    function isProtectionCompatible(stream, previousStream = null) {\n        return compareProtectionConfig(stream, Constants.VIDEO, previousStream) && compareProtectionConfig(stream, Constants.AUDIO, previousStream);\n    }\n\n    function compareProtectionConfig(stream, type, previousStream = null) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n        return !(!isAdaptationDrmProtected(currentAdaptation) && isAdaptationDrmProtected(newAdaptation));\n    }\n\n    function isAdaptationDrmProtected(adaptation) {\n\n        if (!adaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return false;\n        }\n\n        // If the current period is unencrypted and the upcoming one is encrypted we need to reset sourcebuffers.\n        return !!(adaptation.ContentProtection || (adaptation.Representation && adaptation.Representation.length > 0 && adaptation.Representation[0].ContentProtection));\n    }\n\n    function compareCodecs(newStream, type, previousStream = null) {\n        if (!newStream || !newStream.hasOwnProperty('getStreamInfo')) {\n            return false;\n        }\n        const newStreamInfo = newStream.getStreamInfo();\n        const currentStreamInfo = previousStream ? previousStream.getStreamInfo() : getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        const sameMimeType = newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const codecMatch = newCodecs.some((newCodec) => {\n            return oldCodecs.indexOf(newCodec) > -1;\n        });\n\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => capabilities.codecRootCompatibleWithCodec(oldCodec, newCodec)));\n        return codecMatch || (partialCodecMatch && sameMimeType);\n    }\n\n    function setPreloaded(value) {\n        preloaded = value;\n    }\n\n    function getPreloaded() {\n        return preloaded;\n    }\n\n    function preload(mediaSource, previousBuffers) {\n        if (!getPreloaded()) {\n            addInlineEvents();\n\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n            initializeMediaForType(Constants.AUDIO, mediaSource);\n            initializeMediaForType(Constants.TEXT, mediaSource);\n            initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n            initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n            initializeMediaForType(Constants.MUXED, mediaSource);\n            initializeMediaForType(Constants.IMAGE, mediaSource);\n\n            createBuffers(previousBuffers);\n\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n                streamProcessors[i].getScheduleController().start();\n            }\n\n            setPreloaded(true);\n        }\n    }\n\n\n    instance = {\n        initialize: initialize,\n        getStreamId: getStreamId,\n        activate: activate,\n        deactivate: deactivate,\n        isActive: isActive,\n        getDuration: getDuration,\n        getStartTime: getStartTime,\n        getId: getId,\n        getStreamInfo: getStreamInfo,\n        getHasAudioTrack: getHasAudioTrack,\n        getHasVideoTrack: getHasVideoTrack,\n        preload: preload,\n        getThumbnailController: getThumbnailController,\n        getBitrateListFor: getBitrateListFor,\n        updateData: updateData,\n        reset: reset,\n        getProcessors: getProcessors,\n        setMediaSource: setMediaSource,\n        isMediaCodecCompatible: isMediaCodecCompatible,\n        isProtectionCompatible: isProtectionCompatible,\n        getPreloaded: getPreloaded,\n        getPreloadingScheduled,\n        setPreloadingScheduled,\n        getIsEndedEventSignaled,\n        setIsEndedEventSignaled\n    };\n\n    setup();\n    return instance;\n}\n\nStream.__dashjs_factory_name = 'Stream';\nexport default FactoryMaker.getClassFactory(Stream);\n"]},"metadata":{},"sourceType":"script"}