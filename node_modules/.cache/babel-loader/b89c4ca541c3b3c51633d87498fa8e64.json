{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\n\nfunction PlaybackController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      streamController = void 0,\n      dashMetrics = void 0,\n      adapter = void 0,\n      videoModel = void 0,\n      timelineConverter = void 0,\n      streamSwitch = void 0,\n      streamSeekTime = void 0,\n      wallclockTimeIntervalId = void 0,\n      liveDelay = void 0,\n      streamInfo = void 0,\n      isDynamic = void 0,\n      mediaPlayerModel = void 0,\n      playOnceInitialized = void 0,\n      lastLivePlaybackTime = void 0,\n      availabilityStartTime = void 0,\n      seekTarget = void 0,\n      internalSeek = void 0,\n      isLowLatencySeekingInProgress = void 0,\n      playbackStalled = void 0,\n      minPlaybackRateChange = void 0,\n      uriFragmentModel = void 0,\n      settings = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    reset();\n  }\n\n  function initialize(sInfo, periodSwitch, seekTime) {\n    streamInfo = sInfo;\n    addAllListeners();\n    isDynamic = streamInfo.manifestInfo.isDynamic;\n    isLowLatencySeekingInProgress = false;\n    playbackStalled = false;\n    streamSwitch = periodSwitch === true;\n    streamSeekTime = seekTime;\n    internalSeek = false;\n    var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : ''; // Detect safari browser (special behavior for low latency streams)\n\n    var isSafari = /safari/.test(ua) && !/chrome/.test(ua);\n    minPlaybackRateChange = isSafari ? 0.25 : 0.02;\n    eventBus.on(_Events2.default.STREAM_INITIALIZED, onStreamInitialized, this);\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n    eventBus.on(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, this);\n    eventBus.on(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n    eventBus.on(_Events2.default.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n    eventBus.on(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n    eventBus.on(_Events2.default.PLAYBACK_ENDED, onPlaybackEnded, this, {\n      priority: _EventBus2.default.EVENT_PRIORITY_HIGH\n    });\n    eventBus.on(_Events2.default.STREAM_INITIALIZING, onStreamInitializing, this);\n\n    if (playOnceInitialized) {\n      playOnceInitialized = false;\n      play();\n    }\n  }\n\n  function onStreamInitialized(e) {\n    // Seamless period switch\n    if (streamSwitch && isNaN(streamSeekTime)) return; // Seek new stream in priority order:\n    // - at seek time (streamSeekTime) when switching period\n    // - at start time provided in URI parameters\n    // - at stream/period start time (for static streams) or live start time (for dynamic streams)\n\n    var startTime = streamSeekTime;\n\n    if (isNaN(startTime)) {\n      if (isDynamic) {\n        // For dynamic stream, start by default at (live edge - live delay)\n        startTime = e.liveStartTime; // If start time in URI, take min value between live edge time and time from URI (capped by DVR window range)\n\n        var dvrInfo = dashMetrics.getCurrentDVRInfo();\n        var dvrWindow = dvrInfo ? dvrInfo.range : null;\n\n        if (dvrWindow) {\n          // #t shall be relative to period start\n          var startTimeFromUri = getStartTimeFromUriParameters(true);\n\n          if (!isNaN(startTimeFromUri)) {\n            logger.info('Start time from URI parameters: ' + startTimeFromUri);\n            startTime = Math.max(Math.min(startTime, startTimeFromUri), dvrWindow.start);\n          }\n        }\n      } else {\n        // For static stream, start by default at period start\n        startTime = streamInfo.start; // If start time in URI, take max value between period start and time from URI (if in period range)\n\n        var _startTimeFromUri = getStartTimeFromUriParameters(false);\n\n        if (!isNaN(_startTimeFromUri) && _startTimeFromUri < startTime + streamInfo.duration) {\n          logger.info('Start time from URI parameters: ' + _startTimeFromUri);\n          startTime = Math.max(startTime, _startTimeFromUri);\n        }\n      }\n    }\n\n    if (!isNaN(startTime) && startTime !== videoModel.getTime()) {\n      // Trigger PLAYBACK_SEEKING event for controllers\n      eventBus.trigger(_Events2.default.PLAYBACK_SEEKING, {\n        seekTime: startTime\n      }); // Seek video model\n\n      seek(startTime, false, true);\n    }\n  }\n\n  function getTimeToStreamEnd() {\n    return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\n  }\n\n  function getStreamEndTime() {\n    return streamInfo.start + streamInfo.duration;\n  }\n\n  function play() {\n    if (streamInfo && videoModel && videoModel.getElement()) {\n      videoModel.play();\n    } else {\n      playOnceInitialized = true;\n    }\n  }\n\n  function isPaused() {\n    return streamInfo && videoModel ? videoModel.isPaused() : null;\n  }\n\n  function pause() {\n    if (streamInfo && videoModel) {\n      videoModel.pause();\n    }\n  }\n\n  function isSeeking() {\n    return streamInfo && videoModel ? videoModel.isSeeking() : null;\n  }\n\n  function seek(time, stickToBuffered, internal) {\n    if (!streamInfo || !videoModel) return;\n    var currentTime = !isNaN(seekTarget) ? seekTarget : videoModel.getTime();\n    if (time === currentTime) return;\n    internalSeek = internal === true;\n\n    if (!internalSeek) {\n      seekTarget = time;\n      eventBus.trigger(_Events2.default.PLAYBACK_SEEK_ASKED);\n    }\n\n    logger.info('Requesting seek to time: ' + time + (internalSeek ? ' (internal)' : ''));\n    videoModel.setCurrentTime(time, stickToBuffered);\n  }\n\n  function seekToLive() {\n    var DVRMetrics = dashMetrics.getCurrentDVRInfo();\n    var DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n    seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\n  }\n\n  function getTime() {\n    return streamInfo && videoModel ? videoModel.getTime() : null;\n  }\n\n  function getNormalizedTime() {\n    var t = getTime();\n\n    if (isDynamic && !isNaN(availabilityStartTime)) {\n      var timeOffset = availabilityStartTime / 1000; // Fix current time for firefox and safari (returned as an absolute time)\n\n      if (t > timeOffset) {\n        t -= timeOffset;\n      }\n    }\n\n    return t;\n  }\n\n  function getPlaybackRate() {\n    return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\n  }\n\n  function getPlayedRanges() {\n    return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\n  }\n\n  function getEnded() {\n    return streamInfo && videoModel ? videoModel.getEnded() : null;\n  }\n\n  function getIsDynamic() {\n    return isDynamic;\n  }\n\n  function getStreamController() {\n    return streamController;\n  }\n  /**\n  * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\n  * @param {number} fragmentDuration - seconds?\n  * @param {number} dvrWindowSize - seconds?\n  * @param {number} minBufferTime - seconds?\n  * @returns {number} object\n  * @memberof PlaybackController#\n  */\n\n\n  function computeAndSetLiveDelay(fragmentDuration, dvrWindowSize, minBufferTime) {\n    var delay = void 0,\n        ret = void 0,\n        startTime = void 0;\n    var END_OF_PLAYLIST_PADDING = 10;\n    var MIN_BUFFER_TIME_FACTOR = 4;\n    var FRAGMENT_DURATION_FACTOR = 4;\n    var adjustedFragmentDuration = !isNaN(fragmentDuration) && isFinite(fragmentDuration) ? fragmentDuration : NaN;\n    var suggestedPresentationDelay = adapter.getSuggestedPresentationDelay();\n\n    if (settings.get().streaming.lowLatencyEnabled) {\n      delay = 0;\n    } else if (mediaPlayerModel.getLiveDelay()) {\n      delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\n    } else if (settings.get().streaming.liveDelayFragmentCount !== null && !isNaN(settings.get().streaming.liveDelayFragmentCount) && !isNaN(adjustedFragmentDuration)) {\n      delay = adjustedFragmentDuration * settings.get().streaming.liveDelayFragmentCount;\n    } else if (settings.get().streaming.useSuggestedPresentationDelay === true && suggestedPresentationDelay !== null && !isNaN(suggestedPresentationDelay) && suggestedPresentationDelay > 0) {\n      delay = suggestedPresentationDelay;\n    } else if (!isNaN(adjustedFragmentDuration)) {\n      delay = adjustedFragmentDuration * FRAGMENT_DURATION_FACTOR;\n    } else {\n      delay = !isNaN(minBufferTime) ? minBufferTime * MIN_BUFFER_TIME_FACTOR : streamInfo.manifestInfo.minBufferTime * MIN_BUFFER_TIME_FACTOR;\n    }\n\n    startTime = adapter.getAvailabilityStartTime();\n\n    if (startTime !== null) {\n      availabilityStartTime = startTime;\n    }\n\n    if (dvrWindowSize > 0) {\n      // cap target latency to:\n      // - dvrWindowSize / 2 for short playlists\n      // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\n      var targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\n      ret = Math.min(delay, targetDelayCapping);\n    } else {\n      ret = delay;\n    }\n\n    liveDelay = ret;\n    return ret;\n  }\n\n  function getLiveDelay() {\n    return liveDelay;\n  }\n\n  function setLiveDelay(value) {\n    var useMaxValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (useMaxValue && value < liveDelay) {\n      return;\n    }\n\n    liveDelay = value;\n  }\n\n  function getCurrentLiveLatency() {\n    if (!isDynamic || isNaN(availabilityStartTime)) {\n      return NaN;\n    }\n\n    var currentTime = getNormalizedTime();\n\n    if (isNaN(currentTime) || currentTime === 0) {\n      return 0;\n    }\n\n    var now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\n    return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\n  }\n\n  function reset() {\n    playOnceInitialized = false;\n    streamSwitch = false;\n    streamSeekTime = NaN;\n    liveDelay = 0;\n    availabilityStartTime = 0;\n    seekTarget = NaN;\n\n    if (videoModel) {\n      eventBus.off(_Events2.default.STREAM_INITIALIZED, onStreamInitialized, this);\n      eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n      eventBus.off(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n      eventBus.off(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, this);\n      eventBus.off(_Events2.default.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n      eventBus.off(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n      eventBus.off(_Events2.default.PLAYBACK_ENDED, onPlaybackEnded, this);\n      eventBus.off(_Events2.default.STREAM_INITIALIZING, onStreamInitializing, this);\n      stopUpdatingWallclockTime();\n      removeAllListeners();\n    }\n\n    wallclockTimeIntervalId = null;\n    videoModel = null;\n    streamInfo = null;\n    isDynamic = null;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.mediaPlayerModel) {\n      mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.timelineConverter) {\n      timelineConverter = config.timelineConverter;\n    }\n\n    if (config.uriFragmentModel) {\n      uriFragmentModel = config.uriFragmentModel;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function getStartTimeFromUriParameters(isDynamic) {\n    var fragData = uriFragmentModel.getURIFragmentData();\n\n    if (!fragData || !fragData.t) {\n      return NaN;\n    }\n\n    var refStream = streamController.getStreams()[0];\n    var refStreamStartTime = refStream.getStreamInfo().start; // Consider only start time of MediaRange\n    // TODO: consider end time of MediaRange to stop playback at provided end time\n\n    fragData.t = fragData.t.split(',')[0]; // \"t=<time>\" : time is relative to 1st period start\n    // \"t=posix:<time>\" : time is absolute start time as number of seconds since 01-01-1970\n\n    var posix = fragData.t.indexOf('posix:') !== -1 ? fragData.t.substring(6) === 'now' ? Date.now() / 1000 : parseInt(fragData.t.substring(6)) : NaN;\n    var startTime = isDynamic && !isNaN(posix) ? posix - availabilityStartTime / 1000 : parseInt(fragData.t) + refStreamStartTime;\n    return startTime;\n  }\n\n  function getActualPresentationTime(currentTime, mediatype) {\n    var DVRMetrics = dashMetrics.getCurrentDVRInfo(mediatype);\n    var DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n    var actualTime = void 0;\n\n    if (!DVRWindow) {\n      return NaN;\n    }\n\n    logger.debug('Checking DVR window for at ' + currentTime + ' with DVR window range ' + DVRWindow.start + ' - ' + DVRWindow.end);\n\n    if (currentTime > DVRWindow.end) {\n      actualTime = Math.max(DVRWindow.end - liveDelay, DVRWindow.start);\n    } else if (currentTime > 0 && currentTime + 0.250 < DVRWindow.start && Math.abs(currentTime - DVRWindow.start) < 315360000) {\n      // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\n      // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\n      // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\n      // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime\n      // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year)\n      //actualTime = DVRWindow.start;\n      actualTime = DVRWindow.start;\n    } else {\n      actualTime = currentTime;\n    }\n\n    return actualTime;\n  }\n\n  function startUpdatingWallclockTime() {\n    if (wallclockTimeIntervalId !== null) return;\n\n    var tick = function tick() {\n      onWallclockTime();\n    };\n\n    wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval);\n  }\n\n  function stopUpdatingWallclockTime() {\n    clearInterval(wallclockTimeIntervalId);\n    wallclockTimeIntervalId = null;\n  }\n\n  function updateCurrentTime(mediaType) {\n    if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\n    var currentTime = getNormalizedTime();\n    var actualTime = getActualPresentationTime(currentTime, mediaType);\n    var timeChanged = !isNaN(actualTime) && actualTime !== currentTime;\n\n    if (timeChanged && !isSeeking()) {\n      logger.debug('UpdateCurrentTime: Seek to actual time: ' + actualTime + ' from currentTime: ' + currentTime);\n      seek(actualTime);\n    }\n  }\n\n  function onDataUpdateCompleted(e) {\n    if (e.error) return;\n    var representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n    var info = representationInfo ? representationInfo.mediaInfo.streamInfo : null;\n    if (info === null || streamInfo.id !== info.id) return;\n    streamInfo = info;\n    updateCurrentTime();\n  }\n\n  function onCanPlay() {\n    eventBus.trigger(_Events2.default.CAN_PLAY);\n  }\n\n  function onPlaybackStart() {\n    logger.info('Native video element event: play');\n    updateCurrentTime();\n    startUpdatingWallclockTime();\n    eventBus.trigger(_Events2.default.PLAYBACK_STARTED, {\n      startTime: getTime()\n    });\n  }\n\n  function onPlaybackWaiting() {\n    logger.info('Native video element event: waiting');\n    eventBus.trigger(_Events2.default.PLAYBACK_WAITING, {\n      playingTime: getTime()\n    });\n  }\n\n  function onPlaybackPlaying() {\n    logger.info('Native video element event: playing');\n    eventBus.trigger(_Events2.default.PLAYBACK_PLAYING, {\n      playingTime: getTime()\n    });\n  }\n\n  function onPlaybackPaused() {\n    logger.info('Native video element event: pause');\n    eventBus.trigger(_Events2.default.PLAYBACK_PAUSED, {\n      ended: getEnded()\n    });\n  }\n\n  function onPlaybackSeeking() {\n    // Check if internal seeking to be ignored\n    if (internalSeek) {\n      internalSeek = false;\n      return;\n    }\n\n    var seekTime = getTime(); // On some browsers/devices, in case of live streams, setting current time on video element fails when there is no buffered data at requested time\n    // Then re-set seek target time and video element will be seeked afterwhile once data is buffered (see BufferContoller)\n\n    if (!isNaN(seekTarget) && seekTarget !== seekTime) {\n      seekTime = seekTarget;\n    }\n\n    seekTarget = NaN;\n    logger.info('Seeking to: ' + seekTime);\n    startUpdatingWallclockTime();\n    eventBus.trigger(_Events2.default.PLAYBACK_SEEKING, {\n      seekTime: seekTime\n    });\n  }\n\n  function onPlaybackSeeked() {\n    logger.info('Native video element event: seeked');\n    eventBus.trigger(_Events2.default.PLAYBACK_SEEKED);\n  }\n\n  function onPlaybackTimeUpdated() {\n    if (streamInfo) {\n      eventBus.trigger(_Events2.default.PLAYBACK_TIME_UPDATED, {\n        timeToEnd: getTimeToStreamEnd(),\n        time: getTime()\n      });\n    }\n  }\n\n  function updateLivePlaybackTime() {\n    var now = Date.now();\n\n    if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\n      lastLivePlaybackTime = now;\n      onPlaybackTimeUpdated();\n    }\n  }\n\n  function onPlaybackProgress() {\n    eventBus.trigger(_Events2.default.PLAYBACK_PROGRESS);\n  }\n\n  function onPlaybackRateChanged() {\n    var rate = getPlaybackRate();\n    logger.info('Native video element event: ratechange: ', rate);\n    eventBus.trigger(_Events2.default.PLAYBACK_RATE_CHANGED, {\n      playbackRate: rate\n    });\n  }\n\n  function onPlaybackMetaDataLoaded() {\n    logger.info('Native video element event: loadedmetadata');\n    eventBus.trigger(_Events2.default.PLAYBACK_METADATA_LOADED);\n    startUpdatingWallclockTime();\n  } // Event to handle the native video element ended event\n\n\n  function onNativePlaybackEnded() {\n    logger.info('Native video element event: ended');\n    pause();\n    stopUpdatingWallclockTime();\n    var streamInfo = streamController ? streamController.getActiveStreamInfo() : null;\n    if (!streamInfo) return;\n    eventBus.trigger(_Events2.default.PLAYBACK_ENDED, {\n      'isLast': streamInfo.isLast\n    });\n  } // Handle DASH PLAYBACK_ENDED event\n\n\n  function onPlaybackEnded(e) {\n    if (wallclockTimeIntervalId && e.isLast) {\n      // PLAYBACK_ENDED was triggered elsewhere, react.\n      logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\n      var seekTime = e.seekTime ? e.seekTime : getStreamEndTime();\n      videoModel.setCurrentTime(seekTime);\n      pause();\n      stopUpdatingWallclockTime();\n    }\n  }\n\n  function onPlaybackError(event) {\n    var target = event.target || event.srcElement;\n    eventBus.trigger(_Events2.default.PLAYBACK_ERROR, {\n      error: target.error\n    });\n  }\n\n  function onWallclockTime() {\n    eventBus.trigger(_Events2.default.WALLCLOCK_TIME_UPDATED, {\n      isDynamic: isDynamic,\n      time: new Date()\n    }); // Updates playback time for paused dynamic streams\n    // (video element doesn't call timeupdate when the playback is paused)\n\n    if (getIsDynamic() && isPaused()) {\n      updateLivePlaybackTime();\n    }\n  }\n\n  function onPlaybackProgression() {\n    if (isDynamic && _isCatchupEnabled() && settings.get().streaming.liveCatchup.playbackRate > 0 && !isPaused() && !isSeeking()) {\n      if (_needToCatchUp()) {\n        startPlaybackCatchUp();\n      } else {\n        stopPlaybackCatchUp();\n      }\n    }\n  }\n\n  function _isCatchupEnabled() {\n    return settings.get().streaming.liveCatchup.enabled || settings.get().streaming.lowLatencyEnabled;\n  }\n\n  function getBufferLevel() {\n    var bufferLevel = null;\n    streamController.getActiveStreamProcessors().forEach(function (p) {\n      var bl = p.getBufferLevel();\n\n      if (bufferLevel === null) {\n        bufferLevel = bl;\n      } else {\n        bufferLevel = Math.min(bufferLevel, bl);\n      }\n    });\n    return bufferLevel;\n  }\n  /**\n  * Returns the mode for live playback catchup.\n  * @return {String}\n  * @private\n  */\n\n\n  function _getCatchupMode() {\n    var playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n    return settings.get().streaming.liveCatchup.mode === _Constants2.default.LIVE_CATCHUP_MODE_LOLP && playbackBufferMin !== null && !isNaN(playbackBufferMin) ? _Constants2.default.LIVE_CATCHUP_MODE_LOLP : _Constants2.default.LIVE_CATCHUP_MODE_DEFAULT;\n  }\n  /**\n  * Checks whether the catchup mechanism should be enabled\n  * @return {boolean}\n  */\n\n\n  function _needToCatchUp() {\n    try {\n      if (_isCatchupEnabled() && settings.get().streaming.liveCatchup.playbackRate > 0 && getTime() > 0) {\n        var catchupMode = _getCatchupMode();\n\n        var currentLiveLatency = getCurrentLiveLatency();\n\n        var _liveDelay = mediaPlayerModel.getLiveDelay();\n\n        var liveCatchupLatencyThreshold = mediaPlayerModel.getLiveCatchupLatencyThreshold();\n        var liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n\n        if (catchupMode === _Constants2.default.LIVE_CATCHUP_MODE_LOLP) {\n          var currentBuffer = getBufferLevel();\n          var playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n          return _lolpNeedToCatchUpCustom(currentLiveLatency, _liveDelay, liveCatchUpMinDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold);\n        } else {\n          return _defaultNeedToCatchUp(currentLiveLatency, _liveDelay, liveCatchupLatencyThreshold, liveCatchUpMinDrift);\n        }\n      }\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Default algorithm to determine if catchup mode should be enabled\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} liveCatchupLatencyThreshold\n  * @param {number} minDrift\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, minDrift) {\n    try {\n      var latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n      return latencyDrift > minDrift && (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold);\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * LoL+ logic to determine if catchup mode should be enabled\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} minDrift\n  * @param {number} currentBuffer\n  * @param {number} playbackBufferMin\n  * @param {number} liveCatchupLatencyThreshold\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, minDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold) {\n    try {\n      var latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n      return (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold) && (latencyDrift > minDrift || currentBuffer < playbackBufferMin);\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Apply catchup mode\n  */\n\n\n  function startPlaybackCatchUp() {\n    if (videoModel) {\n      var results = void 0;\n      var currentPlaybackRate = videoModel.getPlaybackRate();\n      var liveCatchupPlaybackRate = settings.get().streaming.liveCatchup.playbackRate;\n      var currentLiveLatency = getCurrentLiveLatency();\n\n      var _liveDelay2 = mediaPlayerModel.getLiveDelay();\n\n      var bufferLevel = getBufferLevel(); // Custom playback control: Based on buffer level\n\n      if (_getCatchupMode() === _Constants2.default.LIVE_CATCHUP_MODE_LOLP) {\n        var liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n        var playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n        results = _calculateNewPlaybackRateLolP(liveCatchupPlaybackRate, currentLiveLatency, _liveDelay2, liveCatchUpMinDrift, playbackBufferMin, bufferLevel, currentPlaybackRate);\n      } else {\n        // Default playback control: Based on target and current latency\n        results = _calculateNewPlaybackRateDefault(liveCatchupPlaybackRate, currentLiveLatency, _liveDelay2, bufferLevel, currentPlaybackRate);\n      } // Obtain newRate and apply to video model\n\n\n      var newRate = results.newRate;\n\n      if (newRate) {\n        // non-null\n        videoModel.setPlaybackRate(newRate);\n      }\n\n      var deltaLatency = currentLiveLatency - _liveDelay2;\n\n      if (settings.get().streaming.liveCatchup.maxDrift > 0 && !isLowLatencySeekingInProgress && deltaLatency > settings.get().streaming.liveCatchup.maxDrift) {\n        logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\n        isLowLatencySeekingInProgress = true;\n        seekToLive();\n      } else {\n        isLowLatencySeekingInProgress = false;\n      }\n    }\n  }\n  /**\n  * Default algorithm to calculate the new playback rate\n  * @param {number} liveCatchUpPlaybackRate\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} bufferLevel\n  * @param {number} currentPlaybackRate\n  * @return {{newRate: number}}\n  * @private\n  */\n\n\n  function _calculateNewPlaybackRateDefault(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate) {\n    var cpr = liveCatchUpPlaybackRate;\n    var deltaLatency = currentLiveLatency - liveDelay;\n    var d = deltaLatency * 5; // Playback rate must be between (1 - cpr) - (1 + cpr)\n    // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n\n    var s = cpr * 2 / (1 + Math.pow(Math.E, -d));\n    var newRate = 1 - cpr + s; // take into account situations in which there are buffer stalls,\n    // in which increasing playbackRate to reach target latency will\n    // just cause more and more stall situations\n\n    if (playbackStalled) {\n      // const bufferLevel = getBufferLevel();\n      if (bufferLevel > liveDelay / 2) {\n        // playbackStalled = false;\n        playbackStalled = false;\n      } else if (deltaLatency > 0) {\n        newRate = 1.0;\n      }\n    } // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n\n\n    if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n      newRate = null;\n    }\n\n    return {\n      newRate: newRate\n    };\n  }\n  /**\n  * Lol+ algorithm to calculate the new playback rate\n  * @param {number} liveCatchUpPlaybackRate\n  * @param {number} currentLiveLatency\n  * @param {number} liveDelay\n  * @param {number} minDrift\n  * @param {number} playbackBufferMin\n  * @param {number} bufferLevel\n  * @param {number} currentPlaybackRate\n  * @return {{newRate: number}}\n  * @private\n  */\n\n\n  function _calculateNewPlaybackRateLolP(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, minDrift, playbackBufferMin, bufferLevel, currentPlaybackRate) {\n    var cpr = liveCatchUpPlaybackRate;\n    var newRate = void 0; // Hybrid: Buffer-based\n\n    if (bufferLevel < playbackBufferMin) {\n      // Buffer in danger, slow down\n      var deltaBuffer = bufferLevel - playbackBufferMin; // -ve value\n\n      var d = deltaBuffer * 5; // Playback rate must be between (1 - cpr) - (1 + cpr)\n      // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n\n      var s = cpr * 2 / (1 + Math.pow(Math.E, -d));\n      newRate = 1 - cpr + s;\n      logger.debug('[LoL+ playback control_buffer-based] bufferLevel: ' + bufferLevel + ', newRate: ' + newRate);\n    } else {\n      // Hybrid: Latency-based\n      // Buffer is safe, vary playback rate based on latency\n      // Check if latency is within range of target latency\n      var minDifference = 0.02;\n\n      if (Math.abs(currentLiveLatency - liveDelay) <= minDifference * liveDelay) {\n        newRate = 1;\n      } else {\n        var deltaLatency = currentLiveLatency - liveDelay;\n\n        var _d = deltaLatency * 5; // Playback rate must be between (1 - cpr) - (1 + cpr)\n        // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n\n\n        var _s = cpr * 2 / (1 + Math.pow(Math.E, -_d));\n\n        newRate = 1 - cpr + _s;\n      }\n\n      logger.debug('[LoL+ playback control_latency-based] latency: ' + currentLiveLatency + ', newRate: ' + newRate);\n    }\n\n    if (playbackStalled) {\n      if (bufferLevel > liveDelay / 2) {\n        playbackStalled = false;\n      }\n    } // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n\n\n    if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n      newRate = null;\n    }\n\n    return {\n      newRate: newRate\n    };\n  }\n\n  function stopPlaybackCatchUp() {\n    if (videoModel) {\n      videoModel.setPlaybackRate(1.0);\n    }\n  }\n\n  function onFragmentLoadProgress(e) {\n    // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\n    if (e.stream === false && settings.get().streaming.lowLatencyEnabled && !isNaN(e.request.duration)) {\n      var minDelay = 1.2 * e.request.duration;\n\n      if (minDelay > mediaPlayerModel.getLiveDelay()) {\n        logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\n        var s = {\n          streaming: {\n            liveDelay: minDelay\n          }\n        };\n        settings.update(s);\n      }\n    }\n  }\n\n  function onBufferLevelStateChanged(e) {\n    // do not stall playback when get an event from Stream that is not active\n    if (e.streamId !== streamInfo.id) return;\n\n    if (_isCatchupEnabled()) {\n      if (e.state === _MetricsConstants2.default.BUFFER_EMPTY && !isSeeking()) {\n        if (!playbackStalled) {\n          playbackStalled = true;\n          stopPlaybackCatchUp();\n        }\n      }\n    } else {\n      videoModel.setStallState(e.mediaType, e.state === _MetricsConstants2.default.BUFFER_EMPTY);\n    }\n  }\n\n  function onPlaybackStalled(e) {\n    eventBus.trigger(_Events2.default.PLAYBACK_STALLED, {\n      e: e\n    });\n  }\n\n  function onStreamInitializing(e) {\n    applyServiceDescription(e.streamInfo, e.mediaInfo);\n  }\n\n  function applyServiceDescription(streamInfo, mediaInfo) {\n    if (streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.serviceDescriptions) {\n      // is there a service description for low latency defined?\n      var llsd = void 0;\n\n      for (var i = 0; i < streamInfo.manifestInfo.serviceDescriptions.length; i++) {\n        var sd = streamInfo.manifestInfo.serviceDescriptions[i];\n\n        if (sd.schemeIdUri === _Constants2.default.SERVICE_DESCRIPTION_LL_SCHEME) {\n          llsd = sd;\n          break;\n        }\n      }\n\n      if (llsd) {\n        if (mediaInfo && mediaInfo.supplementalProperties && mediaInfo.supplementalProperties[_Constants2.default.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') {\n          if (llsd.latency && llsd.latency.target > 0) {\n            logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target);\n            settings.update({\n              streaming: {\n                lowLatencyEnabled: true,\n                liveDelay: llsd.latency.target / 1000,\n                liveCatchup: {\n                  minDrift: llsd.latency.max > llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined\n                }\n              }\n            });\n          }\n\n          if (llsd.playbackRate && llsd.playbackRate.max > 1.0) {\n            logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max);\n            settings.update({\n              streaming: {\n                lowLatencyEnabled: true,\n                liveCatchup: {\n                  playbackRate: llsd.playbackRate.max - 1.0\n                }\n              }\n            });\n          }\n        }\n      }\n    }\n  }\n\n  function addAllListeners() {\n    videoModel.addEventListener('canplay', onCanPlay);\n    videoModel.addEventListener('play', onPlaybackStart);\n    videoModel.addEventListener('waiting', onPlaybackWaiting);\n    videoModel.addEventListener('playing', onPlaybackPlaying);\n    videoModel.addEventListener('pause', onPlaybackPaused);\n    videoModel.addEventListener('error', onPlaybackError);\n    videoModel.addEventListener('seeking', onPlaybackSeeking);\n    videoModel.addEventListener('seeked', onPlaybackSeeked);\n    videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\n    videoModel.addEventListener('progress', onPlaybackProgress);\n    videoModel.addEventListener('ratechange', onPlaybackRateChanged);\n    videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n    videoModel.addEventListener('stalled', onPlaybackStalled);\n    videoModel.addEventListener('ended', onNativePlaybackEnded);\n  }\n\n  function removeAllListeners() {\n    videoModel.removeEventListener('canplay', onCanPlay);\n    videoModel.removeEventListener('play', onPlaybackStart);\n    videoModel.removeEventListener('waiting', onPlaybackWaiting);\n    videoModel.removeEventListener('playing', onPlaybackPlaying);\n    videoModel.removeEventListener('pause', onPlaybackPaused);\n    videoModel.removeEventListener('error', onPlaybackError);\n    videoModel.removeEventListener('seeking', onPlaybackSeeking);\n    videoModel.removeEventListener('seeked', onPlaybackSeeked);\n    videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\n    videoModel.removeEventListener('progress', onPlaybackProgress);\n    videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\n    videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n    videoModel.removeEventListener('stalled', onPlaybackStalled);\n    videoModel.removeEventListener('ended', onNativePlaybackEnded);\n  }\n\n  instance = {\n    initialize: initialize,\n    setConfig: setConfig,\n    getStartTimeFromUriParameters: getStartTimeFromUriParameters,\n    getTimeToStreamEnd: getTimeToStreamEnd,\n    getTime: getTime,\n    getNormalizedTime: getNormalizedTime,\n    getPlaybackRate: getPlaybackRate,\n    getPlayedRanges: getPlayedRanges,\n    getEnded: getEnded,\n    getIsDynamic: getIsDynamic,\n    getStreamController: getStreamController,\n    computeAndSetLiveDelay: computeAndSetLiveDelay,\n    getLiveDelay: getLiveDelay,\n    setLiveDelay: setLiveDelay,\n    getCurrentLiveLatency: getCurrentLiveLatency,\n    play: play,\n    isPaused: isPaused,\n    pause: pause,\n    isSeeking: isSeeking,\n    getStreamEndTime: getStreamEndTime,\n    seek: seek,\n    updateCurrentTime: updateCurrentTime,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(PlaybackController);","map":{"version":3,"sources":["../../../../../src/streaming/controllers/PlaybackController.js"],"names":["LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS","context","eventBus","instance","logger","streamController","dashMetrics","adapter","videoModel","timelineConverter","streamSwitch","streamSeekTime","wallclockTimeIntervalId","liveDelay","streamInfo","isDynamic","mediaPlayerModel","playOnceInitialized","lastLivePlaybackTime","availabilityStartTime","seekTarget","internalSeek","isLowLatencySeekingInProgress","playbackStalled","minPlaybackRateChange","uriFragmentModel","settings","reset","addAllListeners","periodSwitch","ua","navigator","isSafari","Events","priority","EventBus","play","isNaN","startTime","e","dvrInfo","dvrWindow","startTimeFromUri","getStartTimeFromUriParameters","Math","seekTime","seek","parseFloat","getStreamEndTime","getTime","currentTime","time","internal","DVRMetrics","DVRWindow","t","timeOffset","delay","ret","END_OF_PLAYLIST_PADDING","MIN_BUFFER_TIME_FACTOR","FRAGMENT_DURATION_FACTOR","adjustedFragmentDuration","isFinite","suggestedPresentationDelay","minBufferTime","dvrWindowSize","targetDelayCapping","useMaxValue","value","getNormalizedTime","now","stopUpdatingWallclockTime","removeAllListeners","config","fragData","refStream","refStreamStartTime","posix","Date","parseInt","actualTime","tick","onWallclockTime","setInterval","clearInterval","isPaused","getActualPresentationTime","timeChanged","isSeeking","representationInfo","info","updateCurrentTime","startUpdatingWallclockTime","playingTime","ended","getEnded","timeToEnd","getTimeToStreamEnd","onPlaybackTimeUpdated","rate","getPlaybackRate","playbackRate","pause","target","event","error","getIsDynamic","updateLivePlaybackTime","_isCatchupEnabled","_needToCatchUp","startPlaybackCatchUp","stopPlaybackCatchUp","bufferLevel","bl","p","playbackBufferMin","Constants","catchupMode","_getCatchupMode","currentLiveLatency","getCurrentLiveLatency","liveCatchupLatencyThreshold","liveCatchUpMinDrift","currentBuffer","getBufferLevel","_lolpNeedToCatchUpCustom","_defaultNeedToCatchUp","latencyDrift","results","currentPlaybackRate","liveCatchupPlaybackRate","_calculateNewPlaybackRateLolP","_calculateNewPlaybackRateDefault","newRate","deltaLatency","seekToLive","cpr","d","s","deltaBuffer","minDifference","minDelay","streaming","MetricsConstants","applyServiceDescription","llsd","i","sd","mediaInfo","lowLatencyEnabled","liveCatchup","minDrift","initialize","setConfig","getPlayedRanges","getStreamController","computeAndSetLiveDelay","getLiveDelay","setLiveDelay","setup","PlaybackController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\n\nfunction PlaybackController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        streamController,\n        dashMetrics,\n        adapter,\n        videoModel,\n        timelineConverter,\n        streamSwitch,\n        streamSeekTime,\n        wallclockTimeIntervalId,\n        liveDelay,\n        streamInfo,\n        isDynamic,\n        mediaPlayerModel,\n        playOnceInitialized,\n        lastLivePlaybackTime,\n        availabilityStartTime,\n        seekTarget,\n        internalSeek,\n        isLowLatencySeekingInProgress,\n        playbackStalled,\n        minPlaybackRateChange,\n        uriFragmentModel,\n        settings;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function initialize(sInfo, periodSwitch, seekTime) {\n        streamInfo = sInfo;\n        addAllListeners();\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        isLowLatencySeekingInProgress = false;\n        playbackStalled = false;\n        streamSwitch = periodSwitch === true;\n        streamSeekTime = seekTime;\n        internalSeek = false;\n\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\n\n        // Detect safari browser (special behavior for low latency streams)\n        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);\n        minPlaybackRateChange = isSafari ? 0.25 : 0.02;\n\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this, { priority: EventBus.EVENT_PRIORITY_HIGH });\n        eventBus.on(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n\n        if (playOnceInitialized) {\n            playOnceInitialized = false;\n            play();\n        }\n    }\n\n    function onStreamInitialized(e) {\n        // Seamless period switch\n        if (streamSwitch && isNaN(streamSeekTime)) return;\n\n        // Seek new stream in priority order:\n        // - at seek time (streamSeekTime) when switching period\n        // - at start time provided in URI parameters\n        // - at stream/period start time (for static streams) or live start time (for dynamic streams)\n        let startTime = streamSeekTime;\n        if (isNaN(startTime)) {\n            if (isDynamic) {\n                // For dynamic stream, start by default at (live edge - live delay)\n                startTime = e.liveStartTime;\n                // If start time in URI, take min value between live edge time and time from URI (capped by DVR window range)\n                const dvrInfo = dashMetrics.getCurrentDVRInfo();\n                const dvrWindow = dvrInfo ? dvrInfo.range : null;\n                if (dvrWindow) {\n                    // #t shall be relative to period start\n                    const startTimeFromUri = getStartTimeFromUriParameters(true);\n                    if (!isNaN(startTimeFromUri)) {\n                        logger.info('Start time from URI parameters: ' + startTimeFromUri);\n                        startTime = Math.max(Math.min(startTime, startTimeFromUri), dvrWindow.start);\n                    }\n                }\n            } else {\n                // For static stream, start by default at period start\n                startTime = streamInfo.start;\n                // If start time in URI, take max value between period start and time from URI (if in period range)\n                const startTimeFromUri = getStartTimeFromUriParameters(false);\n                if (!isNaN(startTimeFromUri) && startTimeFromUri < (startTime + streamInfo.duration)) {\n                    logger.info('Start time from URI parameters: ' + startTimeFromUri);\n                    startTime = Math.max(startTime, startTimeFromUri);\n                }\n            }\n        }\n\n        if (!isNaN(startTime) && startTime !== videoModel.getTime()) {\n            // Trigger PLAYBACK_SEEKING event for controllers\n            eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: startTime });\n            // Seek video model\n            seek(startTime, false, true);\n        }\n    }\n\n    function getTimeToStreamEnd() {\n        return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\n    }\n\n    function getStreamEndTime() {\n        return streamInfo.start + streamInfo.duration;\n    }\n\n    function play() {\n        if (streamInfo && videoModel && videoModel.getElement()) {\n            videoModel.play();\n        } else {\n            playOnceInitialized = true;\n        }\n    }\n\n    function isPaused() {\n        return streamInfo && videoModel ? videoModel.isPaused() : null;\n    }\n\n    function pause() {\n        if (streamInfo && videoModel) {\n            videoModel.pause();\n        }\n    }\n\n    function isSeeking() {\n        return streamInfo && videoModel ? videoModel.isSeeking() : null;\n    }\n\n    function seek(time, stickToBuffered, internal) {\n        if (!streamInfo || !videoModel) return;\n\n        let currentTime = !isNaN(seekTarget) ? seekTarget : videoModel.getTime();\n        if (time === currentTime) return;\n\n        internalSeek = (internal === true);\n\n        if (!internalSeek) {\n            seekTarget = time;\n            eventBus.trigger(Events.PLAYBACK_SEEK_ASKED);\n        }\n        logger.info('Requesting seek to time: ' + time + (internalSeek ? ' (internal)' : ''));\n        videoModel.setCurrentTime(time, stickToBuffered);\n    }\n\n    function seekToLive() {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo();\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n\n        seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\n    }\n\n    function getTime() {\n        return streamInfo && videoModel ? videoModel.getTime() : null;\n    }\n\n    function getNormalizedTime() {\n        let t = getTime();\n\n        if (isDynamic && !isNaN(availabilityStartTime)) {\n            const timeOffset = availabilityStartTime / 1000;\n            // Fix current time for firefox and safari (returned as an absolute time)\n            if (t > timeOffset) {\n                t -= timeOffset;\n            }\n        }\n        return t;\n    }\n\n    function getPlaybackRate() {\n        return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\n    }\n\n    function getPlayedRanges() {\n        return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\n    }\n\n    function getEnded() {\n        return streamInfo && videoModel ? videoModel.getEnded() : null;\n    }\n\n    function getIsDynamic() {\n        return isDynamic;\n    }\n\n    function getStreamController() {\n        return streamController;\n    }\n\n    /**\n     * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\n     * @param {number} fragmentDuration - seconds?\n     * @param {number} dvrWindowSize - seconds?\n     * @param {number} minBufferTime - seconds?\n     * @returns {number} object\n     * @memberof PlaybackController#\n     */\n    function computeAndSetLiveDelay(fragmentDuration, dvrWindowSize, minBufferTime) {\n        let delay,\n            ret,\n            startTime;\n        const END_OF_PLAYLIST_PADDING = 10;\n        const MIN_BUFFER_TIME_FACTOR = 4;\n        const FRAGMENT_DURATION_FACTOR = 4;\n        const adjustedFragmentDuration = !isNaN(fragmentDuration) && isFinite(fragmentDuration) ? fragmentDuration : NaN;\n\n        let suggestedPresentationDelay = adapter.getSuggestedPresentationDelay();\n\n        if (settings.get().streaming.lowLatencyEnabled) {\n            delay = 0;\n        } else if (mediaPlayerModel.getLiveDelay()) {\n            delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\n        } else if (settings.get().streaming.liveDelayFragmentCount !== null && !isNaN(settings.get().streaming.liveDelayFragmentCount) && !isNaN(adjustedFragmentDuration)) {\n            delay = adjustedFragmentDuration * settings.get().streaming.liveDelayFragmentCount;\n        } else if (settings.get().streaming.useSuggestedPresentationDelay === true && suggestedPresentationDelay !== null && !isNaN(suggestedPresentationDelay) && suggestedPresentationDelay > 0) {\n            delay = suggestedPresentationDelay;\n        } else if (!isNaN(adjustedFragmentDuration)) {\n            delay = adjustedFragmentDuration * FRAGMENT_DURATION_FACTOR;\n        } else {\n            delay = !isNaN(minBufferTime) ? minBufferTime * MIN_BUFFER_TIME_FACTOR : streamInfo.manifestInfo.minBufferTime * MIN_BUFFER_TIME_FACTOR;\n        }\n\n        startTime = adapter.getAvailabilityStartTime();\n\n        if (startTime !== null) {\n            availabilityStartTime = startTime;\n        }\n\n        if (dvrWindowSize > 0) {\n            // cap target latency to:\n            // - dvrWindowSize / 2 for short playlists\n            // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\n            const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\n            ret = Math.min(delay, targetDelayCapping);\n        } else {\n            ret = delay;\n        }\n        liveDelay = ret;\n        return ret;\n    }\n\n    function getLiveDelay() {\n        return liveDelay;\n    }\n\n    function setLiveDelay(value, useMaxValue = false) {\n        if (useMaxValue && value < liveDelay) {\n            return;\n        }\n\n        liveDelay = value;\n    }\n\n    function getCurrentLiveLatency() {\n        if (!isDynamic || isNaN(availabilityStartTime)) {\n            return NaN;\n        }\n        let currentTime = getNormalizedTime();\n        if (isNaN(currentTime) || currentTime === 0) {\n            return 0;\n        }\n\n        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\n        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\n    }\n\n    function reset() {\n        playOnceInitialized = false;\n        streamSwitch = false;\n        streamSeekTime = NaN;\n        liveDelay = 0;\n        availabilityStartTime = 0;\n        seekTarget = NaN;\n        if (videoModel) {\n            eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n            eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n            eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n            eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n            eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\n            eventBus.off(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n            stopUpdatingWallclockTime();\n            removeAllListeners();\n        }\n        wallclockTimeIntervalId = null;\n        videoModel = null;\n        streamInfo = null;\n        isDynamic = null;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.uriFragmentModel) {\n            uriFragmentModel = config.uriFragmentModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function getStartTimeFromUriParameters(isDynamic) {\n        const fragData = uriFragmentModel.getURIFragmentData();\n        if (!fragData || !fragData.t) {\n            return NaN;\n        }\n        const refStream = streamController.getStreams()[0];\n        const refStreamStartTime = refStream.getStreamInfo().start;\n        // Consider only start time of MediaRange\n        // TODO: consider end time of MediaRange to stop playback at provided end time\n        fragData.t = fragData.t.split(',')[0];\n        // \"t=<time>\" : time is relative to 1st period start\n        // \"t=posix:<time>\" : time is absolute start time as number of seconds since 01-01-1970\n        const posix = fragData.t.indexOf('posix:') !== -1 ? fragData.t.substring(6) === 'now' ? Date.now() / 1000 : parseInt(fragData.t.substring(6)) : NaN;\n        let startTime = (isDynamic && !isNaN(posix)) ? posix - availabilityStartTime / 1000 : parseInt(fragData.t) + refStreamStartTime;\n        return startTime;\n    }\n\n    function getActualPresentationTime(currentTime, mediatype) {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo(mediatype);\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n        let actualTime;\n\n        if (!DVRWindow) {\n            return NaN;\n        }\n\n        logger.debug(`Checking DVR window for at ${currentTime} with DVR window range ${DVRWindow.start} - ${DVRWindow.end}`);\n        if (currentTime > DVRWindow.end) {\n            actualTime = Math.max(DVRWindow.end - liveDelay, DVRWindow.start);\n\n        } else if (currentTime > 0 && currentTime + 0.250 < DVRWindow.start && Math.abs(currentTime - DVRWindow.start) < 315360000) {\n\n            // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\n            // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\n            // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\n            // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime\n            // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year)\n            //actualTime = DVRWindow.start;\n            actualTime = DVRWindow.start;\n        } else {\n            actualTime = currentTime;\n        }\n\n        return actualTime;\n    }\n\n    function startUpdatingWallclockTime() {\n        if (wallclockTimeIntervalId !== null) return;\n\n        const tick = function () {\n            onWallclockTime();\n        };\n\n        wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval);\n    }\n\n    function stopUpdatingWallclockTime() {\n        clearInterval(wallclockTimeIntervalId);\n        wallclockTimeIntervalId = null;\n    }\n\n    function updateCurrentTime(mediaType) {\n        if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\n        const currentTime = getNormalizedTime();\n        const actualTime = getActualPresentationTime(currentTime, mediaType);\n        const timeChanged = (!isNaN(actualTime) && actualTime !== currentTime);\n        if (timeChanged && !isSeeking()) {\n            logger.debug(`UpdateCurrentTime: Seek to actual time: ${actualTime} from currentTime: ${currentTime}`);\n            seek(actualTime);\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error) return;\n\n        const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n        const info = representationInfo ? representationInfo.mediaInfo.streamInfo : null;\n\n        if (info === null || streamInfo.id !== info.id) return;\n        streamInfo = info;\n\n        updateCurrentTime();\n    }\n\n    function onCanPlay() {\n        eventBus.trigger(Events.CAN_PLAY);\n    }\n\n    function onPlaybackStart() {\n        logger.info('Native video element event: play');\n        updateCurrentTime();\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_STARTED, { startTime: getTime() });\n    }\n\n    function onPlaybackWaiting() {\n        logger.info('Native video element event: waiting');\n        eventBus.trigger(Events.PLAYBACK_WAITING, { playingTime: getTime() });\n    }\n\n    function onPlaybackPlaying() {\n        logger.info('Native video element event: playing');\n        eventBus.trigger(Events.PLAYBACK_PLAYING, { playingTime: getTime() });\n    }\n\n    function onPlaybackPaused() {\n        logger.info('Native video element event: pause');\n        eventBus.trigger(Events.PLAYBACK_PAUSED, { ended: getEnded() });\n    }\n\n    function onPlaybackSeeking() {\n        // Check if internal seeking to be ignored\n        if (internalSeek) {\n            internalSeek = false;\n            return;\n        }\n\n        let seekTime = getTime();\n        // On some browsers/devices, in case of live streams, setting current time on video element fails when there is no buffered data at requested time\n        // Then re-set seek target time and video element will be seeked afterwhile once data is buffered (see BufferContoller)\n        if (!isNaN(seekTarget) && seekTarget !== seekTime) {\n            seekTime = seekTarget;\n        }\n        seekTarget = NaN;\n\n        logger.info('Seeking to: ' + seekTime);\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: seekTime });\n    }\n\n    function onPlaybackSeeked() {\n        logger.info('Native video element event: seeked');\n        eventBus.trigger(Events.PLAYBACK_SEEKED);\n    }\n\n    function onPlaybackTimeUpdated() {\n        if (streamInfo) {\n            eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, {\n                timeToEnd: getTimeToStreamEnd(),\n                time: getTime()\n            });\n        }\n    }\n\n    function updateLivePlaybackTime() {\n        const now = Date.now();\n        if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\n            lastLivePlaybackTime = now;\n            onPlaybackTimeUpdated();\n        }\n    }\n\n    function onPlaybackProgress() {\n        eventBus.trigger(Events.PLAYBACK_PROGRESS);\n    }\n\n    function onPlaybackRateChanged() {\n        const rate = getPlaybackRate();\n        logger.info('Native video element event: ratechange: ', rate);\n        eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, { playbackRate: rate });\n    }\n\n    function onPlaybackMetaDataLoaded() {\n        logger.info('Native video element event: loadedmetadata');\n        eventBus.trigger(Events.PLAYBACK_METADATA_LOADED);\n        startUpdatingWallclockTime();\n    }\n\n    // Event to handle the native video element ended event\n    function onNativePlaybackEnded() {\n        logger.info('Native video element event: ended');\n        pause();\n        stopUpdatingWallclockTime();\n        const streamInfo = streamController ? streamController.getActiveStreamInfo() : null;\n        if (!streamInfo) return;\n        eventBus.trigger(Events.PLAYBACK_ENDED, { 'isLast': streamInfo.isLast });\n    }\n\n    // Handle DASH PLAYBACK_ENDED event\n    function onPlaybackEnded(e) {\n        if (wallclockTimeIntervalId && e.isLast) {\n            // PLAYBACK_ENDED was triggered elsewhere, react.\n            logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\n            const seekTime = e.seekTime ? e.seekTime : getStreamEndTime();\n            videoModel.setCurrentTime(seekTime);\n            pause();\n            stopUpdatingWallclockTime();\n        }\n    }\n\n    function onPlaybackError(event) {\n        const target = event.target || event.srcElement;\n        eventBus.trigger(Events.PLAYBACK_ERROR, { error: target.error });\n    }\n\n    function onWallclockTime() {\n        eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, {\n            isDynamic: isDynamic,\n            time: new Date()\n        });\n\n        // Updates playback time for paused dynamic streams\n        // (video element doesn't call timeupdate when the playback is paused)\n        if (getIsDynamic() && isPaused()) {\n            updateLivePlaybackTime();\n        }\n    }\n\n    function onPlaybackProgression() {\n        if (\n            isDynamic &&\n            _isCatchupEnabled() &&\n            settings.get().streaming.liveCatchup.playbackRate > 0 &&\n            !isPaused() &&\n            !isSeeking()\n        ) {\n            if (_needToCatchUp()) {\n                startPlaybackCatchUp();\n            } else {\n                stopPlaybackCatchUp();\n            }\n        }\n    }\n\n    function _isCatchupEnabled() {\n        return settings.get().streaming.liveCatchup.enabled || settings.get().streaming.lowLatencyEnabled;\n    }\n\n    function getBufferLevel() {\n        let bufferLevel = null;\n        streamController.getActiveStreamProcessors().forEach(p => {\n            const bl = p.getBufferLevel();\n            if (bufferLevel === null) {\n                bufferLevel = bl;\n            } else {\n                bufferLevel = Math.min(bufferLevel, bl);\n            }\n        });\n\n        return bufferLevel;\n    }\n\n    /**\n     * Returns the mode for live playback catchup.\n     * @return {String}\n     * @private\n     */\n    function _getCatchupMode() {\n        const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n\n        return settings.get().streaming.liveCatchup.mode === Constants.LIVE_CATCHUP_MODE_LOLP && playbackBufferMin !== null && !isNaN(playbackBufferMin) ? Constants.LIVE_CATCHUP_MODE_LOLP : Constants.LIVE_CATCHUP_MODE_DEFAULT;\n    }\n\n    /**\n     * Checks whether the catchup mechanism should be enabled\n     * @return {boolean}\n     */\n    function _needToCatchUp() {\n        try {\n            if (_isCatchupEnabled() && settings.get().streaming.liveCatchup.playbackRate > 0 && getTime() > 0) {\n\n                const catchupMode = _getCatchupMode();\n                const currentLiveLatency = getCurrentLiveLatency();\n                const liveDelay = mediaPlayerModel.getLiveDelay();\n                const liveCatchupLatencyThreshold = mediaPlayerModel.getLiveCatchupLatencyThreshold();\n                const liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n\n                if (catchupMode === Constants.LIVE_CATCHUP_MODE_LOLP) {\n                    const currentBuffer = getBufferLevel();\n                    const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n\n                    return _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, liveCatchUpMinDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold);\n                } else {\n                    return _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, liveCatchUpMinDrift);\n                }\n            }\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Default algorithm to determine if catchup mode should be enabled\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} liveCatchupLatencyThreshold\n     * @param {number} minDrift\n     * @return {boolean}\n     * @private\n     */\n    function _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, minDrift) {\n        try {\n            const latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n\n            return latencyDrift > minDrift && (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * LoL+ logic to determine if catchup mode should be enabled\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} minDrift\n     * @param {number} currentBuffer\n     * @param {number} playbackBufferMin\n     * @param {number} liveCatchupLatencyThreshold\n     * @return {boolean}\n     * @private\n     */\n    function _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, minDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold) {\n        try {\n            const latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n\n            return (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold) && (latencyDrift > minDrift || currentBuffer < playbackBufferMin);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Apply catchup mode\n     */\n    function startPlaybackCatchUp() {\n        if (videoModel) {\n            let results;\n            const currentPlaybackRate = videoModel.getPlaybackRate();\n            const liveCatchupPlaybackRate = settings.get().streaming.liveCatchup.playbackRate;\n            const currentLiveLatency = getCurrentLiveLatency();\n            const liveDelay = mediaPlayerModel.getLiveDelay();\n            const bufferLevel = getBufferLevel();\n            // Custom playback control: Based on buffer level\n            if (_getCatchupMode() === Constants.LIVE_CATCHUP_MODE_LOLP) {\n                const liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n                const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n                results = _calculateNewPlaybackRateLolP(liveCatchupPlaybackRate, currentLiveLatency, liveDelay, liveCatchUpMinDrift, playbackBufferMin, bufferLevel, currentPlaybackRate);\n            } else {\n                // Default playback control: Based on target and current latency\n                results = _calculateNewPlaybackRateDefault(liveCatchupPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate);\n            }\n\n            // Obtain newRate and apply to video model\n            let newRate = results.newRate;\n            if (newRate) {  // non-null\n                videoModel.setPlaybackRate(newRate);\n            }\n\n            const deltaLatency = currentLiveLatency - liveDelay;\n            if (settings.get().streaming.liveCatchup.maxDrift > 0 && !isLowLatencySeekingInProgress &&\n                deltaLatency > settings.get().streaming.liveCatchup.maxDrift) {\n                logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\n                isLowLatencySeekingInProgress = true;\n                seekToLive();\n            } else {\n                isLowLatencySeekingInProgress = false;\n            }\n        }\n    }\n\n    /**\n     * Default algorithm to calculate the new playback rate\n     * @param {number} liveCatchUpPlaybackRate\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} bufferLevel\n     * @param {number} currentPlaybackRate\n     * @return {{newRate: number}}\n     * @private\n     */\n    function _calculateNewPlaybackRateDefault(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate) {\n        const cpr = liveCatchUpPlaybackRate;\n        const deltaLatency = currentLiveLatency - liveDelay;\n        const d = deltaLatency * 5;\n\n        // Playback rate must be between (1 - cpr) - (1 + cpr)\n        // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n        const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n        let newRate = (1 - cpr) + s;\n        // take into account situations in which there are buffer stalls,\n        // in which increasing playbackRate to reach target latency will\n        // just cause more and more stall situations\n        if (playbackStalled) {\n            // const bufferLevel = getBufferLevel();\n            if (bufferLevel > liveDelay / 2) {\n                // playbackStalled = false;\n                playbackStalled = false;\n            } else if (deltaLatency > 0) {\n                newRate = 1.0;\n            }\n        }\n\n        // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n        if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n            newRate = null;\n        }\n\n        return {\n            newRate: newRate\n        };\n\n    }\n\n    /**\n     * Lol+ algorithm to calculate the new playback rate\n     * @param {number} liveCatchUpPlaybackRate\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} minDrift\n     * @param {number} playbackBufferMin\n     * @param {number} bufferLevel\n     * @param {number} currentPlaybackRate\n     * @return {{newRate: number}}\n     * @private\n     */\n    function _calculateNewPlaybackRateLolP(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, minDrift, playbackBufferMin, bufferLevel, currentPlaybackRate) {\n        const cpr = liveCatchUpPlaybackRate;\n        let newRate;\n\n        // Hybrid: Buffer-based\n        if (bufferLevel < playbackBufferMin) {\n            // Buffer in danger, slow down\n            const deltaBuffer = bufferLevel - playbackBufferMin;  // -ve value\n            const d = deltaBuffer * 5;\n\n            // Playback rate must be between (1 - cpr) - (1 + cpr)\n            // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n            const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n            newRate = (1 - cpr) + s;\n\n            logger.debug('[LoL+ playback control_buffer-based] bufferLevel: ' + bufferLevel + ', newRate: ' + newRate);\n        } else {\n            // Hybrid: Latency-based\n            // Buffer is safe, vary playback rate based on latency\n\n            // Check if latency is within range of target latency\n            const minDifference = 0.02;\n            if (Math.abs(currentLiveLatency - liveDelay) <= (minDifference * liveDelay)) {\n                newRate = 1;\n            } else {\n                const deltaLatency = currentLiveLatency - liveDelay;\n                const d = deltaLatency * 5;\n\n                // Playback rate must be between (1 - cpr) - (1 + cpr)\n                // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n                const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n                newRate = (1 - cpr) + s;\n            }\n\n            logger.debug('[LoL+ playback control_latency-based] latency: ' + currentLiveLatency + ', newRate: ' + newRate);\n        }\n\n        if (playbackStalled) {\n            if (bufferLevel > liveDelay / 2) {\n                playbackStalled = false;\n            }\n        }\n\n        // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n        if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n            newRate = null;\n        }\n\n        return {\n            newRate: newRate\n        };\n    }\n\n    function stopPlaybackCatchUp() {\n        if (videoModel) {\n            videoModel.setPlaybackRate(1.0);\n        }\n    }\n\n    function onFragmentLoadProgress(e) {\n        // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\n        if (e.stream === false && settings.get().streaming.lowLatencyEnabled && !isNaN(e.request.duration)) {\n            const minDelay = 1.2 * e.request.duration;\n            if (minDelay > mediaPlayerModel.getLiveDelay()) {\n                logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\n                const s = { streaming: { liveDelay: minDelay } };\n                settings.update(s);\n            }\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        // do not stall playback when get an event from Stream that is not active\n        if (e.streamId !== streamInfo.id) return;\n\n        if (_isCatchupEnabled()) {\n            if (e.state === MetricsConstants.BUFFER_EMPTY && !isSeeking()) {\n                if (!playbackStalled) {\n                    playbackStalled = true;\n                    stopPlaybackCatchUp();\n                }\n            }\n        } else {\n            videoModel.setStallState(e.mediaType, e.state === MetricsConstants.BUFFER_EMPTY);\n        }\n    }\n\n    function onPlaybackStalled(e) {\n        eventBus.trigger(Events.PLAYBACK_STALLED, { e: e });\n    }\n\n    function onStreamInitializing(e) {\n        applyServiceDescription(e.streamInfo, e.mediaInfo);\n    }\n\n    function applyServiceDescription(streamInfo, mediaInfo) {\n        if (streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.serviceDescriptions) {\n            // is there a service description for low latency defined?\n            let llsd;\n\n            for (let i = 0; i < streamInfo.manifestInfo.serviceDescriptions.length; i++) {\n                const sd = streamInfo.manifestInfo.serviceDescriptions[i];\n                if (sd.schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME) {\n                    llsd = sd;\n                    break;\n                }\n            }\n\n            if (llsd) {\n                if (mediaInfo && mediaInfo.supplementalProperties &&\n                    mediaInfo.supplementalProperties[Constants.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') {\n                    if (llsd.latency && llsd.latency.target > 0) {\n                        logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveDelay: llsd.latency.target / 1000,\n                                liveCatchup: {\n                                    minDrift: llsd.latency.max > llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined\n                                }\n                            }\n                        });\n                    }\n                    if (llsd.playbackRate && llsd.playbackRate.max > 1.0) {\n                        logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveCatchup: {\n                                    playbackRate: llsd.playbackRate.max - 1.0\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    function addAllListeners() {\n        videoModel.addEventListener('canplay', onCanPlay);\n        videoModel.addEventListener('play', onPlaybackStart);\n        videoModel.addEventListener('waiting', onPlaybackWaiting);\n        videoModel.addEventListener('playing', onPlaybackPlaying);\n        videoModel.addEventListener('pause', onPlaybackPaused);\n        videoModel.addEventListener('error', onPlaybackError);\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\n        videoModel.addEventListener('seeked', onPlaybackSeeked);\n        videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.addEventListener('progress', onPlaybackProgress);\n        videoModel.addEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.addEventListener('stalled', onPlaybackStalled);\n        videoModel.addEventListener('ended', onNativePlaybackEnded);\n    }\n\n    function removeAllListeners() {\n        videoModel.removeEventListener('canplay', onCanPlay);\n        videoModel.removeEventListener('play', onPlaybackStart);\n        videoModel.removeEventListener('waiting', onPlaybackWaiting);\n        videoModel.removeEventListener('playing', onPlaybackPlaying);\n        videoModel.removeEventListener('pause', onPlaybackPaused);\n        videoModel.removeEventListener('error', onPlaybackError);\n        videoModel.removeEventListener('seeking', onPlaybackSeeking);\n        videoModel.removeEventListener('seeked', onPlaybackSeeked);\n        videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.removeEventListener('progress', onPlaybackProgress);\n        videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.removeEventListener('stalled', onPlaybackStalled);\n        videoModel.removeEventListener('ended', onNativePlaybackEnded);\n    }\n\n    instance = {\n        initialize: initialize,\n        setConfig: setConfig,\n        getStartTimeFromUriParameters: getStartTimeFromUriParameters,\n        getTimeToStreamEnd: getTimeToStreamEnd,\n        getTime: getTime,\n        getNormalizedTime: getNormalizedTime,\n        getPlaybackRate: getPlaybackRate,\n        getPlayedRanges: getPlayedRanges,\n        getEnded: getEnded,\n        getIsDynamic: getIsDynamic,\n        getStreamController: getStreamController,\n        computeAndSetLiveDelay: computeAndSetLiveDelay,\n        getLiveDelay: getLiveDelay,\n        setLiveDelay: setLiveDelay,\n        getCurrentLiveLatency: getCurrentLiveLatency,\n        play: play,\n        isPaused: isPaused,\n        pause: pause,\n        isSeeking: isSeeking,\n        getStreamEndTime,\n        seek: seek,\n        updateCurrentTime: updateCurrentTime,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\nexport default FactoryMaker.getSingletonFactory(PlaybackController);\n"]},"metadata":{},"sourceType":"script"}