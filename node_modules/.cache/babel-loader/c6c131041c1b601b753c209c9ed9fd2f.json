{"ast":null,"code":"'use strict';\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2015-2016, DASH Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  1. Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  2. Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (exports) {\n  \"use strict\";\n  /**\n  *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n  */\n\n  var specialCea608CharsCodes = {\n    0x2a: 0xe1,\n    // lowercase a, acute accent\n    0x5c: 0xe9,\n    // lowercase e, acute accent\n    0x5e: 0xed,\n    // lowercase i, acute accent\n    0x5f: 0xf3,\n    // lowercase o, acute accent\n    0x60: 0xfa,\n    // lowercase u, acute accent\n    0x7b: 0xe7,\n    // lowercase c with cedilla\n    0x7c: 0xf7,\n    // division symbol\n    0x7d: 0xd1,\n    // uppercase N tilde\n    0x7e: 0xf1,\n    // lowercase n tilde\n    0x7f: 0x2588,\n    // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae,\n    // Registered symbol (R)\n    0x81: 0xb0,\n    // degree sign\n    0x82: 0xbd,\n    // 1/2 symbol\n    0x83: 0xbf,\n    // Inverted (open) question mark\n    0x84: 0x2122,\n    // Trademark symbol (TM)\n    0x85: 0xa2,\n    // Cents symbol\n    0x86: 0xa3,\n    // Pounds sterling\n    0x87: 0x266a,\n    // Music 8'th note\n    0x88: 0xe0,\n    // lowercase a, grave accent\n    0x89: 0x20,\n    // transparent space (regular)\n    0x8a: 0xe8,\n    // lowercase e, grave accent\n    0x8b: 0xe2,\n    // lowercase a, circumflex accent\n    0x8c: 0xea,\n    // lowercase e, circumflex accent\n    0x8d: 0xee,\n    // lowercase i, circumflex accent\n    0x8e: 0xf4,\n    // lowercase o, circumflex accent\n    0x8f: 0xfb,\n    // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1,\n    // capital letter A with acute\n    0x91: 0xc9,\n    // capital letter E with acute\n    0x92: 0xd3,\n    // capital letter O with acute\n    0x93: 0xda,\n    // capital letter U with acute\n    0x94: 0xdc,\n    // capital letter U with diaresis\n    0x95: 0xfc,\n    // lowercase letter U with diaeresis\n    0x96: 0x2018,\n    // opening single quote\n    0x97: 0xa1,\n    // inverted exclamation mark\n    0x98: 0x2a,\n    // asterisk\n    0x99: 0x2019,\n    // closing single quote\n    0x9a: 0x2501,\n    // box drawings heavy horizontal\n    0x9b: 0xa9,\n    // copyright sign\n    0x9c: 0x2120,\n    // Service mark\n    0x9d: 0x2022,\n    // (round) bullet\n    0x9e: 0x201c,\n    // Left double quotation mark\n    0x9f: 0x201d,\n    // Right double quotation mark\n    0xa0: 0xc0,\n    // uppercase A, grave accent\n    0xa1: 0xc2,\n    // uppercase A, circumflex\n    0xa2: 0xc7,\n    // uppercase C with cedilla\n    0xa3: 0xc8,\n    // uppercase E, grave accent\n    0xa4: 0xca,\n    // uppercase E, circumflex\n    0xa5: 0xcb,\n    // capital letter E with diaresis\n    0xa6: 0xeb,\n    // lowercase letter e with diaresis\n    0xa7: 0xce,\n    // uppercase I, circumflex\n    0xa8: 0xcf,\n    // uppercase I, with diaresis\n    0xa9: 0xef,\n    // lowercase i, with diaresis\n    0xaa: 0xd4,\n    // uppercase O, circumflex\n    0xab: 0xd9,\n    // uppercase U, grave accent\n    0xac: 0xf9,\n    // lowercase u, grave accent\n    0xad: 0xdb,\n    // uppercase U, circumflex\n    0xae: 0xab,\n    // left-pointing double angle quotation mark\n    0xaf: 0xbb,\n    // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3,\n    // Uppercase A, tilde\n    0xb1: 0xe3,\n    // Lowercase a, tilde\n    0xb2: 0xcd,\n    // Uppercase I, acute accent\n    0xb3: 0xcc,\n    // Uppercase I, grave accent\n    0xb4: 0xec,\n    // Lowercase i, grave accent\n    0xb5: 0xd2,\n    // Uppercase O, grave accent\n    0xb6: 0xf2,\n    // Lowercase o, grave accent\n    0xb7: 0xd5,\n    // Uppercase O, tilde\n    0xb8: 0xf5,\n    // Lowercase o, tilde\n    0xb9: 0x7b,\n    // Open curly brace\n    0xba: 0x7d,\n    // Closing curly brace\n    0xbb: 0x5c,\n    // Backslash\n    0xbc: 0x5e,\n    // Caret\n    0xbd: 0x5f,\n    // Underscore\n    0xbe: 0x7c,\n    // Pipe (vertical line)\n    0xbf: 0x223c,\n    // Tilde operator\n    0xc0: 0xc4,\n    // Uppercase A, umlaut\n    0xc1: 0xe4,\n    // Lowercase A, umlaut\n    0xc2: 0xd6,\n    // Uppercase O, umlaut\n    0xc3: 0xf6,\n    // Lowercase o, umlaut\n    0xc4: 0xdf,\n    // Esszett (sharp S)\n    0xc5: 0xa5,\n    // Yen symbol\n    0xc6: 0xa4,\n    // Generic currency sign\n    0xc7: 0x2503,\n    // Box drawings heavy vertical\n    0xc8: 0xc5,\n    // Uppercase A, ring\n    0xc9: 0xe5,\n    // Lowercase A, ring\n    0xca: 0xd8,\n    // Uppercase O, stroke\n    0xcb: 0xf8,\n    // Lowercase o, strok\n    0xcc: 0x250f,\n    // Box drawings heavy down and right\n    0xcd: 0x2513,\n    // Box drawings heavy down and left\n    0xce: 0x2517,\n    // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n\n  };\n  /**\n     * Get Unicode Character from CEA-608 byte code\n     */\n\n  var getCharForByte = function getCharForByte(byte) {\n    var charCode = byte;\n\n    if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n      charCode = specialCea608CharsCodes[byte];\n    }\n\n    return String.fromCharCode(charCode);\n  };\n\n  var NR_ROWS = 15,\n      NR_COLS = 32; // Tables to look up row from PAC data\n\n  var rowsLowCh1 = {\n    0x11: 1,\n    0x12: 3,\n    0x15: 5,\n    0x16: 7,\n    0x17: 9,\n    0x10: 11,\n    0x13: 12,\n    0x14: 14\n  };\n  var rowsHighCh1 = {\n    0x11: 2,\n    0x12: 4,\n    0x15: 6,\n    0x16: 8,\n    0x17: 10,\n    0x13: 13,\n    0x14: 15\n  };\n  var rowsLowCh2 = {\n    0x19: 1,\n    0x1A: 3,\n    0x1D: 5,\n    0x1E: 7,\n    0x1F: 9,\n    0x18: 11,\n    0x1B: 12,\n    0x1C: 14\n  };\n  var rowsHighCh2 = {\n    0x19: 2,\n    0x1A: 4,\n    0x1D: 6,\n    0x1E: 8,\n    0x1F: 10,\n    0x1B: 13,\n    0x1C: 15\n  };\n  var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n  /**\n  * Simple logger class to be able to write with time-stamps and filter on level.\n  */\n\n  var logger = {\n    verboseFilter: {\n      'DATA': 3,\n      'DEBUG': 3,\n      'INFO': 2,\n      'WARNING': 2,\n      'TEXT': 1,\n      'ERROR': 0\n    },\n    time: null,\n    verboseLevel: 0,\n    // Only write errors\n    setTime: function setTime(newTime) {\n      this.time = newTime;\n    },\n    log: function log(severity, msg) {\n      var minLevel = this.verboseFilter[severity];\n\n      if (this.verboseLevel >= minLevel) {\n        console.log(this.time + \" [\" + severity + \"] \" + msg);\n      }\n    }\n  };\n\n  var numArrayToHexArray = function numArrayToHexArray(numArray) {\n    var hexArray = [];\n\n    for (var j = 0; j < numArray.length; j++) {\n      hexArray.push(numArray[j].toString(16));\n    }\n\n    return hexArray;\n  };\n  /**\n  * State of CEA-608 pen or character\n  * @constructor\n  */\n\n\n  var PenState = function PenState(foreground, underline, italics, background, flash) {\n    this.foreground = foreground || \"white\";\n    this.underline = underline || false;\n    this.italics = italics || false;\n    this.background = background || \"black\";\n    this.flash = flash || false;\n  };\n\n  PenState.prototype = {\n    reset: function reset() {\n      this.foreground = \"white\";\n      this.underline = false;\n      this.italics = false;\n      this.background = \"black\";\n      this.flash = false;\n    },\n    setStyles: function setStyles(styles) {\n      var attribs = [\"foreground\", \"underline\", \"italics\", \"background\", \"flash\"];\n\n      for (var i = 0; i < attribs.length; i++) {\n        var style = attribs[i];\n\n        if (styles.hasOwnProperty(style)) {\n          this[style] = styles[style];\n        }\n      }\n    },\n    isDefault: function isDefault() {\n      return this.foreground === \"white\" && !this.underline && !this.italics && this.background === \"black\" && !this.flash;\n    },\n    equals: function equals(other) {\n      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n    },\n    copy: function copy(newPenState) {\n      this.foreground = newPenState.foreground;\n      this.underline = newPenState.underline;\n      this.italics = newPenState.italics;\n      this.background = newPenState.background;\n      this.flash = newPenState.flash;\n    },\n    toString: function toString() {\n      return \"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics + \", background=\" + this.background + \", flash=\" + this.flash;\n    }\n  };\n  /**\n  * Unicode character with styling and background.\n  * @constructor\n  */\n\n  var StyledUnicodeChar = function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {\n    this.uchar = uchar || ' '; // unicode character\n\n    this.penState = new PenState(foreground, underline, italics, background, flash);\n  };\n\n  StyledUnicodeChar.prototype = {\n    reset: function reset() {\n      this.uchar = ' ';\n      this.penState.reset();\n    },\n    setChar: function setChar(uchar, newPenState) {\n      this.uchar = uchar;\n      this.penState.copy(newPenState);\n    },\n    setPenState: function setPenState(newPenState) {\n      this.penState.copy(newPenState);\n    },\n    equals: function equals(other) {\n      return this.uchar === other.uchar && this.penState.equals(other.penState);\n    },\n    copy: function copy(newChar) {\n      this.uchar = newChar.uchar;\n      this.penState.copy(newChar.penState);\n    },\n    isEmpty: function isEmpty() {\n      return this.uchar === ' ' && this.penState.isDefault();\n    }\n  };\n  /**\n  * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n  * @constructor\n  */\n\n  var Row = function Row() {\n    this.chars = [];\n\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n\n    this.pos = 0;\n    this.currPenState = new PenState();\n  };\n\n  Row.prototype = {\n    equals: function equals(other) {\n      var equal = true;\n\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].equals(other.chars[i])) {\n          equal = false;\n          break;\n        }\n      }\n\n      return equal;\n    },\n    copy: function copy(other) {\n      for (var i = 0; i < NR_COLS; i++) {\n        this.chars[i].copy(other.chars[i]);\n      }\n    },\n    isEmpty: function isEmpty() {\n      var empty = true;\n\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n\n      return empty;\n    },\n\n    /**\n    *  Set the cursor to a valid column.\n    */\n    setCursor: function setCursor(absPos) {\n      if (this.pos !== absPos) {\n        this.pos = absPos;\n      }\n\n      if (this.pos < 0) {\n        logger.log(\"ERROR\", \"Negative cursor position \" + this.pos);\n        this.pos = 0;\n      } else if (this.pos > NR_COLS) {\n        logger.log(\"ERROR\", \"Too large cursor position \" + this.pos);\n        this.pos = NR_COLS;\n      }\n    },\n\n    /** \n    * Move the cursor relative to current position.\n    */\n    moveCursor: function moveCursor(relPos) {\n      var newPos = this.pos + relPos;\n\n      if (relPos > 1) {\n        for (var i = this.pos + 1; i < newPos + 1; i++) {\n          this.chars[i].setPenState(this.currPenState);\n        }\n      }\n\n      this.setCursor(newPos);\n    },\n\n    /**\n    * Backspace, move one step back and clear character.\n    */\n    backSpace: function backSpace() {\n      this.moveCursor(-1);\n      this.chars[this.pos].setChar(' ', this.currPenState);\n    },\n    insertChar: function insertChar(byte) {\n      if (byte >= 0x90) {\n        //Extended char\n        this.backSpace();\n      }\n\n      var char = getCharForByte(byte);\n\n      if (this.pos >= NR_COLS) {\n        logger.log(\"ERROR\", \"Cannot insert \" + byte.toString(16) + \" (\" + char + \") at position \" + this.pos + \". Skipping it!\");\n        return;\n      }\n\n      this.chars[this.pos].setChar(char, this.currPenState);\n      this.moveCursor(1);\n    },\n    clearFromPos: function clearFromPos(startPos) {\n      var i;\n\n      for (i = startPos; i < NR_COLS; i++) {\n        this.chars[i].reset();\n      }\n    },\n    clear: function clear() {\n      this.clearFromPos(0);\n      this.pos = 0;\n      this.currPenState.reset();\n    },\n    clearToEndOfRow: function clearToEndOfRow() {\n      this.clearFromPos(this.pos);\n    },\n    getTextString: function getTextString() {\n      var chars = [];\n      var empty = true;\n\n      for (var i = 0; i < NR_COLS; i++) {\n        var char = this.chars[i].uchar;\n\n        if (char !== \" \") {\n          empty = false;\n        }\n\n        chars.push(char);\n      }\n\n      if (empty) {\n        return \"\";\n      } else {\n        return chars.join(\"\");\n      }\n    },\n    setPenStyles: function setPenStyles(styles) {\n      this.currPenState.setStyles(styles);\n      var currChar = this.chars[this.pos];\n      currChar.setPenState(this.currPenState);\n    }\n  };\n  /**\n  * Keep a CEA-608 screen of 32x15 styled characters\n  * @constructor\n  */\n\n  var CaptionScreen = function CaptionScreen() {\n    this.rows = [];\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)\n    }\n\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.reset();\n  };\n\n  CaptionScreen.prototype = {\n    reset: function reset() {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      this.currRow = NR_ROWS - 1;\n    },\n    equals: function equals(other) {\n      var equal = true;\n\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].equals(other.rows[i])) {\n          equal = false;\n          break;\n        }\n      }\n\n      return equal;\n    },\n    copy: function copy(other) {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].copy(other.rows[i]);\n      }\n    },\n    isEmpty: function isEmpty() {\n      var empty = true;\n\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n\n      return empty;\n    },\n    backSpace: function backSpace() {\n      var row = this.rows[this.currRow];\n      row.backSpace();\n    },\n    clearToEndOfRow: function clearToEndOfRow() {\n      var row = this.rows[this.currRow];\n      row.clearToEndOfRow();\n    },\n\n    /**\n    * Insert a character (without styling) in the current row.\n    */\n    insertChar: function insertChar(char) {\n      var row = this.rows[this.currRow];\n      row.insertChar(char);\n    },\n    setPen: function setPen(styles) {\n      var row = this.rows[this.currRow];\n      row.setPenStyles(styles);\n    },\n    moveCursor: function moveCursor(relPos) {\n      var row = this.rows[this.currRow];\n      row.moveCursor(relPos);\n    },\n    setCursor: function setCursor(absPos) {\n      logger.log(\"INFO\", \"setCursor: \" + absPos);\n      var row = this.rows[this.currRow];\n      row.setCursor(absPos);\n    },\n    setPAC: function setPAC(pacData) {\n      logger.log(\"INFO\", \"pacData = \" + JSON.stringify(pacData));\n      var newRow = pacData.row - 1;\n\n      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n        newRow = this.nrRollUpRows - 1;\n      }\n\n      this.currRow = newRow;\n      var row = this.rows[this.currRow];\n\n      if (pacData.indent !== null) {\n        var indent = pacData.indent;\n        var prevPos = Math.max(indent - 1, 0);\n        row.setCursor(pacData.indent);\n        pacData.color = row.chars[prevPos].penState.foreground;\n      }\n\n      var styles = {\n        foreground: pacData.color,\n        underline: pacData.underline,\n        italics: pacData.italics,\n        background: 'black',\n        flash: false\n      };\n      this.setPen(styles);\n    },\n\n    /**\n    * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n    */\n    setBkgData: function setBkgData(bkgData) {\n      logger.log(\"INFO\", \"bkgData = \" + JSON.stringify(bkgData));\n      this.backSpace();\n      this.setPen(bkgData);\n      this.insertChar(0x20); //Space\n    },\n    setRollUpRows: function setRollUpRows(nrRows) {\n      this.nrRollUpRows = nrRows;\n    },\n    rollUp: function rollUp() {\n      if (this.nrRollUpRows === null) {\n        logger.log(\"DEBUG\", \"roll_up but nrRollUpRows not set yet\");\n        return; //Not properly setup\n      }\n\n      logger.log(\"TEXT\", this.getDisplayText());\n      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      var topRow = this.rows.splice(topRowIndex, 1)[0];\n      topRow.clear();\n      this.rows.splice(this.currRow, 0, topRow);\n      logger.log(\"INFO\", \"Rolling up\"); //logger.log(\"TEXT\", this.get_display_text())\n    },\n\n    /**\n          * Get all non-empty rows with as unicode text. \n          */\n    getDisplayText: function getDisplayText(asOneRow) {\n      asOneRow = asOneRow || false;\n      var displayText = [];\n      var text = \"\";\n      var rowNr = -1;\n\n      for (var i = 0; i < NR_ROWS; i++) {\n        var rowText = this.rows[i].getTextString();\n\n        if (rowText) {\n          rowNr = i + 1;\n\n          if (asOneRow) {\n            displayText.push(\"Row \" + rowNr + ': \"' + rowText + '\"');\n          } else {\n            displayText.push(rowText.trim());\n          }\n        }\n      }\n\n      if (displayText.length > 0) {\n        if (asOneRow) {\n          text = \"[\" + displayText.join(\" | \") + \"]\";\n        } else {\n          text = displayText.join(\"\\n\");\n        }\n      }\n\n      return text;\n    },\n    getTextAndFormat: function getTextAndFormat() {\n      return this.rows;\n    }\n  };\n  /**\n  * Handle a CEA-608 channel and send decoded data to outputFilter\n  * @constructor\n  * @param {Number} channelNumber (1 or 2)\n  * @param {CueHandler} outputFilter Output from channel1 newCue(startTime, endTime, captionScreen)\n  */\n\n  var Cea608Channel = function Cea608Channel(channelNumber, outputFilter) {\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen();\n    this.nonDisplayedMemory = new CaptionScreen();\n    this.lastOutputScreen = new CaptionScreen();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n  };\n\n  Cea608Channel.prototype = {\n    modes: [\"MODE_ROLL-UP\", \"MODE_POP-ON\", \"MODE_PAINT-ON\", \"MODE_TEXT\"],\n    reset: function reset() {\n      this.mode = null;\n      this.displayedMemory.reset();\n      this.nonDisplayedMemory.reset();\n      this.lastOutputScreen.reset();\n      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n      this.writeScreen = this.displayedMemory;\n      this.mode = null;\n      this.cueStartTime = null;\n      this.lastCueEndTime = null;\n    },\n    getHandler: function getHandler() {\n      return this.outputFilter;\n    },\n    setHandler: function setHandler(newHandler) {\n      this.outputFilter = newHandler;\n    },\n    setPAC: function setPAC(pacData) {\n      this.writeScreen.setPAC(pacData);\n    },\n    setBkgData: function setBkgData(bkgData) {\n      this.writeScreen.setBkgData(bkgData);\n    },\n    setMode: function setMode(newMode) {\n      if (newMode === this.mode) {\n        return;\n      }\n\n      this.mode = newMode;\n      logger.log(\"INFO\", \"MODE=\" + newMode);\n\n      if (this.mode == \"MODE_POP-ON\") {\n        this.writeScreen = this.nonDisplayedMemory;\n      } else {\n        this.writeScreen = this.displayedMemory;\n        this.writeScreen.reset();\n      }\n\n      if (this.mode !== \"MODE_ROLL-UP\") {\n        this.displayedMemory.nrRollUpRows = null;\n        this.nonDisplayedMemory.nrRollUpRows = null;\n      }\n\n      this.mode = newMode;\n    },\n    insertChars: function insertChars(chars) {\n      for (var i = 0; i < chars.length; i++) {\n        this.writeScreen.insertChar(chars[i]);\n      }\n\n      var screen = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n      logger.log(\"INFO\", screen + \": \" + this.writeScreen.getDisplayText(true));\n\n      if (this.mode === \"MODE_PAINT-ON\" || this.mode === \"MODE_ROLL-UP\") {\n        logger.log(\"TEXT\", \"DISPLAYED: \" + this.displayedMemory.getDisplayText(true));\n        this.outputDataUpdate();\n      }\n    },\n    cc_RCL: function cc_RCL() {\n      // Resume Caption Loading (switch mode to Pop On)\n      logger.log(\"INFO\", \"RCL - Resume Caption Loading\");\n      this.setMode(\"MODE_POP-ON\");\n    },\n    cc_BS: function cc_BS() {\n      // BackSpace\n      logger.log(\"INFO\", \"BS - BackSpace\");\n\n      if (this.mode === \"MODE_TEXT\") {\n        return;\n      }\n\n      this.writeScreen.backSpace();\n\n      if (this.writeScreen === this.displayedMemory) {\n        this.outputDataUpdate();\n      }\n    },\n    cc_AOF: function cc_AOF() {\n      // Reserved (formerly Alarm Off)\n      return;\n    },\n    cc_AON: function cc_AON() {\n      // Reserved (formerly Alarm On)\n      return;\n    },\n    cc_DER: function cc_DER() {\n      // Delete to End of Row\n      logger.log(\"INFO\", \"DER- Delete to End of Row\");\n      this.writeScreen.clearToEndOfRow();\n      this.outputDataUpdate();\n    },\n    cc_RU: function cc_RU(nrRows) {\n      //Roll-Up Captions-2,3,or 4 Rows\n      logger.log(\"INFO\", \"RU(\" + nrRows + \") - Roll Up\");\n      this.writeScreen = this.displayedMemory;\n      this.setMode(\"MODE_ROLL-UP\");\n      this.writeScreen.setRollUpRows(nrRows);\n    },\n    cc_FON: function cc_FON() {\n      //Flash On\n      logger.log(\"INFO\", \"FON - Flash On\");\n      this.writeScreen.setPen({\n        flash: true\n      });\n    },\n    cc_RDC: function cc_RDC() {\n      // Resume Direct Captioning (switch mode to PaintOn)\n      logger.log(\"INFO\", \"RDC - Resume Direct Captioning\");\n      this.setMode(\"MODE_PAINT-ON\");\n    },\n    cc_TR: function cc_TR() {\n      // Text Restart in text mode (not supported, however)\n      logger.log(\"INFO\", \"TR\");\n      this.setMode(\"MODE_TEXT\");\n    },\n    cc_RTD: function cc_RTD() {\n      // Resume Text Display in Text mode (not supported, however)\n      logger.log(\"INFO\", \"RTD\");\n      this.setMode(\"MODE_TEXT\");\n    },\n    cc_EDM: function cc_EDM() {\n      // Erase Displayed Memory\n      logger.log(\"INFO\", \"EDM - Erase Displayed Memory\");\n      this.displayedMemory.reset();\n      this.outputDataUpdate();\n    },\n    cc_CR: function cc_CR() {\n      // Carriage Return\n      logger.log(\"CR - Carriage Return\");\n      this.writeScreen.rollUp();\n      this.outputDataUpdate();\n    },\n    cc_ENM: function cc_ENM() {\n      //Erase Non-Displayed Memory\n      logger.log(\"INFO\", \"ENM - Erase Non-displayed Memory\");\n      this.nonDisplayedMemory.reset();\n    },\n    cc_EOC: function cc_EOC() {\n      //End of Caption (Flip Memories)\n      logger.log(\"INFO\", \"EOC - End Of Caption\");\n\n      if (this.mode === \"MODE_POP-ON\") {\n        var tmp = this.displayedMemory;\n        this.displayedMemory = this.nonDisplayedMemory;\n        this.nonDisplayedMemory = tmp;\n        this.writeScreen = this.nonDisplayedMemory;\n        logger.log(\"TEXT\", \"DISP: \" + this.displayedMemory.getDisplayText());\n      }\n\n      this.outputDataUpdate();\n    },\n    cc_TO: function cc_TO(nrCols) {\n      // Tab Offset 1,2, or 3 columns\n      logger.log(\"INFO\", \"TO(\" + nrCols + \") - Tab Offset\");\n      this.writeScreen.moveCursor(nrCols);\n    },\n    cc_MIDROW: function cc_MIDROW(secondByte) {\n      // Parse MIDROW command\n      var styles = {\n        flash: false\n      };\n      styles.underline = secondByte % 2 === 1;\n      styles.italics = secondByte >= 0x2e;\n\n      if (!styles.italics) {\n        var colorIndex = Math.floor(secondByte / 2) - 0x10;\n        var colors = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\"];\n        styles.foreground = colors[colorIndex];\n      } else {\n        styles.foreground = \"white\";\n      }\n\n      logger.log(\"INFO\", \"MIDROW: \" + JSON.stringify(styles));\n      this.writeScreen.setPen(styles);\n    },\n    outputDataUpdate: function outputDataUpdate() {\n      var t = logger.time;\n\n      if (t === null) {\n        return;\n      }\n\n      if (this.outputFilter) {\n        if (this.outputFilter.updateData) {\n          this.outputFilter.updateData(t, this.displayedMemory);\n        }\n\n        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n          // Start of a new cue\n          this.cueStartTime = t;\n        } else {\n          if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n            if (this.outputFilter.newCue) {\n              this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);\n            }\n\n            this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;\n          }\n        }\n\n        this.lastOutputScreen.copy(this.displayedMemory);\n      }\n    },\n    cueSplitAtTime: function cueSplitAtTime(t) {\n      if (this.outputFilter) {\n        if (!this.displayedMemory.isEmpty()) {\n          if (this.outputFilter.newCue) {\n            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n          }\n\n          this.cueStartTime = t;\n        }\n      }\n    }\n  };\n  /**\n  * Parse CEA-608 data and send decoded data to out1 and out2.\n  * @constructor\n  * @param {Number} field  CEA-608 field (1 or 2)\n  * @param {CueHandler} out1 Output from channel1 newCue(startTime, endTime, captionScreen)\n  * @param {CueHandler} out2 Output from channel2 newCue(startTime, endTime, captionScreen)\n  */\n\n  var Cea608Parser = function Cea608Parser(field, out1, out2) {\n    this.field = field || 1;\n    this.outputs = [out1, out2];\n    this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];\n    this.currChNr = -1; // Will be 1 or 2\n\n    this.lastCmdA = null; // First byte of last command\n\n    this.lastCmdB = null; // Second byte of last command\n\n    this.bufferedData = [];\n    this.startTime = null;\n    this.lastTime = null;\n    this.dataCounters = {\n      'padding': 0,\n      'char': 0,\n      'cmd': 0,\n      'other': 0\n    };\n  };\n\n  Cea608Parser.prototype = {\n    getHandler: function getHandler(index) {\n      return this.channels[index].getHandler();\n    },\n    setHandler: function setHandler(index, newHandler) {\n      this.channels[index].setHandler(newHandler);\n    },\n\n    /**\n    * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n    */\n    addData: function addData(t, byteList) {\n      var cmdFound,\n          a,\n          b,\n          charsFound = false;\n      this.lastTime = t;\n      logger.setTime(t);\n\n      for (var i = 0; i < byteList.length; i += 2) {\n        a = byteList[i] & 0x7f;\n        b = byteList[i + 1] & 0x7f;\n\n        if (a >= 0x10 && a <= 0x1f && a === this.lastCmdA && b === this.lastCmdB) {\n          this.lastCmdA = null;\n          this.lastCmdB = null;\n          logger.log(\"DEBUG\", \"Repeated command (\" + numArrayToHexArray([a, b]) + \") is dropped\");\n          continue; // Repeated commands are dropped (once)\n        }\n\n        if (a === 0 && b === 0) {\n          this.dataCounters.padding += 2;\n          continue;\n        } else {\n          logger.log(\"DATA\", \"[\" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + \"] -> (\" + numArrayToHexArray([a, b]) + \")\");\n        }\n\n        cmdFound = this.parseCmd(a, b);\n\n        if (!cmdFound) {\n          cmdFound = this.parseMidrow(a, b);\n        }\n\n        if (!cmdFound) {\n          cmdFound = this.parsePAC(a, b);\n        }\n\n        if (!cmdFound) {\n          cmdFound = this.parseBackgroundAttributes(a, b);\n        }\n\n        if (!cmdFound) {\n          charsFound = this.parseChars(a, b);\n\n          if (charsFound) {\n            if (this.currChNr && this.currChNr >= 0) {\n              var channel = this.channels[this.currChNr - 1];\n              channel.insertChars(charsFound);\n            } else {\n              logger.log(\"WARNING\", \"No channel found yet. TEXT-MODE?\");\n            }\n          }\n        }\n\n        if (cmdFound) {\n          this.dataCounters.cmd += 2;\n        } else if (charsFound) {\n          this.dataCounters.char += 2;\n        } else {\n          this.dataCounters.other += 2;\n          logger.log(\"WARNING\", \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + \" orig: \" + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n        }\n      }\n    },\n\n    /**\n    * Parse Command.\n    * @returns {Boolean} Tells if a command was found\n    */\n    parseCmd: function parseCmd(a, b) {\n      var chNr = null;\n      var cond1 = (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) && 0x20 <= b && b <= 0x2F;\n      var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;\n\n      if (!(cond1 || cond2)) {\n        return false;\n      }\n\n      if (a === 0x14 || a === 0x15 || a === 0x17) {\n        chNr = 1;\n      } else {\n        chNr = 2; // (a === 0x1C || a === 0x1D || a=== 0x1f)\n      }\n\n      var channel = this.channels[chNr - 1];\n\n      if (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) {\n        if (b === 0x20) {\n          channel.cc_RCL();\n        } else if (b === 0x21) {\n          channel.cc_BS();\n        } else if (b === 0x22) {\n          channel.cc_AOF();\n        } else if (b === 0x23) {\n          channel.cc_AON();\n        } else if (b === 0x24) {\n          channel.cc_DER();\n        } else if (b === 0x25) {\n          channel.cc_RU(2);\n        } else if (b === 0x26) {\n          channel.cc_RU(3);\n        } else if (b === 0x27) {\n          channel.cc_RU(4);\n        } else if (b === 0x28) {\n          channel.cc_FON();\n        } else if (b === 0x29) {\n          channel.cc_RDC();\n        } else if (b === 0x2A) {\n          channel.cc_TR();\n        } else if (b === 0x2B) {\n          channel.cc_RTD();\n        } else if (b === 0x2C) {\n          channel.cc_EDM();\n        } else if (b === 0x2D) {\n          channel.cc_CR();\n        } else if (b === 0x2E) {\n          channel.cc_ENM();\n        } else if (b === 0x2F) {\n          channel.cc_EOC();\n        }\n      } else {\n        //a == 0x17 || a == 0x1F\n        channel.cc_TO(b - 0x20);\n      }\n\n      this.lastCmdA = a;\n      this.lastCmdB = b;\n      this.currChNr = chNr;\n      return true;\n    },\n\n    /**\n    * Parse midrow styling command\n    * @returns {Boolean}\n    */\n    parseMidrow: function parseMidrow(a, b) {\n      var chNr = null;\n\n      if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {\n        if (a === 0x11) {\n          chNr = 1;\n        } else {\n          chNr = 2;\n        }\n\n        if (chNr !== this.currChNr) {\n          logger.log(\"ERROR\", \"Mismatch channel in midrow parsing\");\n          return false;\n        }\n\n        var channel = this.channels[chNr - 1]; // cea608 spec says midrow codes should inject a space\n\n        channel.insertChars([0x20]);\n        channel.cc_MIDROW(b);\n        logger.log(\"DEBUG\", \"MIDROW (\" + numArrayToHexArray([a, b]) + \")\");\n        this.lastCmdA = a;\n        this.lastCmdB = b;\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n    * Parse Preable Access Codes (Table 53).\n    * @returns {Boolean} Tells if PAC found\n    */\n    parsePAC: function parsePAC(a, b) {\n      var chNr = null;\n      var row = null;\n      var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;\n      var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;\n\n      if (!(case1 || case2)) {\n        return false;\n      }\n\n      chNr = a <= 0x17 ? 1 : 2;\n\n      if (0x40 <= b && b <= 0x5F) {\n        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n      } else {\n        // 0x60 <= b <= 0x7F\n        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n      }\n\n      var pacData = this.interpretPAC(row, b);\n      var channel = this.channels[chNr - 1];\n      channel.setPAC(pacData);\n      this.lastCmdA = a;\n      this.lastCmdB = b;\n      this.currChNr = chNr;\n      return true;\n    },\n\n    /**\n    * Interpret the second byte of the pac, and return the information.\n    * @returns {Object} pacData with style parameters.\n    */\n    interpretPAC: function interpretPAC(row, byte) {\n      var pacIndex = byte;\n      var pacData = {\n        color: null,\n        italics: false,\n        indent: null,\n        underline: false,\n        row: row\n      };\n\n      if (byte > 0x5F) {\n        pacIndex = byte - 0x60;\n      } else {\n        pacIndex = byte - 0x40;\n      }\n\n      pacData.underline = (pacIndex & 1) === 1;\n\n      if (pacIndex <= 0xd) {\n        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n      } else if (pacIndex <= 0xf) {\n        pacData.italics = true;\n        pacData.color = 'white';\n      } else {\n        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n      }\n\n      return pacData; // Note that row has zero offset. The spec uses 1.\n    },\n\n    /**\n           * Parse characters.\n           * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n           */\n    parseChars: function parseChars(a, b) {\n      var channelNr = null,\n          charCodes = null,\n          charCode1 = null,\n          charCode2 = null;\n\n      if (a >= 0x19) {\n        channelNr = 2;\n        charCode1 = a - 8;\n      } else {\n        channelNr = 1;\n        charCode1 = a;\n      }\n\n      if (0x11 <= charCode1 && charCode1 <= 0x13) {\n        // Special character\n        var oneCode = b;\n\n        if (charCode1 === 0x11) {\n          oneCode = b + 0x50;\n        } else if (charCode1 === 0x12) {\n          oneCode = b + 0x70;\n        } else {\n          oneCode = b + 0x90;\n        }\n\n        logger.log(\"INFO\", \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n        charCodes = [oneCode];\n        this.lastCmdA = a;\n        this.lastCmdB = b;\n      } else if (0x20 <= a && a <= 0x7f) {\n        charCodes = b === 0 ? [a] : [a, b];\n        this.lastCmdA = null;\n        this.lastCmdB = null;\n      }\n\n      if (charCodes) {\n        var hexCodes = numArrayToHexArray(charCodes);\n        logger.log(\"DEBUG\", \"Char codes =  \" + hexCodes.join(\",\"));\n      }\n\n      return charCodes;\n    },\n\n    /**\n    * Parse extended background attributes as well as new foreground color black.\n    * @returns{Boolean} Tells if background attributes are found\n    */\n    parseBackgroundAttributes: function parseBackgroundAttributes(a, b) {\n      var bkgData, index, chNr, channel;\n      var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;\n      var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;\n\n      if (!(case1 || case2)) {\n        return false;\n      }\n\n      bkgData = {};\n\n      if (a === 0x10 || a === 0x18) {\n        index = Math.floor((b - 0x20) / 2);\n        bkgData.background = backgroundColors[index];\n\n        if (b % 2 === 1) {\n          bkgData.background = bkgData.background + \"_semi\";\n        }\n      } else if (b === 0x2d) {\n        bkgData.background = \"transparent\";\n      } else {\n        bkgData.foreground = \"black\";\n\n        if (b === 0x2f) {\n          bkgData.underline = true;\n        }\n      }\n\n      chNr = a < 0x18 ? 1 : 2;\n      channel = this.channels[chNr - 1];\n      channel.setBkgData(bkgData);\n      this.lastCmdA = a;\n      this.lastCmdB = b;\n      return true;\n    },\n\n    /**\n    * Reset state of parser and its channels.\n    */\n    reset: function reset() {\n      for (var i = 0; i < this.channels.length; i++) {\n        if (this.channels[i]) {\n          this.channels[i].reset();\n        }\n      }\n\n      this.lastCmdA = null;\n      this.lastCmdB = null;\n    },\n\n    /**\n    * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n    */\n    cueSplitAtTime: function cueSplitAtTime(t) {\n      for (var i = 0; i < this.channels.length; i++) {\n        if (this.channels[i]) {\n          this.channels[i].cueSplitAtTime(t);\n        }\n      }\n    }\n  };\n  /**\n  * Find ranges corresponding to SEA CEA-608 NALUS in sizeprepended NALU array.\n  * @param {raw} dataView of binary data\n  * @param {startPos} start position in raw\n  * @param {size} total size of data in raw to consider\n  * @returns \n  */\n\n  var findCea608Nalus = function findCea608Nalus(raw, startPos, size) {\n    var nalSize = 0,\n        cursor = startPos,\n        nalType = 0,\n        cea608NaluRanges = [],\n        // Check SEI data according to ANSI-SCTE 128\n    isCEA608SEI = function isCEA608SEI(payloadType, payloadSize, raw, pos) {\n      if (payloadType !== 4 || payloadSize < 8) {\n        return null;\n      }\n\n      var countryCode = raw.getUint8(pos);\n      var providerCode = raw.getUint16(pos + 1);\n      var userIdentifier = raw.getUint32(pos + 3);\n      var userDataTypeCode = raw.getUint8(pos + 7);\n      return countryCode == 0xB5 && providerCode == 0x31 && userIdentifier == 0x47413934 && userDataTypeCode == 0x3;\n    };\n\n    while (cursor < startPos + size) {\n      nalSize = raw.getUint32(cursor);\n      nalType = raw.getUint8(cursor + 4) & 0x1F; //console.log(time + \"  NAL \" + nalType);\n\n      if (nalType === 6) {\n        // SEI NAL Unit. The NAL header is the first byte\n        //console.log(\"SEI NALU of size \" + nalSize + \" at time \" + time);\n        var pos = cursor + 5;\n        var payloadType = -1;\n\n        while (pos < cursor + 4 + nalSize - 1) {\n          // The last byte should be rbsp_trailing_bits\n          payloadType = 0;\n          var b = 0xFF;\n\n          while (b === 0xFF) {\n            b = raw.getUint8(pos);\n            payloadType += b;\n            pos++;\n          }\n\n          var payloadSize = 0;\n          b = 0xFF;\n\n          while (b === 0xFF) {\n            b = raw.getUint8(pos);\n            payloadSize += b;\n            pos++;\n          }\n\n          if (isCEA608SEI(payloadType, payloadSize, raw, pos)) {\n            //console.log(\"CEA608 SEI \" + time + \" \" + payloadSize);\n            cea608NaluRanges.push([pos, payloadSize]);\n          }\n\n          pos += payloadSize;\n        }\n      }\n\n      cursor += nalSize + 4;\n    }\n\n    return cea608NaluRanges;\n  };\n\n  var extractCea608DataFromRange = function extractCea608DataFromRange(raw, cea608Range) {\n    var pos = cea608Range[0];\n    var fieldData = [[], []];\n    pos += 8; // Skip the identifier up to userDataTypeCode\n\n    var ccCount = raw.getUint8(pos) & 0x1f;\n    pos += 2; // Advance 1 and skip reserved byte\n\n    for (var i = 0; i < ccCount; i++) {\n      var byte = raw.getUint8(pos);\n      var ccValid = byte & 0x4;\n      var ccType = byte & 0x3;\n      pos++;\n      var ccData1 = raw.getUint8(pos); // Keep parity bit\n\n      pos++;\n      var ccData2 = raw.getUint8(pos); // Keep parity bit\n\n      pos++;\n\n      if (ccValid && (ccData1 & 0x7f) + (ccData2 & 0x7f) !== 0) {\n        //Check validity and non-empty data\n        if (ccType === 0) {\n          fieldData[0].push(ccData1);\n          fieldData[0].push(ccData2);\n        } else if (ccType === 1) {\n          fieldData[1].push(ccData1);\n          fieldData[1].push(ccData2);\n        }\n      }\n    }\n\n    return fieldData;\n  };\n\n  exports.logger = logger;\n  exports.PenState = PenState;\n  exports.CaptionScreen = CaptionScreen;\n  exports.Cea608Parser = Cea608Parser;\n  exports.findCea608Nalus = findCea608Nalus;\n  exports.extractCea608DataFromRange = extractCea608DataFromRange;\n})(typeof exports === 'undefined' ? undefined.cea608parser = {} : exports);","map":{"version":3,"sources":["../../../externals/cea608-parser.js"],"names":["specialCea608CharsCodes","getCharForByte","charCode","String","NR_ROWS","NR_COLS","rowsLowCh1","rowsHighCh1","rowsLowCh2","rowsHighCh2","backgroundColors","logger","verboseFilter","time","verboseLevel","setTime","log","minLevel","console","numArrayToHexArray","hexArray","j","numArray","PenState","foreground","underline","italics","background","flash","reset","setStyles","attribs","i","style","styles","isDefault","equals","other","copy","newPenState","toString","StyledUnicodeChar","uchar","setChar","setPenState","newChar","isEmpty","Row","equal","empty","setCursor","moveCursor","newPos","relPos","backSpace","insertChar","byte","char","clearFromPos","clear","clearToEndOfRow","getTextString","chars","setPenStyles","currChar","CaptionScreen","row","setPen","setPAC","JSON","newRow","pacData","indent","prevPos","Math","setBkgData","setRollUpRows","rollUp","topRowIndex","topRow","getDisplayText","asOneRow","displayText","text","rowNr","rowText","getTextAndFormat","Cea608Channel","modes","getHandler","setHandler","setMode","newMode","insertChars","screen","cc_RCL","cc_BS","cc_AOF","cc_AON","cc_DER","cc_RU","cc_FON","cc_RDC","cc_TR","cc_RTD","cc_EDM","cc_CR","cc_ENM","cc_EOC","tmp","cc_TO","cc_MIDROW","secondByte","colorIndex","colors","outputDataUpdate","t","cueSplitAtTime","Cea608Parser","field","addData","charsFound","byteList","a","b","cmdFound","channel","parseCmd","chNr","cond1","cond2","parseMidrow","parsePAC","case1","case2","interpretPAC","pacIndex","color","parseChars","channelNr","charCodes","charCode1","charCode2","oneCode","hexCodes","parseBackgroundAttributes","bkgData","index","findCea608Nalus","nalSize","cursor","nalType","cea608NaluRanges","isCEA608SEI","payloadType","payloadSize","countryCode","raw","providerCode","pos","userIdentifier","userDataTypeCode","startPos","extractCea608DataFromRange","cea608Range","fieldData","ccCount","ccValid","ccType","ccData1","ccData2","exports"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n(function(exports) {\n\n    \"use strict\";\n\n    /**\n     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n     */\n\n    var specialCea608CharsCodes = {\n        0x2a : 0xe1, // lowercase a, acute accent\n        0x5c : 0xe9, // lowercase e, acute accent\n        0x5e : 0xed, // lowercase i, acute accent\n        0x5f : 0xf3, // lowercase o, acute accent\n        0x60 : 0xfa, // lowercase u, acute accent\n        0x7b : 0xe7, // lowercase c with cedilla\n        0x7c : 0xf7, // division symbol\n        0x7d : 0xd1, // uppercase N tilde\n        0x7e : 0xf1, // lowercase n tilde\n        0x7f : 0x2588, // Full block\n        // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n        // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n        // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n        0x80 : 0xae, // Registered symbol (R)\n        0x81 : 0xb0, // degree sign\n        0x82 : 0xbd, // 1/2 symbol\n        0x83 : 0xbf, // Inverted (open) question mark\n        0x84 : 0x2122, // Trademark symbol (TM)\n        0x85 : 0xa2, // Cents symbol\n        0x86 : 0xa3, // Pounds sterling\n        0x87 : 0x266a, // Music 8'th note\n        0x88 : 0xe0, // lowercase a, grave accent\n        0x89 : 0x20, // transparent space (regular)\n        0x8a : 0xe8, // lowercase e, grave accent\n        0x8b : 0xe2, // lowercase a, circumflex accent\n        0x8c : 0xea, // lowercase e, circumflex accent\n        0x8d : 0xee, // lowercase i, circumflex accent\n        0x8e : 0xf4, // lowercase o, circumflex accent\n        0x8f : 0xfb, // lowercase u, circumflex accent\n        // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n        // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n        0x90 : 0xc1, // capital letter A with acute\n        0x91 : 0xc9, // capital letter E with acute\n        0x92 : 0xd3, // capital letter O with acute\n        0x93 : 0xda, // capital letter U with acute\n        0x94 : 0xdc, // capital letter U with diaresis\n        0x95 : 0xfc, // lowercase letter U with diaeresis\n        0x96 : 0x2018, // opening single quote\n        0x97 : 0xa1, // inverted exclamation mark\n        0x98 : 0x2a, // asterisk\n        0x99 : 0x2019, // closing single quote\n        0x9a : 0x2501, // box drawings heavy horizontal\n        0x9b : 0xa9, // copyright sign\n        0x9c : 0x2120, // Service mark\n        0x9d : 0x2022, // (round) bullet\n        0x9e : 0x201c, // Left double quotation mark\n        0x9f : 0x201d, // Right double quotation mark\n        0xa0 : 0xc0, // uppercase A, grave accent\n        0xa1 : 0xc2, // uppercase A, circumflex\n        0xa2 : 0xc7, // uppercase C with cedilla\n        0xa3 : 0xc8, // uppercase E, grave accent\n        0xa4 : 0xca, // uppercase E, circumflex\n        0xa5 : 0xcb, // capital letter E with diaresis\n        0xa6 : 0xeb, // lowercase letter e with diaresis\n        0xa7 : 0xce, // uppercase I, circumflex\n        0xa8 : 0xcf, // uppercase I, with diaresis\n        0xa9 : 0xef, // lowercase i, with diaresis\n        0xaa : 0xd4, // uppercase O, circumflex\n        0xab : 0xd9, // uppercase U, grave accent\n        0xac : 0xf9, // lowercase u, grave accent\n        0xad : 0xdb, // uppercase U, circumflex\n        0xae : 0xab, // left-pointing double angle quotation mark\n        0xaf : 0xbb, // right-pointing double angle quotation mark\n        // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n        // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n        0xb0 : 0xc3, // Uppercase A, tilde\n        0xb1 : 0xe3, // Lowercase a, tilde\n        0xb2 : 0xcd, // Uppercase I, acute accent\n        0xb3 : 0xcc, // Uppercase I, grave accent\n        0xb4 : 0xec, // Lowercase i, grave accent\n        0xb5 : 0xd2, // Uppercase O, grave accent\n        0xb6 : 0xf2, // Lowercase o, grave accent\n        0xb7 : 0xd5, // Uppercase O, tilde\n        0xb8 : 0xf5, // Lowercase o, tilde\n        0xb9 : 0x7b, // Open curly brace\n        0xba : 0x7d, // Closing curly brace\n        0xbb : 0x5c, // Backslash\n        0xbc : 0x5e, // Caret\n        0xbd : 0x5f, // Underscore\n        0xbe : 0x7c, // Pipe (vertical line)\n        0xbf : 0x223c, // Tilde operator\n        0xc0 : 0xc4, // Uppercase A, umlaut\n        0xc1 : 0xe4, // Lowercase A, umlaut\n        0xc2 : 0xd6, // Uppercase O, umlaut\n        0xc3 : 0xf6, // Lowercase o, umlaut\n        0xc4 : 0xdf, // Esszett (sharp S)\n        0xc5 : 0xa5, // Yen symbol\n        0xc6 : 0xa4, // Generic currency sign\n        0xc7 : 0x2503, // Box drawings heavy vertical\n        0xc8 : 0xc5, // Uppercase A, ring\n        0xc9 : 0xe5, // Lowercase A, ring\n        0xca : 0xd8, // Uppercase O, stroke\n        0xcb : 0xf8, // Lowercase o, strok\n        0xcc : 0x250f, // Box drawings heavy down and right\n        0xcd : 0x2513, // Box drawings heavy down and left\n        0xce : 0x2517, // Box drawings heavy up and right\n        0xcf : 0x251b // Box drawings heavy up and left\n    };\n\n    /**\n     * Get Unicode Character from CEA-608 byte code\n     */\n    var getCharForByte = function(byte) {\n        var charCode = byte;\n        if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n            charCode = specialCea608CharsCodes[byte];\n        }\n        return String.fromCharCode(charCode);\n    };\n\n    var NR_ROWS = 15,\n        NR_COLS = 32;\n    // Tables to look up row from PAC data\n    var rowsLowCh1 = {0x11 : 1, 0x12 : 3, 0x15 : 5, 0x16 : 7, 0x17 : 9, 0x10 : 11, 0x13 : 12, 0x14 : 14};\n    var rowsHighCh1 = {0x11 : 2, 0x12 : 4, 0x15 : 6, 0x16 : 8, 0x17 : 10, 0x13 : 13, 0x14 : 15};\n    var rowsLowCh2 = {0x19 : 1, 0x1A : 3, 0x1D : 5, 0x1E : 7, 0x1F : 9, 0x18 : 11, 0x1B : 12, 0x1C : 14};\n    var rowsHighCh2 = {0x19 : 2, 0x1A : 4, 0x1D : 6, 0x1E : 8, 0x1F : 10, 0x1B : 13, 0x1C : 15};\n\n    var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n\n    /**\n     * Simple logger class to be able to write with time-stamps and filter on level.\n     */\n    var logger = {\n        verboseFilter : {'DATA' : 3, 'DEBUG' : 3, 'INFO' : 2, 'WARNING' : 2, 'TEXT' : 1, 'ERROR' : 0},\n        time : null,\n        verboseLevel : 0, // Only write errors\n        setTime : function(newTime) {\n            this.time = newTime;\n        },\n        log : function(severity, msg) {\n            var minLevel = this.verboseFilter[severity];\n            if (this.verboseLevel >= minLevel) {\n                console.log(this.time + \" [\" + severity + \"] \" + msg);\n            }\n        }\n    };\n\n    var numArrayToHexArray = function(numArray) {\n        var hexArray = [];\n        for (var j = 0; j < numArray.length; j++) {\n            hexArray.push(numArray[j].toString(16));\n        }\n        return hexArray;\n    };\n\n    /**\n     * State of CEA-608 pen or character\n     * @constructor\n     */\n    var PenState = function(foreground, underline, italics, background, flash) {\n        this.foreground = foreground || \"white\";\n        this.underline = underline || false;\n        this.italics = italics || false;\n        this.background = background || \"black\";\n        this.flash = flash || false;\n    };\n\n    PenState.prototype = {\n        \n        reset : function() {\n            this.foreground = \"white\";\n            this.underline = false;\n            this.italics = false;\n            this.background = \"black\";\n            this.flash = false;\n        },\n        \n        setStyles : function(styles) {\n            var attribs = [\"foreground\", \"underline\", \"italics\", \"background\", \"flash\"];\n            for (var i = 0 ; i < attribs.length; i++) {\n                var style = attribs[i];\n                if (styles.hasOwnProperty(style)) {\n                    this[style] = styles[style];\n                }\n            }\n        },\n        \n        isDefault : function() {\n            return (this.foreground === \"white\" && !this.underline && !this.italics && \n                    this.background === \"black\" && !this.flash);\n        },\n\n        equals : function(other) {\n            return ( (this.foreground === other.foreground) && \n                     (this.underline === other.underline) &&\n                     (this.italics === other.italics) &&\n                     (this.background === other.background) &&\n                     (this.flash === other.flash) );\n        },\n\n        copy : function(newPenState) {\n            this.foreground = newPenState.foreground;\n            this.underline = newPenState.underline;\n            this.italics = newPenState.italics;\n            this.background = newPenState.background;\n            this.flash = newPenState.flash;\n        },\n        \n        toString: function() {\n            return (\"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics +\n                \", background=\" + this.background + \", flash=\" + this.flash);\n        }\n    };\n\n    /**\n     * Unicode character with styling and background.\n     * @constructor\n     */\n    var StyledUnicodeChar = function(uchar, foreground, underline, italics, background, flash) {\n        this.uchar = uchar || ' '; // unicode character\n        this.penState = new PenState(foreground, underline,italics, background, flash);\n    };\n\n    StyledUnicodeChar.prototype = {\n        \n        reset: function() {\n            this.uchar = ' ';\n            this.penState.reset();\n        },\n        \n        setChar: function(uchar, newPenState) {\n            this.uchar = uchar;\n            this.penState.copy(newPenState);\n        },\n        \n        setPenState: function(newPenState) {\n            this.penState.copy(newPenState);\n        },\n        \n        equals: function(other) {\n            return this.uchar === other.uchar && this.penState.equals(other.penState);\n        },\n        \n        copy: function(newChar) {\n            this.uchar = newChar.uchar;\n            this.penState.copy(newChar.penState);\n        },\n        \n        isEmpty : function() {\n            return this.uchar === ' ' && this.penState.isDefault();\n        }\n    };\n\n    /**\n     * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n     * @constructor\n     */\n    var Row = function() {\n        this.chars = [];\n        for (var i = 0 ; i < NR_COLS ; i++) {\n            this.chars.push(new StyledUnicodeChar());\n        }\n        this.pos = 0;\n        this.currPenState = new PenState();\n    };\n\n    Row.prototype = {\n        \n        equals: function(other) {\n            var equal = true;\n            for (var i = 0 ; i < NR_COLS; i ++) {\n                if (!this.chars[i].equals(other.chars[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        },\n        \n        copy: function(other) {\n            for (var i = 0 ; i < NR_COLS; i ++) {\n                this.chars[i].copy(other.chars[i]);\n            }\n        },\n        \n        isEmpty : function() {\n            var empty = true;\n            for (var i = 0 ; i < NR_COLS; i ++) {\n                if (!this.chars[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        },\n\n        /**\n         *  Set the cursor to a valid column.\n         */\n        setCursor : function(absPos) {\n            if (this.pos !== absPos) {\n                this.pos = absPos;\n            }\n            if (this.pos < 0) {\n                logger.log(\"ERROR\", \"Negative cursor position \" + this.pos);\n                this.pos = 0;\n            } else if (this.pos > NR_COLS) {\n                logger.log(\"ERROR\", \"Too large cursor position \" + this.pos);\n                this.pos = NR_COLS;\n            }\n        },\n\n        /** \n         * Move the cursor relative to current position.\n         */\n        moveCursor : function(relPos) {\n            var newPos = this.pos + relPos;\n            if (relPos > 1) {\n                for (var i = this.pos+1; i < newPos+1 ; i++) {\n                    this.chars[i].setPenState(this.currPenState);\n                }\n            }\n            this.setCursor(newPos);\n        },\n\n        /**\n         * Backspace, move one step back and clear character.\n         */\n        backSpace : function () {\n            this.moveCursor(-1);\n            this.chars[this.pos].setChar(' ', this.currPenState);\n        },\n\n        insertChar: function(byte) {\n            if (byte >= 0x90) { //Extended char\n                this.backSpace();\n            }\n            var char = getCharForByte(byte);\n            if (this.pos >= NR_COLS) {\n                logger.log(\"ERROR\", \"Cannot insert \" + byte.toString(16) +  \n                            \" (\" + char + \") at position \" + this.pos + \". Skipping it!\");\n                return;\n            }\n            this.chars[this.pos].setChar(char, this.currPenState);\n            this.moveCursor(1);\n        },\n\n        clearFromPos : function(startPos) {\n            var i;\n            for (i = startPos ; i < NR_COLS ; i++) {\n                this.chars[i].reset();\n            }\n        },\n\n        clear : function() {\n            this.clearFromPos(0);\n            this.pos = 0;\n            this.currPenState.reset();\n        },\n\n        clearToEndOfRow : function() {\n            this.clearFromPos(this.pos);\n        },\n\n        getTextString: function() {\n            var chars = [];\n            var empty = true;\n            for (var i = 0 ; i < NR_COLS ; i++) {\n                var char = this.chars[i].uchar;\n                if (char !== \" \") {\n                    empty = false;\n                }\n                chars.push(char);\n            }\n            if (empty) {\n                return \"\";\n            } else {\n                return chars.join(\"\");\n            }\n        },\n\n        setPenStyles: function(styles) {\n            this.currPenState.setStyles(styles);\n            var currChar = this.chars[this.pos];\n            currChar.setPenState(this.currPenState);\n        }\n    };\n\n    /**\n     * Keep a CEA-608 screen of 32x15 styled characters\n     * @constructor\n    */\n    var CaptionScreen = function() {\n\n        this.rows = [];\n        for (var i = 0 ; i <  NR_ROWS; i++) {\n            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)\n        }\n        this.currRow = NR_ROWS - 1;\n        this.nrRollUpRows = null;\n        this.reset();\n    };\n\n    CaptionScreen.prototype = {\n\n        reset : function() {\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                this.rows[i].clear();\n            }\n            this.currRow = NR_ROWS - 1;\n        },\n\n        equals : function(other) {\n            var equal = true;\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                if (!this.rows[i].equals(other.rows[i])) {\n                    equal = false;\n                    break;\n                }\n            }\n            return equal;\n        },\n\n        copy : function(other) {\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                this.rows[i].copy(other.rows[i]);\n            }\n        },\n\n        isEmpty : function() {\n            var empty = true;\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                if (!this.rows[i].isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n            return empty;\n        },\n\n        backSpace : function() {\n            var row = this.rows[this.currRow]; \n            row.backSpace();\n        },\n\n        clearToEndOfRow : function() {\n            var row = this.rows[this.currRow];\n            row.clearToEndOfRow();\n        },\n\n        /**\n         * Insert a character (without styling) in the current row.\n         */\n        insertChar : function(char) {\n            var row = this.rows[this.currRow];\n            row.insertChar(char);\n        },\n\n        setPen : function(styles) {\n            var row = this.rows[this.currRow];\n            row.setPenStyles(styles);\n        },\n\n        moveCursor : function(relPos) {\n            var row = this.rows[this.currRow];\n            row.moveCursor(relPos); \n        },\n\n        setCursor : function(absPos) {\n            logger.log(\"INFO\", \"setCursor: \" + absPos);\n            var row = this.rows[this.currRow];\n            row.setCursor(absPos);\n        },\n\n        setPAC : function(pacData) {\n            logger.log(\"INFO\", \"pacData = \" + JSON.stringify(pacData));\n            var newRow = pacData.row - 1;\n            if (this.nrRollUpRows  && newRow < this.nrRollUpRows - 1) {\n                    newRow = this.nrRollUpRows-1;\n            }\n            this.currRow = newRow;\n            var row = this.rows[this.currRow];\n            if (pacData.indent !== null) {\n                var indent = pacData.indent;\n                var prevPos = Math.max(indent-1, 0);\n                row.setCursor(pacData.indent);\n                pacData.color = row.chars[prevPos].penState.foreground;\n            }\n            var styles = {foreground : pacData.color, underline : pacData.underline, italics : pacData.italics, background : 'black', flash : false};\n            this.setPen(styles);\n        },\n\n        /**\n         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n         */\n        setBkgData : function(bkgData) {\n\n            logger.log(\"INFO\", \"bkgData = \" + JSON.stringify(bkgData));\n            this.backSpace();\n            this.setPen(bkgData);\n            this.insertChar(0x20); //Space\n        },\n\n        setRollUpRows : function(nrRows) {\n            this.nrRollUpRows = nrRows;\n        },\n\n        rollUp : function() {\n            if (this.nrRollUpRows === null) {\n                logger.log(\"DEBUG\", \"roll_up but nrRollUpRows not set yet\");\n                return; //Not properly setup\n            }\n            logger.log(\"TEXT\", this.getDisplayText());\n            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n            var topRow = this.rows.splice(topRowIndex, 1)[0];\n            topRow.clear();\n            this.rows.splice(this.currRow, 0, topRow);\n            logger.log(\"INFO\", \"Rolling up\");\n            //logger.log(\"TEXT\", this.get_display_text())\n        },\n\n       /**\n        * Get all non-empty rows with as unicode text. \n        */        \n        getDisplayText : function(asOneRow) {\n            asOneRow = asOneRow || false;\n            var displayText = [];\n            var text = \"\";\n            var rowNr = -1;\n            for (var i = 0 ; i < NR_ROWS ; i++) {\n                var rowText = this.rows[i].getTextString();\n                if (rowText) {\n                    rowNr = i+1;\n                    if (asOneRow) {\n                        displayText.push(\"Row \" + rowNr + ': \"' + rowText + '\"');\n                    } else {\n                        displayText.push(rowText.trim());\n                    }\n                }\n            }\n            if (displayText.length > 0) {\n                if (asOneRow) {\n                    text = \"[\" + displayText.join(\" | \") + \"]\";\n                } else {\n                    text = displayText.join(\"\\n\");\n                }\n            }\n            return text;\n        },\n\n        getTextAndFormat : function() {\n            return this.rows;\n        }\n    };\n\n    /**\n     * Handle a CEA-608 channel and send decoded data to outputFilter\n     * @constructor\n     * @param {Number} channelNumber (1 or 2)\n     * @param {CueHandler} outputFilter Output from channel1 newCue(startTime, endTime, captionScreen)\n    */\n    var Cea608Channel = function(channelNumber, outputFilter) {\n\n        this.chNr = channelNumber;\n        this.outputFilter = outputFilter;\n        this.mode = null;\n        this.verbose = 0;\n        this.displayedMemory = new CaptionScreen();\n        this.nonDisplayedMemory = new CaptionScreen();\n        this.lastOutputScreen = new CaptionScreen();\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS-1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null; // Keeps track of where a cue started.\n    };\n\n    Cea608Channel.prototype = {\n        \n        modes : [\"MODE_ROLL-UP\", \"MODE_POP-ON\", \"MODE_PAINT-ON\", \"MODE_TEXT\"],\n        \n        reset : function() {\n            this.mode = null;\n            this.displayedMemory.reset();\n            this.nonDisplayedMemory.reset();\n            this.lastOutputScreen.reset();\n            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS-1];\n            this.writeScreen = this.displayedMemory;\n            this.mode = null;\n            this.cueStartTime = null;\n            this.lastCueEndTime = null;\n        },\n\n        getHandler : function() {\n            return this.outputFilter;\n        },\n\n        setHandler : function(newHandler) {\n            this.outputFilter = newHandler;\n        },\n\n        setPAC : function(pacData) {\n            this.writeScreen.setPAC(pacData);\n        },\n\n        setBkgData : function(bkgData) {\n            this.writeScreen.setBkgData(bkgData);\n        },\n\n        setMode : function(newMode) {\n            if (newMode === this.mode) {\n                return;\n            }\n            this.mode = newMode;\n            logger.log(\"INFO\", \"MODE=\" + newMode);\n            if (this.mode == \"MODE_POP-ON\") {\n                this.writeScreen = this.nonDisplayedMemory;\n            } else {\n                this.writeScreen = this.displayedMemory;\n                this.writeScreen.reset();\n            }\n            if (this.mode !== \"MODE_ROLL-UP\") {\n                this.displayedMemory.nrRollUpRows = null;\n                this.nonDisplayedMemory.nrRollUpRows = null;\n            }\n            this.mode = newMode;\n        },\n\n        insertChars : function(chars) {\n            for (var i = 0 ; i < chars.length ; i++) {\n                this.writeScreen.insertChar(chars[i]);\n            }\n            var screen = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n            logger.log(\"INFO\", screen + \": \" + this.writeScreen.getDisplayText(true));\n            if (this.mode === \"MODE_PAINT-ON\" || this.mode === \"MODE_ROLL-UP\") {\n                logger.log(\"TEXT\", \"DISPLAYED: \" + this.displayedMemory.getDisplayText(true));\n                this.outputDataUpdate();\n            }\n        },\n\n        cc_RCL: function() { // Resume Caption Loading (switch mode to Pop On)\n            logger.log(\"INFO\", \"RCL - Resume Caption Loading\");\n            this.setMode(\"MODE_POP-ON\");\n        },\n        cc_BS: function() { // BackSpace\n            logger.log(\"INFO\", \"BS - BackSpace\");\n            if (this.mode === \"MODE_TEXT\") {\n                return;\n            }\n            this.writeScreen.backSpace();\n            if (this.writeScreen === this.displayedMemory) {\n                this.outputDataUpdate();\n            }\n        },\n        cc_AOF : function() { // Reserved (formerly Alarm Off)\n            return;\n        },\n        cc_AON: function() { // Reserved (formerly Alarm On)\n            return;\n        },\n        cc_DER: function() { // Delete to End of Row\n            logger.log(\"INFO\", \"DER- Delete to End of Row\");\n            this.writeScreen.clearToEndOfRow();\n            this.outputDataUpdate();\n        },\n        cc_RU: function(nrRows) { //Roll-Up Captions-2,3,or 4 Rows\n            logger.log(\"INFO\", \"RU(\" + nrRows +\") - Roll Up\");\n            this.writeScreen = this.displayedMemory;\n            this.setMode(\"MODE_ROLL-UP\");\n            this.writeScreen.setRollUpRows(nrRows);\n        },\n        cc_FON: function() { //Flash On\n            logger.log(\"INFO\", \"FON - Flash On\");\n            this.writeScreen.setPen({flash : true});\n        },\n        cc_RDC: function() { // Resume Direct Captioning (switch mode to PaintOn)\n            logger.log(\"INFO\", \"RDC - Resume Direct Captioning\");\n            this.setMode(\"MODE_PAINT-ON\");\n        },\n        cc_TR: function() { // Text Restart in text mode (not supported, however)\n            logger.log(\"INFO\", \"TR\");\n            this.setMode(\"MODE_TEXT\");\n        },\n        cc_RTD: function() { // Resume Text Display in Text mode (not supported, however)\n            logger.log(\"INFO\", \"RTD\");\n            this.setMode(\"MODE_TEXT\");\n        },\n        cc_EDM: function() { // Erase Displayed Memory\n            logger.log(\"INFO\", \"EDM - Erase Displayed Memory\");\n            this.displayedMemory.reset();\n            this.outputDataUpdate();\n        },\n        cc_CR: function() { // Carriage Return\n            logger.log(\"CR - Carriage Return\");\n            this.writeScreen.rollUp();\n            this.outputDataUpdate();\n        },\n        cc_ENM: function() { //Erase Non-Displayed Memory\n            logger.log(\"INFO\", \"ENM - Erase Non-displayed Memory\");\n            this.nonDisplayedMemory.reset();\n        },\n        cc_EOC: function() { //End of Caption (Flip Memories)\n            logger.log(\"INFO\", \"EOC - End Of Caption\");\n            if (this.mode === \"MODE_POP-ON\") {\n                var tmp = this.displayedMemory;\n                this.displayedMemory = this.nonDisplayedMemory;\n                this.nonDisplayedMemory = tmp;\n                this.writeScreen = this.nonDisplayedMemory;\n                logger.log(\"TEXT\", \"DISP: \" + this.displayedMemory.getDisplayText());\n            }\n            this.outputDataUpdate();\n        },\n        cc_TO: function(nrCols) { // Tab Offset 1,2, or 3 columns\n            logger.log(\"INFO\", \"TO(\" + nrCols + \") - Tab Offset\");\n            this.writeScreen.moveCursor(nrCols);\n        },\n        cc_MIDROW: function(secondByte) { // Parse MIDROW command\n            var styles = {flash : false};\n            styles.underline = secondByte % 2 === 1;\n            styles.italics = secondByte >= 0x2e;\n            if (!styles.italics) {\n                var colorIndex = Math.floor(secondByte/2) - 0x10;\n                var colors = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\"];\n                styles.foreground = colors[colorIndex];\n            } else {\n                styles.foreground = \"white\";\n            }\n            logger.log(\"INFO\", \"MIDROW: \" + JSON.stringify(styles));\n            this.writeScreen.setPen(styles);\n        },\n\n        outputDataUpdate: function() {\n            var t = logger.time;\n            if (t === null) {\n                return;\n            }\n            if (this.outputFilter) {\n                if (this.outputFilter.updateData) {\n                    this.outputFilter.updateData(t, this.displayedMemory);\n                }\n                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) { // Start of a new cue\n                    this.cueStartTime = t;\n                } else {\n                    if (!this.displayedMemory.equals(this.lastOutputScreen)) { \n                        if (this.outputFilter.newCue) {\n                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);\n                        }\n                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;\n                    }\n                }\n                this.lastOutputScreen.copy(this.displayedMemory);\n            }\n        },\n\n        cueSplitAtTime : function(t) {\n            if (this.outputFilter) {\n                if (!this.displayedMemory.isEmpty()) {\n                    if (this.outputFilter.newCue) {\n                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n                    }\n                    this.cueStartTime = t;\n                }\n            }\n        }\n    };\n\n    /**\n     * Parse CEA-608 data and send decoded data to out1 and out2.\n     * @constructor\n     * @param {Number} field  CEA-608 field (1 or 2)\n     * @param {CueHandler} out1 Output from channel1 newCue(startTime, endTime, captionScreen)\n     * @param {CueHandler} out2 Output from channel2 newCue(startTime, endTime, captionScreen)\n     */\n    var Cea608Parser = function(field, out1, out2) {\n        this.field = field || 1;\n        this.outputs = [out1, out2];\n        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];\n        this.currChNr = -1; // Will be 1 or 2\n        this.lastCmdA = null; // First byte of last command\n        this.lastCmdB = null; // Second byte of last command\n        this.bufferedData = [];\n        this.startTime = null;\n        this.lastTime = null;\n        this.dataCounters = {'padding' : 0, 'char' : 0, 'cmd' : 0, 'other' : 0};\n    };\n\n    Cea608Parser.prototype = {\n        \n        getHandler : function(index) {\n            return this.channels[index].getHandler();\n        },\n        \n        setHandler : function(index, newHandler) {\n            this.channels[index].setHandler(newHandler);\n        },\n\n        /**\n         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n         */\n        addData : function(t, byteList) {\n            var cmdFound, a, b, \n            charsFound = false;\n            \n            this.lastTime = t;\n            logger.setTime(t);\n\n            for (var i = 0 ; i < byteList.length ; i+=2) {\n                a = byteList[i] & 0x7f;\n                b = byteList[i+1] & 0x7f;\n\n                if (a >= 0x10 && a <= 0x1f && a === this.lastCmdA && b === this.lastCmdB) {\n                    this.lastCmdA = null;\n                    this.lastCmdB = null;\n                    logger.log(\"DEBUG\", \"Repeated command (\" + numArrayToHexArray([a, b]) + \") is dropped\");\n                    continue; // Repeated commands are dropped (once)\n                }\n\n                if (a === 0 && b === 0) {\n                    this.dataCounters.padding += 2;\n                    continue;\n                } else {\n                    logger.log(\"DATA\", \"[\" + numArrayToHexArray([byteList[i], byteList[i+1]]) +\"] -> (\" + numArrayToHexArray([a, b]) + \")\");\n                }\n                cmdFound = this.parseCmd(a, b);\n                if (!cmdFound) {\n                    cmdFound = this.parseMidrow(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parsePAC(a, b);\n                }\n                if (!cmdFound) {\n                    cmdFound = this.parseBackgroundAttributes(a, b);\n                }\n                if (!cmdFound) {\n                    charsFound = this.parseChars(a, b);\n                    if (charsFound) {\n                        if (this.currChNr && this.currChNr >=0) {\n                            var channel = this.channels[this.currChNr-1];\n                            channel.insertChars(charsFound);\n                        } else {\n                            logger.log(\"WARNING\", \"No channel found yet. TEXT-MODE?\");\n                        }\n                    }\n                }\n                if (cmdFound) {\n                    this.dataCounters.cmd += 2;\n                } else if (charsFound) {\n                    this.dataCounters.char += 2;\n                } else {\n                    this.dataCounters.other += 2;\n                    logger.log(\"WARNING\", \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) +\n                                \" orig: \" + numArrayToHexArray([byteList[i], byteList[i+1]]));\n                }\n            }\n        },\n\n        /**\n         * Parse Command.\n         * @returns {Boolean} Tells if a command was found\n         */\n        parseCmd: function(a, b) {\n            var chNr = null;\n\n            var cond1 = (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) && (0x20 <= b && b <= 0x2F);\n            var cond2 = (a === 0x17 || a === 0x1F) && (0x21 <= b && b <= 0x23);\n            if (!(cond1 || cond2)) {\n                return false;\n            }\n                 \n            if (a === 0x14 || a === 0x15 || a === 0x17) {\n                chNr = 1;\n            } else {\n                chNr = 2; // (a === 0x1C || a === 0x1D || a=== 0x1f)\n            }\n\n            var channel = this.channels[chNr - 1];\n\n            if (a === 0x14 || a === 0x15 || a === 0x1C || a === 0x1D) {\n                if (b === 0x20) {\n                    channel.cc_RCL();\n                } else if (b === 0x21) {\n                    channel.cc_BS();\n                } else if (b === 0x22) {\n                    channel.cc_AOF();\n                } else if (b === 0x23) {\n                    channel.cc_AON();\n                } else if (b === 0x24) {\n                    channel.cc_DER();\n                } else if (b === 0x25) {\n                    channel.cc_RU(2);\n                } else if (b === 0x26) {\n                    channel.cc_RU(3);\n                } else if (b === 0x27) {\n                    channel.cc_RU(4);\n                } else if (b === 0x28) {\n                    channel.cc_FON();\n                } else if (b === 0x29) {\n                    channel.cc_RDC();\n                } else if (b === 0x2A) {\n                    channel.cc_TR();\n                } else if (b === 0x2B) {\n                    channel.cc_RTD();\n                } else if (b === 0x2C) {\n                    channel.cc_EDM();\n                } else if (b === 0x2D) {\n                    channel.cc_CR();\n                } else if (b === 0x2E) {\n                    channel.cc_ENM();\n                } else if (b === 0x2F) {\n                    channel.cc_EOC();\n                }\n            } else { //a == 0x17 || a == 0x1F\n                channel.cc_TO(b - 0x20);\n            }\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        },\n\n        /**\n         * Parse midrow styling command\n         * @returns {Boolean}\n         */\n        parseMidrow : function(a, b) {\n            var chNr = null;\n                \n            if ( ((a === 0x11) || (a === 0x19)) && 0x20 <= b && b <= 0x2f) {\n                if (a === 0x11) {\n                    chNr = 1;\n                } else  {\n                    chNr = 2;\n                }\n                if (chNr !== this.currChNr) {\n                    logger.log(\"ERROR\", \"Mismatch channel in midrow parsing\");\n                    return false;\n                }\n                var channel = this.channels[chNr-1];\n                // cea608 spec says midrow codes should inject a space\n                channel.insertChars([0x20]);\n                channel.cc_MIDROW(b);\n                logger.log(\"DEBUG\", \"MIDROW (\" + numArrayToHexArray([a, b]) + \")\");\n                this.lastCmdA = a;\n                this.lastCmdB = b;\n                return true;\n            }\n            return false;\n        },\n        /**\n         * Parse Preable Access Codes (Table 53).\n         * @returns {Boolean} Tells if PAC found\n         */\n        parsePAC : function(a, b) {\n\n           var chNr = null;\n           var row = null;\n            \n            var case1 = ((0x11 <= a  && a <= 0x17) || (0x19 <= a && a <= 0x1F)) && (0x40 <= b && b <= 0x7F);\n            var case2 = (a === 0x10 || a === 0x18) && (0x40 <= b && b <= 0x5F);\n            if (! (case1 || case2)) {\n                return false;\n            }\n\n            chNr = (a <= 0x17) ? 1 : 2;\n\n            if (0x40 <= b && b <= 0x5F) {\n                row = (chNr === 1) ? rowsLowCh1[a] : rowsLowCh2[a];\n            } else { // 0x60 <= b <= 0x7F\n                row = (chNr === 1) ? rowsHighCh1[a] : rowsHighCh2[a];\n            }\n            var pacData = this.interpretPAC(row, b);\n            var channel = this.channels[chNr-1];\n            channel.setPAC(pacData);\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            this.currChNr = chNr;\n            return true;\n        },\n\n        /**\n         * Interpret the second byte of the pac, and return the information.\n         * @returns {Object} pacData with style parameters.\n         */\n        interpretPAC : function (row, byte) {\n            var pacIndex = byte;\n            var pacData = {color : null, italics : false, indent : null, underline : false, row : row};\n            \n            if (byte > 0x5F) {\n                pacIndex = byte - 0x60;\n            } else {\n                pacIndex = byte - 0x40;\n            }\n            pacData.underline = (pacIndex & 1) === 1;\n            if (pacIndex <= 0xd) {\n                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex/2)];\n            } else if (pacIndex <= 0xf) {\n                pacData.italics = true;\n                pacData.color = 'white';\n            } else {\n                pacData.indent = (Math.floor((pacIndex-0x10)/2))*4;\n            }\n            return pacData; // Note that row has zero offset. The spec uses 1.\n        },\n\n        /**\n         * Parse characters.\n         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n         */\n        parseChars : function(a, b) {\n\n           var  channelNr = null,\n                charCodes = null,\n                charCode1 = null,\n                charCode2 = null;\n\n            if (a >= 0x19) {\n                channelNr = 2;\n                charCode1 = a - 8;\n            } else {\n                channelNr = 1;\n                charCode1 = a;\n            }\n            if (0x11 <= charCode1 && charCode1 <= 0x13) {\n                // Special character\n                var oneCode = b;\n                if (charCode1 === 0x11) {\n                    oneCode = b + 0x50;\n                } else if (charCode1 === 0x12) {\n                    oneCode = b + 0x70;\n                } else {\n                    oneCode = b + 0x90;\n                }\n                logger.log(\"INFO\", \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n                charCodes = [oneCode];\n                this.lastCmdA = a;\n                this.lastCmdB = b;\n            } else if (0x20 <= a && a <= 0x7f) {\n                charCodes = (b === 0) ? [a] : [a, b];\n                this.lastCmdA = null;\n                this.lastCmdB = null;\n            }\n            if (charCodes) {\n                var hexCodes = numArrayToHexArray(charCodes);\n                logger.log(\"DEBUG\", \"Char codes =  \" + hexCodes.join(\",\"));\n            }\n            return charCodes;\n        },\n        \n        /**\n        * Parse extended background attributes as well as new foreground color black.\n        * @returns{Boolean} Tells if background attributes are found\n        */\n        parseBackgroundAttributes : function(a, b) {\n           var  bkgData,\n                index,\n                chNr,\n                channel;\n\n            var case1 = (a === 0x10 || a === 0x18) && (0x20 <= b && b <= 0x2f);\n            var case2 = (a === 0x17 || a === 0x1f) && (0x2d <=b && b <= 0x2f);\n            if (!(case1 || case2)) {\n                return false;\n            }\n            bkgData = {};\n            if (a  === 0x10 || a === 0x18) {\n                index = Math.floor((b-0x20)/2);\n                bkgData.background = backgroundColors[index];\n                if (b % 2 === 1) {\n                    bkgData.background = bkgData.background + \"_semi\";\n                }\n            } else if (b === 0x2d) {\n                bkgData.background = \"transparent\";\n            } else {\n                bkgData.foreground = \"black\";\n                if (b === 0x2f) {\n                    bkgData.underline = true;\n                }\n            }\n            chNr = (a < 0x18) ? 1 : 2;\n            channel = this.channels[chNr-1];\n            channel.setBkgData(bkgData);\n            this.lastCmdA = a;\n            this.lastCmdB = b;\n            return true;\n        },\n\n        /**\n         * Reset state of parser and its channels.\n         */\n        reset : function() {\n            for (var i=0 ; i < this.channels.length ; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].reset();\n                }\n            }\n            this.lastCmdA = null;\n            this.lastCmdB = null;\n        },\n\n        /**\n         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n         */\n        cueSplitAtTime : function(t) {\n            for (var i=0 ; i < this.channels.length ; i++) {\n                if (this.channels[i]) {\n                    this.channels[i].cueSplitAtTime(t);\n                }\n            }\n        },\n    };\n\n    /**\n     * Find ranges corresponding to SEA CEA-608 NALUS in sizeprepended NALU array.\n     * @param {raw} dataView of binary data\n     * @param {startPos} start position in raw\n     * @param {size} total size of data in raw to consider\n     * @returns \n     */\n    var findCea608Nalus = function(raw, startPos, size) {\n        var nalSize = 0,\n            cursor = startPos,\n            nalType = 0,\n            cea608NaluRanges = [],\n            // Check SEI data according to ANSI-SCTE 128\n            isCEA608SEI = function (payloadType, payloadSize, raw, pos) {\n                if (payloadType !== 4 || payloadSize < 8) {\n                    return null;\n                }\n                var countryCode = raw.getUint8(pos);\n                var providerCode = raw.getUint16(pos + 1);\n                var userIdentifier = raw.getUint32(pos + 3);\n                var userDataTypeCode = raw.getUint8(pos + 7);\n                return countryCode == 0xB5 && providerCode == 0x31 && userIdentifier == 0x47413934 && userDataTypeCode == 0x3;\n            };\n        while (cursor < startPos + size) {\n            nalSize = raw.getUint32(cursor);\n            nalType = raw.getUint8(cursor + 4) & 0x1F;\n            //console.log(time + \"  NAL \" + nalType);\n            if (nalType === 6) {\n                // SEI NAL Unit. The NAL header is the first byte\n                //console.log(\"SEI NALU of size \" + nalSize + \" at time \" + time);\n                var pos = cursor + 5;\n                var payloadType = -1;\n                while (pos < cursor + 4 + nalSize - 1) { // The last byte should be rbsp_trailing_bits\n                    payloadType = 0;\n                    var b = 0xFF;\n                    while (b === 0xFF) {\n                        b = raw.getUint8(pos);\n                        payloadType += b;\n                        pos++;\n                    }\n                    var payloadSize = 0;\n                    b = 0xFF;\n                    while (b === 0xFF) {\n                        b = raw.getUint8(pos);\n                        payloadSize += b;\n                        pos++;\n                    }\n                    if (isCEA608SEI(payloadType, payloadSize, raw, pos)) {\n                        //console.log(\"CEA608 SEI \" + time + \" \" + payloadSize);\n                        cea608NaluRanges.push([pos, payloadSize]);\n                    }\n                    pos += payloadSize;\n                }\n            }\n            cursor += nalSize + 4;\n        }\n        return cea608NaluRanges;\n    };\n    \n    var extractCea608DataFromRange = function(raw, cea608Range) {\n        var pos = cea608Range[0];\n        var fieldData = [[], []];\n\n        pos += 8; // Skip the identifier up to userDataTypeCode\n        var ccCount = raw.getUint8(pos) & 0x1f;\n        pos += 2; // Advance 1 and skip reserved byte\n          \n        for (var i = 0; i < ccCount; i++) {\n            var byte = raw.getUint8(pos);\n            var ccValid = byte & 0x4;\n            var ccType = byte & 0x3;\n            pos++;\n            var ccData1 = raw.getUint8(pos); // Keep parity bit\n            pos++;\n            var ccData2 = raw.getUint8(pos); // Keep parity bit\n            pos++;\n            if (ccValid && ((ccData1 & 0x7f) + (ccData2 & 0x7f) !== 0)) { //Check validity and non-empty data\n                if (ccType === 0) {\n                    fieldData[0].push(ccData1);\n                    fieldData[0].push(ccData2);\n                } else if (ccType === 1) {\n                    fieldData[1].push(ccData1);\n                    fieldData[1].push(ccData2);\n                }\n            }\n        }\n        return fieldData;\n    };\n\n    exports.logger = logger;\n    exports.PenState = PenState;\n    exports.CaptionScreen = CaptionScreen;  \n    exports.Cea608Parser = Cea608Parser;\n    exports.findCea608Nalus = findCea608Nalus;\n    exports.extractCea608DataFromRange = extractCea608DataFromRange;\n\n}(typeof exports === 'undefined' ? this.cea608parser = {} : exports));\n"]},"metadata":{},"sourceType":"script"}