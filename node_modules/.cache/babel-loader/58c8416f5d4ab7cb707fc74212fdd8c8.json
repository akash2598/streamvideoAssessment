{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _InitCache = require('../utils/InitCache');\n\nvar _InitCache2 = _interopRequireDefault(_InitCache);\n\nvar _SourceBufferSink = require('../SourceBufferSink');\n\nvar _SourceBufferSink2 = _interopRequireDefault(_SourceBufferSink);\n\nvar _TextController = require('../../streaming/text/TextController');\n\nvar _TextController2 = _interopRequireDefault(_TextController);\n\nvar _DashJSError = require('../../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Errors = require('../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController';\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\nfunction NotFragmentedTextBufferController(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var textController = (0, _TextController2.default)(context).getInstance();\n  var errHandler = config.errHandler;\n  var streamInfo = config.streamInfo;\n  var type = config.type;\n  var mimeType = config.mimeType;\n  var fragmentModel = config.fragmentModel;\n  var instance = void 0,\n      isBufferingCompleted = void 0,\n      initialized = void 0,\n      mediaSource = void 0,\n      buffer = void 0,\n      initCache = void 0;\n\n  function setup() {\n    initialized = false;\n    mediaSource = null;\n    isBufferingCompleted = false;\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.on(_Events2.default.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n  }\n\n  function getBufferControllerType() {\n    return BUFFER_CONTROLLER_TYPE;\n  }\n\n  function initialize(source) {\n    setMediaSource(source);\n    initCache = (0, _InitCache2.default)(context).getInstance();\n  }\n\n  function createBuffer(mediaInfoArr) {\n    var mediaInfo = mediaInfoArr[0];\n\n    try {\n      buffer = (0, _SourceBufferSink2.default)(context).create(mediaSource, mediaInfo);\n\n      if (!initialized) {\n        var textBuffer = buffer.getBuffer();\n\n        if (textBuffer.hasOwnProperty(_Constants2.default.INITIALIZE)) {\n          textBuffer.initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n        }\n\n        initialized = true;\n      }\n\n      return buffer;\n    } catch (e) {\n      if (mediaInfo && (mediaInfo.isText || mediaInfo.codec.indexOf('codecs=\"stpp') !== -1 || mediaInfo.codec.indexOf('codecs=\"wvtt') !== -1)) {\n        try {\n          buffer = textController.getTextSourceBuffer();\n        } catch (e) {\n          errHandler.error(new _DashJSError2.default(_Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, _Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type + ' : ' + e.message));\n        }\n      } else {\n        errHandler.error(new _DashJSError2.default(_Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, _Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type));\n      }\n    }\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function getBuffer() {\n    return buffer;\n  }\n\n  function setMediaSource(value) {\n    mediaSource = value;\n  }\n\n  function getMediaSource() {\n    return mediaSource;\n  }\n\n  function getIsPruningInProgress() {\n    return false;\n  }\n\n  function dischargePreBuffer() {}\n\n  function getBufferLevel() {\n    return 0;\n  }\n\n  function getIsBufferingCompleted() {\n    return isBufferingCompleted;\n  }\n\n  function reset(errored) {\n    eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.off(_Events2.default.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n\n    if (!errored && buffer) {\n      buffer.abort();\n      buffer.reset();\n      buffer = null;\n    }\n  }\n\n  function onDataUpdateCompleted(e) {\n    if (initCache.extract(streamInfo.id, e.currentRepresentation.id) !== null) {\n      return;\n    } // Representation has changed, clear buffer\n\n\n    isBufferingCompleted = false; // // Text data file is contained in initialization segment\n\n    eventBus.trigger(_Events2.default.INIT_FRAGMENT_NEEDED, {\n      representationId: e.currentRepresentation.id,\n      sender: instance\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function appendInitSegment(representationId) {\n    // If text data file already in cache then no need to append it again\n    return initCache.extract(streamInfo.id, representationId) !== null;\n  }\n\n  function onInitFragmentLoaded(e) {\n    if (!e.chunk.bytes) return;\n    initCache.save(e.chunk);\n    buffer.append(e.chunk);\n    isBufferingCompleted = true;\n    eventBus.trigger(_Events2.default.STREAM_COMPLETED, {\n      request: e.request\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function getRangeAt() {\n    return null;\n  }\n\n  function updateTimestampOffset(MSETimeOffset) {\n    if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n      buffer.timestampOffset = MSETimeOffset;\n    }\n  }\n\n  instance = {\n    getBufferControllerType: getBufferControllerType,\n    initialize: initialize,\n    createBuffer: createBuffer,\n    getStreamId: getStreamId,\n    getType: getType,\n    getBuffer: getBuffer,\n    getBufferLevel: getBufferLevel,\n    setMediaSource: setMediaSource,\n    getMediaSource: getMediaSource,\n    getIsBufferingCompleted: getIsBufferingCompleted,\n    getIsPruningInProgress: getIsPruningInProgress,\n    dischargePreBuffer: dischargePreBuffer,\n    appendInitSegment: appendInitSegment,\n    getRangeAt: getRangeAt,\n    reset: reset,\n    updateTimestampOffset: updateTimestampOffset\n  };\n  setup();\n  return instance;\n}\n\nNotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE;\nexports.default = _FactoryMaker2.default.getClassFactory(NotFragmentedTextBufferController);","map":{"version":3,"sources":["../../../../../src/streaming/text/NotFragmentedTextBufferController.js"],"names":["BUFFER_CONTROLLER_TYPE","config","context","eventBus","textController","errHandler","streamInfo","type","mimeType","fragmentModel","instance","isBufferingCompleted","initialized","mediaSource","buffer","initCache","Events","setMediaSource","mediaInfo","mediaInfoArr","textBuffer","Constants","DashJSError","Errors","e","representationId","sender","streamId","mediaType","request","isNaN","getBufferControllerType","initialize","createBuffer","getStreamId","getType","getBuffer","getBufferLevel","getMediaSource","getIsBufferingCompleted","getIsPruningInProgress","dischargePreBuffer","appendInitSegment","getRangeAt","reset","updateTimestampOffset","setup","NotFragmentedTextBufferController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport InitCache from '../utils/InitCache';\nimport SourceBufferSink from '../SourceBufferSink';\nimport TextController from '../../streaming/text/TextController';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nconst BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController';\nfunction NotFragmentedTextBufferController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const textController = TextController(context).getInstance();\n\n    const errHandler = config.errHandler;\n    const streamInfo = config.streamInfo;\n    const type = config.type;\n    const mimeType = config.mimeType;\n    const fragmentModel = config.fragmentModel;\n\n    let instance,\n        isBufferingCompleted,\n        initialized,\n        mediaSource,\n        buffer,\n        initCache;\n\n    function setup() {\n        initialized = false;\n        mediaSource = null;\n        isBufferingCompleted = false;\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n    }\n\n    function getBufferControllerType() {\n        return BUFFER_CONTROLLER_TYPE;\n    }\n\n    function initialize(source) {\n        setMediaSource(source);\n        initCache = InitCache(context).getInstance();\n    }\n\n    function createBuffer(mediaInfoArr) {\n        const mediaInfo = mediaInfoArr[0];\n        try {\n            buffer = SourceBufferSink(context).create(mediaSource, mediaInfo);\n            if (!initialized) {\n                const textBuffer = buffer.getBuffer();\n                if (textBuffer.hasOwnProperty(Constants.INITIALIZE)) {\n                    textBuffer.initialize(mimeType, streamInfo, mediaInfoArr, fragmentModel);\n                }\n                initialized = true;\n            }\n            return buffer;\n        } catch (e) {\n            if (mediaInfo && ((mediaInfo.isText) || (mediaInfo.codec.indexOf('codecs=\"stpp') !== -1) || (mediaInfo.codec.indexOf('codecs=\"wvtt') !== -1))) {\n                try {\n                    buffer = textController.getTextSourceBuffer();\n                } catch (e) {\n                    errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type + ' : ' + e.message));\n                }\n            } else {\n                errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type));\n            }\n        }\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function setMediaSource(value) {\n        mediaSource = value;\n    }\n\n    function getMediaSource() {\n        return mediaSource;\n    }\n\n    function getIsPruningInProgress() {\n        return false;\n    }\n\n    function dischargePreBuffer() {\n    }\n\n    function getBufferLevel() {\n        return 0;\n    }\n\n    function getIsBufferingCompleted() {\n        return isBufferingCompleted;\n    }\n\n    function reset(errored) {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n\n        if (!errored && buffer) {\n            buffer.abort();\n            buffer.reset();\n            buffer = null;\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (initCache.extract(streamInfo.id, e.currentRepresentation.id) !== null) {\n            return;\n        }\n\n        // Representation has changed, clear buffer\n        isBufferingCompleted = false;\n\n        // // Text data file is contained in initialization segment\n        eventBus.trigger(Events.INIT_FRAGMENT_NEEDED,\n            { representationId: e.currentRepresentation.id, sender: instance },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function appendInitSegment(representationId) {\n        // If text data file already in cache then no need to append it again\n        return initCache.extract(streamInfo.id, representationId) !== null;\n    }\n\n    function onInitFragmentLoaded(e) {\n        if (!e.chunk.bytes) return;\n\n        initCache.save(e.chunk);\n        buffer.append(e.chunk);\n\n        isBufferingCompleted = true;\n\n        eventBus.trigger(Events.STREAM_COMPLETED,\n            { request: e.request },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function getRangeAt() {\n        return null;\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            buffer.timestampOffset = MSETimeOffset;\n        }\n    }\n\n    instance = {\n        getBufferControllerType: getBufferControllerType,\n        initialize: initialize,\n        createBuffer: createBuffer,\n        getStreamId: getStreamId,\n        getType: getType,\n        getBuffer: getBuffer,\n        getBufferLevel: getBufferLevel,\n        setMediaSource: setMediaSource,\n        getMediaSource: getMediaSource,\n        getIsBufferingCompleted: getIsBufferingCompleted,\n        getIsPruningInProgress: getIsPruningInProgress,\n        dischargePreBuffer: dischargePreBuffer,\n        appendInitSegment: appendInitSegment,\n        getRangeAt: getRangeAt,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset\n    };\n\n    setup();\n\n    return instance;\n}\n\nNotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE;\nexport default FactoryMaker.getClassFactory(NotFragmentedTextBufferController);\n"]},"metadata":{},"sourceType":"script"}