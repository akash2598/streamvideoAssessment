{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FragmentRequest = require('../streaming/vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _HTTPRequest = require('../streaming/vo/metrics/HTTPRequest');\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _SegmentsUtils = require('./utils/SegmentsUtils');\n\nvar _SegmentsController = require('./controllers/SegmentsController');\n\nvar _SegmentsController2 = _interopRequireDefault(_SegmentsController);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction DashHandler(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var debug = config.debug;\n  var dashConstants = config.dashConstants;\n  var urlUtils = config.urlUtils;\n  var type = config.type;\n  var streamInfo = config.streamInfo;\n  var timelineConverter = config.timelineConverter;\n  var dashMetrics = config.dashMetrics;\n  var baseURLController = config.baseURLController;\n  var instance = void 0,\n      logger = void 0,\n      segmentIndex = void 0,\n      lastSegment = void 0,\n      requestedTime = void 0,\n      isDynamicManifest = void 0,\n      dynamicStreamCompleted = void 0,\n      selectedMimeType = void 0,\n      segmentsController = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n    segmentsController = (0, _SegmentsController2.default)(context).create(config);\n    eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n    eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n    eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n    eventBus.on(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n  }\n\n  function initialize(isDynamic) {\n    isDynamicManifest = isDynamic;\n    dynamicStreamCompleted = false;\n    segmentsController.initialize(isDynamic);\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function getStreamInfo() {\n    return streamInfo;\n  }\n\n  function setCurrentIndex(value) {\n    segmentIndex = value;\n  }\n\n  function getCurrentIndex() {\n    return segmentIndex;\n  }\n\n  function resetIndex() {\n    segmentIndex = -1;\n    lastSegment = null;\n  }\n\n  function resetInitialSettings() {\n    resetIndex();\n    requestedTime = null;\n    segmentsController = null;\n    selectedMimeType = null;\n  }\n\n  function reset() {\n    resetInitialSettings();\n    eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n    eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n    eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n    eventBus.off(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n  }\n\n  function setRequestUrl(request, destination, representation) {\n    var baseURL = baseURLController.resolve(representation.path);\n    var url = void 0,\n        serviceLocation = void 0;\n\n    if (!baseURL || destination === baseURL.url || !urlUtils.isRelative(destination)) {\n      url = destination;\n    } else {\n      url = baseURL.url;\n      serviceLocation = baseURL.serviceLocation;\n\n      if (destination) {\n        url = urlUtils.resolve(destination, url);\n      }\n    }\n\n    if (urlUtils.isRelative(url)) {\n      return false;\n    }\n\n    request.url = url;\n    request.serviceLocation = serviceLocation;\n    return true;\n  }\n\n  function generateInitRequest(mediaInfo, representation, mediaType) {\n    var request = new _FragmentRequest2.default();\n    var period = representation.adaptation.period;\n    var presentationStartTime = period.start;\n    request.mediaType = mediaType;\n    request.type = _HTTPRequest.HTTPRequest.INIT_SEGMENT_TYPE;\n    request.range = representation.range;\n    request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\n    request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\n    request.quality = representation.index;\n    request.mediaInfo = mediaInfo;\n    request.representationId = representation.id;\n\n    if (setRequestUrl(request, representation.initialization, representation)) {\n      request.url = (0, _SegmentsUtils.replaceTokenForTemplate)(request.url, 'Bandwidth', representation.bandwidth);\n      return request;\n    }\n  }\n\n  function getInitRequest(mediaInfo, representation) {\n    if (!representation) return null;\n    var request = generateInitRequest(mediaInfo, representation, getType());\n    return request;\n  }\n\n  function setMimeType(newMimeType) {\n    selectedMimeType = newMimeType;\n  }\n\n  function setExpectedLiveEdge(liveEdge) {\n    timelineConverter.setExpectedLiveEdge(liveEdge);\n    dashMetrics.updateManifestUpdateInfo({\n      presentationStartTime: liveEdge\n    });\n  }\n\n  function onRepresentationUpdateStarted(e) {\n    processRepresentation(e.representation);\n  }\n\n  function processRepresentation(voRepresentation) {\n    var hasInitialization = voRepresentation.hasInitialization();\n    var hasSegments = voRepresentation.hasSegments(); // If representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\n    // otherwise, it means that a request has to be made to get initialization and/or segments informations\n\n    if (hasInitialization && hasSegments) {\n      eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {\n        representation: voRepresentation\n      }, {\n        streamId: streamInfo.id,\n        mediaType: type\n      });\n    } else {\n      segmentsController.update(voRepresentation, selectedMimeType, hasInitialization, hasSegments);\n    }\n  }\n\n  function getRequestForSegment(mediaInfo, segment) {\n    if (segment === null || segment === undefined) {\n      return null;\n    }\n\n    var request = new _FragmentRequest2.default();\n    var representation = segment.representation;\n    var bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\n    var url = segment.media;\n    url = (0, _SegmentsUtils.replaceTokenForTemplate)(url, 'Number', segment.replacementNumber);\n    url = (0, _SegmentsUtils.replaceTokenForTemplate)(url, 'Time', segment.replacementTime);\n    url = (0, _SegmentsUtils.replaceTokenForTemplate)(url, 'Bandwidth', bandwidth);\n    url = (0, _SegmentsUtils.replaceIDForTemplate)(url, representation.id);\n    url = (0, _SegmentsUtils.unescapeDollarsInTemplate)(url);\n    request.mediaType = getType();\n    request.type = _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE;\n    request.range = segment.mediaRange;\n    request.startTime = segment.presentationStartTime;\n    request.mediaStartTime = segment.mediaStartTime;\n    request.duration = segment.duration;\n    request.timescale = representation.timescale;\n    request.availabilityStartTime = segment.availabilityStartTime;\n    request.availabilityEndTime = segment.availabilityEndTime;\n    request.wallStartTime = segment.wallStartTime;\n    request.quality = representation.index;\n    request.index = segment.availabilityIdx;\n    request.mediaInfo = mediaInfo;\n    request.adaptationIndex = representation.adaptation.index;\n    request.representationId = representation.id;\n\n    if (setRequestUrl(request, url, representation)) {\n      return request;\n    }\n  }\n\n  function isMediaFinished(representation) {\n    var isFinished = false;\n    if (!representation) return isFinished;\n\n    if (!isDynamicManifest) {\n      if (segmentIndex >= representation.availableSegmentsNumber) {\n        isFinished = true;\n      }\n    } else {\n      if (dynamicStreamCompleted) {\n        isFinished = true;\n      } else if (lastSegment) {\n        var time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\n        var endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\n        var duration = representation.adaptation.period.duration;\n        isFinished = endTime >= duration;\n      }\n    }\n\n    return isFinished;\n  }\n\n  function getSegmentRequestForTime(mediaInfo, representation, time, options) {\n    var request = null;\n\n    if (!representation || !representation.segmentInfoType) {\n      return request;\n    }\n\n    var idx = segmentIndex;\n    var keepIdx = options ? options.keepIdx : false;\n    var ignoreIsFinished = options && options.ignoreIsFinished ? true : false;\n\n    if (requestedTime !== time) {\n      // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\n      requestedTime = time;\n      logger.debug('Getting the request for time : ' + time);\n    }\n\n    var segment = segmentsController.getSegmentByTime(representation, time);\n\n    if (segment) {\n      segmentIndex = segment.availabilityIdx;\n      lastSegment = segment;\n      logger.debug('Index for time ' + time + ' is ' + segmentIndex);\n      request = getRequestForSegment(mediaInfo, segment);\n    } else {\n      var finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\n\n      if (finished) {\n        request = new _FragmentRequest2.default();\n        request.action = _FragmentRequest2.default.ACTION_COMPLETE;\n        request.index = segmentIndex - 1;\n        request.mediaType = type;\n        request.mediaInfo = mediaInfo;\n        logger.debug('Signal complete in getSegmentRequestForTime');\n      }\n    }\n\n    if (keepIdx && idx >= 0) {\n      segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\n    }\n\n    return request;\n  }\n  /**\n  * This function returns the next segment request without modifying any internal variables. Any class (e.g CMCD Model) that needs information about the upcoming request should use this method.\n  * @param {object} mediaInfo\n  * @param {object} representation\n  * @return {FragmentRequest|null}\n  */\n\n\n  function getNextSegmentRequestIdempotent(mediaInfo, representation) {\n    var request = null;\n    var indexToRequest = segmentIndex + 1;\n    var segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n    if (!segment) return null;\n    request = getRequestForSegment(mediaInfo, segment);\n    return request;\n  }\n  /**\n  * Main function to get the next segment request.\n  * @param {object} mediaInfo\n  * @param {object} representation\n  * @return {FragmentRequest|null}\n  */\n\n\n  function getNextSegmentRequest(mediaInfo, representation) {\n    var request = null;\n\n    if (!representation || !representation.segmentInfoType) {\n      return null;\n    }\n\n    requestedTime = null;\n    var indexToRequest = segmentIndex + 1;\n    logger.debug('Getting the next request at index: ' + indexToRequest); // check that there is a segment in this index\n\n    var segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n\n    if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\n      logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\n      return null;\n    } else {\n      if (segment) {\n        request = getRequestForSegment(mediaInfo, segment);\n        segmentIndex = segment.availabilityIdx;\n      } else {\n        if (isDynamicManifest) {\n          segmentIndex = indexToRequest - 1;\n        } else {\n          segmentIndex = indexToRequest;\n        }\n      }\n    }\n\n    if (segment) {\n      lastSegment = segment;\n    } else {\n      var finished = isMediaFinished(representation, segment);\n\n      if (finished) {\n        request = new _FragmentRequest2.default();\n        request.action = _FragmentRequest2.default.ACTION_COMPLETE;\n        request.index = segmentIndex - 1;\n        request.mediaType = getType();\n        request.mediaInfo = mediaInfo;\n        logger.debug('Signal complete');\n      }\n    }\n\n    return request;\n  }\n\n  function isEndlessMedia(representation) {\n    return !isFinite(representation.adaptation.period.duration);\n  }\n\n  function onInitializationLoaded(e) {\n    var representation = e.representation;\n    if (!representation.segments) return;\n    eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {\n      representation: representation\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onSegmentsLoaded(e) {\n    if (e.error) return;\n    var fragments = e.segments;\n    var representation = e.representation;\n    var segments = [];\n    var count = 0;\n    var i = void 0,\n        len = void 0,\n        s = void 0,\n        seg = void 0;\n\n    for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\n      s = fragments[i];\n      seg = (0, _SegmentsUtils.getTimeBasedSegment)(timelineConverter, isDynamicManifest, representation, s.startTime, s.duration, s.timescale, s.media, s.mediaRange, count);\n\n      if (seg) {\n        segments.push(seg);\n        seg = null;\n        count++;\n      }\n    }\n\n    if (segments.length > 0) {\n      representation.segmentAvailabilityRange = {\n        start: segments[0].presentationStartTime,\n        end: segments[segments.length - 1].presentationStartTime\n      };\n      representation.availableSegmentsNumber = segments.length;\n      representation.segments = segments;\n\n      if (isDynamicManifest) {\n        var _lastSegment = segments[segments.length - 1];\n        var liveEdge = _lastSegment.presentationStartTime - 8; // the last segment is the Expected, not calculated, live edge.\n\n        setExpectedLiveEdge(liveEdge);\n      }\n    }\n\n    if (!representation.hasInitialization()) {\n      return;\n    }\n\n    eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, {\n      representation: representation\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onDynamicToStatic() {\n    logger.debug('Dynamic stream complete');\n    dynamicStreamCompleted = true;\n  }\n\n  instance = {\n    initialize: initialize,\n    getStreamId: getStreamId,\n    getType: getType,\n    getStreamInfo: getStreamInfo,\n    getInitRequest: getInitRequest,\n    getRequestForSegment: getRequestForSegment,\n    getSegmentRequestForTime: getSegmentRequestForTime,\n    getNextSegmentRequest: getNextSegmentRequest,\n    setCurrentIndex: setCurrentIndex,\n    getCurrentIndex: getCurrentIndex,\n    isMediaFinished: isMediaFinished,\n    reset: reset,\n    resetIndex: resetIndex,\n    setMimeType: setMimeType,\n    getNextSegmentRequestIdempotent: getNextSegmentRequestIdempotent\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nDashHandler.__dashjs_factory_name = 'DashHandler';\nexports.default = _FactoryMaker2.default.getClassFactory(DashHandler);","map":{"version":3,"sources":["../../../../src/dash/DashHandler.js"],"names":["config","context","eventBus","events","debug","dashConstants","urlUtils","type","streamInfo","timelineConverter","dashMetrics","baseURLController","instance","logger","segmentIndex","lastSegment","requestedTime","isDynamicManifest","dynamicStreamCompleted","selectedMimeType","segmentsController","resetInitialSettings","resetIndex","baseURL","representation","url","serviceLocation","destination","request","FragmentRequest","period","presentationStartTime","HTTPRequest","setRequestUrl","generateInitRequest","getType","processRepresentation","e","hasInitialization","voRepresentation","hasSegments","streamId","mediaType","segment","bandwidth","isFinished","time","parseFloat","endTime","duration","idx","keepIdx","options","ignoreIsFinished","getRequestForSegment","finished","isMediaFinished","indexToRequest","isEndlessMedia","isFinite","fragments","segments","count","i","len","s","seg","start","end","liveEdge","setExpectedLiveEdge","initialize","getStreamId","getStreamInfo","getInitRequest","getSegmentRequestForTime","getNextSegmentRequest","setCurrentIndex","getCurrentIndex","reset","setMimeType","getNextSegmentRequestIdempotent","setup","DashHandler","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest';\nimport FactoryMaker from '../core/FactoryMaker';\nimport {\n    replaceIDForTemplate,\n    unescapeDollarsInTemplate,\n    replaceTokenForTemplate,\n    getTimeBasedSegment\n} from './utils/SegmentsUtils';\n\nimport SegmentsController from './controllers/SegmentsController';\n\nfunction DashHandler(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const debug = config.debug;\n    const dashConstants = config.dashConstants;\n    const urlUtils = config.urlUtils;\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const baseURLController = config.baseURLController;\n\n    let instance,\n        logger,\n        segmentIndex,\n        lastSegment,\n        requestedTime,\n        isDynamicManifest,\n        dynamicStreamCompleted,\n        selectedMimeType,\n        segmentsController;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n\n        segmentsController = SegmentsController(context).create(config);\n\n        eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.on(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n    }\n\n    function initialize(isDynamic) {\n        isDynamicManifest = isDynamic;\n        dynamicStreamCompleted = false;\n        segmentsController.initialize(isDynamic);\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function setCurrentIndex(value) {\n        segmentIndex = value;\n    }\n\n    function getCurrentIndex() {\n        return segmentIndex;\n    }\n\n    function resetIndex() {\n        segmentIndex = -1;\n        lastSegment = null;\n    }\n\n    function resetInitialSettings() {\n        resetIndex();\n        requestedTime = null;\n        segmentsController = null;\n        selectedMimeType = null;\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.off(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n    }\n\n    function setRequestUrl(request, destination, representation) {\n        const baseURL = baseURLController.resolve(representation.path);\n        let url,\n            serviceLocation;\n\n        if (!baseURL || (destination === baseURL.url) || (!urlUtils.isRelative(destination))) {\n            url = destination;\n        } else {\n            url = baseURL.url;\n            serviceLocation = baseURL.serviceLocation;\n\n            if (destination) {\n                url = urlUtils.resolve(destination, url);\n            }\n        }\n\n        if (urlUtils.isRelative(url)) {\n            return false;\n        }\n\n        request.url = url;\n        request.serviceLocation = serviceLocation;\n\n        return true;\n    }\n\n    function generateInitRequest(mediaInfo, representation, mediaType) {\n        const request = new FragmentRequest();\n        const period = representation.adaptation.period;\n        const presentationStartTime = period.start;\n\n        request.mediaType = mediaType;\n        request.type = HTTPRequest.INIT_SEGMENT_TYPE;\n        request.range = representation.range;\n        request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\n        request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\n        request.quality = representation.index;\n        request.mediaInfo = mediaInfo;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, representation.initialization, representation)) {\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', representation.bandwidth);\n            return request;\n        }\n    }\n\n    function getInitRequest(mediaInfo, representation) {\n        if (!representation) return null;\n        const request = generateInitRequest(mediaInfo, representation, getType());\n        return request;\n    }\n\n    function setMimeType(newMimeType) {\n        selectedMimeType = newMimeType;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function onRepresentationUpdateStarted(e) {\n        processRepresentation(e.representation);\n    }\n\n    function processRepresentation(voRepresentation) {\n        const hasInitialization = voRepresentation.hasInitialization();\n        const hasSegments = voRepresentation.hasSegments();\n\n        // If representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\n        // otherwise, it means that a request has to be made to get initialization and/or segments informations\n        if (hasInitialization && hasSegments) {\n            eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n                { representation: voRepresentation },\n                { streamId: streamInfo.id, mediaType: type }\n            );\n        } else {\n            segmentsController.update(voRepresentation, selectedMimeType, hasInitialization, hasSegments);\n        }\n    }\n\n    function getRequestForSegment(mediaInfo, segment) {\n        if (segment === null || segment === undefined) {\n            return null;\n        }\n\n        const request = new FragmentRequest();\n        const representation = segment.representation;\n        const bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\n        let url = segment.media;\n\n        url = replaceTokenForTemplate(url, 'Number', segment.replacementNumber);\n        url = replaceTokenForTemplate(url, 'Time', segment.replacementTime);\n        url = replaceTokenForTemplate(url, 'Bandwidth', bandwidth);\n        url = replaceIDForTemplate(url, representation.id);\n        url = unescapeDollarsInTemplate(url);\n\n        request.mediaType = getType();\n        request.type = HTTPRequest.MEDIA_SEGMENT_TYPE;\n        request.range = segment.mediaRange;\n        request.startTime = segment.presentationStartTime;\n        request.mediaStartTime = segment.mediaStartTime;\n        request.duration = segment.duration;\n        request.timescale = representation.timescale;\n        request.availabilityStartTime = segment.availabilityStartTime;\n        request.availabilityEndTime = segment.availabilityEndTime;\n        request.wallStartTime = segment.wallStartTime;\n        request.quality = representation.index;\n        request.index = segment.availabilityIdx;\n        request.mediaInfo = mediaInfo;\n        request.adaptationIndex = representation.adaptation.index;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, url, representation)) {\n            return request;\n        }\n    }\n\n    function isMediaFinished(representation) {\n        let isFinished = false;\n\n        if (!representation) return isFinished;\n\n        if (!isDynamicManifest) {\n            if (segmentIndex >= representation.availableSegmentsNumber) {\n                isFinished = true;\n            }\n        } else {\n            if (dynamicStreamCompleted) {\n                isFinished = true;\n            } else if (lastSegment) {\n                const time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\n                const endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\n                const duration = representation.adaptation.period.duration;\n\n                isFinished = endTime >= duration;\n            }\n        }\n        return isFinished;\n    }\n\n    function getSegmentRequestForTime(mediaInfo, representation, time, options) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return request;\n        }\n\n        const idx = segmentIndex;\n        const keepIdx = options ? options.keepIdx : false;\n        const ignoreIsFinished = (options && options.ignoreIsFinished) ? true : false;\n\n        if (requestedTime !== time) { // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\n            requestedTime = time;\n            logger.debug('Getting the request for time : ' + time);\n        }\n\n        const segment = segmentsController.getSegmentByTime(representation, time);\n        if (segment) {\n            segmentIndex = segment.availabilityIdx;\n            lastSegment = segment;\n            logger.debug('Index for time ' + time + ' is ' + segmentIndex);\n            request = getRequestForSegment(mediaInfo, segment);\n        } else {\n            const finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = type;\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete in getSegmentRequestForTime');\n            }\n        }\n\n        if (keepIdx && idx >= 0) {\n            segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\n        }\n\n        return request;\n    }\n\n    /**\n     * This function returns the next segment request without modifying any internal variables. Any class (e.g CMCD Model) that needs information about the upcoming request should use this method.\n     * @param {object} mediaInfo\n     * @param {object} representation\n     * @return {FragmentRequest|null}\n     */\n    function getNextSegmentRequestIdempotent(mediaInfo, representation) {\n        let request = null;\n        let indexToRequest = segmentIndex + 1;\n        const segment = segmentsController.getSegmentByIndex(\n            representation,\n            indexToRequest,\n            lastSegment ? lastSegment.mediaStartTime : -1\n        );\n        if (!segment) return null;\n        request = getRequestForSegment(mediaInfo, segment);\n        return request;\n    }\n\n    /**\n     * Main function to get the next segment request.\n     * @param {object} mediaInfo\n     * @param {object} representation\n     * @return {FragmentRequest|null}\n     */\n    function getNextSegmentRequest(mediaInfo, representation) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return null;\n        }\n\n        requestedTime = null;\n\n        let indexToRequest = segmentIndex + 1;\n\n        logger.debug('Getting the next request at index: ' + indexToRequest);\n        // check that there is a segment in this index\n        const segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n        if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\n            logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\n            return null;\n        } else {\n            if (segment) {\n                request = getRequestForSegment(mediaInfo, segment);\n                segmentIndex = segment.availabilityIdx;\n            } else {\n                if (isDynamicManifest) {\n                    segmentIndex = indexToRequest - 1;\n                } else {\n                    segmentIndex = indexToRequest;\n                }\n            }\n        }\n\n        if (segment) {\n            lastSegment = segment;\n        } else {\n            const finished = isMediaFinished(representation, segment);\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = getType();\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete');\n            }\n        }\n\n        return request;\n    }\n\n    function isEndlessMedia(representation) {\n        return !isFinite(representation.adaptation.period.duration);\n    }\n\n    function onInitializationLoaded(e) {\n        const representation = e.representation;\n        if (!representation.segments) return;\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n            { representation: representation },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onSegmentsLoaded(e) {\n        if (e.error) return;\n\n        const fragments = e.segments;\n        const representation = e.representation;\n        const segments = [];\n        let count = 0;\n\n        let i,\n            len,\n            s,\n            seg;\n\n        for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\n            s = fragments[i];\n\n            seg = getTimeBasedSegment(\n                timelineConverter,\n                isDynamicManifest,\n                representation,\n                s.startTime,\n                s.duration,\n                s.timescale,\n                s.media,\n                s.mediaRange,\n                count);\n\n            if (seg) {\n                segments.push(seg);\n                seg = null;\n                count++;\n            }\n        }\n\n        if (segments.length > 0) {\n            representation.segmentAvailabilityRange = {\n                start: segments[0].presentationStartTime,\n                end: segments[segments.length - 1].presentationStartTime\n            };\n            representation.availableSegmentsNumber = segments.length;\n            representation.segments = segments;\n\n            if (isDynamicManifest) {\n                const lastSegment = segments[segments.length - 1];\n                const liveEdge = lastSegment.presentationStartTime - 8;\n                // the last segment is the Expected, not calculated, live edge.\n                setExpectedLiveEdge(liveEdge);\n            }\n        }\n\n        if (!representation.hasInitialization()) {\n            return;\n        }\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n            { representation: representation },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onDynamicToStatic() {\n        logger.debug('Dynamic stream complete');\n        dynamicStreamCompleted = true;\n    }\n\n    instance = {\n        initialize: initialize,\n        getStreamId: getStreamId,\n        getType: getType,\n        getStreamInfo: getStreamInfo,\n        getInitRequest: getInitRequest,\n        getRequestForSegment: getRequestForSegment,\n        getSegmentRequestForTime: getSegmentRequestForTime,\n        getNextSegmentRequest: getNextSegmentRequest,\n        setCurrentIndex: setCurrentIndex,\n        getCurrentIndex: getCurrentIndex,\n        isMediaFinished: isMediaFinished,\n        reset: reset,\n        resetIndex: resetIndex,\n        setMimeType: setMimeType,\n        getNextSegmentRequestIdempotent\n    };\n\n    setup();\n\n    return instance;\n}\n\nDashHandler.__dashjs_factory_name = 'DashHandler';\nexport default FactoryMaker.getClassFactory(DashHandler);\n"]},"metadata":{},"sourceType":"script"}