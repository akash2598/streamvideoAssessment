{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar _CommonEncryption = require('../CommonEncryption');\n\nvar _CommonEncryption2 = _interopRequireDefault(_CommonEncryption);\n\nvar _MediaCapability = require('../vo/MediaCapability');\n\nvar _MediaCapability2 = _interopRequireDefault(_MediaCapability);\n\nvar _KeySystemConfiguration = require('../vo/KeySystemConfiguration');\n\nvar _KeySystemConfiguration2 = _interopRequireDefault(_KeySystemConfiguration);\n\nvar _ProtectionErrors = require('../errors/ProtectionErrors');\n\nvar _ProtectionErrors2 = _interopRequireDefault(_ProtectionErrors);\n\nvar _DashJSError = require('../../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _LicenseRequest = require('../vo/LicenseRequest');\n\nvar _LicenseRequest2 = _interopRequireDefault(_LicenseRequest);\n\nvar _LicenseResponse = require('../vo/LicenseResponse');\n\nvar _LicenseResponse2 = _interopRequireDefault(_LicenseResponse);\n\nvar _HTTPRequest = require('../../vo/metrics/HTTPRequest');\n\nvar _Utils = require('../../../core/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Constants = require('../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar NEEDKEY_BEFORE_INITIALIZE_RETRIES = 5;\nvar NEEDKEY_BEFORE_INITIALIZE_TIMEOUT = 500;\nvar LICENSE_SERVER_REQUEST_RETRIES = 3;\nvar LICENSE_SERVER_REQUEST_RETRY_INTERVAL = 1000;\nvar LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT = 8000;\n/**\n* @module ProtectionController\n* @description Provides access to media protection information and functionality.  Each\n* ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel}\n* which encapsulates a set of protection information (EME APIs, selected key system,\n* key sessions).  The APIs of ProtectionController mostly align with the latest EME\n* APIs.  Key system selection is mostly automated when combined with app-overrideable\n* functionality provided in {@link ProtectionKeyController}.\n* @todo ProtectionController does almost all of its tasks automatically after init() is\n* called.  Applications might want more control over this process and want to go through\n* each step manually (key system selection, session creation, session maintenance).\n* @param {Object} config\n*/\n\nfunction ProtectionController(config) {\n  config = config || {};\n  var protectionKeyController = config.protectionKeyController;\n  var protectionModel = config.protectionModel;\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var debug = config.debug;\n  var BASE64 = config.BASE64;\n  var constants = config.constants;\n  var needkeyRetries = [];\n  var cmcdModel = config.cmcdModel;\n  var settings = config.settings;\n  var instance = void 0,\n      logger = void 0,\n      pendingNeedKeyData = void 0,\n      mediaInfoArr = void 0,\n      protDataSet = void 0,\n      sessionType = void 0,\n      robustnessLevel = void 0,\n      keySystem = void 0,\n      licenseRequestFilters = void 0,\n      licenseResponseFilters = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    pendingNeedKeyData = [];\n    mediaInfoArr = [];\n    sessionType = 'temporary';\n    robustnessLevel = '';\n    licenseRequestFilters = [];\n    licenseResponseFilters = [];\n  }\n\n  function checkConfig() {\n    if (!eventBus || !eventBus.hasOwnProperty('on') || !protectionKeyController || !protectionKeyController.hasOwnProperty('getSupportedKeySystemsFromContentProtection')) {\n      throw new Error('Missing config parameter(s)');\n    }\n  }\n  /**\n  * Initialize this protection system with a given audio\n  * or video stream information.\n  *\n  * @param {StreamInfo} [mediaInfo] Media information\n  * @memberof module:ProtectionController\n  * @instance\n  * @todo This API will change when we have better support for allowing applications\n  * to select different adaptation sets for playback.  Right now it is clunky for\n  * applications to create {@link StreamInfo} with the right information,\n  * @ignore\n  */\n\n\n  function initializeForMedia(mediaInfo) {\n    // Not checking here if a session for similar KS/KID combination is already created\n    // because still don't know which keysystem will be selected.\n    // Once Keysystem is selected and before creating the session, we will do that check\n    // so we create the strictly necessary DRM sessions\n    if (!mediaInfo) {\n      throw new Error('mediaInfo can not be null or undefined');\n    }\n\n    checkConfig();\n    eventBus.on(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n    eventBus.on(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n    mediaInfoArr.push(mediaInfo); // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio\n    // and video will be the same.  Just use one valid MediaInfo object\n\n    var supportedKS = protectionKeyController.getSupportedKeySystemsFromContentProtection(mediaInfo.contentProtection);\n\n    if (supportedKS && supportedKS.length > 0) {\n      selectKeySystem(supportedKS, true);\n    }\n  }\n  /**\n  * Removes all entries from the mediaInfoArr array for a specific stream id\n  * @param {String} streamId\n  */\n\n\n  function clearMediaInfoArrayByStreamId(streamId) {\n    mediaInfoArr = mediaInfoArr.filter(function (mediaInfo) {\n      return mediaInfo.streamInfo.id !== streamId;\n    });\n  }\n  /**\n  * Returns a set of supported key systems and CENC initialization data\n  * from the given array of ContentProtection elements.  Only\n  * key systems that are supported by this player will be returned.\n  * Key systems are returned in priority order (highest first).\n  *\n  * @param {Array.<Object>} cps - array of content protection elements parsed\n  * from the manifest\n  * @returns {Array.<Object>} array of objects indicating which supported key\n  * systems were found.  Empty array is returned if no\n  * supported key systems were found\n  * @memberof module:ProtectionKeyController\n  * @instance\n  * @ignore\n  */\n\n\n  function getSupportedKeySystemsFromContentProtection(cps) {\n    checkConfig();\n    return protectionKeyController.getSupportedKeySystemsFromContentProtection(cps);\n  }\n  /**\n  * Create a new key session associated with the given initialization data from\n  * the MPD or from the PSSH box in the media\n  *\n  * @param {ArrayBuffer} initData the initialization data\n  * @param {Uint8Array} cdmData the custom data to provide to licenser\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionCreated\n  * @todo In older versions of the EME spec, there was a one-to-one relationship between\n  * initialization data and key sessions.  That is no longer true in the latest APIs.  This\n  * API will need to modified (and a new \"generateRequest(keySession, initData)\" API created)\n  * to come up to speed with the latest EME standard\n  * @ignore\n  */\n\n\n  function createKeySession(initData, cdmData) {\n    var initDataForKS = _CommonEncryption2.default.getPSSHForKeySystem(keySystem, initData);\n\n    var protData = getProtData(keySystem);\n\n    if (initDataForKS) {\n      // Check for duplicate initData\n      if (_isInitDataDuplicate(initDataForKS)) {\n        return;\n      }\n\n      try {\n        protectionModel.createKeySession(initDataForKS, protData, getSessionType(keySystem), cdmData);\n      } catch (error) {\n        eventBus.trigger(events.KEY_SESSION_CREATED, {\n          data: null,\n          error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + error.message)\n        });\n      }\n    } else if (initData) {\n      protectionModel.createKeySession(initData, protData, getSessionType(keySystem), cdmData);\n    } else {\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: null,\n        error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Selected key system is ' + (keySystem ? keySystem.systemString : null) + '.  needkey/encrypted event contains no initData corresponding to that key system!')\n      });\n    }\n  }\n  /**\n  * Checks if the provided init data is equal to one of the existing init data values\n  * @param {any} initDataForKS\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _isInitDataDuplicate(initDataForKS) {\n    if (!initDataForKS) {\n      return false;\n    }\n\n    try {\n      var currentInitData = protectionModel.getAllInitData();\n\n      for (var i = 0; i < currentInitData.length; i++) {\n        if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) {\n          logger.debug('DRM: Ignoring initData because we have already seen it!');\n          return true;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Loads a key session with the given session ID from persistent storage.  This\n  * essentially creates a new key session\n  *\n  * @param {string} sessionID\n  * @param {string} initData\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionCreated\n  * @ignore\n  */\n\n\n  function loadKeySession(sessionID, initData) {\n    checkConfig();\n    protectionModel.loadKeySession(sessionID, initData, getSessionType(keySystem));\n  }\n  /**\n  * Removes the given key session from persistent storage and closes the session\n  * as if {@link ProtectionController#closeKeySession}\n  * was called\n  *\n  * @param {SessionToken} sessionToken the session\n  * token\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionRemoved\n  * @fires ProtectionController#KeySessionClosed\n  * @ignore\n  */\n\n\n  function removeKeySession(sessionToken) {\n    checkConfig();\n    protectionModel.removeKeySession(sessionToken);\n  }\n  /**\n  * Closes the key session and releases all associated decryption keys.  These\n  * keys will no longer be available for decrypting media\n  *\n  * @param {SessionToken} sessionToken the session\n  * token\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#KeySessionClosed\n  * @ignore\n  */\n\n\n  function closeKeySession(sessionToken) {\n    checkConfig();\n    protectionModel.closeKeySession(sessionToken);\n  }\n  /**\n  * Sets a server certificate for use by the CDM when signing key messages\n  * intended for a particular license server.  This will fire\n  * an error event if a key system has not yet been selected.\n  *\n  * @param {ArrayBuffer} serverCertificate a CDM-specific license server\n  * certificate\n  * @memberof module:ProtectionController\n  * @instance\n  * @fires ProtectionController#ServerCertificateUpdated\n  */\n\n\n  function setServerCertificate(serverCertificate) {\n    checkConfig();\n    protectionModel.setServerCertificate(serverCertificate);\n  }\n  /**\n  * Associate this protection system with the given HTMLMediaElement.  This\n  * causes the system to register for needkey/encrypted events from the given\n  * element and provides a destination for setting of MediaKeys\n  *\n  * @param {HTMLMediaElement} element the media element to which the protection\n  * system should be associated\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function setMediaElement(element) {\n    checkConfig();\n\n    if (element) {\n      protectionModel.setMediaElement(element);\n      eventBus.on(events.NEED_KEY, onNeedKey, this);\n    } else if (element === null) {\n      protectionModel.setMediaElement(element);\n      eventBus.off(events.NEED_KEY, onNeedKey, this);\n    }\n  }\n  /**\n  * Sets the session type to use when creating key sessions.  Either \"temporary\" or\n  * \"persistent-license\".  Default is \"temporary\".\n  *\n  * @param {string} value the session type\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function setSessionType(value) {\n    sessionType = value;\n  }\n  /**\n  * Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings.\n  * Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL.\n  *\n  * @param {string} level the robustness level\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function setRobustnessLevel(level) {\n    robustnessLevel = level;\n  }\n  /**\n  * Attach KeySystem-specific data to use for license acquisition with EME\n  *\n  * @param {Object} data an object containing property names corresponding to\n  * key system name strings (e.g. \"org.w3.clearkey\") and associated values\n  * being instances of {@link ProtectionData}\n  * @memberof module:ProtectionController\n  * @instance\n  * @ignore\n  */\n\n\n  function setProtectionData(data) {\n    protDataSet = data;\n    protectionKeyController.setProtectionData(data);\n  }\n  /**\n  * Stop method is called when current playback is stopped/resetted.\n  *\n  * @memberof module:ProtectionController\n  * @instance\n  */\n\n\n  function stop() {\n    if (protectionModel) {\n      protectionModel.stop();\n    }\n  }\n  /**\n  * Destroys all protection data associated with this protection set.  This includes\n  * deleting all key sessions. In the case of persistent key sessions, the sessions\n  * will simply be unloaded and not deleted.  Additionally, if this protection set is\n  * associated with a HTMLMediaElement, it will be detached from that element.\n  *\n  * @memberof module:ProtectionController\n  * @instance\n  * @ignore\n  */\n\n\n  function reset() {\n    checkConfig();\n    licenseRequestFilters = [];\n    licenseResponseFilters = [];\n    eventBus.off(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n    eventBus.off(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n    setMediaElement(null);\n    keySystem = undefined;\n\n    if (protectionModel) {\n      protectionModel.reset();\n      protectionModel = null;\n    }\n\n    needkeyRetries.forEach(function (retryTimeout) {\n      return clearTimeout(retryTimeout);\n    });\n    needkeyRetries = [];\n    mediaInfoArr = [];\n  } ///////////////\n  // Private\n  ///////////////\n\n\n  function getProtData(keySystem) {\n    var protData = null;\n\n    if (keySystem) {\n      var keySystemString = keySystem.systemString;\n\n      if (protDataSet) {\n        protData = keySystemString in protDataSet ? protDataSet[keySystemString] : null;\n      }\n    }\n\n    return protData;\n  }\n\n  function getKeySystemConfiguration(keySystem) {\n    var protData = getProtData(keySystem);\n    var audioCapabilities = [];\n    var videoCapabilities = [];\n    var audioRobustness = protData && protData.audioRobustness && protData.audioRobustness.length > 0 ? protData.audioRobustness : robustnessLevel;\n    var videoRobustness = protData && protData.videoRobustness && protData.videoRobustness.length > 0 ? protData.videoRobustness : robustnessLevel;\n    var ksSessionType = getSessionType(keySystem);\n    var distinctiveIdentifier = protData && protData.distinctiveIdentifier ? protData.distinctiveIdentifier : 'optional';\n    var persistentState = protData && protData.persistentState ? protData.persistentState : ksSessionType === 'temporary' ? 'optional' : 'required';\n    mediaInfoArr.forEach(function (media) {\n      if (media.type === constants.AUDIO) {\n        audioCapabilities.push(new _MediaCapability2.default(media.codec, audioRobustness));\n      } else if (media.type === constants.VIDEO) {\n        videoCapabilities.push(new _MediaCapability2.default(media.codec, videoRobustness));\n      }\n    });\n    return new _KeySystemConfiguration2.default(audioCapabilities, videoCapabilities, distinctiveIdentifier, persistentState, [ksSessionType]);\n  }\n\n  function getSessionType(keySystem) {\n    var protData = getProtData(keySystem);\n    var ksSessionType = protData && protData.sessionType ? protData.sessionType : sessionType;\n    return ksSessionType;\n  }\n\n  function selectKeySystem(supportedKS, fromManifest) {\n    // Reorder key systems according to priority order provided in protectionData\n    supportedKS = supportedKS.sort(function (ksA, ksB) {\n      var indexA = protDataSet && protDataSet[ksA.ks.systemString] && protDataSet[ksA.ks.systemString].priority >= 0 ? protDataSet[ksA.ks.systemString].priority : supportedKS.length;\n      var indexB = protDataSet && protDataSet[ksB.ks.systemString] && protDataSet[ksB.ks.systemString].priority >= 0 ? protDataSet[ksB.ks.systemString].priority : supportedKS.length;\n      return indexA - indexB;\n    }); // First time, so we need to select a key system\n\n    if (keySystem === undefined) {\n      _selectInitialKeySystem(supportedKS, fromManifest);\n    } // We already selected a key system. we only need to trigger a new license exchange if the init data has changed\n    else if (keySystem) {\n        _selectWithExistingKeySystem(supportedKS, fromManifest);\n      } // We are in the process of selecting a key system, so just save the data which might be coming from additional AdaptationSets.\n      else {\n          pendingNeedKeyData.push(supportedKS);\n        }\n  }\n\n  function _selectWithExistingKeySystem(supportedKS, fromManifest) {\n    var self = this;\n    var requestedKeySystems = [];\n    var ksIdx = supportedKS.findIndex(function (entry) {\n      return entry.ks === keySystem;\n    });\n\n    if (ksIdx === -1 || !supportedKS[ksIdx].initData) {\n      return;\n    } //  we only need to call this if the init data has changed\n\n\n    var initDataForKs = _CommonEncryption2.default.getPSSHForKeySystem(keySystem, supportedKS[ksIdx].initData);\n\n    if (_isInitDataDuplicate(initDataForKs)) {\n      return;\n    }\n\n    requestedKeySystems.push({\n      ks: supportedKS[ksIdx].ks,\n      configs: [getKeySystemConfiguration(keySystem)]\n    }); // Ensure that we would be granted key system access using the key\n    // system and codec information\n\n    var onKeySystemAccessComplete = function onKeySystemAccessComplete(event) {\n      eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n\n      if (event.error) {\n        if (!fromManifest) {\n          eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n            error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, _ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error)\n          });\n        }\n      } else {\n        logger.info('DRM: KeySystem Access Granted');\n        eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n          data: event.data\n        });\n        var protData = getProtData(keySystem);\n\n        if (protectionKeyController.isClearKey(keySystem)) {\n          // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n          // initData and overwrite possible initData indicated in encrypted event (EME)\n          if (protData && protData.hasOwnProperty('clearkeys')) {\n            var initData = {\n              kids: Object.keys(protData.clearkeys)\n            };\n            supportedKS[ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n          }\n        }\n\n        if (supportedKS[ksIdx].sessionId) {\n          // Load MediaKeySession with sessionId\n          loadKeySession(supportedKS[ksIdx].sessionId, supportedKS[ksIdx].initData);\n        } else if (supportedKS[ksIdx].initData) {\n          // Create new MediaKeySession with initData\n          createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData);\n        }\n      }\n    };\n\n    eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n    protectionModel.requestKeySystemAccess(requestedKeySystems);\n  }\n\n  function _selectInitialKeySystem(supportedKS, fromManifest) {\n    var self = this;\n    var requestedKeySystems = [];\n    var ksIdx = void 0; // First time through, so we need to select a key system\n\n    keySystem = null;\n    pendingNeedKeyData.push(supportedKS); // Add all key systems to our request list since we have yet to select a key system\n\n    for (var i = 0; i < supportedKS.length; i++) {\n      requestedKeySystems.push({\n        ks: supportedKS[i].ks,\n        configs: [getKeySystemConfiguration(supportedKS[i].ks)]\n      });\n    }\n\n    var keySystemAccess = void 0;\n\n    var onKeySystemAccessComplete = function onKeySystemAccessComplete(event) {\n      eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n\n      if (event.error) {\n        keySystem = undefined;\n        eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n\n        if (!fromManifest) {\n          eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n            data: null,\n            error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, _ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error)\n          });\n        }\n      } else {\n        keySystemAccess = event.data;\n        logger.info('DRM: KeySystem Access Granted (' + keySystemAccess.keySystem.systemString + ')!  Selecting key system...');\n        protectionModel.selectKeySystem(keySystemAccess);\n      }\n    };\n\n    var onKeySystemSelected = function onKeySystemSelected(event) {\n      eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n      eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n\n      if (!event.error) {\n        if (!protectionModel) {\n          return;\n        }\n\n        keySystem = protectionModel.getKeySystem();\n        eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n          data: keySystemAccess\n        }); // Set server certificate from protData\n\n        var protData = getProtData(keySystem);\n\n        if (protData && protData.serverCertificate && protData.serverCertificate.length > 0) {\n          protectionModel.setServerCertificate(BASE64.decodeArray(protData.serverCertificate).buffer);\n        } // Create key session for the remaining AdaptationSets which have been added to pendingNeedKeyData\n\n\n        for (var _i = 0; _i < pendingNeedKeyData.length; _i++) {\n          for (ksIdx = 0; ksIdx < pendingNeedKeyData[_i].length; ksIdx++) {\n            if (keySystem === pendingNeedKeyData[_i][ksIdx].ks) {\n              if (protectionKeyController.isClearKey(keySystem)) {\n                // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n                // initData and overwrite possible initData indicated in encrypted event (EME)\n                if (protData && protData.hasOwnProperty('clearkeys')) {\n                  var initData = {\n                    kids: Object.keys(protData.clearkeys)\n                  };\n                  pendingNeedKeyData[_i][ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n                }\n              }\n\n              if (pendingNeedKeyData[_i][ksIdx].sessionId) {\n                // Load MediaKeySession with sessionId\n                loadKeySession(pendingNeedKeyData[_i][ksIdx].sessionId, pendingNeedKeyData[_i][ksIdx].initData);\n              } else if (pendingNeedKeyData[_i][ksIdx].initData !== null) {\n                // Create new MediaKeySession with initData\n                createKeySession(pendingNeedKeyData[_i][ksIdx].initData, pendingNeedKeyData[_i][ksIdx].cdmData);\n              }\n\n              break;\n            }\n          }\n        }\n      } else {\n        keySystem = undefined;\n\n        if (!fromManifest) {\n          eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n            data: null,\n            error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, _ProtectionErrors2.default.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + 'Error selecting key system! -- ' + event.error)\n          });\n        }\n      }\n    };\n\n    eventBus.on(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n    eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n    protectionModel.requestKeySystemAccess(requestedKeySystems);\n  }\n\n  function sendLicenseRequestCompleteEvent(data, error) {\n    eventBus.trigger(events.LICENSE_REQUEST_COMPLETE, {\n      data: data,\n      error: error\n    });\n  }\n\n  function onKeyStatusChanged(e) {\n    if (e.error) {\n      eventBus.trigger(events.KEY_STATUSES_CHANGED, {\n        data: null,\n        error: e.error\n      });\n    } else {\n      logger.debug('DRM: key status = ' + e.status);\n    }\n  }\n\n  function onKeyMessage(e) {\n    logger.debug('DRM: onKeyMessage'); // Dispatch event to applications indicating we received a key message\n\n    var keyMessage = e.data;\n    eventBus.trigger(events.KEY_MESSAGE, {\n      data: keyMessage\n    });\n    var messageType = keyMessage.messageType ? keyMessage.messageType : 'license-request';\n    var message = keyMessage.message;\n    var sessionToken = keyMessage.sessionToken;\n    var protData = getProtData(keySystem);\n    var keySystemString = keySystem ? keySystem.systemString : null;\n    var licenseServerData = protectionKeyController.getLicenseServer(keySystem, protData, messageType);\n    var eventData = {\n      sessionToken: sessionToken,\n      messageType: messageType\n    }; // Ensure message from CDM is not empty\n\n    if (!message || message.byteLength === 0) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE));\n      return;\n    } // Message not destined for license server\n\n\n    if (!licenseServerData) {\n      logger.debug('DRM: License server request not required for this message (type = ' + e.data.messageType + ').  Session ID = ' + sessionToken.getSessionID());\n      sendLicenseRequestCompleteEvent(eventData);\n      return;\n    } // Perform any special handling for ClearKey\n\n\n    if (protectionKeyController.isClearKey(keySystem)) {\n      var clearkeys = protectionKeyController.processClearKeyLicenseRequest(keySystem, protData, message);\n\n      if (clearkeys) {\n        logger.debug('DRM: ClearKey license request handled by application!');\n        sendLicenseRequestCompleteEvent(eventData);\n        protectionModel.updateKeySession(sessionToken, clearkeys);\n        return;\n      }\n    } // All remaining key system scenarios require a request to a remote license server\n    // Determine license server URL\n\n\n    var url = null;\n\n    if (protData && protData.serverURL) {\n      var serverURL = protData.serverURL;\n\n      if (typeof serverURL === 'string' && serverURL !== '') {\n        url = serverURL;\n      } else if ((typeof serverURL === 'undefined' ? 'undefined' : _typeof(serverURL)) === 'object' && serverURL.hasOwnProperty(messageType)) {\n        url = serverURL[messageType];\n      }\n    } else if (protData && protData.laURL && protData.laURL !== '') {\n      // TODO: Deprecated!\n      url = protData.laURL;\n    } else {\n      // For clearkey use the url defined in the manifest\n      if (protectionKeyController.isClearKey(keySystem)) {\n        url = keySystem.getLicenseServerUrlFromMediaInfo(mediaInfoArr);\n      } else {\n        var psshData = _CommonEncryption2.default.getPSSHData(sessionToken.initData);\n\n        url = keySystem.getLicenseServerURLFromInitData(psshData);\n\n        if (!url) {\n          url = e.data.laURL;\n        }\n      }\n    } // Possibly update or override the URL based on the message\n\n\n    url = licenseServerData.getServerURLFromMessage(url, message, messageType); // Ensure valid license server URL\n\n    if (!url) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE));\n      return;\n    } // Set optional XMLHttpRequest headers from protection data and message\n\n\n    var reqHeaders = {};\n    var withCredentials = false;\n\n    var updateHeaders = function updateHeaders(headers) {\n      if (headers) {\n        for (var key in headers) {\n          if ('authorization' === key.toLowerCase()) {\n            withCredentials = true;\n          }\n\n          reqHeaders[key] = headers[key];\n        }\n      }\n    };\n\n    if (protData) {\n      updateHeaders(protData.httpRequestHeaders);\n    }\n\n    updateHeaders(keySystem.getRequestHeadersFromMessage(message)); // Overwrite withCredentials property from protData if present\n\n    if (protData && typeof protData.withCredentials == 'boolean') {\n      withCredentials = protData.withCredentials;\n    }\n\n    var reportError = function reportError(xhr, eventData, keySystemString, messageType) {\n      var errorMsg = xhr.response ? licenseServerData.getErrorResponse(xhr.response, keySystemString, messageType) : 'NONE';\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR complete. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState + '.  Response is ' + errorMsg));\n    };\n\n    var onLoad = function onLoad(xhr) {\n      if (!protectionModel) {\n        return;\n      }\n\n      if (xhr.status === 200) {\n        var licenseResponse = new _LicenseResponse2.default(xhr.responseURL, _Utils2.default.parseHttpHeaders(xhr.getAllResponseHeaders ? xhr.getAllResponseHeaders() : null), xhr.response);\n        applyFilters(licenseResponseFilters, licenseResponse).then(function () {\n          var licenseMessage = licenseServerData.getLicenseMessage(licenseResponse.data, keySystemString, messageType);\n\n          if (licenseMessage !== null) {\n            sendLicenseRequestCompleteEvent(eventData);\n            protectionModel.updateKeySession(sessionToken, licenseMessage);\n          } else {\n            reportError(xhr, eventData, keySystemString, messageType);\n          }\n        });\n      } else {\n        reportError(xhr, eventData, keySystemString, messageType);\n      }\n    };\n\n    var onAbort = function onAbort(xhr) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR aborted. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n    };\n\n    var onError = function onError(xhr) {\n      sendLicenseRequestCompleteEvent(eventData, new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR error. status is \"' + xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n    };\n\n    var reqPayload = keySystem.getLicenseRequestFromMessage(message);\n    var reqMethod = licenseServerData.getHTTPMethod(messageType);\n    var responseType = licenseServerData.getResponseType(keySystemString, messageType);\n    var timeout = protData && !isNaN(protData.httpTimeout) ? protData.httpTimeout : LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT;\n    var sessionId = sessionToken.getSessionID() || null;\n    var licenseRequest = new _LicenseRequest2.default(url, reqMethod, responseType, reqHeaders, withCredentials, messageType, sessionId, reqPayload);\n    applyFilters(licenseRequestFilters, licenseRequest).then(function () {\n      doLicenseRequest(licenseRequest, LICENSE_SERVER_REQUEST_RETRIES, timeout, onLoad, onAbort, onError);\n    });\n  } // Implement license requests with a retry mechanism to avoid temporary network issues to affect playback experience\n\n\n  function doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError) {\n    var xhr = new XMLHttpRequest();\n\n    if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n      var cmcdMode = settings.get().streaming.cmcd.mode;\n\n      if (cmcdMode === _Constants2.default.CMCD_MODE_QUERY) {\n        var cmcdParams = cmcdModel.getQueryParameter({\n          url: request.url,\n          type: _HTTPRequest.HTTPRequest.LICENSE\n        });\n\n        if (cmcdParams) {\n          request.url = _Utils2.default.addAditionalQueryParameterToUrl(request.url, [cmcdParams]);\n        }\n      }\n    }\n\n    xhr.open(request.method, request.url, true);\n    xhr.responseType = request.responseType;\n    xhr.withCredentials = request.withCredentials;\n\n    if (timeout > 0) {\n      xhr.timeout = timeout;\n    }\n\n    for (var key in request.headers) {\n      xhr.setRequestHeader(key, request.headers[key]);\n    }\n\n    if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n      var _cmcdMode = settings.get().streaming.cmcd.mode;\n\n      if (_cmcdMode === _Constants2.default.CMCD_MODE_HEADER) {\n        var cmcdHeaders = cmcdModel.getHeaderParameters({\n          url: request.url,\n          type: _HTTPRequest.HTTPRequest.LICENSE\n        });\n\n        if (cmcdHeaders) {\n          for (var header in cmcdHeaders) {\n            var value = cmcdHeaders[header];\n\n            if (value) {\n              xhr.setRequestHeader(header, value);\n            }\n          }\n        }\n      }\n    }\n\n    var retryRequest = function retryRequest() {\n      // fail silently and retry\n      retriesCount--;\n      setTimeout(function () {\n        doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError);\n      }, LICENSE_SERVER_REQUEST_RETRY_INTERVAL);\n    };\n\n    xhr.onload = function () {\n      if (this.status === 200 || retriesCount <= 0) {\n        onLoad(this);\n      } else {\n        logger.warn('License request failed (' + this.status + '). Retrying it... Pending retries: ' + retriesCount);\n        retryRequest();\n      }\n    };\n\n    xhr.ontimeout = xhr.onerror = function () {\n      if (retriesCount <= 0) {\n        onError(this);\n      } else {\n        logger.warn('License request network request failed . Retrying it... Pending retries: ' + retriesCount);\n        retryRequest();\n      }\n    };\n\n    xhr.onabort = function () {\n      onAbort(this);\n    }; // deprecated, to be removed\n\n\n    eventBus.trigger(events.LICENSE_REQUEST_SENDING, {\n      url: request.url,\n      headers: request.headers,\n      payload: request.data,\n      sessionId: request.sessionId\n    });\n    xhr.send(request.data);\n  }\n\n  function onNeedKey(event, retry) {\n    logger.debug('DRM: onNeedKey'); // Ignore non-cenc initData\n\n    if (event.key.initDataType !== 'cenc') {\n      logger.warn('DRM:  Only \\'cenc\\' initData is supported!  Ignoring initData of type: ' + event.key.initDataType);\n      return;\n    }\n\n    if (mediaInfoArr.length === 0) {\n      logger.warn('DRM: onNeedKey called before initializeForMedia, wait until initialized');\n      retry = typeof retry === 'undefined' ? 1 : retry + 1;\n\n      if (retry < NEEDKEY_BEFORE_INITIALIZE_RETRIES) {\n        needkeyRetries.push(setTimeout(function () {\n          onNeedKey(event, retry);\n        }, NEEDKEY_BEFORE_INITIALIZE_TIMEOUT));\n        return;\n      }\n    } // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).\n    // Convert to ArrayBuffer\n\n\n    var abInitData = event.key.initData;\n\n    if (ArrayBuffer.isView(abInitData)) {\n      abInitData = abInitData.buffer;\n    } // If key system has already been selected and initData already seen, then do nothing\n\n\n    if (keySystem) {\n      var initDataForKS = _CommonEncryption2.default.getPSSHForKeySystem(keySystem, abInitData);\n\n      if (initDataForKS) {\n        // Check for duplicate initData\n        if (_isInitDataDuplicate(initDataForKS)) {\n          return;\n        }\n      }\n    }\n\n    logger.debug('DRM: initData:', String.fromCharCode.apply(null, new Uint8Array(abInitData)));\n    var supportedKS = protectionKeyController.getSupportedKeySystems(abInitData, protDataSet);\n\n    if (supportedKS.length === 0) {\n      logger.debug('DRM: Received needkey event with initData, but we don\\'t support any of the key systems!');\n      return;\n    }\n\n    selectKeySystem(supportedKS, false);\n  }\n\n  function getKeySystems() {\n    return protectionKeyController ? protectionKeyController.getKeySystems() : [];\n  }\n\n  function setKeySystems(keySystems) {\n    if (protectionKeyController) {\n      protectionKeyController.setKeySystems(keySystems);\n    }\n  }\n\n  function setLicenseRequestFilters(filters) {\n    licenseRequestFilters = filters;\n  }\n\n  function setLicenseResponseFilters(filters) {\n    licenseResponseFilters = filters;\n  }\n\n  function applyFilters(filters, param) {\n    if (!filters) return Promise.resolve();\n    return filters.reduce(function (prev, next) {\n      return prev.then(function () {\n        return next(param);\n      });\n    }, Promise.resolve());\n  }\n\n  instance = {\n    initializeForMedia: initializeForMedia,\n    clearMediaInfoArrayByStreamId: clearMediaInfoArrayByStreamId,\n    createKeySession: createKeySession,\n    loadKeySession: loadKeySession,\n    removeKeySession: removeKeySession,\n    closeKeySession: closeKeySession,\n    setServerCertificate: setServerCertificate,\n    setMediaElement: setMediaElement,\n    setSessionType: setSessionType,\n    setRobustnessLevel: setRobustnessLevel,\n    setProtectionData: setProtectionData,\n    getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection,\n    getKeySystems: getKeySystems,\n    setKeySystems: setKeySystems,\n    setLicenseRequestFilters: setLicenseRequestFilters,\n    setLicenseResponseFilters: setLicenseResponseFilters,\n    stop: stop,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nProtectionController.__dashjs_factory_name = 'ProtectionController';\nexports.default = dashjs.FactoryMaker.getClassFactory(ProtectionController);\n/* jshint ignore:line */","map":{"version":3,"sources":["../../../../../../src/streaming/protection/controllers/ProtectionController.js"],"names":["NEEDKEY_BEFORE_INITIALIZE_RETRIES","NEEDKEY_BEFORE_INITIALIZE_TIMEOUT","LICENSE_SERVER_REQUEST_RETRIES","LICENSE_SERVER_REQUEST_RETRY_INTERVAL","LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT","config","protectionKeyController","protectionModel","eventBus","events","debug","BASE64","constants","needkeyRetries","cmcdModel","settings","instance","logger","pendingNeedKeyData","mediaInfoArr","protDataSet","sessionType","robustnessLevel","keySystem","licenseRequestFilters","licenseResponseFilters","checkConfig","supportedKS","mediaInfo","selectKeySystem","initDataForKS","CommonEncryption","protData","getProtData","_isInitDataDuplicate","getSessionType","data","error","DashJSError","ProtectionErrors","currentInitData","i","element","setMediaElement","clearTimeout","keySystemString","audioCapabilities","videoCapabilities","audioRobustness","videoRobustness","ksSessionType","distinctiveIdentifier","persistentState","media","MediaCapability","KeySystemConfiguration","indexA","ksA","indexB","ksB","_selectInitialKeySystem","_selectWithExistingKeySystem","self","requestedKeySystems","ksIdx","entry","initDataForKs","ks","configs","getKeySystemConfiguration","onKeySystemAccessComplete","event","initData","kids","Object","JSON","loadKeySession","createKeySession","keySystemAccess","onKeySystemSelected","e","keyMessage","messageType","message","sessionToken","licenseServerData","eventData","sendLicenseRequestCompleteEvent","clearkeys","url","serverURL","psshData","reqHeaders","withCredentials","updateHeaders","key","headers","reportError","errorMsg","xhr","onLoad","licenseResponse","LicenseResponse","Utils","applyFilters","licenseMessage","onAbort","onError","reqPayload","reqMethod","responseType","timeout","isNaN","sessionId","licenseRequest","LicenseRequest","doLicenseRequest","cmcdMode","Constants","cmcdParams","request","type","HTTPRequest","cmcdHeaders","value","retryRequest","retriesCount","setTimeout","payload","retry","onNeedKey","abInitData","ArrayBuffer","String","Promise","filters","prev","next","initializeForMedia","clearMediaInfoArrayByStreamId","removeKeySession","closeKeySession","setServerCertificate","setSessionType","setRobustnessLevel","setProtectionData","getSupportedKeySystemsFromContentProtection","getKeySystems","setKeySystems","setLicenseRequestFilters","setLicenseResponseFilters","stop","reset","setup","ProtectionController","dashjs"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport CommonEncryption from '../CommonEncryption';\nimport MediaCapability from '../vo/MediaCapability';\nimport KeySystemConfiguration from '../vo/KeySystemConfiguration';\nimport ProtectionErrors from '../errors/ProtectionErrors';\nimport DashJSError from '../../vo/DashJSError';\nimport LicenseRequest from '../vo/LicenseRequest';\nimport LicenseResponse from '../vo/LicenseResponse';\nimport { HTTPRequest } from '../../vo/metrics/HTTPRequest';\nimport Utils from '../../../core/Utils';\nimport Constants from '../../constants/Constants';\n\nconst NEEDKEY_BEFORE_INITIALIZE_RETRIES = 5;\nconst NEEDKEY_BEFORE_INITIALIZE_TIMEOUT = 500;\n\nconst LICENSE_SERVER_REQUEST_RETRIES = 3;\nconst LICENSE_SERVER_REQUEST_RETRY_INTERVAL = 1000;\nconst LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT = 8000;\n\n/**\n * @module ProtectionController\n * @description Provides access to media protection information and functionality.  Each\n * ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel}\n * which encapsulates a set of protection information (EME APIs, selected key system,\n * key sessions).  The APIs of ProtectionController mostly align with the latest EME\n * APIs.  Key system selection is mostly automated when combined with app-overrideable\n * functionality provided in {@link ProtectionKeyController}.\n * @todo ProtectionController does almost all of its tasks automatically after init() is\n * called.  Applications might want more control over this process and want to go through\n * each step manually (key system selection, session creation, session maintenance).\n * @param {Object} config\n */\n\nfunction ProtectionController(config) {\n\n    config = config || {};\n    const protectionKeyController = config.protectionKeyController;\n    let protectionModel = config.protectionModel;\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const debug = config.debug;\n    const BASE64 = config.BASE64;\n    const constants = config.constants;\n    let needkeyRetries = [];\n    const cmcdModel = config.cmcdModel;\n    const settings = config.settings;\n\n    let instance,\n        logger,\n        pendingNeedKeyData,\n        mediaInfoArr,\n        protDataSet,\n        sessionType,\n        robustnessLevel,\n        keySystem,\n        licenseRequestFilters,\n        licenseResponseFilters;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        pendingNeedKeyData = [];\n        mediaInfoArr = [];\n        sessionType = 'temporary';\n        robustnessLevel = '';\n        licenseRequestFilters = [];\n        licenseResponseFilters = [];\n    }\n\n    function checkConfig() {\n        if (!eventBus || !eventBus.hasOwnProperty('on') || !protectionKeyController || !protectionKeyController.hasOwnProperty('getSupportedKeySystemsFromContentProtection')) {\n            throw new Error('Missing config parameter(s)');\n        }\n    }\n\n    /**\n     * Initialize this protection system with a given audio\n     * or video stream information.\n     *\n     * @param {StreamInfo} [mediaInfo] Media information\n     * @memberof module:ProtectionController\n     * @instance\n     * @todo This API will change when we have better support for allowing applications\n     * to select different adaptation sets for playback.  Right now it is clunky for\n     * applications to create {@link StreamInfo} with the right information,\n     * @ignore\n     */\n    function initializeForMedia(mediaInfo) {\n        // Not checking here if a session for similar KS/KID combination is already created\n        // because still don't know which keysystem will be selected.\n        // Once Keysystem is selected and before creating the session, we will do that check\n        // so we create the strictly necessary DRM sessions\n        if (!mediaInfo) {\n            throw new Error('mediaInfo can not be null or undefined');\n        }\n\n        checkConfig();\n\n        eventBus.on(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n        eventBus.on(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n        mediaInfoArr.push(mediaInfo);\n\n        // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio\n        // and video will be the same.  Just use one valid MediaInfo object\n        const supportedKS = protectionKeyController.getSupportedKeySystemsFromContentProtection(mediaInfo.contentProtection);\n        if (supportedKS && supportedKS.length > 0) {\n            selectKeySystem(supportedKS, true);\n        }\n    }\n\n    /**\n     * Removes all entries from the mediaInfoArr array for a specific stream id\n     * @param {String} streamId\n     */\n    function clearMediaInfoArrayByStreamId(streamId) {\n        mediaInfoArr = mediaInfoArr.filter((mediaInfo) => {\n            return mediaInfo.streamInfo.id !== streamId;\n        });\n    }\n\n    /**\n     * Returns a set of supported key systems and CENC initialization data\n     * from the given array of ContentProtection elements.  Only\n     * key systems that are supported by this player will be returned.\n     * Key systems are returned in priority order (highest first).\n     *\n     * @param {Array.<Object>} cps - array of content protection elements parsed\n     * from the manifest\n     * @returns {Array.<Object>} array of objects indicating which supported key\n     * systems were found.  Empty array is returned if no\n     * supported key systems were found\n     * @memberof module:ProtectionKeyController\n     * @instance\n     * @ignore\n     */\n    function getSupportedKeySystemsFromContentProtection(cps) {\n        checkConfig();\n        return protectionKeyController.getSupportedKeySystemsFromContentProtection(cps);\n    }\n\n    /**\n     * Create a new key session associated with the given initialization data from\n     * the MPD or from the PSSH box in the media\n     *\n     * @param {ArrayBuffer} initData the initialization data\n     * @param {Uint8Array} cdmData the custom data to provide to licenser\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionCreated\n     * @todo In older versions of the EME spec, there was a one-to-one relationship between\n     * initialization data and key sessions.  That is no longer true in the latest APIs.  This\n     * API will need to modified (and a new \"generateRequest(keySession, initData)\" API created)\n     * to come up to speed with the latest EME standard\n     * @ignore\n     */\n    function createKeySession(initData, cdmData) {\n        const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, initData);\n        const protData = getProtData(keySystem);\n        if (initDataForKS) {\n\n            // Check for duplicate initData\n            if (_isInitDataDuplicate(initDataForKS)) {\n                return;\n            }\n\n            try {\n                protectionModel.createKeySession(initDataForKS, protData, getSessionType(keySystem), cdmData);\n            } catch (error) {\n                eventBus.trigger(events.KEY_SESSION_CREATED, {\n                    data: null,\n                    error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + error.message)\n                });\n            }\n        } else if (initData) {\n            protectionModel.createKeySession(initData, protData, getSessionType(keySystem), cdmData);\n        } else {\n            eventBus.trigger(events.KEY_SESSION_CREATED, {\n                data: null,\n                error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Selected key system is ' + (keySystem ? keySystem.systemString : null) + '.  needkey/encrypted event contains no initData corresponding to that key system!')\n            });\n        }\n    }\n\n    /**\n     * Checks if the provided init data is equal to one of the existing init data values\n     * @param {any} initDataForKS\n     * @return {boolean}\n     * @private\n     */\n    function _isInitDataDuplicate(initDataForKS) {\n\n        if (!initDataForKS) {\n            return false;\n        }\n\n        try {\n            const currentInitData = protectionModel.getAllInitData();\n            for (let i = 0; i < currentInitData.length; i++) {\n                if (protectionKeyController.initDataEquals(initDataForKS, currentInitData[i])) {\n                    logger.debug('DRM: Ignoring initData because we have already seen it!');\n                    return true;\n                }\n            }\n\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads a key session with the given session ID from persistent storage.  This\n     * essentially creates a new key session\n     *\n     * @param {string} sessionID\n     * @param {string} initData\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionCreated\n     * @ignore\n     */\n    function loadKeySession(sessionID, initData) {\n        checkConfig();\n        protectionModel.loadKeySession(sessionID, initData, getSessionType(keySystem));\n    }\n\n    /**\n     * Removes the given key session from persistent storage and closes the session\n     * as if {@link ProtectionController#closeKeySession}\n     * was called\n     *\n     * @param {SessionToken} sessionToken the session\n     * token\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionRemoved\n     * @fires ProtectionController#KeySessionClosed\n     * @ignore\n     */\n    function removeKeySession(sessionToken) {\n        checkConfig();\n        protectionModel.removeKeySession(sessionToken);\n    }\n\n    /**\n     * Closes the key session and releases all associated decryption keys.  These\n     * keys will no longer be available for decrypting media\n     *\n     * @param {SessionToken} sessionToken the session\n     * token\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#KeySessionClosed\n     * @ignore\n     */\n    function closeKeySession(sessionToken) {\n        checkConfig();\n        protectionModel.closeKeySession(sessionToken);\n    }\n\n    /**\n     * Sets a server certificate for use by the CDM when signing key messages\n     * intended for a particular license server.  This will fire\n     * an error event if a key system has not yet been selected.\n     *\n     * @param {ArrayBuffer} serverCertificate a CDM-specific license server\n     * certificate\n     * @memberof module:ProtectionController\n     * @instance\n     * @fires ProtectionController#ServerCertificateUpdated\n     */\n    function setServerCertificate(serverCertificate) {\n        checkConfig();\n        protectionModel.setServerCertificate(serverCertificate);\n    }\n\n    /**\n     * Associate this protection system with the given HTMLMediaElement.  This\n     * causes the system to register for needkey/encrypted events from the given\n     * element and provides a destination for setting of MediaKeys\n     *\n     * @param {HTMLMediaElement} element the media element to which the protection\n     * system should be associated\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function setMediaElement(element) {\n        checkConfig();\n        if (element) {\n            protectionModel.setMediaElement(element);\n            eventBus.on(events.NEED_KEY, onNeedKey, this);\n        } else if (element === null) {\n            protectionModel.setMediaElement(element);\n            eventBus.off(events.NEED_KEY, onNeedKey, this);\n        }\n    }\n\n    /**\n     * Sets the session type to use when creating key sessions.  Either \"temporary\" or\n     * \"persistent-license\".  Default is \"temporary\".\n     *\n     * @param {string} value the session type\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function setSessionType(value) {\n        sessionType = value;\n    }\n\n    /**\n     * Sets the robustness level for video and audio capabilities. Optional to remove Chrome warnings.\n     * Possible values are SW_SECURE_CRYPTO, SW_SECURE_DECODE, HW_SECURE_CRYPTO, HW_SECURE_CRYPTO, HW_SECURE_DECODE, HW_SECURE_ALL.\n     *\n     * @param {string} level the robustness level\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function setRobustnessLevel(level) {\n        robustnessLevel = level;\n    }\n\n    /**\n     * Attach KeySystem-specific data to use for license acquisition with EME\n     *\n     * @param {Object} data an object containing property names corresponding to\n     * key system name strings (e.g. \"org.w3.clearkey\") and associated values\n     * being instances of {@link ProtectionData}\n     * @memberof module:ProtectionController\n     * @instance\n     * @ignore\n     */\n    function setProtectionData(data) {\n        protDataSet = data;\n        protectionKeyController.setProtectionData(data);\n    }\n\n    /**\n     * Stop method is called when current playback is stopped/resetted.\n     *\n     * @memberof module:ProtectionController\n     * @instance\n     */\n    function stop() {\n        if (protectionModel) {\n            protectionModel.stop();\n        }\n    }\n\n\n    /**\n     * Destroys all protection data associated with this protection set.  This includes\n     * deleting all key sessions. In the case of persistent key sessions, the sessions\n     * will simply be unloaded and not deleted.  Additionally, if this protection set is\n     * associated with a HTMLMediaElement, it will be detached from that element.\n     *\n     * @memberof module:ProtectionController\n     * @instance\n     * @ignore\n     */\n    function reset() {\n        checkConfig();\n\n        licenseRequestFilters = [];\n        licenseResponseFilters = [];\n\n        eventBus.off(events.INTERNAL_KEY_MESSAGE, onKeyMessage, this);\n        eventBus.off(events.INTERNAL_KEY_STATUS_CHANGED, onKeyStatusChanged, this);\n\n        setMediaElement(null);\n\n        keySystem = undefined;\n\n        if (protectionModel) {\n            protectionModel.reset();\n            protectionModel = null;\n        }\n\n        needkeyRetries.forEach(retryTimeout => clearTimeout(retryTimeout));\n        needkeyRetries = [];\n\n        mediaInfoArr = [];\n    }\n\n    ///////////////\n    // Private\n    ///////////////\n\n    function getProtData(keySystem) {\n        let protData = null;\n        if (keySystem) {\n            const keySystemString = keySystem.systemString;\n\n            if (protDataSet) {\n                protData = (keySystemString in protDataSet) ? protDataSet[keySystemString] : null;\n            }\n        }\n        return protData;\n    }\n\n    function getKeySystemConfiguration(keySystem) {\n        const protData = getProtData(keySystem);\n        const audioCapabilities = [];\n        const videoCapabilities = [];\n        const audioRobustness = (protData && protData.audioRobustness && protData.audioRobustness.length > 0) ? protData.audioRobustness : robustnessLevel;\n        const videoRobustness = (protData && protData.videoRobustness && protData.videoRobustness.length > 0) ? protData.videoRobustness : robustnessLevel;\n        const ksSessionType = getSessionType(keySystem);\n        const distinctiveIdentifier = (protData && protData.distinctiveIdentifier) ? protData.distinctiveIdentifier : 'optional';\n        const persistentState = (protData && protData.persistentState) ? protData.persistentState : (ksSessionType === 'temporary') ? 'optional' : 'required';\n\n        mediaInfoArr.forEach((media) => {\n            if (media.type === constants.AUDIO) {\n                audioCapabilities.push(new MediaCapability(media.codec, audioRobustness));\n            } else if (media.type === constants.VIDEO) {\n                videoCapabilities.push(new MediaCapability(media.codec, videoRobustness));\n            }\n        });\n\n        return new KeySystemConfiguration(\n            audioCapabilities, videoCapabilities, distinctiveIdentifier,\n            persistentState,\n            [ksSessionType]);\n    }\n\n    function getSessionType(keySystem) {\n        const protData = getProtData(keySystem);\n        const ksSessionType = (protData && protData.sessionType) ? protData.sessionType : sessionType;\n        return ksSessionType;\n    }\n\n    function selectKeySystem(supportedKS, fromManifest) {\n\n        // Reorder key systems according to priority order provided in protectionData\n        supportedKS = supportedKS.sort((ksA, ksB) => {\n            let indexA = (protDataSet && protDataSet[ksA.ks.systemString] && protDataSet[ksA.ks.systemString].priority >= 0) ? protDataSet[ksA.ks.systemString].priority : supportedKS.length;\n            let indexB = (protDataSet && protDataSet[ksB.ks.systemString] && protDataSet[ksB.ks.systemString].priority >= 0) ? protDataSet[ksB.ks.systemString].priority : supportedKS.length;\n            return indexA - indexB;\n        });\n\n\n        // First time, so we need to select a key system\n        if (keySystem === undefined) {\n            _selectInitialKeySystem(supportedKS, fromManifest);\n        }\n\n        // We already selected a key system. we only need to trigger a new license exchange if the init data has changed\n        else if (keySystem) {\n            _selectWithExistingKeySystem(supportedKS, fromManifest);\n        }\n\n        // We are in the process of selecting a key system, so just save the data which might be coming from additional AdaptationSets.\n        else {\n            pendingNeedKeyData.push(supportedKS);\n        }\n    }\n\n    function _selectWithExistingKeySystem(supportedKS, fromManifest) {\n        const self = this;\n        const requestedKeySystems = [];\n\n        const ksIdx = supportedKS.findIndex((entry) => {\n            return entry.ks === keySystem;\n        });\n\n        if (ksIdx === -1 || !supportedKS[ksIdx].initData) {\n            return;\n        }\n\n        //  we only need to call this if the init data has changed\n        const initDataForKs = CommonEncryption.getPSSHForKeySystem(keySystem, supportedKS[ksIdx].initData);\n        if (_isInitDataDuplicate(initDataForKs)) {\n            return;\n        }\n\n        requestedKeySystems.push({\n            ks: supportedKS[ksIdx].ks,\n            configs: [getKeySystemConfiguration(keySystem)]\n        });\n\n        // Ensure that we would be granted key system access using the key\n        // system and codec information\n        const onKeySystemAccessComplete = function (event) {\n            eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n            if (event.error) {\n                if (!fromManifest) {\n                    eventBus.trigger(events.KEY_SYSTEM_SELECTED, { error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error) });\n                }\n            } else {\n                logger.info('DRM: KeySystem Access Granted');\n                eventBus.trigger(events.KEY_SYSTEM_SELECTED, { data: event.data });\n                const protData = getProtData(keySystem);\n                if (protectionKeyController.isClearKey(keySystem)) {\n                    // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n                    // initData and overwrite possible initData indicated in encrypted event (EME)\n                    if (protData && protData.hasOwnProperty('clearkeys')) {\n                        const initData = { kids: Object.keys(protData.clearkeys) };\n                        supportedKS[ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n                    }\n                }\n                if (supportedKS[ksIdx].sessionId) {\n                    // Load MediaKeySession with sessionId\n                    loadKeySession(supportedKS[ksIdx].sessionId, supportedKS[ksIdx].initData);\n                } else if (supportedKS[ksIdx].initData) {\n                    // Create new MediaKeySession with initData\n                    createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData);\n                }\n            }\n        };\n\n        eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n        protectionModel.requestKeySystemAccess(requestedKeySystems);\n    }\n\n    function _selectInitialKeySystem(supportedKS, fromManifest) {\n        const self = this;\n        const requestedKeySystems = [];\n        let ksIdx;\n\n        // First time through, so we need to select a key system\n        keySystem = null;\n        pendingNeedKeyData.push(supportedKS);\n\n        // Add all key systems to our request list since we have yet to select a key system\n        for (let i = 0; i < supportedKS.length; i++) {\n            requestedKeySystems.push({\n                ks: supportedKS[i].ks,\n                configs: [getKeySystemConfiguration(supportedKS[i].ks)]\n            });\n        }\n\n        let keySystemAccess;\n        const onKeySystemAccessComplete = function (event) {\n            eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n            if (event.error) {\n                keySystem = undefined;\n                eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n                if (!fromManifest) {\n                    eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n                        data: null,\n                        error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + event.error)\n                    });\n                }\n            } else {\n                keySystemAccess = event.data;\n                logger.info('DRM: KeySystem Access Granted (' + keySystemAccess.keySystem.systemString + ')!  Selecting key system...');\n                protectionModel.selectKeySystem(keySystemAccess);\n            }\n        };\n        var onKeySystemSelected = function (event) {\n            eventBus.off(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n            eventBus.off(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n            if (!event.error) {\n                if (!protectionModel) {\n                    return;\n                }\n                keySystem = protectionModel.getKeySystem();\n                eventBus.trigger(events.KEY_SYSTEM_SELECTED, { data: keySystemAccess });\n                // Set server certificate from protData\n                const protData = getProtData(keySystem);\n                if (protData && protData.serverCertificate && protData.serverCertificate.length > 0) {\n                    protectionModel.setServerCertificate(BASE64.decodeArray(protData.serverCertificate).buffer);\n                }\n\n                // Create key session for the remaining AdaptationSets which have been added to pendingNeedKeyData\n                for (let i = 0; i < pendingNeedKeyData.length; i++) {\n                    for (ksIdx = 0; ksIdx < pendingNeedKeyData[i].length; ksIdx++) {\n                        if (keySystem === pendingNeedKeyData[i][ksIdx].ks) {\n                            if (protectionKeyController.isClearKey(keySystem)) {\n                                // For Clearkey: if parameters for generating init data was provided by the user, use them for generating\n                                // initData and overwrite possible initData indicated in encrypted event (EME)\n                                if (protData && protData.hasOwnProperty('clearkeys')) {\n                                    const initData = { kids: Object.keys(protData.clearkeys) };\n                                    pendingNeedKeyData[i][ksIdx].initData = new TextEncoder().encode(JSON.stringify(initData));\n                                }\n                            }\n                            if (pendingNeedKeyData[i][ksIdx].sessionId) {\n                                // Load MediaKeySession with sessionId\n                                loadKeySession(pendingNeedKeyData[i][ksIdx].sessionId, pendingNeedKeyData[i][ksIdx].initData);\n                            } else if (pendingNeedKeyData[i][ksIdx].initData !== null) {\n                                // Create new MediaKeySession with initData\n                                createKeySession(pendingNeedKeyData[i][ksIdx].initData, pendingNeedKeyData[i][ksIdx].cdmData);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } else {\n                keySystem = undefined;\n                if (!fromManifest) {\n                    eventBus.trigger(events.KEY_SYSTEM_SELECTED, {\n                        data: null,\n                        error: new DashJSError(ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, ProtectionErrors.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + 'Error selecting key system! -- ' + event.error)\n                    });\n                }\n            }\n        };\n\n        eventBus.on(events.INTERNAL_KEY_SYSTEM_SELECTED, onKeySystemSelected, self);\n        eventBus.on(events.KEY_SYSTEM_ACCESS_COMPLETE, onKeySystemAccessComplete, self);\n        protectionModel.requestKeySystemAccess(requestedKeySystems);\n    }\n\n    function sendLicenseRequestCompleteEvent(data, error) {\n        eventBus.trigger(events.LICENSE_REQUEST_COMPLETE, { data: data, error: error });\n    }\n\n    function onKeyStatusChanged(e) {\n        if (e.error) {\n            eventBus.trigger(events.KEY_STATUSES_CHANGED, { data: null, error: e.error });\n        } else {\n            logger.debug('DRM: key status = ' + e.status);\n        }\n    }\n\n    function onKeyMessage(e) {\n        logger.debug('DRM: onKeyMessage');\n\n        // Dispatch event to applications indicating we received a key message\n        const keyMessage = e.data;\n        eventBus.trigger(events.KEY_MESSAGE, { data: keyMessage });\n        const messageType = (keyMessage.messageType) ? keyMessage.messageType : 'license-request';\n        const message = keyMessage.message;\n        const sessionToken = keyMessage.sessionToken;\n        const protData = getProtData(keySystem);\n        const keySystemString = keySystem ? keySystem.systemString : null;\n        const licenseServerData = protectionKeyController.getLicenseServer(keySystem, protData, messageType);\n        const eventData = { sessionToken: sessionToken, messageType: messageType };\n\n        // Ensure message from CDM is not empty\n        if (!message || message.byteLength === 0) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE));\n            return;\n        }\n\n        // Message not destined for license server\n        if (!licenseServerData) {\n            logger.debug('DRM: License server request not required for this message (type = ' + e.data.messageType + ').  Session ID = ' + sessionToken.getSessionID());\n            sendLicenseRequestCompleteEvent(eventData);\n            return;\n        }\n\n        // Perform any special handling for ClearKey\n        if (protectionKeyController.isClearKey(keySystem)) {\n            const clearkeys = protectionKeyController.processClearKeyLicenseRequest(keySystem, protData, message);\n            if (clearkeys) {\n                logger.debug('DRM: ClearKey license request handled by application!');\n                sendLicenseRequestCompleteEvent(eventData);\n                protectionModel.updateKeySession(sessionToken, clearkeys);\n                return;\n            }\n        }\n\n        // All remaining key system scenarios require a request to a remote license server\n        // Determine license server URL\n        let url = null;\n        if (protData && protData.serverURL) {\n            const serverURL = protData.serverURL;\n            if (typeof serverURL === 'string' && serverURL !== '') {\n                url = serverURL;\n            } else if (typeof serverURL === 'object' && serverURL.hasOwnProperty(messageType)) {\n                url = serverURL[messageType];\n            }\n        } else if (protData && protData.laURL && protData.laURL !== '') {\n            // TODO: Deprecated!\n            url = protData.laURL;\n        } else {\n            // For clearkey use the url defined in the manifest\n            if (protectionKeyController.isClearKey(keySystem)) {\n                url = keySystem.getLicenseServerUrlFromMediaInfo(mediaInfoArr);\n            } else {\n                const psshData = CommonEncryption.getPSSHData(sessionToken.initData);\n                url = keySystem.getLicenseServerURLFromInitData(psshData);\n                if (!url) {\n                    url = e.data.laURL;\n                }\n            }\n        }\n        // Possibly update or override the URL based on the message\n        url = licenseServerData.getServerURLFromMessage(url, message, messageType);\n\n        // Ensure valid license server URL\n        if (!url) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE));\n            return;\n        }\n\n        // Set optional XMLHttpRequest headers from protection data and message\n        const reqHeaders = {};\n        let withCredentials = false;\n        const updateHeaders = function (headers) {\n            if (headers) {\n                for (const key in headers) {\n                    if ('authorization' === key.toLowerCase()) {\n                        withCredentials = true;\n                    }\n                    reqHeaders[key] = headers[key];\n                }\n            }\n        };\n        if (protData) {\n            updateHeaders(protData.httpRequestHeaders);\n        }\n        updateHeaders(keySystem.getRequestHeadersFromMessage(message));\n\n        // Overwrite withCredentials property from protData if present\n        if (protData && typeof protData.withCredentials == 'boolean') {\n            withCredentials = protData.withCredentials;\n        }\n\n        const reportError = function (xhr, eventData, keySystemString, messageType) {\n            const errorMsg = ((xhr.response) ? licenseServerData.getErrorResponse(xhr.response, keySystemString, messageType) : 'NONE');\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE,\n                ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR complete. status is \"' +\n                xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState + '.  Response is ' + errorMsg));\n        };\n\n        const onLoad = function (xhr) {\n            if (!protectionModel) {\n                return;\n            }\n\n            if (xhr.status === 200) {\n                let licenseResponse = new LicenseResponse(xhr.responseURL, Utils.parseHttpHeaders(xhr.getAllResponseHeaders ? xhr.getAllResponseHeaders() : null), xhr.response);\n                applyFilters(licenseResponseFilters, licenseResponse).then(() => {\n                    const licenseMessage = licenseServerData.getLicenseMessage(licenseResponse.data, keySystemString, messageType);\n                    if (licenseMessage !== null) {\n                        sendLicenseRequestCompleteEvent(eventData);\n                        protectionModel.updateKeySession(sessionToken, licenseMessage);\n                    } else {\n                        reportError(xhr, eventData, keySystemString, messageType);\n                    }\n                });\n            } else {\n                reportError(xhr, eventData, keySystemString, messageType);\n            }\n        };\n\n        const onAbort = function (xhr) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE,\n                ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR aborted. status is \"' +\n                xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n        };\n\n        const onError = function (xhr) {\n            sendLicenseRequestCompleteEvent(eventData, new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE,\n                ProtectionErrors.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + keySystemString + ' update, XHR error. status is \"' +\n                xhr.statusText + '\" (' + xhr.status + '), readyState is ' + xhr.readyState));\n        };\n\n        const reqPayload = keySystem.getLicenseRequestFromMessage(message);\n        const reqMethod = licenseServerData.getHTTPMethod(messageType);\n        const responseType = licenseServerData.getResponseType(keySystemString, messageType);\n        const timeout = protData && !isNaN(protData.httpTimeout) ? protData.httpTimeout : LICENSE_SERVER_REQUEST_DEFAULT_TIMEOUT;\n        const sessionId = sessionToken.getSessionID() || null;\n\n        let licenseRequest = new LicenseRequest(url, reqMethod, responseType, reqHeaders, withCredentials, messageType, sessionId, reqPayload);\n        applyFilters(licenseRequestFilters, licenseRequest).then(() => {\n            doLicenseRequest(licenseRequest, LICENSE_SERVER_REQUEST_RETRIES, timeout, onLoad, onAbort, onError);\n        });\n    }\n\n    // Implement license requests with a retry mechanism to avoid temporary network issues to affect playback experience\n    function doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError) {\n        const xhr = new XMLHttpRequest();\n\n        if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n            const cmcdMode = settings.get().streaming.cmcd.mode;\n            if (cmcdMode === Constants.CMCD_MODE_QUERY) {\n                const cmcdParams = cmcdModel.getQueryParameter({\n                    url: request.url,\n                    type: HTTPRequest.LICENSE\n                });\n\n                if (cmcdParams) {\n                    request.url = Utils.addAditionalQueryParameterToUrl(request.url, [cmcdParams]);\n                }\n            }\n        }\n\n        xhr.open(request.method, request.url, true);\n        xhr.responseType = request.responseType;\n        xhr.withCredentials = request.withCredentials;\n        if (timeout > 0) {\n            xhr.timeout = timeout;\n        }\n        for (const key in request.headers) {\n            xhr.setRequestHeader(key, request.headers[key]);\n        }\n\n        if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n            const cmcdMode = settings.get().streaming.cmcd.mode;\n            if (cmcdMode === Constants.CMCD_MODE_HEADER) {\n                const cmcdHeaders = cmcdModel.getHeaderParameters({\n                    url: request.url,\n                    type: HTTPRequest.LICENSE\n                });\n\n                if (cmcdHeaders) {\n                    for (const header in cmcdHeaders) {\n                        let value = cmcdHeaders[header];\n                        if (value) {\n                            xhr.setRequestHeader(header, value);\n                        }\n                    }\n                }\n            }\n        }\n\n        const retryRequest = function () {\n            // fail silently and retry\n            retriesCount--;\n            setTimeout(function () {\n                doLicenseRequest(request, retriesCount, timeout, onLoad, onAbort, onError);\n            }, LICENSE_SERVER_REQUEST_RETRY_INTERVAL);\n        };\n\n        xhr.onload = function () {\n            if (this.status === 200 || retriesCount <= 0) {\n                onLoad(this);\n            } else {\n                logger.warn('License request failed (' + this.status + '). Retrying it... Pending retries: ' + retriesCount);\n                retryRequest();\n            }\n        };\n\n        xhr.ontimeout = xhr.onerror = function () {\n            if (retriesCount <= 0) {\n                onError(this);\n            } else {\n                logger.warn('License request network request failed . Retrying it... Pending retries: ' + retriesCount);\n                retryRequest();\n            }\n        };\n\n        xhr.onabort = function () {\n            onAbort(this);\n        };\n\n        // deprecated, to be removed\n        eventBus.trigger(events.LICENSE_REQUEST_SENDING, {\n            url: request.url,\n            headers: request.headers,\n            payload: request.data,\n            sessionId: request.sessionId\n        });\n\n        xhr.send(request.data);\n    }\n\n    function onNeedKey(event, retry) {\n        logger.debug('DRM: onNeedKey');\n        // Ignore non-cenc initData\n        if (event.key.initDataType !== 'cenc') {\n            logger.warn('DRM:  Only \\'cenc\\' initData is supported!  Ignoring initData of type: ' + event.key.initDataType);\n            return;\n        }\n\n        if (mediaInfoArr.length === 0) {\n            logger.warn('DRM: onNeedKey called before initializeForMedia, wait until initialized');\n            retry = typeof retry === 'undefined' ? 1 : retry + 1;\n            if (retry < NEEDKEY_BEFORE_INITIALIZE_RETRIES) {\n                needkeyRetries.push(setTimeout(() => {\n                    onNeedKey(event, retry);\n                }, NEEDKEY_BEFORE_INITIALIZE_TIMEOUT));\n                return;\n            }\n\n        }\n\n        // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).\n        // Convert to ArrayBuffer\n        let abInitData = event.key.initData;\n        if (ArrayBuffer.isView(abInitData)) {\n            abInitData = abInitData.buffer;\n        }\n\n        // If key system has already been selected and initData already seen, then do nothing\n        if (keySystem) {\n            const initDataForKS = CommonEncryption.getPSSHForKeySystem(keySystem, abInitData);\n            if (initDataForKS) {\n\n                // Check for duplicate initData\n                if (_isInitDataDuplicate(initDataForKS)) {\n                    return;\n                }\n            }\n        }\n\n        logger.debug('DRM: initData:', String.fromCharCode.apply(null, new Uint8Array(abInitData)));\n\n        const supportedKS = protectionKeyController.getSupportedKeySystems(abInitData, protDataSet);\n        if (supportedKS.length === 0) {\n            logger.debug('DRM: Received needkey event with initData, but we don\\'t support any of the key systems!');\n            return;\n        }\n\n        selectKeySystem(supportedKS, false);\n    }\n\n    function getKeySystems() {\n        return protectionKeyController ? protectionKeyController.getKeySystems() : [];\n    }\n\n    function setKeySystems(keySystems) {\n        if (protectionKeyController) {\n            protectionKeyController.setKeySystems(keySystems);\n        }\n    }\n\n    function setLicenseRequestFilters (filters) {\n        licenseRequestFilters = filters;\n    }\n\n    function setLicenseResponseFilters (filters) {\n        licenseResponseFilters = filters;\n    }\n\n    function applyFilters (filters, param) {\n        if (!filters) return Promise.resolve();\n        return filters.reduce((prev, next) => {\n            return prev.then(() => {\n                return next(param);\n            });\n        }, Promise.resolve());\n    }\n\n    instance = {\n        initializeForMedia: initializeForMedia,\n        clearMediaInfoArrayByStreamId: clearMediaInfoArrayByStreamId,\n        createKeySession: createKeySession,\n        loadKeySession: loadKeySession,\n        removeKeySession: removeKeySession,\n        closeKeySession: closeKeySession,\n        setServerCertificate: setServerCertificate,\n        setMediaElement: setMediaElement,\n        setSessionType: setSessionType,\n        setRobustnessLevel: setRobustnessLevel,\n        setProtectionData: setProtectionData,\n        getSupportedKeySystemsFromContentProtection: getSupportedKeySystemsFromContentProtection,\n        getKeySystems: getKeySystems,\n        setKeySystems: setKeySystems,\n        setLicenseRequestFilters: setLicenseRequestFilters,\n        setLicenseResponseFilters: setLicenseResponseFilters,\n        stop: stop,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nProtectionController.__dashjs_factory_name = 'ProtectionController';\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionController); /* jshint ignore:line */\n"]},"metadata":{},"sourceType":"script"}