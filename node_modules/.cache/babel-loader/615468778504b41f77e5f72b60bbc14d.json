{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _DashJSError = require('./vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _TextController = require('./text/TextController');\n\nvar _TextController2 = _interopRequireDefault(_TextController);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MAX_ALLOWED_DISCONTINUITY = 0.1; // 100 milliseconds\n\n/**\n * @class SourceBufferSink\n * @ignore\n * @implements FragmentSink\n */\n\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      type = void 0,\n      logger = void 0,\n      buffer = void 0,\n      isAppendingInProgress = void 0,\n      intervalId = void 0;\n  var callbacks = [];\n  var appendQueue = [];\n  var onAppended = onAppendedCallback;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    isAppendingInProgress = false;\n    type = mediaInfo.type;\n    var codec = mediaInfo.codec;\n\n    try {\n      // Safari claims to support anything starting 'application/mp4'.\n      // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n      // - currently no browser does, so check for it and use our own\n      // implementation. The same is true for codecs=\"wvtt\".\n      if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n        throw new Error('not really supported');\n      }\n\n      buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\n\n      if (buffer.changeType && oldBuffer) {\n        logger.debug('Doing period transition with changeType');\n        buffer.changeType(codec);\n      }\n\n      updateAppendWindow();\n      var CHECK_INTERVAL = 50; // use updateend event if possible\n\n      if (typeof buffer.addEventListener === 'function') {\n        try {\n          buffer.addEventListener('updateend', updateEndHandler, false);\n          buffer.addEventListener('error', errHandler, false);\n          buffer.addEventListener('abort', errHandler, false);\n        } catch (err) {\n          // use setInterval to periodically check if updating has been completed\n          intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n        }\n      } else {\n        // use setInterval to periodically check if updating has been completed\n        intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n      }\n    } catch (ex) {\n      // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n      if (mediaInfo.isText || codec.indexOf('codecs=\"stpp') !== -1 || codec.indexOf('codecs=\"wvtt') !== -1) {\n        var textController = (0, _TextController2.default)(context).getInstance();\n        buffer = textController.getTextSourceBuffer();\n      } else {\n        throw ex;\n      }\n    }\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function reset(keepBuffer) {\n    if (buffer) {\n      if (typeof buffer.removeEventListener === 'function') {\n        buffer.removeEventListener('updateend', updateEndHandler, false);\n        buffer.removeEventListener('error', errHandler, false);\n        buffer.removeEventListener('abort', errHandler, false);\n      }\n\n      clearInterval(intervalId);\n      callbacks = [];\n\n      if (!keepBuffer) {\n        try {\n          if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\n            logger.debug('Removing sourcebuffer from media source');\n            mediaSource.removeSourceBuffer(buffer);\n          }\n        } catch (e) {\n          logger.error('Failed to remove source buffer from media source.');\n        }\n\n        buffer = null;\n      }\n\n      isAppendingInProgress = false;\n    }\n\n    appendQueue = [];\n    onAppended = null;\n  }\n\n  function getBuffer() {\n    return buffer;\n  }\n\n  function getAllBufferRanges() {\n    try {\n      return buffer.buffered;\n    } catch (e) {\n      logger.error('getAllBufferRanges exception: ' + e.message);\n      return null;\n    }\n  }\n\n  function hasDiscontinuitiesAfter(time) {\n    try {\n      var ranges = getAllBufferRanges();\n\n      if (ranges && ranges.length > 1) {\n        for (var i = 0, len = ranges.length; i < len; i++) {\n          if (i > 0) {\n            if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      logger.error('hasDiscontinuities exception: ' + e.message);\n    }\n\n    return false;\n  }\n\n  function append(chunk) {\n    if (!chunk) {\n      onAppended({\n        chunk: chunk,\n        error: new _DashJSError2.default(_Errors2.default.APPEND_ERROR_CODE, _Errors2.default.APPEND_ERROR_MESSAGE)\n      });\n      return;\n    }\n\n    appendQueue.push(chunk);\n\n    if (!isAppendingInProgress) {\n      waitForUpdateEnd(appendNextInQueue.bind(this));\n    }\n  }\n\n  function updateTimestampOffset(MSETimeOffset) {\n    if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n      waitForUpdateEnd(function () {\n        if (MSETimeOffset < 0) {\n          MSETimeOffset += 0.001;\n        }\n\n        buffer.timestampOffset = MSETimeOffset;\n      });\n    }\n  }\n\n  function updateAppendWindow(sInfo) {\n    if (!buffer) {\n      return;\n    }\n\n    waitForUpdateEnd(function () {\n      try {\n        var appendWindowEnd = mediaSource.duration;\n        var appendWindowStart = 0;\n\n        if (sInfo && !isNaN(sInfo.start) && !isNaN(sInfo.duration) && isFinite(sInfo.duration)) {\n          appendWindowEnd = sInfo.start + sInfo.duration;\n        }\n\n        if (sInfo && !isNaN(sInfo.start)) {\n          appendWindowStart = sInfo.start;\n        }\n\n        buffer.appendWindowStart = 0;\n        buffer.appendWindowEnd = appendWindowEnd;\n        buffer.appendWindowStart = appendWindowStart;\n        logger.debug('Updated append window. Set start to ' + buffer.appendWindowStart + ' and end to ' + buffer.appendWindowEnd);\n      } catch (e) {\n        logger.warn('Failed to set append window');\n      }\n    });\n  }\n\n  function remove(start, end, forceRemoval) {\n    var sourceBufferSink = this; // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n\n    waitForUpdateEnd(function () {\n      try {\n        if (start >= 0 && end > start && (forceRemoval || mediaSource.readyState !== 'ended')) {\n          buffer.remove(start, end);\n        } // updating is in progress, we should wait for it to complete before signaling that this operation is done\n\n\n        waitForUpdateEnd(function () {\n          eventBus.trigger(_Events2.default.SOURCEBUFFER_REMOVE_COMPLETED, {\n            buffer: sourceBufferSink,\n            from: start,\n            to: end,\n            unintended: false\n          });\n        });\n      } catch (err) {\n        eventBus.trigger(_Events2.default.SOURCEBUFFER_REMOVE_COMPLETED, {\n          buffer: sourceBufferSink,\n          from: start,\n          to: end,\n          unintended: false,\n          error: new _DashJSError2.default(err.code, err.message)\n        });\n      }\n    });\n  }\n\n  function appendNextInQueue() {\n    var sourceBufferSink = this;\n\n    if (appendQueue.length > 0) {\n      isAppendingInProgress = true;\n      var nextChunk = appendQueue[0];\n      appendQueue.splice(0, 1);\n      var oldRanges = [];\n\n      var afterSuccess = function afterSuccess() {\n        // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\n        var newRanges = getAllBufferRanges();\n        checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\n\n        if (appendQueue.length > 0) {\n          appendNextInQueue.call(this);\n        } else {\n          isAppendingInProgress = false;\n\n          if (onAppended) {\n            onAppended({\n              chunk: nextChunk\n            });\n          }\n        }\n      };\n\n      try {\n        if (nextChunk.bytes.length === 0) {\n          afterSuccess.call(this);\n        } else {\n          oldRanges = getAllBufferRanges();\n\n          if (buffer.appendBuffer) {\n            buffer.appendBuffer(nextChunk.bytes);\n          } else {\n            buffer.append(nextChunk.bytes, nextChunk);\n          } // updating is in progress, we should wait for it to complete before signaling that this operation is done\n\n\n          waitForUpdateEnd(afterSuccess.bind(this));\n        }\n      } catch (err) {\n        logger.fatal('SourceBuffer append failed \"' + err + '\"');\n\n        if (appendQueue.length > 0) {\n          appendNextInQueue();\n        } else {\n          isAppendingInProgress = false;\n        }\n\n        if (onAppended) {\n          onAppended({\n            chunk: nextChunk,\n            error: new _DashJSError2.default(err.code, err.message)\n          });\n        }\n      }\n    }\n  }\n\n  function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\n    if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length && isChunkAlignedWithRange(oldRanges, chunk)) {\n      // A split in the range was created while appending\n      eventBus.trigger(_Events2.default.SOURCEBUFFER_REMOVE_COMPLETED, {\n        buffer: buffer,\n        from: newRanges.end(newRanges.length - 2),\n        to: newRanges.start(newRanges.length - 1),\n        unintended: true\n      });\n    }\n  }\n\n  function isChunkAlignedWithRange(oldRanges, chunk) {\n    for (var i = 0; i < oldRanges.length; i++) {\n      var start = Math.round(oldRanges.start(i));\n      var end = Math.round(oldRanges.end(i));\n\n      if (end === chunk.start || start === chunk.end || chunk.start >= start && chunk.end <= end) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function abort() {\n    try {\n      if (mediaSource.readyState === 'open') {\n        buffer.abort();\n      } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n        buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n      }\n    } catch (ex) {\n      logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\n    }\n\n    appendQueue = [];\n  }\n\n  function executeCallback() {\n    if (callbacks.length > 0) {\n      var cb = callbacks.shift();\n\n      if (buffer.updating) {\n        waitForUpdateEnd(cb);\n      } else {\n        cb(); // Try to execute next callback if still not updating\n\n        executeCallback();\n      }\n    }\n  }\n\n  function checkIsUpdateEnded() {\n    // if updating is still in progress do nothing and wait for the next check again.\n    if (buffer.updating) return; // updating is completed, now we can stop checking and resolve the promise\n\n    executeCallback();\n  }\n\n  function updateEndHandler() {\n    if (buffer.updating) return;\n    executeCallback();\n  }\n\n  function errHandler() {\n    logger.error('SourceBufferSink error');\n  }\n\n  function waitForUpdateEnd(callback) {\n    callbacks.push(callback);\n\n    if (!buffer.updating) {\n      executeCallback();\n    }\n  }\n\n  instance = {\n    getType: getType,\n    getAllBufferRanges: getAllBufferRanges,\n    getBuffer: getBuffer,\n    append: append,\n    remove: remove,\n    abort: abort,\n    reset: reset,\n    updateTimestampOffset: updateTimestampOffset,\n    hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n    waitForUpdateEnd: waitForUpdateEnd,\n    updateAppendWindow: updateAppendWindow\n  };\n  setup();\n  return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\n\nvar factory = _FactoryMaker2.default.getClassFactory(SourceBufferSink);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../src/streaming/SourceBufferSink.js"],"names":["MAX_ALLOWED_DISCONTINUITY","context","eventBus","instance","type","logger","buffer","isAppendingInProgress","intervalId","callbacks","appendQueue","onAppended","mediaInfo","codec","oldBuffer","mediaSource","updateAppendWindow","CHECK_INTERVAL","setInterval","textController","clearInterval","e","ranges","getAllBufferRanges","i","len","time","chunk","error","DashJSError","Errors","waitForUpdateEnd","appendNextInQueue","isNaN","MSETimeOffset","appendWindowEnd","appendWindowStart","sInfo","isFinite","sourceBufferSink","start","end","forceRemoval","Events","from","to","unintended","err","nextChunk","oldRanges","afterSuccess","newRanges","checkBufferGapsAfterAppend","isChunkAlignedWithRange","Math","cb","executeCallback","getType","getBuffer","append","remove","abort","reset","updateTimestampOffset","hasDiscontinuitiesAfter","setup","SourceBufferSink","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport DashJSError from './vo/DashJSError';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport TextController from './text/TextController';\nimport Errors from '../core/errors/Errors';\n\nconst MAX_ALLOWED_DISCONTINUITY = 0.1; // 100 milliseconds\n\n/**\n * @class SourceBufferSink\n * @ignore\n * @implements FragmentSink\n */\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        type,\n        logger,\n        buffer,\n        isAppendingInProgress,\n        intervalId;\n\n    let callbacks = [];\n    let appendQueue = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        isAppendingInProgress = false;\n\n        type = mediaInfo.type;\n        const codec = mediaInfo.codec;\n        try {\n            // Safari claims to support anything starting 'application/mp4'.\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n            // - currently no browser does, so check for it and use our own\n            // implementation. The same is true for codecs=\"wvtt\".\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n                throw new Error('not really supported');\n            }\n            buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\n            if (buffer.changeType && oldBuffer) {\n                logger.debug('Doing period transition with changeType');\n                buffer.changeType(codec);\n            }\n\n            updateAppendWindow();\n\n            const CHECK_INTERVAL = 50;\n            // use updateend event if possible\n            if (typeof buffer.addEventListener === 'function') {\n                try {\n                    buffer.addEventListener('updateend', updateEndHandler, false);\n                    buffer.addEventListener('error', errHandler, false);\n                    buffer.addEventListener('abort', errHandler, false);\n\n                } catch (err) {\n                    // use setInterval to periodically check if updating has been completed\n                    intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n                }\n            } else {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } catch (ex) {\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\n                const textController = TextController(context).getInstance();\n                buffer = textController.getTextSourceBuffer();\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function reset(keepBuffer) {\n        if (buffer) {\n            if (typeof buffer.removeEventListener === 'function') {\n                buffer.removeEventListener('updateend', updateEndHandler, false);\n                buffer.removeEventListener('error', errHandler, false);\n                buffer.removeEventListener('abort', errHandler, false);\n            }\n            clearInterval(intervalId);\n            callbacks = [];\n            if (!keepBuffer) {\n                try {\n                    if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\n                        logger.debug(`Removing sourcebuffer from media source`);\n                        mediaSource.removeSourceBuffer(buffer);\n                    }\n                } catch (e) {\n                    logger.error('Failed to remove source buffer from media source.');\n                }\n                buffer = null;\n            }\n            isAppendingInProgress = false;\n        }\n        appendQueue = [];\n        onAppended = null;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function getAllBufferRanges() {\n        try {\n            return buffer.buffered;\n        } catch (e) {\n            logger.error('getAllBufferRanges exception: ' + e.message);\n            return null;\n        }\n    }\n\n    function hasDiscontinuitiesAfter(time) {\n        try {\n            const ranges = getAllBufferRanges();\n            if (ranges && ranges.length > 1) {\n                for (let i = 0, len = ranges.length; i < len; i++) {\n                    if (i > 0) {\n                        if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            logger.error('hasDiscontinuities exception: ' + e.message);\n        }\n        return false;\n    }\n\n    function append(chunk) {\n        if (!chunk) {\n            onAppended({\n                chunk: chunk,\n                error: new DashJSError(Errors.APPEND_ERROR_CODE, Errors.APPEND_ERROR_MESSAGE)\n            });\n            return;\n        }\n        appendQueue.push(chunk);\n        if (!isAppendingInProgress) {\n            waitForUpdateEnd(appendNextInQueue.bind(this));\n        }\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            waitForUpdateEnd(() => {\n                if (MSETimeOffset < 0) {\n                    MSETimeOffset += 0.001;\n                }\n                buffer.timestampOffset = MSETimeOffset;\n            });\n        }\n    }\n\n    function updateAppendWindow(sInfo) {\n        if (!buffer) {\n            return;\n        }\n        waitForUpdateEnd(() => {\n            try {\n                let appendWindowEnd = mediaSource.duration;\n                let appendWindowStart = 0;\n                if (sInfo && !isNaN(sInfo.start) && !isNaN(sInfo.duration) && isFinite(sInfo.duration)) {\n                    appendWindowEnd = sInfo.start + sInfo.duration;\n                }\n                if (sInfo && !isNaN(sInfo.start)) {\n                    appendWindowStart = sInfo.start;\n                }\n                buffer.appendWindowStart = 0;\n                buffer.appendWindowEnd = appendWindowEnd;\n                buffer.appendWindowStart = appendWindowStart;\n                logger.debug(`Updated append window. Set start to ${buffer.appendWindowStart} and end to ${buffer.appendWindowEnd}`);\n            } catch (e) {\n                logger.warn(`Failed to set append window`);\n            }\n        });\n    }\n\n    function remove(start, end, forceRemoval) {\n        const sourceBufferSink = this;\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n        waitForUpdateEnd(function () {\n            try {\n                if ((start >= 0) && (end > start) && (forceRemoval || mediaSource.readyState !== 'ended')) {\n                    buffer.remove(start, end);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                        buffer: sourceBufferSink,\n                        from: start,\n                        to: end,\n                        unintended: false\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                    buffer: sourceBufferSink,\n                    from: start,\n                    to: end,\n                    unintended: false,\n                    error: new DashJSError(err.code, err.message)\n                });\n            }\n        });\n    }\n\n    function appendNextInQueue() {\n        const sourceBufferSink = this;\n\n        if (appendQueue.length > 0) {\n            isAppendingInProgress = true;\n            const nextChunk = appendQueue[0];\n            appendQueue.splice(0, 1);\n            let oldRanges = [];\n            const afterSuccess = function () {\n                // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\n                const newRanges = getAllBufferRanges();\n                checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\n                if (appendQueue.length > 0) {\n                    appendNextInQueue.call(this);\n                } else {\n                    isAppendingInProgress = false;\n                    if (onAppended) {\n                        onAppended({\n                            chunk: nextChunk\n                        });\n                    }\n                }\n            };\n\n            try {\n                if (nextChunk.bytes.length === 0) {\n                    afterSuccess.call(this);\n                } else {\n                    oldRanges = getAllBufferRanges();\n                    if (buffer.appendBuffer) {\n                        buffer.appendBuffer(nextChunk.bytes);\n                    } else {\n                        buffer.append(nextChunk.bytes, nextChunk);\n                    }\n                    // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                    waitForUpdateEnd(afterSuccess.bind(this));\n                }\n            } catch (err) {\n                logger.fatal('SourceBuffer append failed \"' + err + '\"');\n                if (appendQueue.length > 0) {\n                    appendNextInQueue();\n                } else {\n                    isAppendingInProgress = false;\n                }\n\n                if (onAppended) {\n                    onAppended({\n                        chunk: nextChunk,\n                        error: new DashJSError(err.code, err.message)\n                    });\n                }\n            }\n        }\n    }\n\n    function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\n        if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length &&\n            isChunkAlignedWithRange(oldRanges, chunk)) {\n            // A split in the range was created while appending\n            eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                buffer: buffer,\n                from: newRanges.end(newRanges.length - 2),\n                to: newRanges.start(newRanges.length - 1),\n                unintended: true\n            });\n        }\n    }\n\n    function isChunkAlignedWithRange(oldRanges, chunk) {\n        for (let i = 0; i < oldRanges.length; i++) {\n            const start = Math.round(oldRanges.start(i));\n            const end = Math.round(oldRanges.end(i));\n            if (end === chunk.start || start === chunk.end || (chunk.start >= start && chunk.end <= end)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function abort() {\n        try {\n            if (mediaSource.readyState === 'open') {\n                buffer.abort();\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n            }\n        } catch (ex) {\n            logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\n        }\n        appendQueue = [];\n    }\n\n    function executeCallback() {\n        if (callbacks.length > 0) {\n            const cb = callbacks.shift();\n            if (buffer.updating) {\n                waitForUpdateEnd(cb);\n            } else {\n                cb();\n                // Try to execute next callback if still not updating\n                executeCallback();\n            }\n        }\n    }\n\n    function checkIsUpdateEnded() {\n        // if updating is still in progress do nothing and wait for the next check again.\n        if (buffer.updating) return;\n        // updating is completed, now we can stop checking and resolve the promise\n        executeCallback();\n    }\n\n    function updateEndHandler() {\n        if (buffer.updating) return;\n\n        executeCallback();\n    }\n\n    function errHandler() {\n        logger.error('SourceBufferSink error');\n    }\n\n    function waitForUpdateEnd(callback) {\n        callbacks.push(callback);\n\n        if (!buffer.updating) {\n            executeCallback();\n        }\n    }\n\n    instance = {\n        getType: getType,\n        getAllBufferRanges: getAllBufferRanges,\n        getBuffer: getBuffer,\n        append: append,\n        remove: remove,\n        abort: abort,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n        waitForUpdateEnd: waitForUpdateEnd,\n        updateAppendWindow\n    };\n\n    setup();\n\n    return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\nconst factory = FactoryMaker.getClassFactory(SourceBufferSink);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}