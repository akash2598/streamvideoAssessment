{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction MediaController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      tracks = void 0,\n      settings = void 0,\n      initialSettings = void 0,\n      domStorage = void 0;\n  var validTrackSwitchModes = [_Constants2.default.TRACK_SWITCH_MODE_ALWAYS_REPLACE, _Constants2.default.TRACK_SWITCH_MODE_NEVER_REPLACE];\n  var validTrackSelectionModes = [_Constants2.default.TRACK_SELECTION_MODE_HIGHEST_BITRATE, _Constants2.default.TRACK_SELECTION_MODE_FIRST_TRACK, _Constants2.default.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY, _Constants2.default.TRACK_SELECTION_MODE_WIDEST_RANGE];\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    reset();\n  }\n  /**\n  * @param {string} type\n  * @param {StreamInfo} streamInfo\n  * @memberof MediaController#\n  */\n\n\n  function checkInitialMediaSettingsForType(type, streamInfo) {\n    var settings = getInitialSettings(type);\n    var tracksForType = getTracksFor(type, streamInfo);\n    var tracks = [];\n\n    if (!settings) {\n      settings = domStorage.getSavedMediaSettings(type);\n      setInitialSettings(type, settings);\n    }\n\n    if (!tracksForType || tracksForType.length === 0) return;\n\n    if (settings) {\n      tracksForType.forEach(function (track) {\n        if (matchSettings(settings, track)) {\n          tracks.push(track);\n        }\n      });\n    }\n\n    if (tracks.length === 0) {\n      setTrack(this.selectInitialTrack(type, tracksForType), true);\n    } else {\n      if (tracks.length > 1) {\n        setTrack(this.selectInitialTrack(type, tracks));\n      } else {\n        setTrack(tracks[0]);\n      }\n    }\n  }\n  /**\n  * @param {MediaInfo} track\n  * @memberof MediaController#\n  */\n\n\n  function addTrack(track) {\n    if (!track) return;\n    var mediaType = track.type;\n    if (!isMultiTrackSupportedByType(mediaType)) return;\n    var streamId = track.streamInfo.id;\n\n    if (!tracks[streamId]) {\n      tracks[streamId] = createTrackInfo();\n    }\n\n    var mediaTracks = tracks[streamId][mediaType].list;\n\n    for (var i = 0, len = mediaTracks.length; i < len; ++i) {\n      //track is already set.\n      if (isTracksEqual(mediaTracks[i], track)) {\n        return;\n      }\n    }\n\n    mediaTracks.push(track);\n    var initSettings = getInitialSettings(mediaType);\n\n    if (initSettings && matchSettings(initSettings, track) && !getCurrentTrackFor(mediaType, track.streamInfo)) {\n      setTrack(track);\n    }\n  }\n  /**\n  * @param {string} type\n  * @param {StreamInfo} streamInfo\n  * @returns {Array}\n  * @memberof MediaController#\n  */\n\n\n  function getTracksFor(type, streamInfo) {\n    if (!type || !streamInfo) return [];\n    var id = streamInfo.id;\n    if (!tracks[id] || !tracks[id][type]) return [];\n    return tracks[id][type].list;\n  }\n  /**\n  * @param {string} type\n  * @param {StreamInfo} streamInfo\n  * @returns {Object|null}\n  * @memberof MediaController#\n  */\n\n\n  function getCurrentTrackFor(type, streamInfo) {\n    if (!type || !streamInfo || streamInfo && !tracks[streamInfo.id]) return null;\n    return tracks[streamInfo.id][type].current;\n  }\n  /**\n  * @param {MediaInfo} track\n  * @returns {boolean}\n  * @memberof MediaController#\n  */\n\n\n  function isCurrentTrack(track) {\n    if (!track) {\n      return false;\n    }\n\n    var type = track.type;\n    var id = track.streamInfo.id;\n    return tracks[id] && tracks[id][type] && isTracksEqual(tracks[id][type].current, track);\n  }\n  /**\n  * @param {MediaInfo} track\n  * @param {boolean} noSettingsSave specify if settings must be not be saved\n  * @memberof MediaController#\n  */\n\n\n  function setTrack(track, noSettingsSave) {\n    if (!track || !track.streamInfo) return;\n    var type = track.type;\n    var streamInfo = track.streamInfo;\n    var id = streamInfo.id;\n    var current = getCurrentTrackFor(type, streamInfo);\n    if (!tracks[id] || !tracks[id][type] || isTracksEqual(track, current)) return;\n    tracks[id][type].current = track;\n\n    if (tracks[id][type].current && !(noSettingsSave && type === _Constants2.default.FRAGMENTED_TEXT)) {\n      eventBus.trigger(_Events2.default.CURRENT_TRACK_CHANGED, {\n        oldMediaInfo: current,\n        newMediaInfo: track,\n        switchMode: getSwitchMode(type)\n      });\n    }\n\n    if (!noSettingsSave) {\n      var _settings = extractSettings(track);\n\n      if (!_settings || !tracks[id][type].storeLastSettings) return;\n\n      if (_settings.roles) {\n        _settings.role = _settings.roles[0];\n        delete _settings.roles;\n      }\n\n      if (_settings.accessibility) {\n        _settings.accessibility = _settings.accessibility[0];\n      }\n\n      if (_settings.audioChannelConfiguration) {\n        _settings.audioChannelConfiguration = _settings.audioChannelConfiguration[0];\n      }\n\n      domStorage.setSavedMediaSettings(type, _settings);\n    }\n  }\n  /**\n  * @param {string} type\n  * @param {Object} value\n  * @memberof MediaController#\n  */\n\n\n  function setInitialSettings(type, value) {\n    if (!type || !value) return;\n    initialSettings[type] = value;\n  }\n  /**\n  * @param {string} type\n  * @returns {Object|null}\n  * @memberof MediaController#\n  */\n\n\n  function getInitialSettings(type) {\n    if (!type) return null;\n    return initialSettings[type];\n  }\n  /**\n  * @memberof MediaController#\n  */\n\n\n  function saveTextSettingsDisabled() {\n    domStorage.setSavedMediaSettings(_Constants2.default.FRAGMENTED_TEXT, null);\n  }\n  /**\n  * @param {string} type\n  * @param {string} mode\n  * @memberof MediaController#\n  * @deprecated Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead\n  */\n\n\n  function setSwitchMode(type, mode) {\n    logger.warn('deprecated: Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead');\n    var isModeSupported = validTrackSwitchModes.indexOf(mode) !== -1;\n\n    if (!isModeSupported) {\n      logger.warn('Track switch mode is not supported: ' + mode);\n      return;\n    }\n\n    var switchMode = {};\n    switchMode[type] = mode;\n    settings.update({\n      streaming: {\n        trackSwitchMode: switchMode\n      }\n    });\n  }\n  /**\n  * @param {string} type\n  * @returns {string} mode\n  * @memberof MediaController#\n  */\n\n\n  function getSwitchMode(type) {\n    return settings.get().streaming.trackSwitchMode[type];\n  }\n  /**\n  * @param {string} mode\n  * @memberof MediaController#\n  * @deprecated Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead\n  */\n\n\n  function setSelectionModeForInitialTrack(mode) {\n    logger.warn('deprecated: Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead');\n    var isModeSupported = validTrackSelectionModes.indexOf(mode) !== -1;\n\n    if (!isModeSupported) {\n      logger.warn('Track selection mode is not supported: ' + mode);\n      return;\n    }\n\n    settings.update({\n      streaming: {\n        selectionModeForInitialTrack: mode\n      }\n    });\n  }\n  /**\n  * @returns {string} mode\n  * @memberof MediaController#\n  */\n\n\n  function getSelectionModeForInitialTrack() {\n    return settings.get().streaming.selectionModeForInitialTrack;\n  }\n  /**\n  * @param {string} type\n  * @returns {boolean}\n  * @memberof MediaController#\n  */\n\n\n  function isMultiTrackSupportedByType(type) {\n    return type === _Constants2.default.AUDIO || type === _Constants2.default.VIDEO || type === _Constants2.default.TEXT || type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.IMAGE;\n  }\n  /**\n  * @param {MediaInfo} t1 - first track to compare\n  * @param {MediaInfo} t2 - second track to compare\n  * @returns {boolean}\n  * @memberof MediaController#\n  */\n\n\n  function isTracksEqual(t1, t2) {\n    if (!t1 && !t2) {\n      return true;\n    }\n\n    if (!t1 || !t2) {\n      return false;\n    }\n\n    var sameId = t1.id === t2.id;\n    var sameViewpoint = t1.viewpoint === t2.viewpoint;\n    var sameLang = t1.lang === t2.lang;\n    var sameRoles = t1.roles.toString() === t2.roles.toString();\n    var sameAccessibility = t1.accessibility.toString() === t2.accessibility.toString();\n    var sameAudioChannelConfiguration = t1.audioChannelConfiguration.toString() === t2.audioChannelConfiguration.toString();\n    return sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.domStorage) {\n      domStorage = config.domStorage;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n  /**\n  * @memberof MediaController#\n  */\n\n\n  function reset() {\n    tracks = {};\n    resetInitialSettings();\n  }\n\n  function extractSettings(mediaInfo) {\n    var settings = {\n      lang: mediaInfo.lang,\n      viewpoint: mediaInfo.viewpoint,\n      roles: mediaInfo.roles,\n      accessibility: mediaInfo.accessibility,\n      audioChannelConfiguration: mediaInfo.audioChannelConfiguration\n    };\n    var notEmpty = settings.lang || settings.viewpoint || settings.role && settings.role.length > 0 || settings.accessibility && settings.accessibility.length > 0 || settings.audioChannelConfiguration && settings.audioChannelConfiguration.length > 0;\n    return notEmpty ? settings : null;\n  }\n\n  function matchSettings(settings, track) {\n    var matchLang = !settings.lang || track.lang.match(settings.lang);\n    var matchIndex = settings.index === undefined || settings.index === null || track.index === settings.index;\n    var matchViewPoint = !settings.viewpoint || settings.viewpoint === track.viewpoint;\n    var matchRole = !settings.role || !!track.roles.filter(function (item) {\n      return item === settings.role;\n    })[0];\n    var matchAccessibility = !settings.accessibility || !!track.accessibility.filter(function (item) {\n      return item === settings.accessibility;\n    })[0];\n    var matchAudioChannelConfiguration = !settings.audioChannelConfiguration || !!track.audioChannelConfiguration.filter(function (item) {\n      return item === settings.audioChannelConfiguration;\n    })[0];\n    return matchLang && matchIndex && matchViewPoint && matchRole && matchAccessibility && matchAudioChannelConfiguration;\n  }\n\n  function resetInitialSettings() {\n    initialSettings = {\n      audio: null,\n      video: null,\n      fragmentedText: null\n    };\n  }\n\n  function getTracksWithHighestBitrate(trackArr) {\n    var max = 0;\n    var result = [];\n    var tmp = void 0;\n    trackArr.forEach(function (track) {\n      tmp = Math.max.apply(Math, track.bitrateList.map(function (obj) {\n        return obj.bandwidth;\n      }));\n\n      if (tmp > max) {\n        max = tmp;\n        result = [track];\n      } else if (tmp === max) {\n        result.push(track);\n      }\n    });\n    return result;\n  }\n\n  function getTracksWithHighestEfficiency(trackArr) {\n    var min = Infinity;\n    var result = [];\n    var tmp = void 0;\n    trackArr.forEach(function (track) {\n      var sum = track.bitrateList.reduce(function (acc, obj) {\n        var resolution = Math.max(1, obj.width * obj.height);\n        var efficiency = obj.bandwidth / resolution;\n        return acc + efficiency;\n      }, 0);\n      tmp = sum / track.bitrateList.length;\n\n      if (tmp < min) {\n        min = tmp;\n        result = [track];\n      } else if (tmp === min) {\n        result.push(track);\n      }\n    });\n    return result;\n  }\n\n  function getTracksWithWidestRange(trackArr) {\n    var max = 0;\n    var result = [];\n    var tmp = void 0;\n    trackArr.forEach(function (track) {\n      tmp = track.representationCount;\n\n      if (tmp > max) {\n        max = tmp;\n        result = [track];\n      } else if (tmp === max) {\n        result.push(track);\n      }\n    });\n    return result;\n  }\n\n  function selectInitialTrack(type, tracks) {\n    if (type === _Constants2.default.FRAGMENTED_TEXT) return tracks[0];\n    var mode = getSelectionModeForInitialTrack();\n    var tmpArr = [];\n\n    switch (mode) {\n      case _Constants2.default.TRACK_SELECTION_MODE_HIGHEST_BITRATE:\n        tmpArr = getTracksWithHighestBitrate(tracks);\n\n        if (tmpArr.length > 1) {\n          tmpArr = getTracksWithWidestRange(tmpArr);\n        }\n\n        break;\n\n      case _Constants2.default.TRACK_SELECTION_MODE_FIRST_TRACK:\n        tmpArr.push(tracks[0]);\n        break;\n\n      case _Constants2.default.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY:\n        tmpArr = getTracksWithHighestEfficiency(tracks);\n\n        if (tmpArr.length > 1) {\n          tmpArr = getTracksWithHighestBitrate(tmpArr);\n        }\n\n        break;\n\n      case _Constants2.default.TRACK_SELECTION_MODE_WIDEST_RANGE:\n        tmpArr = getTracksWithWidestRange(tracks);\n\n        if (tmpArr.length > 1) {\n          tmpArr = getTracksWithHighestBitrate(tracks);\n        }\n\n        break;\n\n      default:\n        logger.warn('Track selection mode is not supported: ' + mode);\n        break;\n    }\n\n    return tmpArr[0];\n  }\n\n  function createTrackInfo() {\n    return {\n      audio: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      video: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      text: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      fragmentedText: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      },\n      image: {\n        list: [],\n        storeLastSettings: true,\n        current: null\n      }\n    };\n  }\n\n  instance = {\n    checkInitialMediaSettingsForType: checkInitialMediaSettingsForType,\n    addTrack: addTrack,\n    getTracksFor: getTracksFor,\n    getCurrentTrackFor: getCurrentTrackFor,\n    isCurrentTrack: isCurrentTrack,\n    setTrack: setTrack,\n    setInitialSettings: setInitialSettings,\n    getInitialSettings: getInitialSettings,\n    setSwitchMode: setSwitchMode,\n    getSwitchMode: getSwitchMode,\n    selectInitialTrack: selectInitialTrack,\n    getTracksWithHighestBitrate: getTracksWithHighestBitrate,\n    getTracksWithHighestEfficiency: getTracksWithHighestEfficiency,\n    getTracksWithWidestRange: getTracksWithWidestRange,\n    setSelectionModeForInitialTrack: setSelectionModeForInitialTrack,\n    getSelectionModeForInitialTrack: getSelectionModeForInitialTrack,\n    isMultiTrackSupportedByType: isMultiTrackSupportedByType,\n    isTracksEqual: isTracksEqual,\n    matchSettings: matchSettings,\n    saveTextSettingsDisabled: saveTextSettingsDisabled,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nMediaController.__dashjs_factory_name = 'MediaController';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(MediaController);\n\n_FactoryMaker2.default.updateSingletonFactory(MediaController.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../src/streaming/controllers/MediaController.js"],"names":["context","eventBus","instance","logger","tracks","settings","initialSettings","domStorage","validTrackSwitchModes","Constants","validTrackSelectionModes","reset","getInitialSettings","tracksForType","getTracksFor","setInitialSettings","matchSettings","setTrack","mediaType","track","isMultiTrackSupportedByType","streamId","createTrackInfo","mediaTracks","i","len","isTracksEqual","initSettings","getCurrentTrackFor","id","streamInfo","type","current","noSettingsSave","Events","oldMediaInfo","newMediaInfo","switchMode","getSwitchMode","extractSettings","isModeSupported","streaming","trackSwitchMode","selectionModeForInitialTrack","sameId","t1","t2","sameViewpoint","sameLang","sameRoles","sameAccessibility","sameAudioChannelConfiguration","config","resetInitialSettings","lang","mediaInfo","viewpoint","roles","accessibility","audioChannelConfiguration","notEmpty","matchLang","matchIndex","matchViewPoint","matchRole","item","matchAccessibility","matchAudioChannelConfiguration","audio","video","fragmentedText","max","result","tmp","trackArr","Math","obj","min","sum","resolution","efficiency","acc","mode","getSelectionModeForInitialTrack","tmpArr","getTracksWithHighestBitrate","getTracksWithWidestRange","getTracksWithHighestEfficiency","list","storeLastSettings","text","image","checkInitialMediaSettingsForType","addTrack","isCurrentTrack","setSwitchMode","selectInitialTrack","setSelectionModeForInitialTrack","saveTextSettingsDisabled","setConfig","setup","MediaController","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport Events from '../../core/events/Events';\nimport EventBus from '../../core/EventBus';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nfunction MediaController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        tracks,\n        settings,\n        initialSettings,\n        domStorage;\n\n    const validTrackSwitchModes = [\n        Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,\n        Constants.TRACK_SWITCH_MODE_NEVER_REPLACE\n    ];\n\n    const validTrackSelectionModes = [\n        Constants.TRACK_SELECTION_MODE_HIGHEST_BITRATE,\n        Constants.TRACK_SELECTION_MODE_FIRST_TRACK,\n        Constants.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY,\n        Constants.TRACK_SELECTION_MODE_WIDEST_RANGE\n    ];\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        reset();\n    }\n\n    /**\n     * @param {string} type\n     * @param {StreamInfo} streamInfo\n     * @memberof MediaController#\n     */\n    function checkInitialMediaSettingsForType(type, streamInfo) {\n        let settings = getInitialSettings(type);\n        const tracksForType = getTracksFor(type, streamInfo);\n        const tracks = [];\n\n        if (!settings) {\n            settings = domStorage.getSavedMediaSettings(type);\n            setInitialSettings(type, settings);\n        }\n\n        if (!tracksForType || (tracksForType.length === 0)) return;\n\n        if (settings) {\n            tracksForType.forEach(function (track) {\n                if (matchSettings(settings, track)) {\n                    tracks.push(track);\n                }\n            });\n        }\n\n        if (tracks.length === 0) {\n            setTrack(this.selectInitialTrack(type, tracksForType), true);\n        } else {\n            if (tracks.length > 1) {\n                setTrack(this.selectInitialTrack(type, tracks));\n            } else {\n                setTrack(tracks[0]);\n            }\n        }\n    }\n\n    /**\n     * @param {MediaInfo} track\n     * @memberof MediaController#\n     */\n    function addTrack(track) {\n        if (!track) return;\n\n        const mediaType = track.type;\n        if (!isMultiTrackSupportedByType(mediaType)) return;\n\n        let streamId = track.streamInfo.id;\n        if (!tracks[streamId]) {\n            tracks[streamId] = createTrackInfo();\n        }\n\n        const mediaTracks = tracks[streamId][mediaType].list;\n        for (let i = 0, len = mediaTracks.length; i < len; ++i) {\n            //track is already set.\n            if (isTracksEqual(mediaTracks[i], track)) {\n                return;\n            }\n        }\n\n        mediaTracks.push(track);\n\n        let initSettings = getInitialSettings(mediaType);\n        if (initSettings && (matchSettings(initSettings, track)) && !getCurrentTrackFor(mediaType, track.streamInfo)) {\n            setTrack(track);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {StreamInfo} streamInfo\n     * @returns {Array}\n     * @memberof MediaController#\n     */\n    function getTracksFor(type, streamInfo) {\n        if (!type || !streamInfo) return [];\n\n        const id = streamInfo.id;\n\n        if (!tracks[id] || !tracks[id][type]) return [];\n\n        return tracks[id][type].list;\n    }\n\n    /**\n     * @param {string} type\n     * @param {StreamInfo} streamInfo\n     * @returns {Object|null}\n     * @memberof MediaController#\n     */\n    function getCurrentTrackFor(type, streamInfo) {\n        if (!type || !streamInfo || (streamInfo && !tracks[streamInfo.id])) return null;\n        return tracks[streamInfo.id][type].current;\n    }\n\n    /**\n     * @param {MediaInfo} track\n     * @returns {boolean}\n     * @memberof MediaController#\n     */\n    function isCurrentTrack(track) {\n        if (!track) {\n            return false;\n        }\n        const type = track.type;\n        const id = track.streamInfo.id;\n\n        return (tracks[id] && tracks[id][type] && isTracksEqual(tracks[id][type].current, track));\n    }\n\n    /**\n     * @param {MediaInfo} track\n     * @param {boolean} noSettingsSave specify if settings must be not be saved\n     * @memberof MediaController#\n     */\n    function setTrack(track, noSettingsSave) {\n        if (!track || !track.streamInfo) return;\n\n        const type = track.type;\n        const streamInfo = track.streamInfo;\n        const id = streamInfo.id;\n        const current = getCurrentTrackFor(type, streamInfo);\n\n        if (!tracks[id] || !tracks[id][type] || isTracksEqual(track, current)) return;\n\n        tracks[id][type].current = track;\n\n        if (tracks[id][type].current && !(noSettingsSave && type === Constants.FRAGMENTED_TEXT)) {\n            eventBus.trigger(Events.CURRENT_TRACK_CHANGED, {\n                oldMediaInfo: current,\n                newMediaInfo: track,\n                switchMode: getSwitchMode(type)\n            });\n        }\n\n        if (!noSettingsSave) {\n\n            let settings = extractSettings(track);\n\n            if (!settings || !tracks[id][type].storeLastSettings) return;\n\n            if (settings.roles) {\n                settings.role = settings.roles[0];\n                delete settings.roles;\n            }\n\n            if (settings.accessibility) {\n                settings.accessibility = settings.accessibility[0];\n            }\n\n            if (settings.audioChannelConfiguration) {\n                settings.audioChannelConfiguration = settings.audioChannelConfiguration[0];\n            }\n\n            domStorage.setSavedMediaSettings(type, settings);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {Object} value\n     * @memberof MediaController#\n     */\n    function setInitialSettings(type, value) {\n        if (!type || !value) return;\n\n        initialSettings[type] = value;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Object|null}\n     * @memberof MediaController#\n     */\n    function getInitialSettings(type) {\n        if (!type) return null;\n\n        return initialSettings[type];\n    }\n\n    /**\n     * @memberof MediaController#\n     */\n    function saveTextSettingsDisabled() {\n        domStorage.setSavedMediaSettings(Constants.FRAGMENTED_TEXT, null);\n    }\n\n    /**\n     * @param {string} type\n     * @param {string} mode\n     * @memberof MediaController#\n     * @deprecated Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead\n     */\n    function setSwitchMode(type, mode) {\n        logger.warn('deprecated: Please use updateSettings({streaming: { trackSwitchMode: mode } }) instead');\n        const isModeSupported = (validTrackSwitchModes.indexOf(mode) !== -1);\n\n        if (!isModeSupported) {\n            logger.warn('Track switch mode is not supported: ' + mode);\n            return;\n        }\n\n        let switchMode = {};\n        switchMode[type] = mode;\n\n        settings.update({\n            streaming: {\n                trackSwitchMode: switchMode\n            }\n        });\n    }\n\n    /**\n     * @param {string} type\n     * @returns {string} mode\n     * @memberof MediaController#\n     */\n    function getSwitchMode(type) {\n        return settings.get().streaming.trackSwitchMode[type];\n    }\n\n    /**\n     * @param {string} mode\n     * @memberof MediaController#\n     * @deprecated Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead\n     */\n    function setSelectionModeForInitialTrack(mode) {\n        logger.warn('deprecated: Please use updateSettings({streaming: { selectionModeForInitialTrack: mode } }) instead');\n        const isModeSupported = (validTrackSelectionModes.indexOf(mode) !== -1);\n\n        if (!isModeSupported) {\n            logger.warn('Track selection mode is not supported: ' + mode);\n            return;\n        }\n\n        settings.update({\n            streaming: {\n                selectionModeForInitialTrack: mode\n            }\n        });\n    }\n\n    /**\n     * @returns {string} mode\n     * @memberof MediaController#\n     */\n    function getSelectionModeForInitialTrack() {\n        return settings.get().streaming.selectionModeForInitialTrack;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {boolean}\n     * @memberof MediaController#\n     */\n    function isMultiTrackSupportedByType(type) {\n        return (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.TEXT ||\n            type === Constants.FRAGMENTED_TEXT || type === Constants.IMAGE);\n    }\n\n    /**\n     * @param {MediaInfo} t1 - first track to compare\n     * @param {MediaInfo} t2 - second track to compare\n     * @returns {boolean}\n     * @memberof MediaController#\n     */\n    function isTracksEqual(t1, t2) {\n        if (!t1 && !t2) {\n            return true;\n        }\n\n        if (!t1 || !t2) {\n            return false;\n        }\n\n        const sameId = t1.id === t2.id;\n        const sameViewpoint = t1.viewpoint === t2.viewpoint;\n        const sameLang = t1.lang === t2.lang;\n        const sameRoles = t1.roles.toString() === t2.roles.toString();\n        const sameAccessibility = t1.accessibility.toString() === t2.accessibility.toString();\n        const sameAudioChannelConfiguration = t1.audioChannelConfiguration.toString() === t2.audioChannelConfiguration.toString();\n\n        return (sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration);\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.domStorage) {\n            domStorage = config.domStorage;\n        }\n\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    /**\n     * @memberof MediaController#\n     */\n    function reset() {\n        tracks = {};\n        resetInitialSettings();\n    }\n\n    function extractSettings(mediaInfo) {\n        const settings = {\n            lang: mediaInfo.lang,\n            viewpoint: mediaInfo.viewpoint,\n            roles: mediaInfo.roles,\n            accessibility: mediaInfo.accessibility,\n            audioChannelConfiguration: mediaInfo.audioChannelConfiguration\n        };\n        let notEmpty = settings.lang || settings.viewpoint || (settings.role && settings.role.length > 0) ||\n        (settings.accessibility && settings.accessibility.length > 0) || (settings.audioChannelConfiguration && settings.audioChannelConfiguration.length > 0);\n\n        return notEmpty ? settings : null;\n    }\n\n    function matchSettings(settings, track) {\n        const matchLang = !settings.lang || (track.lang.match(settings.lang));\n        const matchIndex = (settings.index === undefined) || (settings.index === null) || (track.index === settings.index);\n        const matchViewPoint = !settings.viewpoint || (settings.viewpoint === track.viewpoint);\n        const matchRole = !settings.role || !!track.roles.filter(function (item) {\n            return item === settings.role;\n        })[0];\n        let matchAccessibility = !settings.accessibility || !!track.accessibility.filter(function (item) {\n            return item === settings.accessibility;\n        })[0];\n        let matchAudioChannelConfiguration = !settings.audioChannelConfiguration || !!track.audioChannelConfiguration.filter(function (item) {\n            return item === settings.audioChannelConfiguration;\n        })[0];\n\n        return (matchLang && matchIndex && matchViewPoint && matchRole && matchAccessibility && matchAudioChannelConfiguration);\n    }\n\n    function resetInitialSettings() {\n        initialSettings = {\n            audio: null,\n            video: null,\n            fragmentedText: null\n        };\n    }\n\n    function getTracksWithHighestBitrate (trackArr) {\n        let max = 0;\n        let result = [];\n        let tmp;\n\n        trackArr.forEach(function (track) {\n            tmp = Math.max.apply(Math, track.bitrateList.map(function (obj) { return obj.bandwidth; }));\n\n            if (tmp > max) {\n                max = tmp;\n                result = [track];\n            } else if (tmp === max) {\n                result.push(track);\n            }\n        });\n\n        return result;\n    }\n\n    function getTracksWithHighestEfficiency (trackArr) {\n        let min = Infinity;\n        let result = [];\n        let tmp;\n\n        trackArr.forEach(function (track) {\n            const sum = track.bitrateList.reduce(function (acc, obj) {\n                const resolution = Math.max(1, obj.width * obj.height);\n                const efficiency = obj.bandwidth / resolution;\n                return acc + efficiency;\n            }, 0);\n            tmp = sum / track.bitrateList.length;\n\n            if (tmp < min) {\n                min = tmp;\n                result = [track];\n            } else if (tmp === min) {\n                result.push(track);\n            }\n        });\n\n        return result;\n    }\n\n    function getTracksWithWidestRange (trackArr) {\n        let max = 0;\n        let result = [];\n        let tmp;\n\n        trackArr.forEach(function (track) {\n            tmp = track.representationCount;\n\n            if (tmp > max) {\n                max = tmp;\n                result = [track];\n            } else if (tmp === max) {\n                result.push(track);\n            }\n        });\n\n        return result;\n    }\n\n    function selectInitialTrack(type, tracks) {\n        if (type === Constants.FRAGMENTED_TEXT) return tracks[0];\n\n        let mode = getSelectionModeForInitialTrack();\n        let tmpArr = [];\n\n        switch (mode) {\n            case Constants.TRACK_SELECTION_MODE_HIGHEST_BITRATE:\n                tmpArr = getTracksWithHighestBitrate(tracks);\n\n                if (tmpArr.length > 1) {\n                    tmpArr = getTracksWithWidestRange(tmpArr);\n                }\n                break;\n            case Constants.TRACK_SELECTION_MODE_FIRST_TRACK:\n                tmpArr.push(tracks[0]);\n                break;\n            case Constants.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY:\n                tmpArr = getTracksWithHighestEfficiency(tracks);\n\n                if (tmpArr.length > 1) {\n                    tmpArr = getTracksWithHighestBitrate(tmpArr);\n                }\n                break;\n            case Constants.TRACK_SELECTION_MODE_WIDEST_RANGE:\n                tmpArr = getTracksWithWidestRange(tracks);\n\n                if (tmpArr.length > 1) {\n                    tmpArr = getTracksWithHighestBitrate(tracks);\n                }\n                break;\n            default:\n                logger.warn('Track selection mode is not supported: ' + mode);\n                break;\n        }\n\n        return tmpArr[0];\n    }\n\n    function createTrackInfo() {\n        return {\n            audio: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            video: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            text: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            fragmentedText: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            },\n            image: {\n                list: [],\n                storeLastSettings: true,\n                current: null\n            }\n        };\n    }\n\n    instance = {\n        checkInitialMediaSettingsForType: checkInitialMediaSettingsForType,\n        addTrack: addTrack,\n        getTracksFor: getTracksFor,\n        getCurrentTrackFor: getCurrentTrackFor,\n        isCurrentTrack: isCurrentTrack,\n        setTrack: setTrack,\n        setInitialSettings: setInitialSettings,\n        getInitialSettings: getInitialSettings,\n        setSwitchMode: setSwitchMode,\n        getSwitchMode: getSwitchMode,\n        selectInitialTrack: selectInitialTrack,\n        getTracksWithHighestBitrate: getTracksWithHighestBitrate,\n        getTracksWithHighestEfficiency: getTracksWithHighestEfficiency,\n        getTracksWithWidestRange: getTracksWithWidestRange,\n        setSelectionModeForInitialTrack: setSelectionModeForInitialTrack,\n        getSelectionModeForInitialTrack: getSelectionModeForInitialTrack,\n        isMultiTrackSupportedByType: isMultiTrackSupportedByType,\n        isTracksEqual: isTracksEqual,\n        matchSettings: matchSettings,\n        saveTextSettingsDisabled: saveTextSettingsDisabled,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nMediaController.__dashjs_factory_name = 'MediaController';\nconst factory = FactoryMaker.getSingletonFactory(MediaController);\nFactoryMaker.updateSingletonFactory(MediaController.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}