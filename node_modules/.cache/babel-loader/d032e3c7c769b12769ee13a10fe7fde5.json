{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ABRRulesCollection = require('../rules/abr/ABRRulesCollection');\n\nvar _ABRRulesCollection2 = _interopRequireDefault(_ABRRulesCollection);\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _BitrateInfo = require('../vo/BitrateInfo');\n\nvar _BitrateInfo2 = _interopRequireDefault(_BitrateInfo);\n\nvar _FragmentModel = require('../models/FragmentModel');\n\nvar _FragmentModel2 = _interopRequireDefault(_FragmentModel);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _RulesContext = require('../rules/RulesContext');\n\nvar _RulesContext2 = _interopRequireDefault(_RulesContext);\n\nvar _SwitchRequest = require('../rules/SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _SwitchRequestHistory = require('../rules/SwitchRequestHistory');\n\nvar _SwitchRequestHistory2 = _interopRequireDefault(_SwitchRequestHistory);\n\nvar _DroppedFramesHistory = require('../rules/DroppedFramesHistory');\n\nvar _DroppedFramesHistory2 = _interopRequireDefault(_DroppedFramesHistory);\n\nvar _ThroughputHistory = require('../rules/ThroughputHistory');\n\nvar _ThroughputHistory2 = _interopRequireDefault(_ThroughputHistory);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _SupervisorTools = require('../utils/SupervisorTools');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar DEFAULT_VIDEO_BITRATE = 1000;\nvar DEFAULT_AUDIO_BITRATE = 100;\nvar QUALITY_DEFAULT = 0;\n\nfunction AbrController() {\n  var context = this.context;\n  var debug = (0, _Debug2.default)(context).getInstance();\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      abrRulesCollection = void 0,\n      streamController = void 0,\n      topQualities = void 0,\n      qualityDict = void 0,\n      streamProcessorDict = void 0,\n      abandonmentStateDict = void 0,\n      abandonmentTimeout = void 0,\n      windowResizeEventCalled = void 0,\n      elementWidth = void 0,\n      elementHeight = void 0,\n      adapter = void 0,\n      videoModel = void 0,\n      mediaPlayerModel = void 0,\n      domStorage = void 0,\n      playbackIndex = void 0,\n      switchHistoryDict = void 0,\n      droppedFramesHistory = void 0,\n      throughputHistory = void 0,\n      isUsingBufferOccupancyABRDict = void 0,\n      isUsingL2AABRDict = void 0,\n      isUsingLoLPBRDict = void 0,\n      dashMetrics = void 0,\n      settings = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n  }\n\n  function registerStreamType(type, streamProcessor) {\n    switchHistoryDict[type] = switchHistoryDict[type] || (0, _SwitchRequestHistory2.default)(context).create();\n    streamProcessorDict[type] = streamProcessor;\n    abandonmentStateDict[type] = abandonmentStateDict[type] || {};\n    abandonmentStateDict[type].state = _MetricsConstants2.default.ALLOW_LOAD;\n    isUsingBufferOccupancyABRDict[type] = false;\n    isUsingL2AABRDict[type] = false;\n    isUsingLoLPBRDict[type] = false;\n    eventBus.on(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n\n    if (type === _Constants2.default.VIDEO) {\n      eventBus.on(_Events2.default.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n      droppedFramesHistory = droppedFramesHistory || (0, _DroppedFramesHistory2.default)(context).create();\n      setElementSize();\n    }\n\n    eventBus.on(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.on(_Events2.default.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n    throughputHistory = throughputHistory || (0, _ThroughputHistory2.default)(context).create({\n      settings: settings\n    });\n  }\n\n  function unRegisterStreamType(type) {\n    delete streamProcessorDict[type];\n  }\n\n  function createAbrRulesCollection() {\n    abrRulesCollection = (0, _ABRRulesCollection2.default)(context).create({\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      settings: settings\n    });\n    abrRulesCollection.initialize();\n  }\n\n  function resetInitialSettings() {\n    topQualities = {};\n    qualityDict = {};\n    abandonmentStateDict = {};\n    streamProcessorDict = {};\n    switchHistoryDict = {};\n    isUsingBufferOccupancyABRDict = {};\n    isUsingL2AABRDict = {};\n    isUsingLoLPBRDict = {};\n\n    if (windowResizeEventCalled === undefined) {\n      windowResizeEventCalled = false;\n    }\n\n    playbackIndex = undefined;\n    droppedFramesHistory = undefined;\n    throughputHistory = undefined;\n    clearTimeout(abandonmentTimeout);\n    abandonmentTimeout = null;\n  }\n\n  function reset() {\n    resetInitialSettings();\n    eventBus.off(_Events2.default.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n    eventBus.off(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.off(_Events2.default.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n    if (abrRulesCollection) {\n      abrRulesCollection.reset();\n    }\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.domStorage) {\n      domStorage = config.domStorage;\n    }\n\n    if (config.mediaPlayerModel) {\n      mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function checkConfig() {\n    if (!domStorage || !domStorage.hasOwnProperty('getSavedBitrateSettings')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function onQualityChangeRendered(e) {\n    if (e.mediaType === _Constants2.default.VIDEO) {\n      if (playbackIndex !== undefined) {\n        droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality());\n      }\n\n      playbackIndex = e.newQuality;\n    }\n  }\n\n  function onMetricAdded(e) {\n    if (e.metric === _MetricsConstants2.default.HTTP_REQUEST && e.value && e.value.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE && (e.mediaType === _Constants2.default.AUDIO || e.mediaType === _Constants2.default.VIDEO)) {\n      throughputHistory.push(e.mediaType, e.value, settings.get().streaming.abr.useDeadTimeLatency);\n    }\n\n    if (e.metric === _MetricsConstants2.default.BUFFER_LEVEL && (e.mediaType === _Constants2.default.AUDIO || e.mediaType === _Constants2.default.VIDEO)) {\n      _updateAbrStrategy(e.mediaType, 0.001 * e.value.level);\n    }\n  }\n\n  function getTopQualityIndexFor(type, id) {\n    var idx = void 0;\n    topQualities[id] = topQualities[id] || {};\n\n    if (!topQualities[id].hasOwnProperty(type)) {\n      topQualities[id][type] = 0;\n    }\n\n    idx = checkMaxBitrate(topQualities[id][type], type);\n    idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]);\n    idx = checkPortalSize(idx, type);\n    return idx;\n  }\n  /**\n  * Gets top BitrateInfo for the player\n  * @param {string} type - 'video' or 'audio' are the type options.\n  * @returns {BitrateInfo | null}\n  */\n\n\n  function getTopBitrateInfoFor(type) {\n    if (type && streamProcessorDict && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n\n      if (streamInfo && streamInfo.id) {\n        var idx = getTopQualityIndexFor(type, streamInfo.id);\n        var bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo());\n        return bitrates[idx] ? bitrates[idx] : null;\n      }\n    }\n\n    return null;\n  }\n  /**\n  * @param {string} type\n  * @returns {number} A value of the initial bitrate, kbps\n  * @memberof AbrController#\n  */\n\n\n  function getInitialBitrateFor(type) {\n    checkConfig();\n\n    if (type === _Constants2.default.TEXT || type === _Constants2.default.FRAGMENTED_TEXT) {\n      return NaN;\n    }\n\n    var savedBitrate = domStorage.getSavedBitrateSettings(type);\n    var configBitrate = settings.get().streaming.abr.initialBitrate[type];\n    var configRatio = settings.get().streaming.abr.initialRepresentationRatio[type];\n\n    if (configBitrate === -1) {\n      if (configRatio > -1) {\n        var representation = adapter.getAdaptationForType(0, type).Representation;\n\n        if (Array.isArray(representation)) {\n          var repIdx = Math.max(Math.round(representation.length * configRatio) - 1, 0);\n          configBitrate = representation[repIdx].bandwidth;\n        } else {\n          configBitrate = 0;\n        }\n      } else if (!isNaN(savedBitrate)) {\n        configBitrate = savedBitrate;\n      } else {\n        configBitrate = type === _Constants2.default.VIDEO ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE;\n      }\n    }\n\n    return configBitrate;\n  }\n\n  function getMaxAllowedBitrateFor(type) {\n    return settings.get().streaming.abr.maxBitrate[type];\n  }\n\n  function getMinAllowedBitrateFor(type) {\n    return settings.get().streaming.abr.minBitrate[type];\n  }\n\n  function getMaxAllowedIndexFor(type) {\n    var maxBitrate = getMaxAllowedBitrateFor(type);\n\n    if (maxBitrate > -1) {\n      return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate);\n    } else {\n      return undefined;\n    }\n  }\n\n  function getMinAllowedIndexFor(type) {\n    var minBitrate = getMinAllowedBitrateFor(type);\n\n    if (minBitrate > -1) {\n      var mediaInfo = streamProcessorDict[type].getMediaInfo();\n      var bitrateList = getBitrateList(mediaInfo); // This returns the quality index <= for the given bitrate\n\n      var minIdx = getQualityForBitrate(mediaInfo, minBitrate);\n\n      if (bitrateList[minIdx] && minIdx < bitrateList.length - 1 && bitrateList[minIdx].bitrate < minBitrate * 1000) {\n        minIdx++; // Go to the next bitrate\n      }\n\n      return minIdx;\n    } else {\n      return undefined;\n    }\n  }\n\n  function checkPlaybackQuality(type) {\n    if (type && streamProcessorDict && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n      var streamId = streamInfo ? streamInfo.id : null;\n      var oldQuality = getQualityFor(type);\n      var rulesContext = (0, _RulesContext2.default)(context).create({\n        abrController: instance,\n        streamProcessor: streamProcessorDict[type],\n        currentValue: oldQuality,\n        switchHistory: switchHistoryDict[type],\n        droppedFramesHistory: droppedFramesHistory,\n        useBufferOccupancyABR: useBufferOccupancyABR(type),\n        useL2AABR: useL2AABR(type),\n        useLoLPABR: useLoLPABR(type),\n        videoModel: videoModel\n      });\n\n      if (droppedFramesHistory) {\n        var playbackQuality = videoModel.getPlaybackQuality();\n\n        if (playbackQuality) {\n          droppedFramesHistory.push(playbackIndex, playbackQuality);\n        }\n      }\n\n      if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n        var minIdx = getMinAllowedIndexFor(type);\n        var topQualityIdx = getTopQualityIndexFor(type, streamId);\n        var switchRequest = abrRulesCollection.getMaxQuality(rulesContext);\n        var newQuality = switchRequest.quality;\n\n        if (minIdx !== undefined && (newQuality > _SwitchRequest2.default.NO_CHANGE ? newQuality : oldQuality) < minIdx) {\n          newQuality = minIdx;\n        }\n\n        if (newQuality > topQualityIdx) {\n          newQuality = topQualityIdx;\n        }\n\n        switchHistoryDict[type].push({\n          oldValue: oldQuality,\n          newValue: newQuality\n        });\n\n        if (newQuality > _SwitchRequest2.default.NO_CHANGE && newQuality != oldQuality) {\n          if (abandonmentStateDict[type].state === _MetricsConstants2.default.ALLOW_LOAD || newQuality > oldQuality) {\n            changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason);\n          }\n        } else if (settings.get().debug.logLevel === _Debug2.default.LOG_LEVEL_DEBUG) {\n          var bufferLevel = dashMetrics.getCurrentBufferLevel(type, true);\n          logger.debug('[' + type + '] stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')');\n        }\n      }\n    }\n  }\n\n  function setPlaybackQuality(type, streamInfo, newQuality, reason) {\n    var id = streamInfo.id;\n    var oldQuality = getQualityFor(type);\n    (0, _SupervisorTools.checkInteger)(newQuality);\n    var topQualityIdx = getTopQualityIndexFor(type, id);\n\n    if (newQuality !== oldQuality && newQuality >= 0 && newQuality <= topQualityIdx) {\n      changeQuality(type, oldQuality, newQuality, topQualityIdx, reason);\n    }\n  }\n\n  function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) {\n    if (type && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n      var id = streamInfo ? streamInfo.id : null;\n\n      if (settings.get().debug.logLevel === _Debug2.default.LOG_LEVEL_DEBUG) {\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(type);\n        logger.info('[' + type + '] switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.'));\n      }\n\n      setQualityFor(type, id, newQuality);\n      eventBus.trigger(_Events2.default.QUALITY_CHANGE_REQUESTED, {\n        oldQuality: oldQuality,\n        newQuality: newQuality,\n        reason: reason\n      }, {\n        streamId: streamInfo.id,\n        mediaType: type\n      });\n      var bitrate = throughputHistory.getAverageThroughput(type);\n\n      if (!isNaN(bitrate)) {\n        domStorage.setSavedBitrateSettings(type, bitrate);\n      }\n    }\n  }\n\n  function setAbandonmentStateFor(type, state) {\n    abandonmentStateDict[type].state = state;\n  }\n\n  function getAbandonmentStateFor(type) {\n    return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null;\n  }\n  /**\n  * @param {MediaInfo} mediaInfo\n  * @param {number} bitrate A bitrate value, kbps\n  * @param {number} latency Expected latency of connection, ms\n  * @returns {number} A quality index <= for the given bitrate\n  * @memberof AbrController#\n  */\n\n\n  function getQualityForBitrate(mediaInfo, bitrate, latency) {\n    var voRepresentation = mediaInfo && mediaInfo.type ? streamProcessorDict[mediaInfo.type].getRepresentationInfo() : null;\n\n    if (settings.get().streaming.abr.useDeadTimeLatency && latency && voRepresentation && voRepresentation.fragmentDuration) {\n      latency = latency / 1000;\n      var fragmentDuration = voRepresentation.fragmentDuration;\n\n      if (latency > fragmentDuration) {\n        return 0;\n      } else {\n        var deadTimeRatio = latency / fragmentDuration;\n        bitrate = bitrate * (1 - deadTimeRatio);\n      }\n    }\n\n    var bitrateList = getBitrateList(mediaInfo);\n\n    for (var i = bitrateList.length - 1; i >= 0; i--) {\n      var bitrateInfo = bitrateList[i];\n\n      if (bitrate * 1000 >= bitrateInfo.bitrate) {\n        return i;\n      }\n    }\n\n    return QUALITY_DEFAULT;\n  }\n  /**\n  * @param {MediaInfo} mediaInfo\n  * @returns {Array|null} A list of {@link BitrateInfo} objects\n  * @memberof AbrController#\n  */\n\n\n  function getBitrateList(mediaInfo) {\n    var infoList = [];\n    if (!mediaInfo || !mediaInfo.bitrateList) return infoList;\n    var bitrateList = mediaInfo.bitrateList;\n    var type = mediaInfo.type;\n    var bitrateInfo = void 0;\n\n    for (var i = 0, ln = bitrateList.length; i < ln; i++) {\n      bitrateInfo = new _BitrateInfo2.default();\n      bitrateInfo.mediaType = type;\n      bitrateInfo.qualityIndex = i;\n      bitrateInfo.bitrate = bitrateList[i].bandwidth;\n      bitrateInfo.width = bitrateList[i].width;\n      bitrateInfo.height = bitrateList[i].height;\n      bitrateInfo.scanType = bitrateList[i].scanType;\n      infoList.push(bitrateInfo);\n    }\n\n    return infoList;\n  }\n\n  function _updateAbrStrategy(mediaType, bufferLevel) {\n    var strategy = settings.get().streaming.abr.ABRStrategy;\n\n    if (strategy === _Constants2.default.ABR_STRATEGY_L2A) {\n      isUsingBufferOccupancyABRDict[mediaType] = false;\n      isUsingLoLPBRDict[mediaType] = false;\n      isUsingL2AABRDict[mediaType] = true;\n      return;\n    }\n\n    if (strategy === _Constants2.default.ABR_STRATEGY_LoLP) {\n      isUsingBufferOccupancyABRDict[mediaType] = false;\n      isUsingLoLPBRDict[mediaType] = true;\n      isUsingL2AABRDict[mediaType] = false;\n      return;\n    } else if (strategy === _Constants2.default.ABR_STRATEGY_BOLA) {\n      isUsingBufferOccupancyABRDict[mediaType] = true;\n      isUsingLoLPBRDict[mediaType] = false;\n      isUsingL2AABRDict[mediaType] = false;\n      return;\n    } else if (strategy === _Constants2.default.ABR_STRATEGY_THROUGHPUT) {\n      isUsingBufferOccupancyABRDict[mediaType] = false;\n      isUsingLoLPBRDict[mediaType] = false;\n      isUsingL2AABRDict[mediaType] = false;\n      return;\n    } // else ABR_STRATEGY_DYNAMIC\n\n\n    _updateDynamicAbrStrategy(mediaType, bufferLevel);\n  }\n\n  function _updateDynamicAbrStrategy(mediaType, bufferLevel) {\n    var stableBufferTime = mediaPlayerModel.getStableBufferTime();\n    var switchOnThreshold = stableBufferTime;\n    var switchOffThreshold = 0.5 * stableBufferTime;\n    var useBufferABR = isUsingBufferOccupancyABRDict[mediaType];\n    var newUseBufferABR = bufferLevel > (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules\n\n    isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR;\n\n    if (newUseBufferABR !== useBufferABR) {\n      if (newUseBufferABR) {\n        logger.info('[' + mediaType + '] switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n      } else {\n        logger.info('[' + mediaType + '] switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n      }\n    }\n  }\n\n  function useBufferOccupancyABR(mediaType) {\n    return isUsingBufferOccupancyABRDict[mediaType];\n  }\n\n  function useL2AABR(mediaType) {\n    return isUsingL2AABRDict[mediaType];\n  }\n\n  function useLoLPABR(mediaType) {\n    return isUsingLoLPBRDict[mediaType];\n  }\n\n  function getThroughputHistory() {\n    return throughputHistory;\n  }\n\n  function updateTopQualityIndex(mediaInfo) {\n    var type = mediaInfo.type;\n    var streamId = mediaInfo.streamInfo.id;\n    var max = mediaInfo.representationCount - 1;\n    setTopQualityIndex(type, streamId, max);\n    return max;\n  }\n\n  function isPlayingAtTopQuality(streamInfo) {\n    var streamId = streamInfo ? streamInfo.id : null;\n    var audioQuality = getQualityFor(_Constants2.default.AUDIO);\n    var videoQuality = getQualityFor(_Constants2.default.VIDEO);\n    var isAtTop = audioQuality === getTopQualityIndexFor(_Constants2.default.AUDIO, streamId) && videoQuality === getTopQualityIndexFor(_Constants2.default.VIDEO, streamId);\n    return isAtTop;\n  }\n\n  function getQualityFor(type) {\n    if (type && streamProcessorDict[type]) {\n      var streamInfo = streamProcessorDict[type].getStreamInfo();\n      var id = streamInfo ? streamInfo.id : null;\n      var quality = void 0;\n\n      if (id) {\n        qualityDict[id] = qualityDict[id] || {};\n\n        if (!qualityDict[id].hasOwnProperty(type)) {\n          qualityDict[id][type] = QUALITY_DEFAULT;\n        }\n\n        quality = qualityDict[id][type];\n        return quality;\n      }\n    }\n\n    return QUALITY_DEFAULT;\n  }\n\n  function setQualityFor(type, id, value) {\n    qualityDict[id] = qualityDict[id] || {};\n    qualityDict[id][type] = value;\n  }\n\n  function setTopQualityIndex(type, id, value) {\n    topQualities[id] = topQualities[id] || {};\n    topQualities[id][type] = value;\n  }\n\n  function checkMaxBitrate(idx, type) {\n    var newIdx = idx;\n\n    if (!streamProcessorDict[type]) {\n      return newIdx;\n    }\n\n    var minIdx = getMinAllowedIndexFor(type);\n\n    if (minIdx !== undefined) {\n      newIdx = Math.max(idx, minIdx);\n    }\n\n    var maxIdx = getMaxAllowedIndexFor(type);\n\n    if (maxIdx !== undefined) {\n      newIdx = Math.min(newIdx, maxIdx);\n    }\n\n    return newIdx;\n  }\n\n  function checkMaxRepresentationRatio(idx, type, maxIdx) {\n    var maxRepresentationRatio = settings.get().streaming.abr.maxRepresentationRatio[type];\n\n    if (isNaN(maxRepresentationRatio) || maxRepresentationRatio >= 1 || maxRepresentationRatio < 0) {\n      return idx;\n    }\n\n    return Math.min(idx, Math.round(maxIdx * maxRepresentationRatio));\n  }\n\n  function setWindowResizeEventCalled(value) {\n    windowResizeEventCalled = value;\n  }\n\n  function setElementSize() {\n    if (videoModel) {\n      var hasPixelRatio = settings.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty('devicePixelRatio');\n      var pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1;\n      elementWidth = videoModel.getClientWidth() * pixelRatio;\n      elementHeight = videoModel.getClientHeight() * pixelRatio;\n    }\n  }\n\n  function checkPortalSize(idx, type) {\n    if (type !== _Constants2.default.VIDEO || !settings.get().streaming.abr.limitBitrateByPortal || !streamProcessorDict[type]) {\n      return idx;\n    }\n\n    if (!windowResizeEventCalled) {\n      setElementSize();\n    }\n\n    var representation = adapter.getAdaptationForType(0, type).Representation;\n    var newIdx = idx;\n\n    if (elementWidth > 0 && elementHeight > 0) {\n      while (newIdx > 0 && representation[newIdx] && elementWidth < representation[newIdx].width && elementWidth - representation[newIdx - 1].width < representation[newIdx].width - elementWidth) {\n        newIdx = newIdx - 1;\n      } // Make sure that in case of multiple representation elements have same\n      // resolution, every such element is included\n\n\n      while (newIdx < representation.length - 1 && representation[newIdx].width === representation[newIdx + 1].width) {\n        newIdx = newIdx + 1;\n      }\n    }\n\n    return newIdx;\n  }\n\n  function onFragmentLoadProgress(e) {\n    var type = e.request.mediaType;\n\n    if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n      var streamProcessor = streamProcessorDict[type];\n      if (!streamProcessor) return; // There may be a fragment load in progress when we switch periods and recreated some controllers.\n\n      var rulesContext = (0, _RulesContext2.default)(context).create({\n        abrController: instance,\n        streamProcessor: streamProcessor,\n        currentRequest: e.request,\n        useBufferOccupancyABR: useBufferOccupancyABR(type),\n        useL2AABR: useL2AABR(type),\n        useLoLPABR: useLoLPABR(type),\n        videoModel: videoModel\n      });\n      var switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext);\n\n      if (switchRequest.quality > _SwitchRequest2.default.NO_CHANGE) {\n        var fragmentModel = streamProcessor.getFragmentModel();\n        var request = fragmentModel.getRequests({\n          state: _FragmentModel2.default.FRAGMENT_MODEL_LOADING,\n          index: e.request.index\n        })[0];\n\n        if (request) {\n          //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total\n          fragmentModel.abortRequests();\n          setAbandonmentStateFor(type, _MetricsConstants2.default.ABANDON_LOAD);\n          switchHistoryDict[type].reset();\n          switchHistoryDict[type].push({\n            oldValue: getQualityFor(type),\n            newValue: switchRequest.quality,\n            confidence: 1,\n            reason: switchRequest.reason\n          });\n          setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason);\n          clearTimeout(abandonmentTimeout);\n          abandonmentTimeout = setTimeout(function () {\n            setAbandonmentStateFor(type, _MetricsConstants2.default.ALLOW_LOAD);\n            abandonmentTimeout = null;\n          }, settings.get().streaming.abandonLoadTimeout);\n        }\n      }\n    }\n  }\n\n  instance = {\n    isPlayingAtTopQuality: isPlayingAtTopQuality,\n    updateTopQualityIndex: updateTopQualityIndex,\n    getThroughputHistory: getThroughputHistory,\n    getBitrateList: getBitrateList,\n    getQualityForBitrate: getQualityForBitrate,\n    getTopBitrateInfoFor: getTopBitrateInfoFor,\n    getMaxAllowedIndexFor: getMaxAllowedIndexFor,\n    getMinAllowedIndexFor: getMinAllowedIndexFor,\n    getInitialBitrateFor: getInitialBitrateFor,\n    getQualityFor: getQualityFor,\n    getAbandonmentStateFor: getAbandonmentStateFor,\n    setPlaybackQuality: setPlaybackQuality,\n    checkPlaybackQuality: checkPlaybackQuality,\n    getTopQualityIndexFor: getTopQualityIndexFor,\n    setElementSize: setElementSize,\n    setWindowResizeEventCalled: setWindowResizeEventCalled,\n    createAbrRulesCollection: createAbrRulesCollection,\n    registerStreamType: registerStreamType,\n    unRegisterStreamType: unRegisterStreamType,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nAbrController.__dashjs_factory_name = 'AbrController';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(AbrController);\n\nfactory.QUALITY_DEFAULT = QUALITY_DEFAULT;\n\n_FactoryMaker2.default.updateSingletonFactory(AbrController.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../src/streaming/controllers/AbrController.js"],"names":["DEFAULT_VIDEO_BITRATE","DEFAULT_AUDIO_BITRATE","QUALITY_DEFAULT","context","debug","eventBus","instance","logger","abrRulesCollection","streamController","topQualities","qualityDict","streamProcessorDict","abandonmentStateDict","abandonmentTimeout","windowResizeEventCalled","elementWidth","elementHeight","adapter","videoModel","mediaPlayerModel","domStorage","playbackIndex","switchHistoryDict","droppedFramesHistory","throughputHistory","isUsingBufferOccupancyABRDict","isUsingL2AABRDict","isUsingLoLPBRDict","dashMetrics","settings","resetInitialSettings","MetricsConstants","Events","type","Constants","setElementSize","clearTimeout","config","e","HTTPRequest","_updateAbrStrategy","idx","checkMaxBitrate","checkMaxRepresentationRatio","checkPortalSize","streamInfo","getTopQualityIndexFor","bitrates","getBitrateList","checkConfig","savedBitrate","configBitrate","configRatio","representation","Array","repIdx","Math","isNaN","maxBitrate","getMaxAllowedBitrateFor","getQualityForBitrate","minBitrate","getMinAllowedBitrateFor","mediaInfo","bitrateList","minIdx","streamId","oldQuality","getQualityFor","rulesContext","abrController","streamProcessor","currentValue","switchHistory","useBufferOccupancyABR","useL2AABR","useLoLPABR","playbackQuality","getMinAllowedIndexFor","topQualityIdx","switchRequest","newQuality","SwitchRequest","oldValue","newValue","changeQuality","Debug","bufferLevel","id","reason","JSON","setQualityFor","mediaType","bitrate","voRepresentation","latency","fragmentDuration","deadTimeRatio","i","bitrateInfo","infoList","ln","BitrateInfo","strategy","_updateDynamicAbrStrategy","stableBufferTime","switchOnThreshold","switchOffThreshold","useBufferABR","newUseBufferABR","max","setTopQualityIndex","audioQuality","videoQuality","isAtTop","quality","newIdx","maxIdx","getMaxAllowedIndexFor","maxRepresentationRatio","hasPixelRatio","window","pixelRatio","currentRequest","fragmentModel","request","state","FragmentModel","index","setAbandonmentStateFor","confidence","setPlaybackQuality","setTimeout","isPlayingAtTopQuality","updateTopQualityIndex","getThroughputHistory","getTopBitrateInfoFor","getInitialBitrateFor","getAbandonmentStateFor","checkPlaybackQuality","setWindowResizeEventCalled","createAbrRulesCollection","registerStreamType","unRegisterStreamType","setConfig","reset","setup","AbrController","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport ABRRulesCollection from '../rules/abr/ABRRulesCollection';\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport BitrateInfo from '../vo/BitrateInfo';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport RulesContext from '../rules/RulesContext';\nimport SwitchRequest from '../rules/SwitchRequest';\nimport SwitchRequestHistory from '../rules/SwitchRequestHistory';\nimport DroppedFramesHistory from '../rules/DroppedFramesHistory';\nimport ThroughputHistory from '../rules/ThroughputHistory';\nimport Debug from '../../core/Debug';\nimport { HTTPRequest } from '../vo/metrics/HTTPRequest';\nimport { checkInteger } from '../utils/SupervisorTools';\n\nconst DEFAULT_VIDEO_BITRATE = 1000;\nconst DEFAULT_AUDIO_BITRATE = 100;\nconst QUALITY_DEFAULT = 0;\n\nfunction AbrController() {\n\n    const context = this.context;\n    const debug = Debug(context).getInstance();\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        abrRulesCollection,\n        streamController,\n        topQualities,\n        qualityDict,\n        streamProcessorDict,\n        abandonmentStateDict,\n        abandonmentTimeout,\n        windowResizeEventCalled,\n        elementWidth,\n        elementHeight,\n        adapter,\n        videoModel,\n        mediaPlayerModel,\n        domStorage,\n        playbackIndex,\n        switchHistoryDict,\n        droppedFramesHistory,\n        throughputHistory,\n        isUsingBufferOccupancyABRDict,\n        isUsingL2AABRDict,\n        isUsingLoLPBRDict,\n        dashMetrics,\n        settings;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n    }\n\n    function registerStreamType(type, streamProcessor) {\n        switchHistoryDict[type] = switchHistoryDict[type] || SwitchRequestHistory(context).create();\n        streamProcessorDict[type] = streamProcessor;\n        abandonmentStateDict[type] = abandonmentStateDict[type] || {};\n        abandonmentStateDict[type].state = MetricsConstants.ALLOW_LOAD;\n        isUsingBufferOccupancyABRDict[type] = false;\n        isUsingL2AABRDict[type] = false;\n        isUsingLoLPBRDict[type] = false;\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n        if (type === Constants.VIDEO) {\n            eventBus.on(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n            droppedFramesHistory = droppedFramesHistory || DroppedFramesHistory(context).create();\n            setElementSize();\n        }\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n        throughputHistory = throughputHistory || ThroughputHistory(context).create({\n            settings: settings\n        });\n    }\n\n    function unRegisterStreamType(type) {\n        delete streamProcessorDict[type];\n    }\n\n    function createAbrRulesCollection() {\n        abrRulesCollection = ABRRulesCollection(context).create({\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            settings: settings\n        });\n\n        abrRulesCollection.initialize();\n    }\n\n    function resetInitialSettings() {\n        topQualities = {};\n        qualityDict = {};\n        abandonmentStateDict = {};\n        streamProcessorDict = {};\n        switchHistoryDict = {};\n        isUsingBufferOccupancyABRDict = {};\n        isUsingL2AABRDict = {};\n        isUsingLoLPBRDict = {};\n        if (windowResizeEventCalled === undefined) {\n            windowResizeEventCalled = false;\n        }\n        playbackIndex = undefined;\n        droppedFramesHistory = undefined;\n        throughputHistory = undefined;\n        clearTimeout(abandonmentTimeout);\n        abandonmentTimeout = null;\n    }\n\n    function reset() {\n\n        resetInitialSettings();\n\n        eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n        eventBus.off(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n        if (abrRulesCollection) {\n            abrRulesCollection.reset();\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.domStorage) {\n            domStorage = config.domStorage;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function checkConfig() {\n        if (!domStorage || !domStorage.hasOwnProperty('getSavedBitrateSettings')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function onQualityChangeRendered(e) {\n        if (e.mediaType === Constants.VIDEO) {\n            if (playbackIndex !== undefined) {\n                droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality());\n            }\n            playbackIndex = e.newQuality;\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            throughputHistory.push(e.mediaType, e.value, settings.get().streaming.abr.useDeadTimeLatency);\n        }\n\n        if (e.metric === MetricsConstants.BUFFER_LEVEL && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            _updateAbrStrategy(e.mediaType, 0.001 * e.value.level);\n        }\n    }\n\n    function getTopQualityIndexFor(type, id) {\n        let idx;\n        topQualities[id] = topQualities[id] || {};\n\n        if (!topQualities[id].hasOwnProperty(type)) {\n            topQualities[id][type] = 0;\n        }\n\n        idx = checkMaxBitrate(topQualities[id][type], type);\n        idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]);\n        idx = checkPortalSize(idx, type);\n        return idx;\n    }\n\n    /**\n     * Gets top BitrateInfo for the player\n     * @param {string} type - 'video' or 'audio' are the type options.\n     * @returns {BitrateInfo | null}\n     */\n    function getTopBitrateInfoFor(type) {\n        if (type && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            if (streamInfo && streamInfo.id) {\n                const idx = getTopQualityIndexFor(type, streamInfo.id);\n                const bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo());\n                return bitrates[idx] ? bitrates[idx] : null;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {number} A value of the initial bitrate, kbps\n     * @memberof AbrController#\n     */\n    function getInitialBitrateFor(type) {\n        checkConfig();\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT) {\n            return NaN;\n        }\n        const savedBitrate = domStorage.getSavedBitrateSettings(type);\n        let configBitrate = settings.get().streaming.abr.initialBitrate[type];\n        let configRatio = settings.get().streaming.abr.initialRepresentationRatio[type];\n\n        if (configBitrate === -1) {\n            if (configRatio > -1) {\n                const representation = adapter.getAdaptationForType(0, type).Representation;\n                if (Array.isArray(representation)) {\n                    const repIdx = Math.max(Math.round(representation.length * configRatio) - 1, 0);\n                    configBitrate = representation[repIdx].bandwidth;\n                } else {\n                    configBitrate = 0;\n                }\n            } else if (!isNaN(savedBitrate)) {\n                configBitrate = savedBitrate;\n            } else {\n                configBitrate = (type === Constants.VIDEO) ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE;\n            }\n        }\n\n        return configBitrate;\n    }\n\n    function getMaxAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.maxBitrate[type];\n    }\n\n    function getMinAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.minBitrate[type];\n    }\n\n    function getMaxAllowedIndexFor(type) {\n        const maxBitrate = getMaxAllowedBitrateFor(type);\n        if (maxBitrate > -1) {\n            return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate);\n        } else {\n            return undefined;\n        }\n    }\n\n    function getMinAllowedIndexFor(type) {\n        const minBitrate = getMinAllowedBitrateFor(type);\n\n        if (minBitrate > -1) {\n            const mediaInfo = streamProcessorDict[type].getMediaInfo();\n            const bitrateList = getBitrateList(mediaInfo);\n            // This returns the quality index <= for the given bitrate\n            let minIdx = getQualityForBitrate(mediaInfo, minBitrate);\n            if (bitrateList[minIdx] && minIdx < bitrateList.length - 1 && bitrateList[minIdx].bitrate < minBitrate * 1000) {\n                minIdx++; // Go to the next bitrate\n            }\n            return minIdx;\n        } else {\n            return undefined;\n        }\n    }\n\n    function checkPlaybackQuality(type) {\n        if (type && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const streamId = streamInfo ? streamInfo.id : null;\n            const oldQuality = getQualityFor(type);\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessorDict[type],\n                currentValue: oldQuality,\n                switchHistory: switchHistoryDict[type],\n                droppedFramesHistory: droppedFramesHistory,\n                useBufferOccupancyABR: useBufferOccupancyABR(type),\n                useL2AABR: useL2AABR(type),\n                useLoLPABR: useLoLPABR(type),\n                videoModel\n            });\n\n            if (droppedFramesHistory) {\n                const playbackQuality = videoModel.getPlaybackQuality();\n                if (playbackQuality) {\n                    droppedFramesHistory.push(playbackIndex, playbackQuality);\n                }\n            }\n            if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n                const minIdx = getMinAllowedIndexFor(type);\n                const topQualityIdx = getTopQualityIndexFor(type, streamId);\n                const switchRequest = abrRulesCollection.getMaxQuality(rulesContext);\n                let newQuality = switchRequest.quality;\n                if (minIdx !== undefined && ((newQuality > SwitchRequest.NO_CHANGE) ? newQuality : oldQuality) < minIdx) {\n                    newQuality = minIdx;\n                }\n                if (newQuality > topQualityIdx) {\n                    newQuality = topQualityIdx;\n                }\n\n                switchHistoryDict[type].push({ oldValue: oldQuality, newValue: newQuality });\n\n                if (newQuality > SwitchRequest.NO_CHANGE && newQuality != oldQuality) {\n                    if (abandonmentStateDict[type].state === MetricsConstants.ALLOW_LOAD || newQuality > oldQuality) {\n                        changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason);\n                    }\n                } else if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                    const bufferLevel = dashMetrics.getCurrentBufferLevel(type, true);\n                    logger.debug('[' + type + '] stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')');\n                }\n            }\n        }\n    }\n\n    function setPlaybackQuality(type, streamInfo, newQuality, reason) {\n        const id = streamInfo.id;\n        const oldQuality = getQualityFor(type);\n\n        checkInteger(newQuality);\n\n        const topQualityIdx = getTopQualityIndexFor(type, id);\n        if (newQuality !== oldQuality && newQuality >= 0 && newQuality <= topQualityIdx) {\n            changeQuality(type, oldQuality, newQuality, topQualityIdx, reason);\n        }\n    }\n\n    function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) {\n        if (type && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(type);\n                logger.info('[' + type + '] switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.'));\n            }\n            setQualityFor(type, id, newQuality);\n            eventBus.trigger(Events.QUALITY_CHANGE_REQUESTED,\n                {\n                    oldQuality: oldQuality,\n                    newQuality: newQuality,\n                    reason: reason\n                },\n                { streamId: streamInfo.id, mediaType: type }\n            );\n            const bitrate = throughputHistory.getAverageThroughput(type);\n            if (!isNaN(bitrate)) {\n                domStorage.setSavedBitrateSettings(type, bitrate);\n            }\n        }\n    }\n\n    function setAbandonmentStateFor(type, state) {\n        abandonmentStateDict[type].state = state;\n    }\n\n    function getAbandonmentStateFor(type) {\n        return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @param {number} bitrate A bitrate value, kbps\n     * @param {number} latency Expected latency of connection, ms\n     * @returns {number} A quality index <= for the given bitrate\n     * @memberof AbrController#\n     */\n    function getQualityForBitrate(mediaInfo, bitrate, latency) {\n        const voRepresentation = mediaInfo && mediaInfo.type ? streamProcessorDict[mediaInfo.type].getRepresentationInfo() : null;\n\n        if (settings.get().streaming.abr.useDeadTimeLatency && latency && voRepresentation && voRepresentation.fragmentDuration) {\n            latency = latency / 1000;\n            const fragmentDuration = voRepresentation.fragmentDuration;\n            if (latency > fragmentDuration) {\n                return 0;\n            } else {\n                const deadTimeRatio = latency / fragmentDuration;\n                bitrate = bitrate * (1 - deadTimeRatio);\n            }\n        }\n\n        const bitrateList = getBitrateList(mediaInfo);\n\n        for (let i = bitrateList.length - 1; i >= 0; i--) {\n            const bitrateInfo = bitrateList[i];\n            if (bitrate * 1000 >= bitrateInfo.bitrate) {\n                return i;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @returns {Array|null} A list of {@link BitrateInfo} objects\n     * @memberof AbrController#\n     */\n    function getBitrateList(mediaInfo) {\n        const infoList = [];\n        if (!mediaInfo || !mediaInfo.bitrateList) return infoList;\n\n        const bitrateList = mediaInfo.bitrateList;\n        const type = mediaInfo.type;\n\n        let bitrateInfo;\n\n        for (let i = 0, ln = bitrateList.length; i < ln; i++) {\n            bitrateInfo = new BitrateInfo();\n            bitrateInfo.mediaType = type;\n            bitrateInfo.qualityIndex = i;\n            bitrateInfo.bitrate = bitrateList[i].bandwidth;\n            bitrateInfo.width = bitrateList[i].width;\n            bitrateInfo.height = bitrateList[i].height;\n            bitrateInfo.scanType = bitrateList[i].scanType;\n            infoList.push(bitrateInfo);\n        }\n\n        return infoList;\n    }\n\n    function _updateAbrStrategy(mediaType, bufferLevel) {\n        const strategy = settings.get().streaming.abr.ABRStrategy;\n\n        if (strategy === Constants.ABR_STRATEGY_L2A) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingLoLPBRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = true;\n            return;\n        }\n        if (strategy === Constants.ABR_STRATEGY_LoLP) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingLoLPBRDict[mediaType] = true;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        } else if (strategy === Constants.ABR_STRATEGY_BOLA) {\n            isUsingBufferOccupancyABRDict[mediaType] = true;\n            isUsingLoLPBRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        } else if (strategy === Constants.ABR_STRATEGY_THROUGHPUT) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingLoLPBRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        }\n        // else ABR_STRATEGY_DYNAMIC\n        _updateDynamicAbrStrategy(mediaType, bufferLevel);\n    }\n\n    function _updateDynamicAbrStrategy(mediaType, bufferLevel) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const switchOnThreshold = stableBufferTime;\n        const switchOffThreshold = 0.5 * stableBufferTime;\n\n        const useBufferABR = isUsingBufferOccupancyABRDict[mediaType];\n        const newUseBufferABR = bufferLevel > (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules\n        isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR;\n\n        if (newUseBufferABR !== useBufferABR) {\n            if (newUseBufferABR) {\n                logger.info('[' + mediaType + '] switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            } else {\n                logger.info('[' + mediaType + '] switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            }\n        }\n    }\n\n    function useBufferOccupancyABR(mediaType) {\n        return isUsingBufferOccupancyABRDict[mediaType];\n    }\n\n    function useL2AABR(mediaType) {\n        return isUsingL2AABRDict[mediaType];\n    }\n\n    function useLoLPABR(mediaType) {\n        return isUsingLoLPBRDict[mediaType];\n    }\n\n    function getThroughputHistory() {\n        return throughputHistory;\n    }\n\n    function updateTopQualityIndex(mediaInfo) {\n        const type = mediaInfo.type;\n        const streamId = mediaInfo.streamInfo.id;\n        const max = mediaInfo.representationCount - 1;\n\n        setTopQualityIndex(type, streamId, max);\n\n        return max;\n    }\n\n    function isPlayingAtTopQuality(streamInfo) {\n        const streamId = streamInfo ? streamInfo.id : null;\n        const audioQuality = getQualityFor(Constants.AUDIO);\n        const videoQuality = getQualityFor(Constants.VIDEO);\n\n        const isAtTop = (audioQuality === getTopQualityIndexFor(Constants.AUDIO, streamId)) &&\n            (videoQuality === getTopQualityIndexFor(Constants.VIDEO, streamId));\n\n        return isAtTop;\n    }\n\n    function getQualityFor(type) {\n        if (type && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            let quality;\n\n            if (id) {\n                qualityDict[id] = qualityDict[id] || {};\n\n                if (!qualityDict[id].hasOwnProperty(type)) {\n                    qualityDict[id][type] = QUALITY_DEFAULT;\n                }\n\n                quality = qualityDict[id][type];\n                return quality;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    function setQualityFor(type, id, value) {\n        qualityDict[id] = qualityDict[id] || {};\n        qualityDict[id][type] = value;\n    }\n\n    function setTopQualityIndex(type, id, value) {\n        topQualities[id] = topQualities[id] || {};\n        topQualities[id][type] = value;\n    }\n\n    function checkMaxBitrate(idx, type) {\n        let newIdx = idx;\n\n        if (!streamProcessorDict[type]) {\n            return newIdx;\n        }\n\n        const minIdx = getMinAllowedIndexFor(type);\n        if (minIdx !== undefined) {\n            newIdx = Math.max(idx, minIdx);\n        }\n\n        const maxIdx = getMaxAllowedIndexFor(type);\n        if (maxIdx !== undefined) {\n            newIdx = Math.min(newIdx, maxIdx);\n        }\n\n        return newIdx;\n    }\n\n    function checkMaxRepresentationRatio(idx, type, maxIdx) {\n        const maxRepresentationRatio = settings.get().streaming.abr.maxRepresentationRatio[type];\n        if (isNaN(maxRepresentationRatio) || maxRepresentationRatio >= 1 || maxRepresentationRatio < 0) {\n            return idx;\n        }\n        return Math.min(idx, Math.round(maxIdx * maxRepresentationRatio));\n    }\n\n    function setWindowResizeEventCalled(value) {\n        windowResizeEventCalled = value;\n    }\n\n    function setElementSize() {\n        if (videoModel) {\n            const hasPixelRatio = settings.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty('devicePixelRatio');\n            const pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1;\n            elementWidth = videoModel.getClientWidth() * pixelRatio;\n            elementHeight = videoModel.getClientHeight() * pixelRatio;\n        }\n    }\n\n    function checkPortalSize(idx, type) {\n        if (type !== Constants.VIDEO || !settings.get().streaming.abr.limitBitrateByPortal || !streamProcessorDict[type]) {\n            return idx;\n        }\n\n        if (!windowResizeEventCalled) {\n            setElementSize();\n        }\n\n        const representation = adapter.getAdaptationForType(0, type).Representation;\n        let newIdx = idx;\n\n        if (elementWidth > 0 && elementHeight > 0) {\n            while (\n                newIdx > 0 &&\n                representation[newIdx] &&\n                elementWidth < representation[newIdx].width &&\n                elementWidth - representation[newIdx - 1].width < representation[newIdx].width - elementWidth) {\n                newIdx = newIdx - 1;\n            }\n\n            // Make sure that in case of multiple representation elements have same\n            // resolution, every such element is included\n            while (newIdx < representation.length - 1 && representation[newIdx].width === representation[newIdx + 1].width) {\n                newIdx = newIdx + 1;\n            }\n        }\n\n        return newIdx;\n    }\n\n    function onFragmentLoadProgress(e) {\n        const type = e.request.mediaType;\n        if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n            const streamProcessor = streamProcessorDict[type];\n            if (!streamProcessor) return; // There may be a fragment load in progress when we switch periods and recreated some controllers.\n\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessor,\n                currentRequest: e.request,\n                useBufferOccupancyABR: useBufferOccupancyABR(type),\n                useL2AABR: useL2AABR(type),\n                useLoLPABR: useLoLPABR(type),\n                videoModel\n            });\n            const switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext);\n\n            if (switchRequest.quality > SwitchRequest.NO_CHANGE) {\n                const fragmentModel = streamProcessor.getFragmentModel();\n                const request = fragmentModel.getRequests({\n                    state: FragmentModel.FRAGMENT_MODEL_LOADING,\n                    index: e.request.index\n                })[0];\n                if (request) {\n                    //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total\n                    fragmentModel.abortRequests();\n                    setAbandonmentStateFor(type, MetricsConstants.ABANDON_LOAD);\n                    switchHistoryDict[type].reset();\n                    switchHistoryDict[type].push({\n                        oldValue: getQualityFor(type),\n                        newValue: switchRequest.quality,\n                        confidence: 1,\n                        reason: switchRequest.reason\n                    });\n                    setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason);\n\n                    clearTimeout(abandonmentTimeout);\n                    abandonmentTimeout = setTimeout(\n                        () => {\n                            setAbandonmentStateFor(type, MetricsConstants.ALLOW_LOAD);\n                            abandonmentTimeout = null;\n                        },\n                        settings.get().streaming.abandonLoadTimeout\n                    );\n                }\n            }\n        }\n    }\n\n    instance = {\n        isPlayingAtTopQuality: isPlayingAtTopQuality,\n        updateTopQualityIndex: updateTopQualityIndex,\n        getThroughputHistory: getThroughputHistory,\n        getBitrateList: getBitrateList,\n        getQualityForBitrate: getQualityForBitrate,\n        getTopBitrateInfoFor: getTopBitrateInfoFor,\n        getMaxAllowedIndexFor: getMaxAllowedIndexFor,\n        getMinAllowedIndexFor: getMinAllowedIndexFor,\n        getInitialBitrateFor: getInitialBitrateFor,\n        getQualityFor: getQualityFor,\n        getAbandonmentStateFor: getAbandonmentStateFor,\n        setPlaybackQuality: setPlaybackQuality,\n        checkPlaybackQuality: checkPlaybackQuality,\n        getTopQualityIndexFor: getTopQualityIndexFor,\n        setElementSize: setElementSize,\n        setWindowResizeEventCalled: setWindowResizeEventCalled,\n        createAbrRulesCollection: createAbrRulesCollection,\n        registerStreamType: registerStreamType,\n        unRegisterStreamType: unRegisterStreamType,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nAbrController.__dashjs_factory_name = 'AbrController';\nconst factory = FactoryMaker.getSingletonFactory(AbrController);\nfactory.QUALITY_DEFAULT = QUALITY_DEFAULT;\nFactoryMaker.updateSingletonFactory(AbrController.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}