{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Settings = require('../../core/Settings');\n\nvar _Settings2 = _interopRequireDefault(_Settings);\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* @module FetchLoader\n* @ignore\n* @description Manages download of resources via HTTP using fetch.\n* @param {Object} cfg - dependencies from parent\n*/\n\n\nfunction FetchLoader(cfg) {\n  cfg = cfg || {};\n  var context = this.context;\n  var requestModifier = cfg.requestModifier;\n  var boxParser = cfg.boxParser;\n  var settings = (0, _Settings2.default)(context).getInstance();\n  var instance = void 0;\n\n  function load(httpRequest) {\n    // Variables will be used in the callback functions\n    var requestStartTime = new Date();\n    var request = httpRequest.request;\n    var headers = new Headers();\n    /*jshint ignore:line*/\n\n    if (request.range) {\n      headers.append('Range', 'bytes=' + request.range);\n    }\n\n    if (httpRequest.headers) {\n      for (var header in httpRequest.headers) {\n        var value = httpRequest.headers[header];\n\n        if (value) {\n          headers.append(header, value);\n        }\n      }\n    }\n\n    if (!request.requestStartDate) {\n      request.requestStartDate = requestStartTime;\n    }\n\n    if (requestModifier) {\n      // modifyRequestHeader expects a XMLHttpRequest object so,\n      // to keep backward compatibility, we should expose a setRequestHeader method\n      // TODO: Remove RequestModifier dependency on XMLHttpRequest object and define\n      // a more generic way to intercept/modify requests\n      requestModifier.modifyRequestHeader({\n        setRequestHeader: function setRequestHeader(header, value) {\n          headers.append(header, value);\n        }\n      });\n    }\n\n    var abortController = void 0;\n\n    if (typeof window.AbortController === 'function') {\n      abortController = new AbortController();\n      /*jshint ignore:line*/\n\n      httpRequest.abortController = abortController;\n      abortController.signal.onabort = httpRequest.onabort;\n    }\n\n    var reqOptions = {\n      method: httpRequest.method,\n      headers: headers,\n      credentials: httpRequest.withCredentials ? 'include' : undefined,\n      signal: abortController ? abortController.signal : undefined\n    };\n    fetch(httpRequest.url, reqOptions).then(function (response) {\n      if (!httpRequest.response) {\n        httpRequest.response = {};\n      }\n\n      httpRequest.response.status = response.status;\n      httpRequest.response.statusText = response.statusText;\n      httpRequest.response.responseURL = response.url;\n\n      if (!response.ok) {\n        httpRequest.onerror();\n      }\n\n      var responseHeaders = '';\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = response.headers.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          responseHeaders += key + ': ' + response.headers.get(key) + '\\r\\n';\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      httpRequest.response.responseHeaders = responseHeaders;\n\n      if (!response.body) {\n        // Fetch returning a ReadableStream response body is not currently supported by all browsers.\n        // Browser compatibility: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n        // If it is not supported, returning the whole segment when it's ready (as xhr)\n        return response.arrayBuffer().then(function (buffer) {\n          httpRequest.response.response = buffer;\n          var event = {\n            loaded: buffer.byteLength,\n            total: buffer.byteLength,\n            stream: false\n          };\n          httpRequest.progress(event);\n          httpRequest.onload();\n          httpRequest.onend();\n          return;\n        });\n      }\n\n      var totalBytes = parseInt(response.headers.get('Content-Length'), 10);\n      var bytesReceived = 0;\n      var signaledFirstByte = false;\n      var remaining = new Uint8Array();\n      var offset = 0;\n      httpRequest.reader = response.body.getReader();\n      var downloadedData = [];\n      var startTimeData = [];\n      var endTimeData = [];\n      var lastChunkWasFinished = true;\n      var calculationMode = settings.get().streaming.abr.fetchThroughputCalculationMode;\n\n      var processResult = function processResult(_ref) {\n        var value = _ref.value,\n            done = _ref.done; // Bug fix Parse whenever data is coming [value] better than 1ms looking that increase CPU\n\n        if (done) {\n          if (remaining) {\n            // If there is pending data, call progress so network metrics\n            // are correctly generated\n            // Same structure as https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/\n            httpRequest.progress({\n              loaded: bytesReceived,\n              total: isNaN(totalBytes) ? bytesReceived : totalBytes,\n              lengthComputable: true,\n              time: calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived),\n              stream: true\n            });\n            httpRequest.response.response = remaining.buffer;\n          }\n\n          httpRequest.onload();\n          httpRequest.onend();\n          return;\n        }\n\n        if (value && value.length > 0) {\n          remaining = concatTypedArray(remaining, value);\n          bytesReceived += value.length;\n          downloadedData.push({\n            ts: Date.now(),\n            bytes: value.length\n          });\n\n          if (calculationMode === _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING && lastChunkWasFinished) {\n            // Parse the payload and capture the the 'moof' box\n            var _boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moof'], remaining, offset);\n\n            if (_boxesInfo.found) {\n              // Store the beginning time of each chunk download in array StartTimeData\n              lastChunkWasFinished = false;\n              startTimeData.push({\n                ts: performance.now(),\n\n                /* jshint ignore:line */\n                bytes: value.length\n              });\n            }\n          }\n\n          var boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moov', 'mdat'], remaining, offset);\n\n          if (boxesInfo.found) {\n            var end = boxesInfo.lastCompletedOffset + boxesInfo.size; // Store the end time of each chunk download  with its size in array EndTimeData\n\n            if (calculationMode === _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING) {\n              lastChunkWasFinished = true;\n              endTimeData.push({\n                ts: performance.now(),\n\n                /* jshint ignore:line */\n                bytes: remaining.length\n              });\n            } // If we are going to pass full buffer, avoid copying it and pass\n            // complete buffer. Otherwise clone the part of the buffer that is completed\n            // and adjust remaining buffer. A clone is needed because ArrayBuffer of a typed-array\n            // keeps a reference to the original data\n\n\n            var data = void 0;\n\n            if (end === remaining.length) {\n              data = remaining;\n              remaining = new Uint8Array();\n            } else {\n              data = new Uint8Array(remaining.subarray(0, end));\n              remaining = remaining.subarray(end);\n            } // Announce progress but don't track traces. Throughput measures are quite unstable\n            // when they are based in small amount of data\n\n\n            httpRequest.progress({\n              data: data.buffer,\n              lengthComputable: false,\n              noTrace: true\n            });\n            offset = 0;\n          } else {\n            offset = boxesInfo.lastCompletedOffset; // Call progress so it generates traces that will be later used to know when the first byte\n            // were received\n\n            if (!signaledFirstByte) {\n              httpRequest.progress({\n                lengthComputable: false,\n                noTrace: true\n              });\n              signaledFirstByte = true;\n            }\n          }\n        }\n\n        read(httpRequest, processResult);\n      };\n\n      read(httpRequest, processResult);\n    }).catch(function (e) {\n      if (httpRequest.onerror) {\n        httpRequest.onerror(e);\n      }\n    });\n  }\n\n  function read(httpRequest, processResult) {\n    httpRequest.reader.read().then(processResult).catch(function (e) {\n      if (httpRequest.onerror && httpRequest.response.status === 200) {\n        // Error, but response code is 200, trigger error\n        httpRequest.onerror(e);\n      }\n    });\n  }\n\n  function concatTypedArray(remaining, data) {\n    if (remaining.length === 0) {\n      return data;\n    }\n\n    var result = new Uint8Array(remaining.length + data.length);\n    result.set(remaining);\n    result.set(data, remaining.length);\n    return result;\n  }\n\n  function abort(request) {\n    if (request.abortController) {\n      // For firefox and edge\n      request.abortController.abort();\n    } else if (request.reader) {\n      // For Chrome\n      try {\n        request.reader.cancel();\n        request.onabort();\n      } catch (e) {// throw exceptions (TypeError) when reader was previously closed,\n        // for example, because a network issue\n      }\n    }\n  } // Compute the download time of a segment\n\n\n  function calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived) {\n    switch (calculationMode) {\n      case _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING:\n        return _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData);\n\n      case _Constants2.default.ABR_FETCH_THROUGHPUT_CALCULATION_DOWNLOADED_DATA:\n        return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n\n      default:\n        return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n    }\n  }\n\n  function _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData) {\n    try {\n      var datum = void 0,\n          datumE = void 0; // Filter the first and last chunks in a segment in both arrays [StartTimeData and EndTimeData]\n\n      datum = startTimeData.filter(function (data, i) {\n        return i > 0 && i < startTimeData.length - 1;\n      });\n      datumE = endTimeData.filter(function (dataE, i) {\n        return i > 0 && i < endTimeData.length - 1;\n      }); // Compute the download time of a segment based on the filtered data [last chunk end time - first chunk beginning time]\n\n      var segDownloadTime = 0;\n\n      if (datum.length > 1) {\n        for (var i = 0; i < datum.length; i++) {\n          if (datum[i] && datumE[i]) {\n            var chunkDownladTime = datumE[i].ts - datum[i].ts;\n            segDownloadTime += chunkDownladTime;\n          }\n        }\n\n        return segDownloadTime;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived) {\n    try {\n      downloadedData = downloadedData.filter(function (data) {\n        return data.bytes > bytesReceived / 4 / downloadedData.length;\n      });\n\n      if (downloadedData.length > 1) {\n        var time = 0;\n        var avgTimeDistance = (downloadedData[downloadedData.length - 1].ts - downloadedData[0].ts) / downloadedData.length;\n        downloadedData.forEach(function (data, index) {\n          // To be counted the data has to be over a threshold\n          var next = downloadedData[index + 1];\n\n          if (next) {\n            var distance = next.ts - data.ts;\n            time += distance < avgTimeDistance ? distance : 0;\n          }\n        });\n        return time;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  instance = {\n    load: load,\n    abort: abort,\n    calculateDownloadedTime: calculateDownloadedTime\n  };\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nFetchLoader.__dashjs_factory_name = 'FetchLoader';\n\nvar factory = _FactoryMaker2.default.getClassFactory(FetchLoader);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../src/streaming/net/FetchLoader.js"],"names":["cfg","context","requestModifier","boxParser","settings","instance","requestStartTime","request","httpRequest","headers","value","setRequestHeader","abortController","window","reqOptions","method","credentials","signal","response","responseHeaders","key","event","loaded","buffer","total","stream","totalBytes","parseInt","bytesReceived","signaledFirstByte","remaining","offset","downloadedData","startTimeData","endTimeData","lastChunkWasFinished","calculationMode","processResult","done","isNaN","lengthComputable","time","calculateDownloadedTime","concatTypedArray","ts","Date","bytes","Constants","boxesInfo","performance","end","data","noTrace","read","result","_calculateDownloadedTimeByMoofParsing","_calculateDownloadedTimeByBytesReceived","datum","datumE","i","segDownloadTime","chunkDownladTime","avgTimeDistance","next","index","distance","load","abort","FetchLoader","factory","FactoryMaker"],"mappings":";;;;;;AA+BA,IAAA,aAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;;;;;;;AAEA;AAAA;;;;;;;;AAMA,SAAA,WAAA,CAAA,GAAA,EAA0B;AAEtBA,EAAAA,GAAAA,GAAMA,GAAAA,IAANA,EAAAA;AACA,MAAMC,OAAAA,GAAU,KAAhB,OAAA;AACA,MAAMC,eAAAA,GAAkBF,GAAAA,CAAxB,eAAA;AACA,MAAMG,SAAAA,GAAYH,GAAAA,CAAlB,SAAA;AACA,MAAMI,QAAAA,GAAW,CAAA,GAAA,UAAA,CAAA,OAAA,EAAA,OAAA,EAAjB,WAAiB,EAAjB;AACA,MAAIC,QAAAA,GAAAA,KAAJ,CAAA;;AAEA,WAAA,IAAA,CAAA,WAAA,EAA2B;AAEvB;AACA,QAAMC,gBAAAA,GAAmB,IAAzB,IAAyB,EAAzB;AACA,QAAMC,OAAAA,GAAUC,WAAAA,CAAhB,OAAA;AAEA,QAAMC,OAAAA,GAAU,IAAhB,OAAgB,EAAhB;AAA+B;;AAC/B,QAAIF,OAAAA,CAAJ,KAAA,EAAmB;AACfE,MAAAA,OAAAA,CAAAA,MAAAA,CAAAA,OAAAA,EAAwB,WAAWF,OAAAA,CAAnCE,KAAAA;AAGJ;;AAAA,QAAID,WAAAA,CAAJ,OAAA,EAAyB;AACrB,WAAK,IAAL,MAAA,IAAmBA,WAAAA,CAAnB,OAAA,EAAwC;AACpC,YAAIE,KAAAA,GAAQF,WAAAA,CAAAA,OAAAA,CAAZ,MAAYA,CAAZ;;AACA,YAAA,KAAA,EAAW;AACPC,UAAAA,OAAAA,CAAAA,MAAAA,CAAAA,MAAAA,EAAAA,KAAAA;AAEP;AACJ;AAED;;AAAA,QAAI,CAACF,OAAAA,CAAL,gBAAA,EAA+B;AAC3BA,MAAAA,OAAAA,CAAAA,gBAAAA,GAAAA,gBAAAA;AAGJ;;AAAA,QAAA,eAAA,EAAqB;AACjB;AACA;AACA;AACA;AACAL,MAAAA,eAAAA,CAAAA,mBAAAA,CAAoC;AAChCS,QAAAA,gBAAAA,EAAkB,SAAA,gBAAA,CAAA,MAAA,EAAA,KAAA,EAAyB;AACvCF,UAAAA,OAAAA,CAAAA,MAAAA,CAAAA,MAAAA,EAAAA,KAAAA;AAFRP;AAAoC,OAApCA;AAOJ;;AAAA,QAAIU,eAAAA,GAAAA,KAAJ,CAAA;;AACA,QAAI,OAAOC,MAAAA,CAAP,eAAA,KAAJ,UAAA,EAAkD;AAC9CD,MAAAA,eAAAA,GAAkB,IAAlBA,eAAkB,EAAlBA;AAAyC;;AACzCJ,MAAAA,WAAAA,CAAAA,eAAAA,GAAAA,eAAAA;AACAI,MAAAA,eAAAA,CAAAA,MAAAA,CAAAA,OAAAA,GAAiCJ,WAAAA,CAAjCI,OAAAA;AAGJ;;AAAA,QAAME,UAAAA,GAAa;AACfC,MAAAA,MAAAA,EAAQP,WAAAA,CADO,MAAA;AAEfC,MAAAA,OAAAA,EAFe,OAAA;AAGfO,MAAAA,WAAAA,EAAaR,WAAAA,CAAAA,eAAAA,GAAAA,SAAAA,GAHE,SAAA;AAIfS,MAAAA,MAAAA,EAAQL,eAAAA,GAAkBA,eAAAA,CAAlBA,MAAAA,GAJZ;AAAmB,KAAnB;AAOA,IAAA,KAAA,CAAMJ,WAAAA,CAAN,GAAA,EAAA,UAAA,CAAA,CAAA,IAAA,CAAwC,UAAA,QAAA,EAAoB;AACxD,UAAI,CAACA,WAAAA,CAAL,QAAA,EAA2B;AACvBA,QAAAA,WAAAA,CAAAA,QAAAA,GAAAA,EAAAA;AAEJA;;AAAAA,MAAAA,WAAAA,CAAAA,QAAAA,CAAAA,MAAAA,GAA8BU,QAAAA,CAA9BV,MAAAA;AACAA,MAAAA,WAAAA,CAAAA,QAAAA,CAAAA,UAAAA,GAAkCU,QAAAA,CAAlCV,UAAAA;AACAA,MAAAA,WAAAA,CAAAA,QAAAA,CAAAA,WAAAA,GAAmCU,QAAAA,CAAnCV,GAAAA;;AAEA,UAAI,CAACU,QAAAA,CAAL,EAAA,EAAkB;AACdV,QAAAA,WAAAA,CAAAA,OAAAA;AAGJ;;AAAA,UAAIW,eAAAA,GAAJ,EAAA;AAZwD,UAAA,yBAAA,GAAA,IAAA;AAAA,UAAA,iBAAA,GAAA,KAAA;AAAA,UAAA,cAAA,GAAA,SAAA;;AAAA,UAAA;AAaxD,aAAA,IAAA,SAAA,GAAkBD,QAAAA,CAAAA,OAAAA,CAAlB,IAAkBA,GAAlB,MAAA,CAAA,QAAkBA,GAAlB,EAAA,KAAA,EAAA,EAAA,yBAAA,GAAA,CAAA,KAAA,GAAA,SAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,yBAAA,GAAA,IAAA,EAA2C;AAAhCE,cAAAA,GAAgC,GAAA,KAAA,CAAA,KAAhCA;AACPD,UAAAA,eAAAA,IAAmBC,GAAAA,GAAAA,IAAAA,GAAaF,QAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAbE,GAAaF,CAAbE,GAAnBD,MAAAA;AAdoD;AAAA,OAAA,CAAA,OAAA,GAAA,EAAA;AAAA,QAAA,iBAAA,GAAA,IAAA;AAAA,QAAA,cAAA,GAAA,GAAA;AAAA,OAAA,SAAA;AAAA,YAAA;AAAA,cAAA,CAAA,yBAAA,IAAA,SAAA,CAAA,MAAA,EAAA;AAAA,YAAA,SAAA,CAAA,MAAA;AAAA;AAAA,SAAA,SAAA;AAAA,cAAA,iBAAA,EAAA;AAAA,kBAAA,cAAA;AAAA;AAAA;AAgBxDX;;AAAAA,MAAAA,WAAAA,CAAAA,QAAAA,CAAAA,eAAAA,GAAAA,eAAAA;;AAEA,UAAI,CAACU,QAAAA,CAAL,IAAA,EAAoB;AAChB;AACA;AACA;AACA,eAAOA,QAAAA,CAAAA,WAAAA,GAAAA,IAAAA,CAA4B,UAAA,MAAA,EAAkB;AACjDV,UAAAA,WAAAA,CAAAA,QAAAA,CAAAA,QAAAA,GAAAA,MAAAA;AACA,cAAMa,KAAAA,GAAQ;AACVC,YAAAA,MAAAA,EAAQC,MAAAA,CADE,UAAA;AAEVC,YAAAA,KAAAA,EAAOD,MAAAA,CAFG,UAAA;AAGVE,YAAAA,MAAAA,EAHJ;AAAc,WAAd;AAKAjB,UAAAA,WAAAA,CAAAA,QAAAA,CAAAA,KAAAA;AACAA,UAAAA,WAAAA,CAAAA,MAAAA;AACAA,UAAAA,WAAAA,CAAAA,KAAAA;AACA;AAVJ,SAAOU,CAAP;AAcJ;;AAAA,UAAMQ,UAAAA,GAAaC,QAAAA,CAAST,QAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAATS,gBAAST,CAATS,EAAnB,EAAmBA,CAAnB;AACA,UAAIC,aAAAA,GAAJ,CAAA;AACA,UAAIC,iBAAAA,GAAJ,KAAA;AACA,UAAIC,SAAAA,GAAY,IAAhB,UAAgB,EAAhB;AACA,UAAIC,MAAAA,GAAJ,CAAA;AAEAvB,MAAAA,WAAAA,CAAAA,MAAAA,GAAqBU,QAAAA,CAAAA,IAAAA,CAArBV,SAAqBU,EAArBV;AACA,UAAIwB,cAAAA,GAAJ,EAAA;AACA,UAAIC,aAAAA,GAAJ,EAAA;AACA,UAAIC,WAAAA,GAAJ,EAAA;AACA,UAAIC,oBAAAA,GAAJ,IAAA;AACA,UAAMC,eAAAA,GAAkBhC,QAAAA,CAAAA,GAAAA,GAAAA,SAAAA,CAAAA,GAAAA,CAAxB,8BAAA;;AAEA,UAAMiC,aAAAA,GAAAA,SAAAA,aAAAA,CAAgB,IAAhBA,EAA2C;AAAf3B,YAAAA,KAAe,GAAA,IAAA,CAAfA,KAAAA;AAAAA,YAAO4B,IAAQ,GAAA,IAAA,CAARA,IAAP5B,CAAe,CAAE;;AAC/C,YAAA,IAAA,EAAU;AACN,cAAA,SAAA,EAAe;AACX;AACA;AACA;AACAF,YAAAA,WAAAA,CAAAA,QAAAA,CAAqB;AACjBc,cAAAA,MAAAA,EADiB,aAAA;AAEjBE,cAAAA,KAAAA,EAAOe,KAAAA,CAAAA,UAAAA,CAAAA,GAAAA,aAAAA,GAFU,UAAA;AAGjBC,cAAAA,gBAAAA,EAHiB,IAAA;AAIjBC,cAAAA,IAAAA,EAAMC,uBAAAA,CAAAA,eAAAA,EAAAA,aAAAA,EAAAA,WAAAA,EAAAA,cAAAA,EAJW,aAIXA,CAJW;AAKjBjB,cAAAA,MAAAA,EALJjB;AAAqB,aAArBA;AAQAA,YAAAA,WAAAA,CAAAA,QAAAA,CAAAA,QAAAA,GAAgCsB,SAAAA,CAAhCtB,MAAAA;AAEJA;;AAAAA,UAAAA,WAAAA,CAAAA,MAAAA;AACAA,UAAAA,WAAAA,CAAAA,KAAAA;AACA;AAGJ;;AAAA,YAAIE,KAAAA,IAASA,KAAAA,CAAAA,MAAAA,GAAb,CAAA,EAA+B;AAC3BoB,UAAAA,SAAAA,GAAYa,gBAAAA,CAAAA,SAAAA,EAAZb,KAAYa,CAAZb;AACAF,UAAAA,aAAAA,IAAiBlB,KAAAA,CAAjBkB,MAAAA;AAEAI,UAAAA,cAAAA,CAAAA,IAAAA,CAAoB;AAChBY,YAAAA,EAAAA,EAAIC,IAAAA,CADY,GACZA,EADY;AAEhBC,YAAAA,KAAAA,EAAOpC,KAAAA,CAFXsB;AAAoB,WAApBA;;AAKA,cAAII,eAAAA,KAAoBW,WAAAA,CAAAA,OAAAA,CAApBX,6CAAAA,IAAJ,oBAAA,EAAyG;AACrG;AACA,gBAAMY,UAAAA,GAAY7C,SAAAA,CAAAA,0BAAAA,CAAqC,CAArCA,MAAqC,CAArCA,EAAAA,SAAAA,EAAlB,MAAkBA,CAAlB;;AACA,gBAAI6C,UAAAA,CAAJ,KAAA,EAAqB;AACjB;AACAb,cAAAA,oBAAAA,GAAAA,KAAAA;AACAF,cAAAA,aAAAA,CAAAA,IAAAA,CAAmB;AACfW,gBAAAA,EAAAA,EAAIK,WAAAA,CADW,GACXA,EADW;;AACQ;AACvBH,gBAAAA,KAAAA,EAAOpC,KAAAA,CAFXuB;AAAmB,eAAnBA;AAKP;AAED;;AAAA,cAAMe,SAAAA,GAAY7C,SAAAA,CAAAA,0BAAAA,CAAqC,CAAA,MAAA,EAArCA,MAAqC,CAArCA,EAAAA,SAAAA,EAAlB,MAAkBA,CAAlB;;AACA,cAAI6C,SAAAA,CAAJ,KAAA,EAAqB;AACjB,gBAAME,GAAAA,GAAMF,SAAAA,CAAAA,mBAAAA,GAAgCA,SAAAA,CAA5C,IAAA,CADiB,CAGjB;;AACA,gBAAIZ,eAAAA,KAAoBW,WAAAA,CAAAA,OAAAA,CAAxB,6CAAA,EAAiF;AAC7EZ,cAAAA,oBAAAA,GAAAA,IAAAA;AACAD,cAAAA,WAAAA,CAAAA,IAAAA,CAAiB;AACbU,gBAAAA,EAAAA,EAAIK,WAAAA,CADS,GACTA,EADS;;AACU;AACvBH,gBAAAA,KAAAA,EAAOhB,SAAAA,CAFXI;AAAiB,eAAjBA;AAMJ,aAZiB,CAYjB;AACA;AACA;AACA;;;AACA,gBAAIiB,IAAAA,GAAAA,KAAJ,CAAA;;AACA,gBAAID,GAAAA,KAAQpB,SAAAA,CAAZ,MAAA,EAA8B;AAC1BqB,cAAAA,IAAAA,GAAAA,SAAAA;AACArB,cAAAA,SAAAA,GAAY,IAAZA,UAAY,EAAZA;AAFJ,aAAA,MAGO;AACHqB,cAAAA,IAAAA,GAAO,IAAA,UAAA,CAAerB,SAAAA,CAAAA,QAAAA,CAAAA,CAAAA,EAAtBqB,GAAsBrB,CAAf,CAAPqB;AACArB,cAAAA,SAAAA,GAAYA,SAAAA,CAAAA,QAAAA,CAAZA,GAAYA,CAAZA;AAEJ,aAxBiB,CAwBjB;AACA;;;AACAtB,YAAAA,WAAAA,CAAAA,QAAAA,CAAqB;AACjB2C,cAAAA,IAAAA,EAAMA,IAAAA,CADW,MAAA;AAEjBX,cAAAA,gBAAAA,EAFiB,KAAA;AAGjBY,cAAAA,OAAAA,EAHJ5C;AAAqB,aAArBA;AAMAuB,YAAAA,MAAAA,GAAAA,CAAAA;AAhCJ,WAAA,MAiCO;AACHA,YAAAA,MAAAA,GAASiB,SAAAA,CAATjB,mBAAAA,CADG,CAEH;AACA;;AACA,gBAAI,CAAJ,iBAAA,EAAwB;AACpBvB,cAAAA,WAAAA,CAAAA,QAAAA,CAAqB;AACjBgC,gBAAAA,gBAAAA,EADiB,KAAA;AAEjBY,gBAAAA,OAAAA,EAFJ5C;AAAqB,eAArBA;AAIAqB,cAAAA,iBAAAA,GAAAA,IAAAA;AAEP;AACJ;AACDwB;;AAAAA,QAAAA,IAAAA,CAAAA,WAAAA,EAAAA,aAAAA,CAAAA;AA1FJ,OAAA;;AA4FAA,MAAAA,IAAAA,CAAAA,WAAAA,EAAAA,aAAAA,CAAAA;AA7IJ,KAAA,EAAA,KAAA,CA+IW,UAAA,CAAA,EAAa;AAChB,UAAI7C,WAAAA,CAAJ,OAAA,EAAyB;AACrBA,QAAAA,WAAAA,CAAAA,OAAAA,CAAAA,CAAAA;AAEP;AAnJL,KAAA;AAsJJ;;AAAA,WAAA,IAAA,CAAA,WAAA,EAAA,aAAA,EAA0C;AACtC,IAAA,WAAA,CAAA,MAAA,CAAA,IAAA,GAAA,IAAA,CAAA,aAAA,EAAA,KAAA,CAEW,UAAA,CAAA,EAAa;AAChB,UAAIA,WAAAA,CAAAA,OAAAA,IAAuBA,WAAAA,CAAAA,QAAAA,CAAAA,MAAAA,KAA3B,GAAA,EAAgE;AAC5D;AACAA,QAAAA,WAAAA,CAAAA,OAAAA,CAAAA,CAAAA;AAEP;AAPL,KAAA;AAUJ;;AAAA,WAAA,gBAAA,CAAA,SAAA,EAAA,IAAA,EAA2C;AACvC,QAAIsB,SAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAA4B;AACxB,aAAA,IAAA;AAEJ;;AAAA,QAAMwB,MAAAA,GAAS,IAAA,UAAA,CAAexB,SAAAA,CAAAA,MAAAA,GAAmBqB,IAAAA,CAAjD,MAAe,CAAf;AACAG,IAAAA,MAAAA,CAAAA,GAAAA,CAAAA,SAAAA;AACAA,IAAAA,MAAAA,CAAAA,GAAAA,CAAAA,IAAAA,EAAiBxB,SAAAA,CAAjBwB,MAAAA;AACA,WAAA,MAAA;AAGJ;;AAAA,WAAA,KAAA,CAAA,OAAA,EAAwB;AACpB,QAAI/C,OAAAA,CAAJ,eAAA,EAA6B;AACzB;AACAA,MAAAA,OAAAA,CAAAA,eAAAA,CAAAA,KAAAA;AAFJ,KAAA,MAGO,IAAIA,OAAAA,CAAJ,MAAA,EAAoB;AACvB;AACA,UAAI;AACAA,QAAAA,OAAAA,CAAAA,MAAAA,CAAAA,MAAAA;AACAA,QAAAA,OAAAA,CAAAA,OAAAA;AACF,OAHF,CAGE,OAAA,CAAA,EAAU,CACR;AACA;AAEP;AACJ;AAED,GAtPsB,CAsPtB;;;AACA,WAAA,uBAAA,CAAA,eAAA,EAAA,aAAA,EAAA,WAAA,EAAA,cAAA,EAAA,aAAA,EAA6G;AACzG,YAAA,eAAA;AACI,WAAKwC,WAAAA,CAAAA,OAAAA,CAAL,6CAAA;AACI,eAAOQ,qCAAAA,CAAAA,aAAAA,EAAP,WAAOA,CAAP;;AACJ,WAAKR,WAAAA,CAAAA,OAAAA,CAAL,gDAAA;AACI,eAAOS,uCAAAA,CAAAA,cAAAA,EAAP,aAAOA,CAAP;;AACJ;AACI,eAAOA,uCAAAA,CAAAA,cAAAA,EANf,aAMeA,CAAP;AANR;AAUJ;;AAAA,WAAA,qCAAA,CAAA,aAAA,EAAA,WAAA,EAA2E;AACvE,QAAI;AACA,UAAIC,KAAAA,GAAAA,KAAJ,CAAA;AAAA,UAAWC,MAAAA,GAAAA,KAAX,CAAA,CADA,CAEA;;AACAD,MAAAA,KAAAA,GAAQxB,aAAAA,CAAAA,MAAAA,CAAqB,UAAA,IAAA,EAAA,CAAA,EAAA;AAAA,eAAa0B,CAAAA,GAAAA,CAAAA,IAASA,CAAAA,GAAI1B,aAAAA,CAAAA,MAAAA,GAA1B,CAAA;AAA7BwB,OAAQxB,CAARwB;AACAC,MAAAA,MAAAA,GAASxB,WAAAA,CAAAA,MAAAA,CAAmB,UAAA,KAAA,EAAA,CAAA,EAAA;AAAA,eAAcyB,CAAAA,GAAAA,CAAAA,IAASA,CAAAA,GAAIzB,WAAAA,CAAAA,MAAAA,GAA3B,CAAA;AAA5BwB,OAASxB,CAATwB,CAJA,CAKA;;AACA,UAAIE,eAAAA,GAAJ,CAAA;;AACA,UAAIH,KAAAA,CAAAA,MAAAA,GAAJ,CAAA,EAAsB;AAClB,aAAK,IAAIE,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAIF,KAAAA,CAApB,MAAA,EAAkCE,CAAlC,EAAA,EAAuC;AACnC,cAAIF,KAAAA,CAAAA,CAAAA,CAAAA,IAAYC,MAAAA,CAAhB,CAAgBA,CAAhB,EAA2B;AACvB,gBAAIG,gBAAAA,GAAmBH,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,GAAeD,KAAAA,CAAAA,CAAAA,CAAAA,CAAtC,EAAA;AACAG,YAAAA,eAAAA,IAAAA,gBAAAA;AAEP;AAED;;AAAA,eAAA,eAAA;AAEJ;;AAAA,aAAA,IAAA;AACF,KAlBF,CAkBE,OAAA,CAAA,EAAU;AACR,aAAA,IAAA;AAEP;AAED;;AAAA,WAAA,uCAAA,CAAA,cAAA,EAAA,aAAA,EAAgF;AAC5E,QAAI;AACA5B,MAAAA,cAAAA,GAAiBA,cAAAA,CAAAA,MAAAA,CAAsB,UAAA,IAAA,EAAA;AAAA,eAAQmB,IAAAA,CAAAA,KAAAA,GAAevB,aAAAA,GAAD,CAACA,GAAqBI,cAAAA,CAA5C,MAAA;AAAvCA,OAAiBA,CAAjBA;;AACA,UAAIA,cAAAA,CAAAA,MAAAA,GAAJ,CAAA,EAA+B;AAC3B,YAAIS,IAAAA,GAAJ,CAAA;AACA,YAAMqB,eAAAA,GAAkB,CAAC9B,cAAAA,CAAeA,cAAAA,CAAAA,MAAAA,GAAfA,CAAAA,CAAAA,CAAAA,EAAAA,GAA+CA,cAAAA,CAAAA,CAAAA,CAAAA,CAAhD,EAAA,IAAwEA,cAAAA,CAAhG,MAAA;AACA,QAAA,cAAA,CAAA,OAAA,CAAuB,UAAA,IAAA,EAAA,KAAA,EAAiB;AACpC;AACA,cAAM+B,IAAAA,GAAO/B,cAAAA,CAAegC,KAAAA,GAA5B,CAAahC,CAAb;;AACA,cAAA,IAAA,EAAU;AACN,gBAAMiC,QAAAA,GAAWF,IAAAA,CAAAA,EAAAA,GAAUZ,IAAAA,CAA3B,EAAA;AACAV,YAAAA,IAAAA,IAAQwB,QAAAA,GAAAA,eAAAA,GAAAA,QAAAA,GAARxB,CAAAA;AAEP;AAPD,SAAA;AAQA,eAAA,IAAA;AAEJ;;AAAA,aAAA,IAAA;AACF,KAhBF,CAgBE,OAAA,CAAA,EAAU;AACR,aAAA,IAAA;AAEP;AAEDpC;;AAAAA,EAAAA,QAAAA,GAAW;AACP6D,IAAAA,IAAAA,EADO,IAAA;AAEPC,IAAAA,KAAAA,EAFO,KAAA;AAGPzB,IAAAA,uBAAAA,EAHJrC;AAAW,GAAXA;AAMA,SAAA,QAAA;AA/VJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkWA+D,WAAAA,CAAAA,qBAAAA,GAAAA,aAAAA;;AAEA,IAAMC,OAAAA,GAAUC,cAAAA,CAAAA,OAAAA,CAAAA,eAAAA,CAAhB,WAAgBA,CAAhB;;kBACeD,O","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Settings from '../../core/Settings';\nimport Constants from '../constants/Constants';\n\n/**\n * @module FetchLoader\n * @ignore\n * @description Manages download of resources via HTTP using fetch.\n * @param {Object} cfg - dependencies from parent\n */\nfunction FetchLoader(cfg) {\n\n    cfg = cfg || {};\n    const context = this.context;\n    const requestModifier = cfg.requestModifier;\n    const boxParser = cfg.boxParser;\n    const settings = Settings(context).getInstance();\n    let instance;\n\n    function load(httpRequest) {\n\n        // Variables will be used in the callback functions\n        const requestStartTime = new Date();\n        const request = httpRequest.request;\n\n        const headers = new Headers(); /*jshint ignore:line*/\n        if (request.range) {\n            headers.append('Range', 'bytes=' + request.range);\n        }\n\n        if (httpRequest.headers) {\n            for (let header in httpRequest.headers) {\n                let value = httpRequest.headers[header];\n                if (value) {\n                    headers.append(header, value);\n                }\n            }\n        }\n\n        if (!request.requestStartDate) {\n            request.requestStartDate = requestStartTime;\n        }\n\n        if (requestModifier) {\n            // modifyRequestHeader expects a XMLHttpRequest object so,\n            // to keep backward compatibility, we should expose a setRequestHeader method\n            // TODO: Remove RequestModifier dependency on XMLHttpRequest object and define\n            // a more generic way to intercept/modify requests\n            requestModifier.modifyRequestHeader({\n                setRequestHeader: function (header, value) {\n                    headers.append(header, value);\n                }\n            });\n        }\n\n        let abortController;\n        if (typeof window.AbortController === 'function') {\n            abortController = new AbortController(); /*jshint ignore:line*/\n            httpRequest.abortController = abortController;\n            abortController.signal.onabort = httpRequest.onabort;\n        }\n\n        const reqOptions = {\n            method: httpRequest.method,\n            headers: headers,\n            credentials: httpRequest.withCredentials ? 'include' : undefined,\n            signal: abortController ? abortController.signal : undefined\n        };\n\n        fetch(httpRequest.url, reqOptions).then(function (response) {\n            if (!httpRequest.response) {\n                httpRequest.response = {};\n            }\n            httpRequest.response.status = response.status;\n            httpRequest.response.statusText = response.statusText;\n            httpRequest.response.responseURL = response.url;\n\n            if (!response.ok) {\n                httpRequest.onerror();\n            }\n\n            let responseHeaders = '';\n            for (const key of response.headers.keys()) {\n                responseHeaders += key + ': ' + response.headers.get(key) + '\\r\\n';\n            }\n            httpRequest.response.responseHeaders = responseHeaders;\n\n            if (!response.body) {\n                // Fetch returning a ReadableStream response body is not currently supported by all browsers.\n                // Browser compatibility: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n                // If it is not supported, returning the whole segment when it's ready (as xhr)\n                return response.arrayBuffer().then(function (buffer) {\n                    httpRequest.response.response = buffer;\n                    const event = {\n                        loaded: buffer.byteLength,\n                        total: buffer.byteLength,\n                        stream: false\n                    };\n                    httpRequest.progress(event);\n                    httpRequest.onload();\n                    httpRequest.onend();\n                    return;\n                });\n            }\n\n            const totalBytes = parseInt(response.headers.get('Content-Length'), 10);\n            let bytesReceived = 0;\n            let signaledFirstByte = false;\n            let remaining = new Uint8Array();\n            let offset = 0;\n\n            httpRequest.reader = response.body.getReader();\n            let downloadedData = [];\n            let startTimeData = [];\n            let endTimeData = [];\n            let lastChunkWasFinished = true;\n            const calculationMode = settings.get().streaming.abr.fetchThroughputCalculationMode;\n\n            const processResult = function ({ value, done }) { // Bug fix Parse whenever data is coming [value] better than 1ms looking that increase CPU\n                if (done) {\n                    if (remaining) {\n                        // If there is pending data, call progress so network metrics\n                        // are correctly generated\n                        // Same structure as https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/\n                        httpRequest.progress({\n                            loaded: bytesReceived,\n                            total: isNaN(totalBytes) ? bytesReceived : totalBytes,\n                            lengthComputable: true,\n                            time: calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived),\n                            stream: true\n                        });\n\n                        httpRequest.response.response = remaining.buffer;\n                    }\n                    httpRequest.onload();\n                    httpRequest.onend();\n                    return;\n                }\n\n                if (value && value.length > 0) {\n                    remaining = concatTypedArray(remaining, value);\n                    bytesReceived += value.length;\n\n                    downloadedData.push({\n                        ts: Date.now(),\n                        bytes: value.length\n                    });\n\n                    if (calculationMode === Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING && lastChunkWasFinished) {\n                        // Parse the payload and capture the the 'moof' box\n                        const boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moof'], remaining, offset);\n                        if (boxesInfo.found) {\n                            // Store the beginning time of each chunk download in array StartTimeData\n                            lastChunkWasFinished = false;\n                            startTimeData.push({\n                                ts: performance.now(), /* jshint ignore:line */\n                                bytes: value.length\n                            });\n                        }\n                    }\n\n                    const boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moov', 'mdat'], remaining, offset);\n                    if (boxesInfo.found) {\n                        const end = boxesInfo.lastCompletedOffset + boxesInfo.size;\n\n                        // Store the end time of each chunk download  with its size in array EndTimeData\n                        if (calculationMode === Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING) {\n                            lastChunkWasFinished = true;\n                            endTimeData.push({\n                                ts: performance.now(), /* jshint ignore:line */\n                                bytes: remaining.length\n                            });\n                        }\n\n                        // If we are going to pass full buffer, avoid copying it and pass\n                        // complete buffer. Otherwise clone the part of the buffer that is completed\n                        // and adjust remaining buffer. A clone is needed because ArrayBuffer of a typed-array\n                        // keeps a reference to the original data\n                        let data;\n                        if (end === remaining.length) {\n                            data = remaining;\n                            remaining = new Uint8Array();\n                        } else {\n                            data = new Uint8Array(remaining.subarray(0, end));\n                            remaining = remaining.subarray(end);\n                        }\n                        // Announce progress but don't track traces. Throughput measures are quite unstable\n                        // when they are based in small amount of data\n                        httpRequest.progress({\n                            data: data.buffer,\n                            lengthComputable: false,\n                            noTrace: true\n                        });\n\n                        offset = 0;\n                    } else {\n                        offset = boxesInfo.lastCompletedOffset;\n                        // Call progress so it generates traces that will be later used to know when the first byte\n                        // were received\n                        if (!signaledFirstByte) {\n                            httpRequest.progress({\n                                lengthComputable: false,\n                                noTrace: true\n                            });\n                            signaledFirstByte = true;\n                        }\n                    }\n                }\n                read(httpRequest, processResult);\n            };\n            read(httpRequest, processResult);\n        })\n            .catch(function (e) {\n                if (httpRequest.onerror) {\n                    httpRequest.onerror(e);\n                }\n            });\n    }\n\n    function read(httpRequest, processResult) {\n        httpRequest.reader.read()\n            .then(processResult)\n            .catch(function (e) {\n                if (httpRequest.onerror && httpRequest.response.status === 200) {\n                    // Error, but response code is 200, trigger error\n                    httpRequest.onerror(e);\n                }\n            });\n    }\n\n    function concatTypedArray(remaining, data) {\n        if (remaining.length === 0) {\n            return data;\n        }\n        const result = new Uint8Array(remaining.length + data.length);\n        result.set(remaining);\n        result.set(data, remaining.length);\n        return result;\n    }\n\n    function abort(request) {\n        if (request.abortController) {\n            // For firefox and edge\n            request.abortController.abort();\n        } else if (request.reader) {\n            // For Chrome\n            try {\n                request.reader.cancel();\n                request.onabort();\n            } catch (e) {\n                // throw exceptions (TypeError) when reader was previously closed,\n                // for example, because a network issue\n            }\n        }\n    }\n\n    // Compute the download time of a segment\n    function calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived) {\n        switch (calculationMode) {\n            case Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING:\n                return _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData);\n            case Constants.ABR_FETCH_THROUGHPUT_CALCULATION_DOWNLOADED_DATA:\n                return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n            default:\n                return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\n        }\n    }\n\n    function _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData) {\n        try {\n            let datum, datumE;\n            // Filter the first and last chunks in a segment in both arrays [StartTimeData and EndTimeData]\n            datum = startTimeData.filter((data, i) => i > 0 && i < startTimeData.length - 1);\n            datumE = endTimeData.filter((dataE, i) => i > 0 && i < endTimeData.length - 1);\n            // Compute the download time of a segment based on the filtered data [last chunk end time - first chunk beginning time]\n            let segDownloadTime = 0;\n            if (datum.length > 1) {\n                for (let i = 0; i < datum.length; i++) {\n                    if (datum[i] && datumE[i]) {\n                        let chunkDownladTime = datumE[i].ts - datum[i].ts;\n                        segDownloadTime += chunkDownladTime;\n                    }\n                }\n\n                return segDownloadTime;\n            }\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived) {\n        try {\n            downloadedData = downloadedData.filter(data => data.bytes > ((bytesReceived / 4) / downloadedData.length));\n            if (downloadedData.length > 1) {\n                let time = 0;\n                const avgTimeDistance = (downloadedData[downloadedData.length - 1].ts - downloadedData[0].ts) / downloadedData.length;\n                downloadedData.forEach((data, index) => {\n                    // To be counted the data has to be over a threshold\n                    const next = downloadedData[index + 1];\n                    if (next) {\n                        const distance = next.ts - data.ts;\n                        time += distance < avgTimeDistance ? distance : 0;\n                    }\n                });\n                return time;\n            }\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    instance = {\n        load: load,\n        abort: abort,\n        calculateDownloadedTime: calculateDownloadedTime\n    };\n\n    return instance;\n}\n\nFetchLoader.__dashjs_factory_name = 'FetchLoader';\n\nconst factory = FactoryMaker.getClassFactory(FetchLoader);\nexport default factory;\n\n"]},"metadata":{},"sourceType":"script"}