{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.THUMBNAILS_SCHEME_ID_URIS = undefined;\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _ThumbnailTrackInfo = require('../vo/ThumbnailTrackInfo');\n\nvar _ThumbnailTrackInfo2 = _interopRequireDefault(_ThumbnailTrackInfo);\n\nvar _URLUtils = require('../../streaming/utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nvar _SegmentsUtils = require('../../dash/utils/SegmentsUtils');\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _BoxParser = require('../../streaming/utils/BoxParser');\n\nvar _BoxParser2 = _interopRequireDefault(_BoxParser);\n\nvar _XHRLoader = require('../../streaming/net/XHRLoader');\n\nvar _XHRLoader2 = _interopRequireDefault(_XHRLoader);\n\nvar _DashHandler = require('../../dash/DashHandler');\n\nvar _DashHandler2 = _interopRequireDefault(_DashHandler);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar THUMBNAILS_SCHEME_ID_URIS = exports.THUMBNAILS_SCHEME_ID_URIS = ['http://dashif.org/thumbnail_tile', 'http://dashif.org/guidelines/thumbnail_tile'];\n\nfunction ThumbnailTracks(config) {\n  var context = this.context;\n  var adapter = config.adapter;\n  var baseURLController = config.baseURLController;\n  var streamInfo = config.streamInfo;\n  var timelineConverter = config.timelineConverter;\n  var debug = config.debug;\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var dashConstants = config.dashConstants;\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var instance = void 0,\n      tracks = void 0,\n      indexHandler = void 0,\n      currentTrackIndex = void 0,\n      mediaInfo = void 0,\n      loader = void 0,\n      boxParser = void 0;\n\n  function initialize() {\n    reset();\n    loader = (0, _XHRLoader2.default)(context).create({});\n    boxParser = (0, _BoxParser2.default)(context).getInstance();\n    indexHandler = (0, _DashHandler2.default)(context).create({\n      streamInfo: streamInfo,\n      timelineConverter: timelineConverter,\n      baseURLController: baseURLController,\n      debug: debug,\n      eventBus: eventBus,\n      events: events,\n      dashConstants: dashConstants,\n      urlUtils: urlUtils\n    }); // initialize controllers\n\n    indexHandler.initialize(adapter ? adapter.getIsDynamic() : false); // parse representation and create tracks\n\n    addTracks();\n  }\n\n  function normalizeSegments(fragments, representation) {\n    var segments = [];\n    var count = 0;\n    var i = void 0,\n        len = void 0,\n        s = void 0,\n        seg = void 0;\n\n    for (i = 0, len = fragments.length; i < len; i++) {\n      s = fragments[i];\n      seg = (0, _SegmentsUtils.getTimeBasedSegment)(timelineConverter, adapter.getIsDynamic(), representation, s.startTime, s.duration, s.timescale, s.media, s.mediaRange, count);\n\n      if (seg) {\n        segments.push(seg);\n        seg = null;\n        count++;\n      }\n    }\n\n    return segments;\n  }\n\n  function addTracks() {\n    if (!streamInfo || !adapter) {\n      return;\n    } // Extract thumbnail tracks\n\n\n    mediaInfo = adapter.getMediaInfoForType(streamInfo, _Constants2.default.IMAGE);\n\n    if (!mediaInfo) {\n      return;\n    }\n\n    var voReps = adapter.getVoRepresentations(mediaInfo);\n\n    if (voReps && voReps.length > 0) {\n      voReps.forEach(function (rep) {\n        if (rep.segmentInfoType === _DashConstants2.default.SEGMENT_TEMPLATE && rep.segmentDuration > 0 && rep.media || rep.segmentInfoType === _DashConstants2.default.SEGMENT_TIMELINE) {\n          createTrack(rep);\n        }\n\n        if (rep.segmentInfoType === _DashConstants2.default.SEGMENT_BASE) {\n          createTrack(rep, true);\n        }\n      });\n    }\n\n    if (tracks.length > 0) {\n      // Sort bitrates and select the lowest bitrate rendition\n      tracks.sort(function (a, b) {\n        return a.bitrate - b.bitrate;\n      });\n      currentTrackIndex = tracks.length - 1;\n    }\n  }\n\n  function createTrack(representation, useSegmentBase) {\n    var track = new _ThumbnailTrackInfo2.default();\n    track.id = representation.id;\n    track.bitrate = representation.bandwidth;\n    track.width = representation.width;\n    track.height = representation.height;\n    track.tilesHor = 1;\n    track.tilesVert = 1;\n\n    if (representation.essentialProperties) {\n      representation.essentialProperties.forEach(function (p) {\n        if (THUMBNAILS_SCHEME_ID_URIS.indexOf(p.schemeIdUri) >= 0 && p.value) {\n          var vars = p.value.split('x');\n\n          if (vars.length === 2 && !isNaN(vars[0]) && !isNaN(vars[1])) {\n            track.tilesHor = parseInt(vars[0], 10);\n            track.tilesVert = parseInt(vars[1], 10);\n          }\n        }\n      });\n    }\n\n    if (useSegmentBase) {\n      eventBus.trigger(_Events2.default.SEGMENTBASE_SEGMENTSLIST_REQUEST_NEEDED, {\n        streamId: streamInfo.id,\n        mediaType: _Constants2.default.IMAGE,\n        mimeType: mediaInfo.mimeType,\n        representation: representation,\n        callback: function callback(streamId, mediaType, segments, representation) {\n          var cache = [];\n          segments = normalizeSegments(segments, representation);\n          track.segmentDuration = segments[0].duration; //assume all segments have the same duration\n\n          track.readThumbnail = function (time, callback) {\n            var cached = null;\n            cache.some(function (el) {\n              if (el.start <= time && el.end > time) {\n                cached = el.url;\n                return true;\n              }\n            });\n\n            if (cached) {\n              callback(cached);\n            } else {\n              segments.some(function (ss) {\n                if (ss.mediaStartTime <= time && ss.mediaStartTime + ss.duration > time) {\n                  var baseURL = baseURLController.resolve(representation.path);\n                  loader.load({\n                    method: 'get',\n                    url: baseURL.url,\n                    request: {\n                      range: ss.mediaRange,\n                      responseType: 'arraybuffer'\n                    },\n                    onload: function onload(e) {\n                      var info = boxParser.getSamplesInfo(e.target.response);\n                      var blob = new Blob([e.target.response.slice(info.sampleList[0].offset, info.sampleList[0].offset + info.sampleList[0].size)], {\n                        type: 'image/jpeg'\n                      });\n                      var imageUrl = window.URL.createObjectURL(blob);\n                      cache.push({\n                        start: ss.mediaStartTime,\n                        end: ss.mediaStartTime + ss.duration,\n                        url: imageUrl\n                      });\n                      if (callback) callback(imageUrl);\n                    }\n                  });\n                  return true;\n                }\n              });\n            }\n          };\n        }\n      });\n    } else {\n      track.startNumber = representation.startNumber;\n      track.segmentDuration = representation.segmentDuration;\n      track.timescale = representation.timescale;\n      track.templateUrl = buildTemplateUrl(representation);\n    }\n\n    if (track.tilesHor > 0 && track.tilesVert > 0) {\n      // Precalculate width and heigth per tile for perf reasons\n      track.widthPerTile = track.width / track.tilesHor;\n      track.heightPerTile = track.height / track.tilesVert;\n      tracks.push(track);\n    }\n  }\n\n  function buildTemplateUrl(representation) {\n    var templateUrl = urlUtils.isRelative(representation.media) ? urlUtils.resolve(representation.media, baseURLController.resolve(representation.path).url) : representation.media;\n\n    if (!templateUrl) {\n      return '';\n    }\n\n    return (0, _SegmentsUtils.replaceIDForTemplate)(templateUrl, representation.id);\n  }\n\n  function getTracks() {\n    return tracks;\n  }\n\n  function getCurrentTrackIndex() {\n    return currentTrackIndex;\n  }\n\n  function getCurrentTrack() {\n    if (currentTrackIndex < 0) {\n      return null;\n    }\n\n    return tracks[currentTrackIndex];\n  }\n\n  function setTrackByIndex(index) {\n    if (!tracks || tracks.length === 0) {\n      return;\n    } // select highest bitrate in case selected index is higher than bitrate list length\n\n\n    if (index >= tracks.length) {\n      index = tracks.length - 1;\n    }\n\n    currentTrackIndex = index;\n  }\n\n  function getThumbnailRequestForTime(time) {\n    var currentVoRep = void 0;\n    var voReps = adapter.getVoRepresentations(mediaInfo);\n\n    for (var i = 0; i < voReps.length; i++) {\n      if (tracks[currentTrackIndex].id === voReps[i].id) {\n        currentVoRep = voReps[i];\n        break;\n      }\n    }\n\n    return indexHandler.getSegmentRequestForTime(mediaInfo, currentVoRep, time);\n  }\n\n  function reset() {\n    tracks = [];\n    currentTrackIndex = -1;\n    mediaInfo = null;\n  }\n\n  instance = {\n    initialize: initialize,\n    getTracks: getTracks,\n    reset: reset,\n    setTrackByIndex: setTrackByIndex,\n    getCurrentTrack: getCurrentTrack,\n    getCurrentTrackIndex: getCurrentTrackIndex,\n    getThumbnailRequestForTime: getThumbnailRequestForTime\n  };\n  initialize();\n  return instance;\n}\n\nThumbnailTracks.__dashjs_factory_name = 'ThumbnailTracks';\nexports.default = _FactoryMaker2.default.getClassFactory(ThumbnailTracks);","map":{"version":3,"sources":["../../../../../src/streaming/thumbnail/ThumbnailTracks.js"],"names":["THUMBNAILS_SCHEME_ID_URIS","context","adapter","config","baseURLController","streamInfo","timelineConverter","debug","eventBus","events","dashConstants","urlUtils","instance","tracks","indexHandler","currentTrackIndex","mediaInfo","loader","boxParser","reset","addTracks","segments","count","i","len","s","seg","fragments","Constants","voReps","rep","DashConstants","createTrack","a","b","track","ThumbnailTrackInfo","representation","p","vars","isNaN","parseInt","Events","streamId","mediaType","mimeType","callback","cache","normalizeSegments","cached","el","ss","baseURL","method","url","request","range","responseType","onload","info","e","blob","type","imageUrl","window","start","end","buildTemplateUrl","templateUrl","index","currentVoRep","initialize","getTracks","setTrackByIndex","getCurrentTrack","getCurrentTrackIndex","getThumbnailRequestForTime","ThumbnailTracks","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport DashConstants from '../../dash/constants/DashConstants';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport ThumbnailTrackInfo from '../vo/ThumbnailTrackInfo';\nimport URLUtils from '../../streaming/utils/URLUtils';\nimport { replaceIDForTemplate, getTimeBasedSegment } from '../../dash/utils/SegmentsUtils';\nimport Events from '../../core/events/Events';\nimport BoxParser from '../../streaming/utils/BoxParser';\nimport XHRLoader from '../../streaming/net/XHRLoader';\nimport DashHandler from '../../dash/DashHandler';\n\nexport const THUMBNAILS_SCHEME_ID_URIS = ['http://dashif.org/thumbnail_tile',\n                                   'http://dashif.org/guidelines/thumbnail_tile'];\n\nfunction ThumbnailTracks(config) {\n    const context = this.context;\n    const adapter = config.adapter;\n    const baseURLController = config.baseURLController;\n    const streamInfo = config.streamInfo;\n    const timelineConverter = config.timelineConverter;\n    const debug = config.debug;\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const dashConstants = config.dashConstants;\n\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        tracks,\n        indexHandler,\n        currentTrackIndex,\n        mediaInfo,\n        loader,\n        boxParser;\n\n    function initialize() {\n        reset();\n        loader = XHRLoader(context).create({});\n        boxParser = BoxParser(context).getInstance();\n\n        indexHandler = DashHandler(context).create({\n            streamInfo: streamInfo,\n            timelineConverter: timelineConverter,\n            baseURLController: baseURLController,\n            debug: debug,\n            eventBus: eventBus,\n            events: events,\n            dashConstants: dashConstants,\n            urlUtils: urlUtils\n        });\n\n        // initialize controllers\n        indexHandler.initialize(adapter ? adapter.getIsDynamic() : false);\n\n        // parse representation and create tracks\n        addTracks();\n    }\n\n    function normalizeSegments(fragments, representation) {\n        const segments = [];\n        let count = 0;\n\n        let i,\n            len,\n            s,\n            seg;\n\n        for (i = 0, len = fragments.length; i < len; i++) {\n            s = fragments[i];\n\n            seg = getTimeBasedSegment(\n                timelineConverter,\n                adapter.getIsDynamic(),\n                representation,\n                s.startTime,\n                s.duration,\n                s.timescale,\n                s.media,\n                s.mediaRange,\n                count);\n\n            if (seg) {\n                segments.push(seg);\n                seg = null;\n                count++;\n            }\n        }\n        return segments;\n    }\n\n    function addTracks() {\n        if (!streamInfo || !adapter) {\n            return;\n        }\n\n        // Extract thumbnail tracks\n        mediaInfo = adapter.getMediaInfoForType(streamInfo, Constants.IMAGE);\n        if (!mediaInfo) {\n            return;\n        }\n\n        const voReps = adapter.getVoRepresentations(mediaInfo);\n\n        if (voReps && voReps.length > 0) {\n            voReps.forEach((rep) => {\n                if ((rep.segmentInfoType === DashConstants.SEGMENT_TEMPLATE && rep.segmentDuration > 0 && rep.media) ||\n                     rep.segmentInfoType === DashConstants.SEGMENT_TIMELINE) {\n                    createTrack(rep);\n                }\n                if (rep.segmentInfoType === DashConstants.SEGMENT_BASE) {\n                    createTrack(rep, true);\n                }\n            });\n        }\n\n        if (tracks.length > 0) {\n            // Sort bitrates and select the lowest bitrate rendition\n            tracks.sort((a, b) => a.bitrate - b.bitrate);\n            currentTrackIndex = tracks.length - 1;\n        }\n    }\n\n    function createTrack(representation, useSegmentBase) {\n        const track = new ThumbnailTrackInfo();\n        track.id = representation.id;\n        track.bitrate = representation.bandwidth;\n        track.width = representation.width;\n        track.height = representation.height;\n        track.tilesHor = 1;\n        track.tilesVert = 1;\n\n        if (representation.essentialProperties) {\n            representation.essentialProperties.forEach((p) => {\n                if (THUMBNAILS_SCHEME_ID_URIS.indexOf(p.schemeIdUri) >= 0 && p.value) {\n                    const vars = p.value.split('x');\n                    if (vars.length === 2 && !isNaN(vars[0]) && !isNaN(vars[1])) {\n                        track.tilesHor = parseInt(vars[0], 10);\n                        track.tilesVert = parseInt(vars[1], 10);\n                    }\n                }\n            });\n        }\n\n        if (useSegmentBase) {\n            eventBus.trigger(Events.SEGMENTBASE_SEGMENTSLIST_REQUEST_NEEDED, {\n                streamId: streamInfo.id,\n                mediaType: Constants.IMAGE,\n                mimeType: mediaInfo.mimeType,\n                representation: representation,\n                callback: function (streamId, mediaType, segments, representation) {\n                    let cache = [];\n                    segments = normalizeSegments(segments, representation);\n                    track.segmentDuration = segments[0].duration; //assume all segments have the same duration\n                    track.readThumbnail = function (time, callback) {\n\n                        let cached = null;\n                        cache.some(el => {\n                            if (el.start <= time && el.end > time) {\n                                cached = el.url;\n                                return true;\n                            }\n                        });\n                        if (cached) {\n                            callback(cached);\n                        } else {\n                            segments.some((ss) => {\n                                if (ss.mediaStartTime <= time && ss.mediaStartTime + ss.duration > time) {\n                                    const baseURL = baseURLController.resolve(representation.path);\n                                    loader.load({\n                                        method: 'get',\n                                        url: baseURL.url,\n                                        request: {\n                                            range: ss.mediaRange,\n                                            responseType: 'arraybuffer'\n                                        },\n                                        onload: function (e) {\n                                            let info = boxParser.getSamplesInfo(e.target.response);\n                                            let blob = new Blob( [ e.target.response.slice(info.sampleList[0].offset, info.sampleList[0].offset + info.sampleList[0].size) ], { type: 'image/jpeg' } );\n                                            let imageUrl = window.URL.createObjectURL( blob );\n                                            cache.push({\n                                                start: ss.mediaStartTime,\n                                                end: ss.mediaStartTime + ss.duration,\n                                                url: imageUrl\n                                            });\n                                            if (callback)\n                                                callback(imageUrl);\n                                        }\n                                    });\n                                    return true;\n                                }\n                            });\n                        }\n                    };\n                }\n            });\n        } else {\n            track.startNumber = representation.startNumber;\n            track.segmentDuration = representation.segmentDuration;\n            track.timescale = representation.timescale;\n            track.templateUrl = buildTemplateUrl(representation);\n        }\n\n        if (track.tilesHor > 0 && track.tilesVert > 0) {\n            // Precalculate width and heigth per tile for perf reasons\n            track.widthPerTile = track.width / track.tilesHor;\n            track.heightPerTile = track.height / track.tilesVert;\n            tracks.push(track);\n        }\n    }\n\n    function buildTemplateUrl(representation) {\n        const templateUrl = urlUtils.isRelative(representation.media) ?\n            urlUtils.resolve(representation.media, baseURLController.resolve(representation.path).url) : representation.media;\n\n        if (!templateUrl) {\n            return '';\n        }\n\n        return replaceIDForTemplate(templateUrl, representation.id);\n    }\n\n    function getTracks() {\n        return tracks;\n    }\n\n    function getCurrentTrackIndex() {\n        return currentTrackIndex;\n    }\n\n    function getCurrentTrack() {\n        if (currentTrackIndex < 0) {\n            return null;\n        }\n        return tracks[currentTrackIndex];\n    }\n\n    function setTrackByIndex(index) {\n        if (!tracks || tracks.length === 0) {\n            return;\n        }\n        // select highest bitrate in case selected index is higher than bitrate list length\n        if (index >= tracks.length) {\n            index = tracks.length - 1;\n        }\n        currentTrackIndex = index;\n    }\n\n    function getThumbnailRequestForTime(time) {\n        let currentVoRep;\n        const voReps = adapter.getVoRepresentations(mediaInfo);\n        for (let i = 0; i < voReps.length; i++) {\n            if (tracks[currentTrackIndex].id === voReps[i].id) {\n                currentVoRep = voReps[i];\n                break;\n            }\n        }\n\n        return indexHandler.getSegmentRequestForTime(mediaInfo, currentVoRep, time);\n    }\n\n    function reset() {\n        tracks = [];\n        currentTrackIndex = -1;\n        mediaInfo = null;\n    }\n\n    instance = {\n        initialize: initialize,\n        getTracks: getTracks,\n        reset: reset,\n        setTrackByIndex: setTrackByIndex,\n        getCurrentTrack: getCurrentTrack,\n        getCurrentTrackIndex: getCurrentTrackIndex,\n        getThumbnailRequestForTime: getThumbnailRequestForTime\n    };\n\n    initialize();\n\n    return instance;\n}\n\nThumbnailTracks.__dashjs_factory_name = 'ThumbnailTracks';\nexport default FactoryMaker.getClassFactory(ThumbnailTracks);\n"]},"metadata":{},"sourceType":"script"}