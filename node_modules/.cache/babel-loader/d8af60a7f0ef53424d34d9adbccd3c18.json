{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar GAP_HANDLER_INTERVAL = 100;\nvar THRESHOLD_TO_STALLS = 30;\nvar GAP_THRESHOLD = 0.1;\n\nfunction GapController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      lastPlaybackTime = void 0,\n      settings = void 0,\n      wallclockTicked = void 0,\n      gapHandlerInterval = void 0,\n      lastGapJumpPosition = void 0,\n      playbackController = void 0,\n      streamController = void 0,\n      videoModel = void 0,\n      timelineConverter = void 0,\n      adapter = void 0,\n      jumpTimeoutHandler = void 0,\n      logger = void 0;\n\n  function initialize() {\n    registerEvents();\n  }\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    reset();\n  }\n\n  function reset() {\n    stopGapHandler();\n    unregisterEvents();\n    resetInitialSettings();\n  }\n\n  function resetInitialSettings() {\n    gapHandlerInterval = null;\n    lastGapJumpPosition = NaN;\n    wallclockTicked = 0;\n    jumpTimeoutHandler = null;\n  }\n\n  function setConfig(config) {\n    if (!config) {\n      return;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n\n    if (config.playbackController) {\n      playbackController = config.playbackController;\n    }\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.timelineConverter) {\n      timelineConverter = config.timelineConverter;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n  }\n\n  function registerEvents() {\n    eventBus.on(_Events2.default.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n    eventBus.on(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n  }\n\n  function unregisterEvents() {\n    eventBus.off(_Events2.default.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n    eventBus.off(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n  }\n\n  function onBytesAppended() {\n    if (!gapHandlerInterval) {\n      startGapHandler();\n    }\n  }\n\n  function _onPlaybackSeeking() {\n    if (jumpTimeoutHandler) {\n      clearTimeout(jumpTimeoutHandler);\n      jumpTimeoutHandler = null;\n    }\n  }\n\n  function _onWallclockTimeUpdated()\n  /*e*/\n  {\n    if (!_shouldCheckForGaps()) {\n      return;\n    }\n\n    wallclockTicked++;\n\n    if (wallclockTicked >= THRESHOLD_TO_STALLS) {\n      var currentTime = playbackController.getTime();\n\n      if (lastPlaybackTime === currentTime) {\n        jumpGap(currentTime, true);\n      } else {\n        lastPlaybackTime = currentTime;\n        lastGapJumpPosition = NaN;\n      }\n\n      wallclockTicked = 0;\n    }\n  }\n\n  function _shouldCheckForGaps() {\n    return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 && (!playbackController.isSeeking() || streamController.hasStreamFinishedBuffering(streamController.getActiveStream())) && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() && !streamController.getHasMediaOrIntialisationError();\n  }\n\n  function getNextRangeIndex(ranges, currentTime) {\n    try {\n      if (!ranges || ranges.length <= 1 && currentTime > 0) {\n        return NaN;\n      }\n\n      var nextRangeIndex = NaN;\n      var j = 0;\n\n      while (isNaN(nextRangeIndex) && j < ranges.length) {\n        var rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\n\n        if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\n          nextRangeIndex = j;\n        }\n\n        j += 1;\n      }\n\n      return nextRangeIndex;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function startGapHandler() {\n    try {\n      if (!gapHandlerInterval) {\n        logger.debug('Starting the gap controller');\n        gapHandlerInterval = setInterval(function () {\n          if (!_shouldCheckForGaps()) {\n            return;\n          }\n\n          var currentTime = playbackController.getTime();\n          jumpGap(currentTime);\n        }, GAP_HANDLER_INTERVAL);\n      }\n    } catch (e) {}\n  }\n\n  function stopGapHandler() {\n    logger.debug('Stopping the gap controller');\n\n    if (gapHandlerInterval) {\n      clearInterval(gapHandlerInterval);\n      gapHandlerInterval = null;\n    }\n  }\n\n  function jumpGap(currentTime) {\n    var playbackStalled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var smallGapLimit = settings.get().streaming.smallGapLimit;\n    var jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\n    var ranges = videoModel.getBufferRange();\n    var nextRangeIndex = void 0;\n    var seekToPosition = NaN;\n    var jumpToStreamEnd = false; // Get the range just after current time position\n\n    nextRangeIndex = getNextRangeIndex(ranges, currentTime);\n\n    if (!isNaN(nextRangeIndex)) {\n      var start = ranges.start(nextRangeIndex);\n      var gap = start - currentTime;\n\n      if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\n        seekToPosition = start;\n      }\n    } // Playback has stalled before period end. We seek to the end of the period\n\n\n    var timeToStreamEnd = playbackController.getTimeToStreamEnd();\n\n    if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && timeToStreamEnd < smallGapLimit) {\n      seekToPosition = parseFloat(playbackController.getStreamEndTime().toFixed(5));\n      jumpToStreamEnd = true;\n    }\n\n    if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition && seekToPosition > currentTime && !jumpTimeoutHandler) {\n      var timeUntilGapEnd = seekToPosition - currentTime;\n\n      if (jumpToStreamEnd) {\n        logger.warn('Jumping to end of stream because of gap from ' + currentTime + ' to ' + seekToPosition + '. Gap duration: ' + timeUntilGapEnd);\n        eventBus.trigger(_Events2.default.GAP_CAUSED_SEEK_TO_PERIOD_END, {\n          seekTime: seekToPosition,\n          duration: timeUntilGapEnd\n        });\n      } else {\n        var isDynamic = playbackController.getIsDynamic();\n\n        var _start = nextRangeIndex > 0 ? ranges.end(nextRangeIndex - 1) : currentTime;\n\n        var timeToWait = !isDynamic ? 0 : timeUntilGapEnd * 1000;\n        jumpTimeoutHandler = window.setTimeout(function () {\n          playbackController.seek(seekToPosition, true, true);\n          logger.warn('Jumping gap starting at ' + _start + ' and ending at ' + seekToPosition + '. Jumping by: ' + timeUntilGapEnd);\n          eventBus.trigger(_Events2.default.GAP_CAUSED_INTERNAL_SEEK, {\n            seekTime: seekToPosition,\n            duration: timeUntilGapEnd\n          });\n          jumpTimeoutHandler = null;\n        }, timeToWait);\n      }\n\n      lastGapJumpPosition = seekToPosition;\n    }\n  }\n\n  instance = {\n    reset: reset,\n    setConfig: setConfig,\n    initialize: initialize\n  };\n  setup();\n  return instance;\n}\n\nGapController.__dashjs_factory_name = 'GapController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(GapController);","map":{"version":3,"sources":["../../../../../src/streaming/controllers/GapController.js"],"names":["GAP_HANDLER_INTERVAL","THRESHOLD_TO_STALLS","GAP_THRESHOLD","context","eventBus","instance","lastPlaybackTime","settings","wallclockTicked","gapHandlerInterval","lastGapJumpPosition","playbackController","streamController","videoModel","timelineConverter","adapter","jumpTimeoutHandler","logger","registerEvents","reset","stopGapHandler","unregisterEvents","resetInitialSettings","config","Events","startGapHandler","clearTimeout","_shouldCheckForGaps","currentTime","jumpGap","ranges","nextRangeIndex","j","isNaN","rangeEnd","setInterval","clearInterval","playbackStalled","smallGapLimit","jumpLargeGaps","seekToPosition","jumpToStreamEnd","getNextRangeIndex","start","gap","timeToStreamEnd","isFinite","parseFloat","timeUntilGapEnd","seekTime","duration","isDynamic","timeToWait","window","setConfig","initialize","setup","GapController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport Events from '../../core/events/Events';\nimport EventBus from '../../core/EventBus';\n\nconst GAP_HANDLER_INTERVAL = 100;\nconst THRESHOLD_TO_STALLS = 30;\nconst GAP_THRESHOLD = 0.1;\n\nfunction GapController() {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        lastPlaybackTime,\n        settings,\n        wallclockTicked,\n        gapHandlerInterval,\n        lastGapJumpPosition,\n        playbackController,\n        streamController,\n        videoModel,\n        timelineConverter,\n        adapter,\n        jumpTimeoutHandler,\n        logger;\n\n    function initialize() {\n        registerEvents();\n    }\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function reset() {\n        stopGapHandler();\n        unregisterEvents();\n        resetInitialSettings();\n    }\n\n    function resetInitialSettings() {\n        gapHandlerInterval = null;\n        lastGapJumpPosition = NaN;\n        wallclockTicked = 0;\n        jumpTimeoutHandler = null;\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n        if (config.playbackController) {\n            playbackController = config.playbackController;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n    }\n\n    function unregisterEvents() {\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n    }\n\n    function onBytesAppended() {\n        if (!gapHandlerInterval) {\n            startGapHandler();\n        }\n    }\n\n    function _onPlaybackSeeking() {\n        if (jumpTimeoutHandler) {\n            clearTimeout(jumpTimeoutHandler);\n            jumpTimeoutHandler = null;\n        }\n    }\n\n    function _onWallclockTimeUpdated(/*e*/) {\n        if (!_shouldCheckForGaps()) {\n            return;\n        }\n\n        wallclockTicked++;\n        if (wallclockTicked >= THRESHOLD_TO_STALLS) {\n            const currentTime = playbackController.getTime();\n            if (lastPlaybackTime === currentTime) {\n                jumpGap(currentTime, true);\n            } else {\n                lastPlaybackTime = currentTime;\n                lastGapJumpPosition = NaN;\n            }\n            wallclockTicked = 0;\n        }\n    }\n\n    function _shouldCheckForGaps() {\n        return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 &&\n            (!playbackController.isSeeking() || streamController.hasStreamFinishedBuffering(streamController.getActiveStream())) && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() &&\n            !streamController.getHasMediaOrIntialisationError();\n    }\n\n    function getNextRangeIndex(ranges, currentTime) {\n        try {\n\n            if (!ranges || (ranges.length <= 1 && currentTime > 0)) {\n                return NaN;\n            }\n            let nextRangeIndex = NaN;\n            let j = 0;\n\n            while (isNaN(nextRangeIndex) && j < ranges.length) {\n                const rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\n                if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\n                    nextRangeIndex = j;\n                }\n                j += 1;\n            }\n            return nextRangeIndex;\n\n        } catch (e) {\n            return null;\n        }\n    }\n\n\n    function startGapHandler() {\n        try {\n            if (!gapHandlerInterval) {\n                logger.debug('Starting the gap controller');\n                gapHandlerInterval = setInterval(() => {\n                    if (!_shouldCheckForGaps()) {\n                        return;\n                    }\n                    const currentTime = playbackController.getTime();\n                    jumpGap(currentTime);\n\n                }, GAP_HANDLER_INTERVAL);\n            }\n        } catch (e) {\n        }\n    }\n\n    function stopGapHandler() {\n        logger.debug('Stopping the gap controller');\n        if (gapHandlerInterval) {\n            clearInterval(gapHandlerInterval);\n            gapHandlerInterval = null;\n        }\n    }\n\n    function jumpGap(currentTime, playbackStalled = false) {\n        const smallGapLimit = settings.get().streaming.smallGapLimit;\n        const jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\n        const ranges = videoModel.getBufferRange();\n        let nextRangeIndex;\n        let seekToPosition = NaN;\n        let jumpToStreamEnd = false;\n\n\n        // Get the range just after current time position\n        nextRangeIndex = getNextRangeIndex(ranges, currentTime);\n\n        if (!isNaN(nextRangeIndex)) {\n            const start = ranges.start(nextRangeIndex);\n            const gap = start - currentTime;\n            if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\n                seekToPosition = start;\n            }\n        }\n\n        // Playback has stalled before period end. We seek to the end of the period\n        const timeToStreamEnd = playbackController.getTimeToStreamEnd();\n        if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && timeToStreamEnd < smallGapLimit) {\n            seekToPosition = parseFloat(playbackController.getStreamEndTime().toFixed(5));\n            jumpToStreamEnd = true;\n        }\n\n        if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition && seekToPosition > currentTime && !jumpTimeoutHandler) {\n            const timeUntilGapEnd = seekToPosition - currentTime;\n\n            if (jumpToStreamEnd) {\n                logger.warn(`Jumping to end of stream because of gap from ${currentTime} to ${seekToPosition}. Gap duration: ${timeUntilGapEnd}`);\n                eventBus.trigger(Events.GAP_CAUSED_SEEK_TO_PERIOD_END, {\n                    seekTime: seekToPosition,\n                    duration: timeUntilGapEnd\n                });\n            } else {\n                const isDynamic = playbackController.getIsDynamic();\n                const start = nextRangeIndex > 0 ? ranges.end(nextRangeIndex - 1) : currentTime;\n                const timeToWait = !isDynamic ? 0 : timeUntilGapEnd * 1000;\n\n                jumpTimeoutHandler = window.setTimeout(() => {\n                    playbackController.seek(seekToPosition, true, true);\n                    logger.warn(`Jumping gap starting at ${start} and ending at ${seekToPosition}. Jumping by: ${timeUntilGapEnd}`);\n                    eventBus.trigger(Events.GAP_CAUSED_INTERNAL_SEEK, {\n                        seekTime: seekToPosition,\n                        duration: timeUntilGapEnd\n                    });\n                    jumpTimeoutHandler = null;\n                }, timeToWait);\n            }\n            lastGapJumpPosition = seekToPosition;\n        }\n    }\n\n    instance = {\n        reset,\n        setConfig,\n        initialize\n    };\n\n    setup();\n\n    return instance;\n}\n\nGapController.__dashjs_factory_name = 'GapController';\nexport default FactoryMaker.getSingletonFactory(GapController);\n"]},"metadata":{},"sourceType":"script"}