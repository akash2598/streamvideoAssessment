{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DashJSError = require('./../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _EventBus = require('./../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('./../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Errors = require('./../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _URLUtils = require('../utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar HTTP_TIMEOUT_MS = 5000;\nvar DEFAULT_MAXIMUM_ALLOWED_DRIFT = 100;\nvar DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR = 2;\nvar DEFAULT_BACKGROUND_ATTEMPTS = 2;\nvar DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS = 30;\nvar DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS = 30;\nvar DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC = 600;\nvar DEFAULT_MINIMUM_TIME_BETWEEN_SYNC = 2;\n\nfunction TimeSyncController() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      isSynchronizing = void 0,\n      isBackgroundSynchronizing = void 0,\n      settings = void 0,\n      handlers = void 0,\n      dashMetrics = void 0,\n      backgroundSyncTimeOffsets = void 0,\n      timingSources = void 0,\n      timeOfLastSync = void 0,\n      timeOfLastBackgroundSync = void 0,\n      lastOffset = void 0,\n      lastTimingSource = void 0,\n      internalTimeBetweenSyncAttempts = void 0,\n      baseURLController = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    eventBus.on(_Events2.default.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.baseURLController) {\n      baseURLController = config.baseURLController;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function _resetInitialSettings() {\n    backgroundSyncTimeOffsets = [];\n    timingSources = [];\n    timeOfLastSync = null;\n    timeOfLastBackgroundSync = null;\n    lastTimingSource = null;\n    lastOffset = NaN;\n    isSynchronizing = false;\n    isBackgroundSynchronizing = false;\n    internalTimeBetweenSyncAttempts = settings.get().streaming.utcSynchronization.timeBetweenSyncAttempts;\n  }\n  /**\n  * Register the timing handler depending on the schemeIdUris. This method is called once when the StreamController is initialized\n  */\n\n\n  function initialize() {\n    _resetInitialSettings(); // a list of known schemeIdUris and a method to call with @value\n\n\n    handlers = {\n      'urn:mpeg:dash:utc:http-head:2014': _httpHeadHandler,\n      'urn:mpeg:dash:utc:http-xsdate:2014': _httpHandler.bind(null, _xsdatetimeDecoder),\n      'urn:mpeg:dash:utc:http-iso:2014': _httpHandler.bind(null, _iso8601Decoder),\n      'urn:mpeg:dash:utc:direct:2014': _directHandler,\n      // some specs referencing early ISO23009-1 drafts incorrectly use\n      // 2012 in the URI, rather than 2014. support these for now.\n      'urn:mpeg:dash:utc:http-head:2012': _httpHeadHandler,\n      'urn:mpeg:dash:utc:http-xsdate:2012': _httpHandler.bind(null, _xsdatetimeDecoder),\n      'urn:mpeg:dash:utc:http-iso:2012': _httpHandler.bind(null, _iso8601Decoder),\n      'urn:mpeg:dash:utc:direct:2012': _directHandler,\n      // it isn't clear how the data returned would be formatted, and\n      // no public examples available so http-ntp not supported for now.\n      // presumably you would do an arraybuffer type xhr and decode the\n      // binary data returned but I would want to see a sample first.\n      'urn:mpeg:dash:utc:http-ntp:2014': _notSupportedHandler,\n      // not clear how this would be supported in javascript (in browser)\n      'urn:mpeg:dash:utc:ntp:2014': _notSupportedHandler,\n      'urn:mpeg:dash:utc:sntp:2014': _notSupportedHandler\n    };\n  }\n  /**\n  * Sync against a timing source. T\n  * @param {array} tSources\n  */\n\n\n  function attemptSync(tSources) {\n    timingSources = tSources; // Stop if we are already synchronizing\n\n    if (isSynchronizing) {\n      return;\n    } // No synchronization required we can signal the completion immediately\n\n\n    if (!_shouldPerformSynchronization()) {\n      eventBus.trigger(_Events2.default.TIME_SYNCHRONIZATION_COMPLETED);\n      return;\n    }\n\n    isSynchronizing = true;\n\n    _attemptRecursiveSync();\n  }\n  /**\n  * Does a synchronization in the background in case the last offset should be verified or a 404 occurs\n  */\n\n\n  function _onAttemptBackgroundSync() {\n    if (isSynchronizing || isBackgroundSynchronizing || !lastTimingSource || !lastTimingSource.value || !lastTimingSource.schemeIdUri || isNaN(lastOffset) || isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts)) {\n      return;\n    }\n\n    if (timeOfLastBackgroundSync && (Date.now() - timeOfLastBackgroundSync) / 1000 < DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS) {\n      return;\n    }\n\n    backgroundSyncTimeOffsets = [];\n    isBackgroundSynchronizing = true;\n    var backgroundAttempts = !isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts) ? settings.get().streaming.utcSynchronization.backgroundAttempts : DEFAULT_BACKGROUND_ATTEMPTS;\n\n    _attemptBackgroundSync(backgroundAttempts);\n  }\n  /**\n  * Perform a defined number of background attempts\n  * @param {number} attempts\n  * @private\n  */\n\n\n  function _attemptBackgroundSync(attempts) {\n    try {\n      if (attempts <= 0) {\n        _completeBackgroundTimeSyncSequence();\n\n        return;\n      }\n\n      var deviceTimeBeforeSync = Date.now();\n      handlers[lastTimingSource.schemeIdUri](lastTimingSource.value, function (serverTime) {\n        // the timing source returned something useful\n        var deviceTimeAfterSync = Date.now();\n\n        var offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n\n        backgroundSyncTimeOffsets.push(offset);\n\n        _attemptBackgroundSync(attempts - 1);\n      }, function () {\n        _completeBackgroundTimeSyncSequence();\n      });\n    } catch (e) {\n      _completeBackgroundTimeSyncSequence();\n    }\n  }\n  /**\n  * Sync against a timing source. This method is called recursively if the time sync for the first entry in timingSources fails.\n  * @param {number} sourceIndex\n  */\n\n\n  function _attemptRecursiveSync() {\n    var sourceIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null; // if called with no sourceIndex, use zero (highest priority)\n\n    var index = sourceIndex || 0; // the sources should be ordered in priority from the manifest.\n    // try each in turn, from the top, until either something\n    // sensible happens, or we run out of sources to try.\n\n    if (!timingSources || timingSources.length === 0 || index >= timingSources.length) {\n      _onComplete();\n\n      return;\n    }\n\n    var source = timingSources[index];\n\n    if (source) {\n      // check if there is a handler for this @schemeIdUri\n      if (handlers.hasOwnProperty(source.schemeIdUri)) {\n        // if so, call it with its @value\n        var deviceTimeBeforeSync = new Date().getTime();\n        handlers[source.schemeIdUri](source.value, function (serverTime) {\n          // the timing source returned something useful\n          var deviceTimeAfterSync = new Date().getTime();\n\n          var offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n\n          lastTimingSource = source;\n\n          _onComplete(offset);\n        }, function () {\n          // the timing source was probably uncontactable\n          // or returned something we can't use - try again\n          // with the remaining sources\n          _attemptRecursiveSync(index + 1);\n        });\n      } else {\n        // an unknown schemeIdUri must have been found\n        // try again with the remaining sources\n        _attemptRecursiveSync(index + 1);\n      }\n    } else {\n      // no valid time source could be found, just use device time\n      _onComplete();\n    }\n  }\n  /**\n  * Calculate the offset between client and server. Account for the roundtrip time\n  * @param {number} deviceTimeBeforeSync\n  * @param {number} deviceTimeAfterSync\n  * @param {number} serverTime\n  * @return {number}\n  * @private\n  */\n\n\n  function _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime) {\n    var deviceReferenceTime = deviceTimeAfterSync - (deviceTimeAfterSync - deviceTimeBeforeSync) / 2;\n    return serverTime - deviceReferenceTime;\n  }\n  /**\n  * Checks if a synchronization is required\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _shouldPerformSynchronization() {\n    try {\n      var timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n\n      if (!timeOfLastSync || !timeBetweenSyncAttempts || isNaN(timeBetweenSyncAttempts)) {\n        return true;\n      }\n\n      return (Date.now() - timeOfLastSync) / 1000 >= timeBetweenSyncAttempts;\n    } catch (e) {\n      return true;\n    }\n  }\n  /**\n  * Callback after sync has been completed\n  * @param {number} offset\n  * @private\n  */\n\n\n  function _onComplete() {\n    var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;\n    var failed = isNaN(offset);\n\n    if (failed && settings.get().streaming.useManifestDateHeaderTimeSource) {\n      //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n      _checkForDateHeader();\n    } else {\n      _completeTimeSyncSequence(failed, offset);\n    }\n  }\n  /**\n  * Takes xsdatetime and returns milliseconds since UNIX epoch. May not be necessary as xsdatetime is very similar to ISO 8601 which is natively understood by javascript Date parser\n  * @param {string} xsdatetimeStr\n  * @return {number}\n  * @private\n  */\n\n\n  function _alternateXsdatetimeDecoder(xsdatetimeStr) {\n    // taken from DashParser - should probably refactor both uses\n    var SECONDS_IN_MIN = 60;\n    var MINUTES_IN_HOUR = 60;\n    var MILLISECONDS_IN_SECONDS = 1000;\n    var datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n    var utcDate = void 0,\n        timezoneOffset = void 0;\n    var match = datetimeRegex.exec(xsdatetimeStr); // If the string does not contain a timezone offset different browsers can interpret it either\n    // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n    // all browsers\n\n    utcDate = Date.UTC(parseInt(match[1], 10), parseInt(match[2], 10) - 1, // months start from zero\n    parseInt(match[3], 10), parseInt(match[4], 10), parseInt(match[5], 10), match[6] && (parseInt(match[6], 10) || 0), match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS || 0); // If the date has timezone offset take it into account as well\n\n    if (match[9] && match[10]) {\n      timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n      utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n    }\n\n    return new Date(utcDate).getTime();\n  }\n  /**\n  * Try to use the built in parser, since xsdate is a constrained ISO8601 which is supported natively by Date.parse. if that fails, try a regex-based version used elsewhere in this application.\n  * @param {string} xsdatetimeStr\n  * @return {number}\n  */\n\n\n  function _xsdatetimeDecoder(xsdatetimeStr) {\n    var parsedDate = Date.parse(xsdatetimeStr);\n\n    if (isNaN(parsedDate)) {\n      parsedDate = _alternateXsdatetimeDecoder(xsdatetimeStr);\n    }\n\n    return parsedDate;\n  }\n  /**\n  * Takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n  * @param {string} isoStr\n  * @return {number}\n  */\n\n\n  function _iso8601Decoder(isoStr) {\n    return Date.parse(isoStr);\n  }\n  /**\n  * Takes RFC 1123 timestamp (which is same as ISO8601) and returns milliseconds since UNIX epoch\n  * @param {string} dateStr\n  * @return {number}\n  */\n\n\n  function _rfc1123Decoder(dateStr) {\n    return Date.parse(dateStr);\n  }\n  /**\n  * Handler for unsupported scheme ids.\n  * @param {string} url\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  * @private\n  */\n\n\n  function _notSupportedHandler(url, onSuccessCB, onFailureCB) {\n    onFailureCB();\n  }\n  /**\n  * Direct handler\n  * @param {string} xsdatetimeStr\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  */\n\n\n  function _directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n    var time = _xsdatetimeDecoder(xsdatetimeStr);\n\n    if (!isNaN(time)) {\n      onSuccessCB(time);\n      return;\n    }\n\n    onFailureCB();\n  }\n  /**\n  * Generic http handler\n  * @param {function} decoder\n  * @param {string} url\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  * @param {boolean} isHeadRequest\n  * @private\n  */\n\n\n  function _httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n    var oncomplete = void 0,\n        onload = void 0;\n    var complete = false;\n    var req = new XMLHttpRequest();\n    var verb = isHeadRequest ? _HTTPRequest.HTTPRequest.HEAD : _HTTPRequest.HTTPRequest.GET;\n    var urls = url.match(/\\S+/g); // according to ISO 23009-1, url could be a white-space\n    // separated list of URLs. just handle one at a time.\n\n    url = urls.shift();\n\n    oncomplete = function oncomplete() {\n      if (complete) {\n        return;\n      } // we only want to pass through here once per xhr,\n      // regardless of whether the load was successful.\n\n\n      complete = true; // if there are more urls to try, call self.\n\n      if (urls.length) {\n        _httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n      } else {\n        onFailureCB();\n      }\n    };\n\n    onload = function onload() {\n      var time = void 0,\n          result = void 0;\n\n      if (req.status === 200) {\n        time = isHeadRequest ? req.getResponseHeader('Date') : req.response;\n        result = decoder(time); // decoder returns NaN if non-standard input\n\n        if (!isNaN(result)) {\n          onSuccessCB(result);\n          complete = true;\n        }\n      }\n    };\n\n    if (urlUtils.isRelative(url)) {\n      // passing no path to resolve will return just MPD BaseURL/baseUri\n      var baseUrl = baseURLController.resolve();\n\n      if (baseUrl) {\n        url = urlUtils.resolve(url, baseUrl.url);\n      }\n    }\n\n    req.open(verb, url);\n    req.timeout = HTTP_TIMEOUT_MS || 0;\n    req.onload = onload;\n    req.onloadend = oncomplete;\n    req.send();\n  }\n  /**\n  * Handler for http-head schemeIdUri\n  * @param {string} url\n  * @param {function} onSuccessCB\n  * @param {function} onFailureCB\n  * @private\n  */\n\n\n  function _httpHeadHandler(url, onSuccessCB, onFailureCB) {\n    _httpHandler(_rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n  }\n  /**\n  * Checks if a date header is present in the MPD response and calculates the offset based on the header\n  * @private\n  */\n\n\n  function _checkForDateHeader() {\n    var dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID('Date');\n    var dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n    if (!isNaN(dateHeaderTime)) {\n      var offsetToDeviceTimeMs = dateHeaderTime - Date.now();\n\n      _completeTimeSyncSequence(false, offsetToDeviceTimeMs);\n    } else {\n      _completeTimeSyncSequence(true);\n    }\n  }\n  /**\n  * Triggers the event to signal that the time synchronization was completed\n  * @param {boolean} failed\n  * @param {number} offset\n  * @private\n  */\n\n\n  function _completeTimeSyncSequence(failed, offset) {\n    // Adjust the time of the next sync based on the drift between current offset and last offset\n    if (!isNaN(lastOffset) && !isNaN(offset) && !failed) {\n      _adjustTimeBetweenSyncAttempts(offset);\n    } // Update the internal data\n\n\n    if (!failed && !isNaN(offset)) {\n      timeOfLastSync = Date.now();\n      isSynchronizing = false; // if this is the first sync we are doing perform background syncs as well to confirm current offset\n\n      var shouldAttemptBackgroundSync = isNaN(lastOffset);\n      lastOffset = offset;\n\n      if (shouldAttemptBackgroundSync) {\n        _onAttemptBackgroundSync();\n      }\n\n      logger.debug('Completed UTC sync. Setting client - server offset to ' + offset);\n    }\n\n    if (failed) {\n      lastTimingSource = null;\n    } // Notify other classes\n\n\n    eventBus.trigger(_Events2.default.UPDATE_TIME_SYNC_OFFSET, {\n      offset: offset,\n      error: failed ? new _DashJSError2.default(_Errors2.default.TIME_SYNC_FAILED_ERROR_CODE, _Errors2.default.TIME_SYNC_FAILED_ERROR_MESSAGE) : null\n    });\n    eventBus.trigger(_Events2.default.TIME_SYNCHRONIZATION_COMPLETED);\n  }\n\n  function _adjustTimeBetweenSyncAttempts(offset) {\n    try {\n      var isOffsetDriftWithinThreshold = _isOffsetDriftWithinThreshold(offset);\n\n      var timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n      var timeBetweenSyncAttemptsAdjustmentFactor = !isNaN(settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor) ? settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR;\n      var maximumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts : DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC;\n      var minimumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts : DEFAULT_MINIMUM_TIME_BETWEEN_SYNC;\n      var adjustedTimeBetweenSyncAttempts = void 0;\n\n      if (isOffsetDriftWithinThreshold) {\n        // The drift between the current offset and the last offset is within the allowed threshold. Increase sync time\n        adjustedTimeBetweenSyncAttempts = Math.min(timeBetweenSyncAttempts * timeBetweenSyncAttemptsAdjustmentFactor, maximumTimeBetweenSyncAttempts);\n        logger.debug('Increasing timeBetweenSyncAttempts to ' + adjustedTimeBetweenSyncAttempts);\n      } else {\n        // Drift between the current offset and the last offset is not within the allowed threshold. Decrease sync time\n        adjustedTimeBetweenSyncAttempts = Math.max(timeBetweenSyncAttempts / timeBetweenSyncAttemptsAdjustmentFactor, minimumTimeBetweenSyncAttempts);\n        logger.debug('Decreasing timeBetweenSyncAttempts to ' + adjustedTimeBetweenSyncAttempts);\n      }\n\n      internalTimeBetweenSyncAttempts = adjustedTimeBetweenSyncAttempts;\n    } catch (e) {}\n  }\n  /**\n  * Callback after all background syncs have been completed.\n  * @private\n  */\n\n\n  function _completeBackgroundTimeSyncSequence() {\n    if (!backgroundSyncTimeOffsets || backgroundSyncTimeOffsets.length === 0) {\n      return;\n    }\n\n    var averageOffset = backgroundSyncTimeOffsets.reduce(function (acc, curr) {\n      return acc + curr;\n    }, 0) / backgroundSyncTimeOffsets.length;\n\n    if (!_isOffsetDriftWithinThreshold(averageOffset)) {\n      logger.debug('Completed background UTC sync. Setting client - server offset to ' + averageOffset);\n      lastOffset = averageOffset;\n      eventBus.trigger(_Events2.default.UPDATE_TIME_SYNC_OFFSET, {\n        offset: lastOffset\n      });\n    } else {\n      logger.debug('Completed background UTC sync. Offset is within allowed threshold and is not adjusted.');\n    }\n\n    isBackgroundSynchronizing = false;\n    timeOfLastBackgroundSync = Date.now();\n  }\n\n  function _isOffsetDriftWithinThreshold(offset) {\n    try {\n      if (isNaN(lastOffset)) {\n        return true;\n      }\n\n      var maxAllowedDrift = settings.get().streaming.utcSynchronization.maximumAllowedDrift && !isNaN(settings.get().streaming.utcSynchronization.maximumAllowedDrift) ? settings.get().streaming.utcSynchronization.maximumAllowedDrift : DEFAULT_MAXIMUM_ALLOWED_DRIFT;\n      var lowerBound = lastOffset - maxAllowedDrift;\n      var upperBound = lastOffset + maxAllowedDrift;\n      return offset >= lowerBound && offset <= upperBound;\n    } catch (e) {\n      return true;\n    }\n  }\n\n  function reset() {\n    _resetInitialSettings();\n\n    eventBus.off(_Events2.default.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n  }\n\n  instance = {\n    initialize: initialize,\n    attemptSync: attemptSync,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(TimeSyncController);\n\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\n\n_FactoryMaker2.default.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":["HTTP_TIMEOUT_MS","DEFAULT_MAXIMUM_ALLOWED_DRIFT","DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR","DEFAULT_BACKGROUND_ATTEMPTS","DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS","DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS","DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC","DEFAULT_MINIMUM_TIME_BETWEEN_SYNC","context","eventBus","urlUtils","instance","logger","isSynchronizing","isBackgroundSynchronizing","settings","handlers","dashMetrics","backgroundSyncTimeOffsets","timingSources","timeOfLastSync","timeOfLastBackgroundSync","lastOffset","lastTimingSource","internalTimeBetweenSyncAttempts","baseURLController","Events","config","_resetInitialSettings","_httpHandler","_shouldPerformSynchronization","_attemptRecursiveSync","isNaN","Date","backgroundAttempts","_attemptBackgroundSync","attempts","_completeBackgroundTimeSyncSequence","deviceTimeBeforeSync","deviceTimeAfterSync","offset","_calculateOffset","sourceIndex","index","_onComplete","source","deviceReferenceTime","serverTime","timeBetweenSyncAttempts","NaN","failed","_checkForDateHeader","_completeTimeSyncSequence","SECONDS_IN_MIN","MINUTES_IN_HOUR","MILLISECONDS_IN_SECONDS","datetimeRegex","utcDate","timezoneOffset","match","parseInt","parseFloat","parsedDate","_alternateXsdatetimeDecoder","onFailureCB","time","_xsdatetimeDecoder","onSuccessCB","oncomplete","onload","complete","req","verb","isHeadRequest","HTTPRequest","urls","url","result","decoder","baseUrl","dateHeaderValue","dateHeaderTime","Number","offsetToDeviceTimeMs","_adjustTimeBetweenSyncAttempts","shouldAttemptBackgroundSync","_onAttemptBackgroundSync","error","DashJSError","Errors","isOffsetDriftWithinThreshold","_isOffsetDriftWithinThreshold","timeBetweenSyncAttemptsAdjustmentFactor","maximumTimeBetweenSyncAttempts","minimumTimeBetweenSyncAttempts","adjustedTimeBetweenSyncAttempts","Math","averageOffset","acc","maxAllowedDrift","lowerBound","upperBound","initialize","attemptSync","setConfig","reset","setup","TimeSyncController","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashJSError from './../vo/DashJSError';\nimport {HTTPRequest} from '../vo/metrics/HTTPRequest';\nimport EventBus from './../../core/EventBus';\nimport Events from './../../core/events/Events';\nimport Errors from './../../core/errors/Errors';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport URLUtils from '../utils/URLUtils';\n\nconst HTTP_TIMEOUT_MS = 5000;\nconst DEFAULT_MAXIMUM_ALLOWED_DRIFT = 100;\nconst DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR = 2;\nconst DEFAULT_BACKGROUND_ATTEMPTS = 2;\nconst DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS = 30;\nconst DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS = 30;\nconst DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC = 600;\nconst DEFAULT_MINIMUM_TIME_BETWEEN_SYNC = 2;\n\nfunction TimeSyncController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        isSynchronizing,\n        isBackgroundSynchronizing,\n        settings,\n        handlers,\n        dashMetrics,\n        backgroundSyncTimeOffsets,\n        timingSources,\n        timeOfLastSync,\n        timeOfLastBackgroundSync,\n        lastOffset,\n        lastTimingSource,\n        internalTimeBetweenSyncAttempts,\n        baseURLController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        eventBus.on(Events.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function _resetInitialSettings() {\n        backgroundSyncTimeOffsets = [];\n        timingSources = [];\n        timeOfLastSync = null;\n        timeOfLastBackgroundSync = null;\n        lastTimingSource = null;\n        lastOffset = NaN;\n        isSynchronizing = false;\n        isBackgroundSynchronizing = false;\n        internalTimeBetweenSyncAttempts = settings.get().streaming.utcSynchronization.timeBetweenSyncAttempts;\n    }\n\n    /**\n     * Register the timing handler depending on the schemeIdUris. This method is called once when the StreamController is initialized\n     */\n    function initialize() {\n        _resetInitialSettings();\n\n        // a list of known schemeIdUris and a method to call with @value\n        handlers = {\n            'urn:mpeg:dash:utc:http-head:2014': _httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2014': _httpHandler.bind(null, _xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2014': _httpHandler.bind(null, _iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2014': _directHandler,\n\n            // some specs referencing early ISO23009-1 drafts incorrectly use\n            // 2012 in the URI, rather than 2014. support these for now.\n            'urn:mpeg:dash:utc:http-head:2012': _httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2012': _httpHandler.bind(null, _xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2012': _httpHandler.bind(null, _iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2012': _directHandler,\n\n            // it isn't clear how the data returned would be formatted, and\n            // no public examples available so http-ntp not supported for now.\n            // presumably you would do an arraybuffer type xhr and decode the\n            // binary data returned but I would want to see a sample first.\n            'urn:mpeg:dash:utc:http-ntp:2014': _notSupportedHandler,\n\n            // not clear how this would be supported in javascript (in browser)\n            'urn:mpeg:dash:utc:ntp:2014': _notSupportedHandler,\n            'urn:mpeg:dash:utc:sntp:2014': _notSupportedHandler\n        };\n\n    }\n\n    /**\n     * Sync against a timing source. T\n     * @param {array} tSources\n     */\n    function attemptSync(tSources) {\n\n        timingSources = tSources;\n\n        // Stop if we are already synchronizing\n        if (isSynchronizing) {\n            return;\n        }\n\n        // No synchronization required we can signal the completion immediately\n        if (!_shouldPerformSynchronization()) {\n            eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED);\n            return;\n        }\n\n        isSynchronizing = true;\n        _attemptRecursiveSync();\n    }\n\n    /**\n     * Does a synchronization in the background in case the last offset should be verified or a 404 occurs\n     */\n    function _onAttemptBackgroundSync() {\n        if (isSynchronizing || isBackgroundSynchronizing || !lastTimingSource || !lastTimingSource.value || !lastTimingSource.schemeIdUri || isNaN(lastOffset) || isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts)) {\n            return;\n        }\n\n        if (timeOfLastBackgroundSync && ((Date.now() - timeOfLastBackgroundSync) / 1000) < DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS) {\n            return;\n        }\n\n        backgroundSyncTimeOffsets = [];\n        isBackgroundSynchronizing = true;\n        const backgroundAttempts = !isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts) ? settings.get().streaming.utcSynchronization.backgroundAttempts : DEFAULT_BACKGROUND_ATTEMPTS;\n        _attemptBackgroundSync(backgroundAttempts);\n    }\n\n    /**\n     * Perform a defined number of background attempts\n     * @param {number} attempts\n     * @private\n     */\n    function _attemptBackgroundSync(attempts) {\n        try {\n            if (attempts <= 0) {\n                _completeBackgroundTimeSyncSequence();\n                return;\n            }\n\n            const deviceTimeBeforeSync = Date.now();\n            handlers[lastTimingSource.schemeIdUri](\n                lastTimingSource.value,\n                function (serverTime) {\n                    // the timing source returned something useful\n                    const deviceTimeAfterSync = Date.now();\n                    const offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n\n                    backgroundSyncTimeOffsets.push(offset);\n                    _attemptBackgroundSync(attempts - 1);\n                },\n                function () {\n                    _completeBackgroundTimeSyncSequence();\n                }\n            );\n        } catch (e) {\n            _completeBackgroundTimeSyncSequence();\n        }\n    }\n\n    /**\n     * Sync against a timing source. This method is called recursively if the time sync for the first entry in timingSources fails.\n     * @param {number} sourceIndex\n     */\n    function _attemptRecursiveSync(sourceIndex = null) {\n        // if called with no sourceIndex, use zero (highest priority)\n        let index = sourceIndex || 0;\n\n        // the sources should be ordered in priority from the manifest.\n        // try each in turn, from the top, until either something\n        // sensible happens, or we run out of sources to try.\n        if (!timingSources || timingSources.length === 0 || index >= timingSources.length) {\n            _onComplete();\n            return;\n        }\n        let source = timingSources[index];\n\n        if (source) {\n            // check if there is a handler for this @schemeIdUri\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\n                // if so, call it with its @value\n                const deviceTimeBeforeSync = new Date().getTime();\n                handlers[source.schemeIdUri](\n                    source.value,\n                    function (serverTime) {\n                        // the timing source returned something useful\n                        const deviceTimeAfterSync = new Date().getTime();\n                        const offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\n                        lastTimingSource = source;\n\n                        _onComplete(offset);\n                    },\n                    function () {\n                        // the timing source was probably uncontactable\n                        // or returned something we can't use - try again\n                        // with the remaining sources\n                        _attemptRecursiveSync(index + 1);\n                    }\n                );\n            } else {\n                // an unknown schemeIdUri must have been found\n                // try again with the remaining sources\n                _attemptRecursiveSync(index + 1);\n            }\n        } else {\n            // no valid time source could be found, just use device time\n            _onComplete();\n        }\n\n    }\n\n    /**\n     * Calculate the offset between client and server. Account for the roundtrip time\n     * @param {number} deviceTimeBeforeSync\n     * @param {number} deviceTimeAfterSync\n     * @param {number} serverTime\n     * @return {number}\n     * @private\n     */\n    function _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime) {\n        const deviceReferenceTime = deviceTimeAfterSync - ((deviceTimeAfterSync - deviceTimeBeforeSync) / 2);\n\n        return serverTime - deviceReferenceTime;\n    }\n\n    /**\n     * Checks if a synchronization is required\n     * @return {boolean}\n     * @private\n     */\n    function _shouldPerformSynchronization() {\n        try {\n            const timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n\n            if (!timeOfLastSync || !timeBetweenSyncAttempts || isNaN(timeBetweenSyncAttempts)) {\n                return true;\n            }\n\n            return ((Date.now() - timeOfLastSync) / 1000) >= timeBetweenSyncAttempts;\n        } catch (e) {\n            return true;\n        }\n    }\n\n    /**\n     * Callback after sync has been completed\n     * @param {number} offset\n     * @private\n     */\n    function _onComplete(offset = NaN) {\n        let failed = isNaN(offset);\n        if (failed && settings.get().streaming.useManifestDateHeaderTimeSource) {\n            //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n            _checkForDateHeader();\n        } else {\n            _completeTimeSyncSequence(failed, offset);\n        }\n    }\n\n    /**\n     * Takes xsdatetime and returns milliseconds since UNIX epoch. May not be necessary as xsdatetime is very similar to ISO 8601 which is natively understood by javascript Date parser\n     * @param {string} xsdatetimeStr\n     * @return {number}\n     * @private\n     */\n    function _alternateXsdatetimeDecoder(xsdatetimeStr) {\n        // taken from DashParser - should probably refactor both uses\n        const SECONDS_IN_MIN = 60;\n        const MINUTES_IN_HOUR = 60;\n        const MILLISECONDS_IN_SECONDS = 1000;\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n\n        let utcDate,\n            timezoneOffset;\n\n        let match = datetimeRegex.exec(xsdatetimeStr);\n\n        // If the string does not contain a timezone offset different browsers can interpret it either\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n        // all browsers\n        utcDate = Date.UTC(\n            parseInt(match[1], 10),\n            parseInt(match[2], 10) - 1, // months start from zero\n            parseInt(match[3], 10),\n            parseInt(match[4], 10),\n            parseInt(match[5], 10),\n            (match[6] && (parseInt(match[6], 10) || 0)),\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\n        );\n        // If the date has timezone offset take it into account as well\n        if (match[9] && match[10]) {\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n        }\n\n        return new Date(utcDate).getTime();\n    }\n\n\n    /**\n     * Try to use the built in parser, since xsdate is a constrained ISO8601 which is supported natively by Date.parse. if that fails, try a regex-based version used elsewhere in this application.\n     * @param {string} xsdatetimeStr\n     * @return {number}\n     */\n    function _xsdatetimeDecoder(xsdatetimeStr) {\n        let parsedDate = Date.parse(xsdatetimeStr);\n\n        if (isNaN(parsedDate)) {\n            parsedDate = _alternateXsdatetimeDecoder(xsdatetimeStr);\n        }\n\n        return parsedDate;\n    }\n\n    /**\n     * Takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n     * @param {string} isoStr\n     * @return {number}\n     */\n    function _iso8601Decoder(isoStr) {\n        return Date.parse(isoStr);\n    }\n\n    /**\n     * Takes RFC 1123 timestamp (which is same as ISO8601) and returns milliseconds since UNIX epoch\n     * @param {string} dateStr\n     * @return {number}\n     */\n    function _rfc1123Decoder(dateStr) {\n        return Date.parse(dateStr);\n    }\n\n    /**\n     * Handler for unsupported scheme ids.\n     * @param {string} url\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     * @private\n     */\n    function _notSupportedHandler(url, onSuccessCB, onFailureCB) {\n        onFailureCB();\n    }\n\n    /**\n     * Direct handler\n     * @param {string} xsdatetimeStr\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     */\n    function _directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n        let time = _xsdatetimeDecoder(xsdatetimeStr);\n\n        if (!isNaN(time)) {\n            onSuccessCB(time);\n            return;\n        }\n\n        onFailureCB();\n    }\n\n    /**\n     * Generic http handler\n     * @param {function} decoder\n     * @param {string} url\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     * @param {boolean} isHeadRequest\n     * @private\n     */\n    function _httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n        let oncomplete,\n            onload;\n        let complete = false;\n        let req = new XMLHttpRequest();\n\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\n        let urls = url.match(/\\S+/g);\n\n        // according to ISO 23009-1, url could be a white-space\n        // separated list of URLs. just handle one at a time.\n        url = urls.shift();\n\n        oncomplete = function () {\n            if (complete) {\n                return;\n            }\n\n            // we only want to pass through here once per xhr,\n            // regardless of whether the load was successful.\n            complete = true;\n\n            // if there are more urls to try, call self.\n            if (urls.length) {\n                _httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n            } else {\n                onFailureCB();\n            }\n        };\n\n        onload = function () {\n            let time,\n                result;\n\n            if (req.status === 200) {\n                time = isHeadRequest ?\n                    req.getResponseHeader('Date') :\n                    req.response;\n\n                result = decoder(time);\n\n                // decoder returns NaN if non-standard input\n                if (!isNaN(result)) {\n                    onSuccessCB(result);\n                    complete = true;\n                }\n            }\n        };\n\n        if (urlUtils.isRelative(url)) {\n            // passing no path to resolve will return just MPD BaseURL/baseUri\n            const baseUrl = baseURLController.resolve();\n            if (baseUrl) {\n                url = urlUtils.resolve(url, baseUrl.url);\n            }\n        }\n\n        req.open(verb, url);\n        req.timeout = HTTP_TIMEOUT_MS || 0;\n        req.onload = onload;\n        req.onloadend = oncomplete;\n        req.send();\n    }\n\n    /**\n     * Handler for http-head schemeIdUri\n     * @param {string} url\n     * @param {function} onSuccessCB\n     * @param {function} onFailureCB\n     * @private\n     */\n    function _httpHeadHandler(url, onSuccessCB, onFailureCB) {\n        _httpHandler(_rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n    }\n\n    /**\n     * Checks if a date header is present in the MPD response and calculates the offset based on the header\n     * @private\n     */\n    function _checkForDateHeader() {\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID('Date');\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n        if (!isNaN(dateHeaderTime)) {\n            const offsetToDeviceTimeMs = dateHeaderTime - Date.now();\n            _completeTimeSyncSequence(false, offsetToDeviceTimeMs);\n        } else {\n            _completeTimeSyncSequence(true);\n        }\n    }\n\n    /**\n     * Triggers the event to signal that the time synchronization was completed\n     * @param {boolean} failed\n     * @param {number} offset\n     * @private\n     */\n    function _completeTimeSyncSequence(failed, offset) {\n\n        // Adjust the time of the next sync based on the drift between current offset and last offset\n        if (!isNaN(lastOffset) && !isNaN(offset) && !failed) {\n            _adjustTimeBetweenSyncAttempts(offset);\n        }\n\n        // Update the internal data\n        if (!failed && !isNaN(offset)) {\n            timeOfLastSync = Date.now();\n            isSynchronizing = false;\n\n            // if this is the first sync we are doing perform background syncs as well to confirm current offset\n            const shouldAttemptBackgroundSync = isNaN(lastOffset);\n            lastOffset = offset;\n            if (shouldAttemptBackgroundSync) {\n                _onAttemptBackgroundSync();\n            }\n            logger.debug(`Completed UTC sync. Setting client - server offset to ${offset}`);\n        }\n\n        if (failed) {\n            lastTimingSource = null;\n        }\n\n        // Notify other classes\n        eventBus.trigger(Events.UPDATE_TIME_SYNC_OFFSET, {\n            offset: offset,\n            error: failed ? new DashJSError(Errors.TIME_SYNC_FAILED_ERROR_CODE, Errors.TIME_SYNC_FAILED_ERROR_MESSAGE) : null\n        });\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED);\n    }\n\n    function _adjustTimeBetweenSyncAttempts(offset) {\n        try {\n            const isOffsetDriftWithinThreshold = _isOffsetDriftWithinThreshold(offset);\n            const timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\n            const timeBetweenSyncAttemptsAdjustmentFactor = !isNaN(settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor) ? settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR;\n            const maximumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts : DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC;\n            const minimumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts : DEFAULT_MINIMUM_TIME_BETWEEN_SYNC;\n            let adjustedTimeBetweenSyncAttempts;\n\n            if (isOffsetDriftWithinThreshold) {\n                // The drift between the current offset and the last offset is within the allowed threshold. Increase sync time\n                adjustedTimeBetweenSyncAttempts = Math.min(timeBetweenSyncAttempts * timeBetweenSyncAttemptsAdjustmentFactor, maximumTimeBetweenSyncAttempts);\n                logger.debug(`Increasing timeBetweenSyncAttempts to ${adjustedTimeBetweenSyncAttempts}`);\n            } else {\n                // Drift between the current offset and the last offset is not within the allowed threshold. Decrease sync time\n                adjustedTimeBetweenSyncAttempts = Math.max(timeBetweenSyncAttempts / timeBetweenSyncAttemptsAdjustmentFactor, minimumTimeBetweenSyncAttempts);\n                logger.debug(`Decreasing timeBetweenSyncAttempts to ${adjustedTimeBetweenSyncAttempts}`);\n            }\n\n            internalTimeBetweenSyncAttempts = adjustedTimeBetweenSyncAttempts;\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Callback after all background syncs have been completed.\n     * @private\n     */\n    function _completeBackgroundTimeSyncSequence() {\n        if (!backgroundSyncTimeOffsets || backgroundSyncTimeOffsets.length === 0) {\n            return;\n        }\n\n        const averageOffset = backgroundSyncTimeOffsets.reduce((acc, curr) => {\n            return acc + curr;\n        }, 0) / backgroundSyncTimeOffsets.length;\n\n        if (!_isOffsetDriftWithinThreshold(averageOffset)) {\n            logger.debug(`Completed background UTC sync. Setting client - server offset to ${averageOffset}`);\n            lastOffset = averageOffset;\n            eventBus.trigger(Events.UPDATE_TIME_SYNC_OFFSET, {\n                offset: lastOffset\n            });\n        } else {\n            logger.debug(`Completed background UTC sync. Offset is within allowed threshold and is not adjusted.`);\n        }\n\n        isBackgroundSynchronizing = false;\n        timeOfLastBackgroundSync = Date.now();\n    }\n\n    function _isOffsetDriftWithinThreshold(offset) {\n        try {\n            if (isNaN(lastOffset)) {\n                return true;\n            }\n\n            const maxAllowedDrift = settings.get().streaming.utcSynchronization.maximumAllowedDrift && !isNaN(settings.get().streaming.utcSynchronization.maximumAllowedDrift) ? settings.get().streaming.utcSynchronization.maximumAllowedDrift : DEFAULT_MAXIMUM_ALLOWED_DRIFT;\n            const lowerBound = lastOffset - maxAllowedDrift;\n            const upperBound = lastOffset + maxAllowedDrift;\n\n            return offset >= lowerBound && offset <= upperBound;\n        } catch (e) {\n            return true;\n        }\n    }\n\n    function reset() {\n        _resetInitialSettings();\n\n        eventBus.off(Events.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\n    }\n\n    instance = {\n        initialize,\n        attemptSync,\n        setConfig,\n        reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\nconst factory = FactoryMaker.getSingletonFactory(TimeSyncController);\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}