{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _FragmentRequest = require('../vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar FRAGMENT_MODEL_LOADING = 'loading';\nvar FRAGMENT_MODEL_EXECUTED = 'executed';\nvar FRAGMENT_MODEL_CANCELED = 'canceled';\nvar FRAGMENT_MODEL_FAILED = 'failed';\n\nfunction FragmentModel(config) {\n  config = config || {};\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var dashMetrics = config.dashMetrics;\n  var fragmentLoader = config.fragmentLoader;\n  var debug = config.debug;\n  var streamInfo = config.streamInfo;\n  var type = config.type;\n  var instance = void 0,\n      logger = void 0,\n      executedRequests = void 0,\n      loadingRequests = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    resetInitialSettings();\n    eventBus.on(events.LOADING_COMPLETED, onLoadingCompleted, instance);\n    eventBus.on(events.LOADING_DATA_PROGRESS, onLoadingInProgress, instance);\n    eventBus.on(events.LOADING_ABANDONED, onLoadingAborted, instance);\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function isFragmentLoaded(request) {\n    var isEqualComplete = function isEqualComplete(req1, req2) {\n      return req1.action === _FragmentRequest2.default.ACTION_COMPLETE && req1.action === req2.action;\n    };\n\n    var isEqualMedia = function isEqualMedia(req1, req2) {\n      return !isNaN(req1.index) && req1.startTime === req2.startTime && req1.adaptationIndex === req2.adaptationIndex && req1.type === req2.type;\n    };\n\n    var isEqualInit = function isEqualInit(req1, req2) {\n      return isNaN(req1.index) && isNaN(req2.index) && req1.quality === req2.quality;\n    };\n\n    var check = function check(requests) {\n      var isLoaded = false;\n      requests.some(function (req) {\n        if (isEqualMedia(request, req) || isEqualInit(request, req) || isEqualComplete(request, req)) {\n          isLoaded = true;\n          return isLoaded;\n        }\n      });\n      return isLoaded;\n    };\n\n    if (!request) {\n      return false;\n    }\n\n    return check(executedRequests);\n  }\n\n  function isFragmentLoadedOrPending(request) {\n    var isLoaded = false;\n    var i = 0;\n    var req = void 0; // First, check if the fragment has already been loaded\n\n    isLoaded = isFragmentLoaded(request); // Then, check if the fragment is about to be loeaded\n\n    if (!isLoaded) {\n      for (i = 0; i < loadingRequests.length; i++) {\n        req = loadingRequests[i];\n\n        if (request.url === req.url && request.startTime === req.startTime) {\n          isLoaded = true;\n        }\n      }\n    }\n\n    return isLoaded;\n  }\n  /**\n  *\n  * Gets an array of {@link FragmentRequest} objects\n  *\n  * @param {Object} filter The object with properties by which the method filters the requests to be returned.\n  *  the only mandatory property is state, which must be a value from\n  *  other properties should match the properties of {@link FragmentRequest}. E.g.:\n  *  getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: 0}) - returns\n  *  all the requests from executedRequests array where requests.quality = filter.quality\n  *\n  * @returns {Array}\n  * @memberof FragmentModel#\n  */\n\n\n  function getRequests(filter) {\n    var states = filter ? filter.state instanceof Array ? filter.state : [filter.state] : [];\n    var filteredRequests = [];\n    states.forEach(function (state) {\n      var requests = getRequestsForState(state);\n      filteredRequests = filteredRequests.concat(filterRequests(requests, filter));\n    });\n    return filteredRequests;\n  }\n\n  function getRequestThreshold(req) {\n    return isNaN(req.duration) ? 0.25 : Math.min(req.duration / 8, 0.5);\n  }\n\n  function removeExecutedRequestsBeforeTime(time) {\n    executedRequests = executedRequests.filter(function (req) {\n      var threshold = getRequestThreshold(req);\n      return isNaN(req.startTime) || (time !== undefined ? req.startTime >= time - threshold : false);\n    });\n  }\n\n  function removeExecutedRequestsAfterTime(time) {\n    executedRequests = executedRequests.filter(function (req) {\n      return isNaN(req.startTime) || (time !== undefined ? req.startTime < time : false);\n    });\n  }\n\n  function removeExecutedRequestsInTimeRange(start, end) {\n    if (end <= start + 0.5) {\n      return;\n    }\n\n    executedRequests = executedRequests.filter(function (req) {\n      var threshold = getRequestThreshold(req);\n      return isNaN(req.startTime) || req.startTime >= end - threshold || isNaN(req.duration) || req.startTime + req.duration <= start + threshold;\n    });\n  } // Remove requests that are not \"represented\" by any of buffered ranges\n\n\n  function syncExecutedRequestsWithBufferedRange(bufferedRanges, streamDuration) {\n    if (!bufferedRanges || bufferedRanges.length === 0) {\n      removeExecutedRequestsBeforeTime();\n      return;\n    }\n\n    var start = 0;\n\n    for (var i = 0, ln = bufferedRanges.length; i < ln; i++) {\n      removeExecutedRequestsInTimeRange(start, bufferedRanges.start(i));\n      start = bufferedRanges.end(i);\n    }\n\n    if (streamDuration > 0) {\n      removeExecutedRequestsInTimeRange(start, streamDuration);\n    }\n  }\n\n  function abortRequests() {\n    logger.debug('abort requests');\n    fragmentLoader.abort();\n    loadingRequests = [];\n  }\n\n  function executeRequest(request) {\n    switch (request.action) {\n      case _FragmentRequest2.default.ACTION_COMPLETE:\n        executedRequests.push(request);\n        addSchedulingInfoMetrics(request, FRAGMENT_MODEL_EXECUTED);\n        logger.debug('STREAM_COMPLETED');\n        eventBus.trigger(events.STREAM_COMPLETED, {\n          request: request\n        }, {\n          streamId: request.mediaInfo.streamInfo.id,\n          mediaType: request.mediaType\n        });\n        break;\n\n      case _FragmentRequest2.default.ACTION_DOWNLOAD:\n        addSchedulingInfoMetrics(request, FRAGMENT_MODEL_LOADING);\n        loadingRequests.push(request);\n        loadCurrentFragment(request);\n        break;\n\n      default:\n        logger.warn('Unknown request action.');\n    }\n  }\n\n  function loadCurrentFragment(request) {\n    eventBus.trigger(events.FRAGMENT_LOADING_STARTED, {\n      request: request\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n    fragmentLoader.load(request);\n  }\n\n  function getRequestForTime(arr, time, threshold) {\n    // loop through the executed requests and pick the one for which the playback interval matches the given time\n    var lastIdx = arr.length - 1;\n\n    for (var i = lastIdx; i >= 0; i--) {\n      var req = arr[i];\n      var start = req.startTime;\n      var end = start + req.duration;\n      threshold = !isNaN(threshold) ? threshold : getRequestThreshold(req);\n\n      if (!isNaN(start) && !isNaN(end) && time + threshold >= start && time - threshold < end || isNaN(start) && isNaN(time)) {\n        return req;\n      }\n    }\n\n    return null;\n  }\n\n  function filterRequests(arr, filter) {\n    // for time use a specific filtration function\n    if (filter.hasOwnProperty('time')) {\n      return [getRequestForTime(arr, filter.time, filter.threshold)];\n    }\n\n    return arr.filter(function (request) {\n      for (var prop in filter) {\n        if (prop === 'state') continue;\n        if (filter.hasOwnProperty(prop) && request[prop] != filter[prop]) return false;\n      }\n\n      return true;\n    });\n  }\n\n  function getRequestsForState(state) {\n    var requests = void 0;\n\n    switch (state) {\n      case FRAGMENT_MODEL_LOADING:\n        requests = loadingRequests;\n        break;\n\n      case FRAGMENT_MODEL_EXECUTED:\n        requests = executedRequests;\n        break;\n\n      default:\n        requests = [];\n    }\n\n    return requests;\n  }\n\n  function addSchedulingInfoMetrics(request, state) {\n    dashMetrics.addSchedulingInfo(request, state);\n    dashMetrics.addRequestsQueue(request.mediaType, loadingRequests, executedRequests);\n  }\n\n  function onLoadingCompleted(e) {\n    if (e.sender !== fragmentLoader) return;\n    loadingRequests.splice(loadingRequests.indexOf(e.request), 1);\n\n    if (e.response && !e.error) {\n      executedRequests.push(e.request);\n    }\n\n    addSchedulingInfoMetrics(e.request, e.error ? FRAGMENT_MODEL_FAILED : FRAGMENT_MODEL_EXECUTED);\n    eventBus.trigger(events.FRAGMENT_LOADING_COMPLETED, {\n      request: e.request,\n      response: e.response,\n      error: e.error,\n      sender: this\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onLoadingInProgress(e) {\n    if (e.sender !== fragmentLoader) return;\n    eventBus.trigger(events.FRAGMENT_LOADING_PROGRESS, {\n      request: e.request,\n      response: e.response,\n      error: e.error,\n      sender: this\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function onLoadingAborted(e) {\n    if (e.sender !== fragmentLoader) return;\n    eventBus.trigger(events.FRAGMENT_LOADING_ABANDONED, {\n      request: e.request\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function resetInitialSettings() {\n    executedRequests = [];\n    loadingRequests = [];\n  }\n\n  function reset() {\n    eventBus.off(events.LOADING_COMPLETED, onLoadingCompleted, this);\n    eventBus.off(events.LOADING_DATA_PROGRESS, onLoadingInProgress, this);\n    eventBus.off(events.LOADING_ABANDONED, onLoadingAborted, this);\n\n    if (fragmentLoader) {\n      fragmentLoader.reset();\n    }\n\n    resetInitialSettings();\n  }\n\n  function addExecutedRequest(request) {\n    executedRequests.push(request);\n  }\n\n  instance = {\n    getStreamId: getStreamId,\n    getType: getType,\n    getRequests: getRequests,\n    isFragmentLoaded: isFragmentLoaded,\n    isFragmentLoadedOrPending: isFragmentLoadedOrPending,\n    removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\n    removeExecutedRequestsAfterTime: removeExecutedRequestsAfterTime,\n    syncExecutedRequestsWithBufferedRange: syncExecutedRequestsWithBufferedRange,\n    abortRequests: abortRequests,\n    executeRequest: executeRequest,\n    reset: reset,\n    addExecutedRequest: addExecutedRequest\n  };\n  setup();\n  return instance;\n}\n\nFragmentModel.__dashjs_factory_name = 'FragmentModel';\n\nvar factory = _FactoryMaker2.default.getClassFactory(FragmentModel);\n\nfactory.FRAGMENT_MODEL_LOADING = FRAGMENT_MODEL_LOADING;\nfactory.FRAGMENT_MODEL_EXECUTED = FRAGMENT_MODEL_EXECUTED;\nfactory.FRAGMENT_MODEL_CANCELED = FRAGMENT_MODEL_CANCELED;\nfactory.FRAGMENT_MODEL_FAILED = FRAGMENT_MODEL_FAILED;\n\n_FactoryMaker2.default.updateClassFactory(FragmentModel.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../src/streaming/models/FragmentModel.js"],"names":["FRAGMENT_MODEL_LOADING","FRAGMENT_MODEL_EXECUTED","FRAGMENT_MODEL_CANCELED","FRAGMENT_MODEL_FAILED","config","eventBus","events","dashMetrics","fragmentLoader","debug","streamInfo","type","instance","logger","executedRequests","loadingRequests","resetInitialSettings","isEqualComplete","req1","FragmentRequest","req2","isEqualMedia","isNaN","isEqualInit","check","isLoaded","requests","i","req","isFragmentLoaded","request","states","filter","filteredRequests","getRequestsForState","filterRequests","Math","threshold","getRequestThreshold","time","end","start","bufferedRanges","removeExecutedRequestsBeforeTime","ln","removeExecutedRequestsInTimeRange","streamDuration","addSchedulingInfoMetrics","streamId","mediaType","loadCurrentFragment","lastIdx","arr","getRequestForTime","prop","e","response","error","sender","getStreamId","getType","getRequests","isFragmentLoadedOrPending","removeExecutedRequestsAfterTime","syncExecutedRequestsWithBufferedRange","abortRequests","executeRequest","reset","addExecutedRequest","setup","FragmentModel","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport FragmentRequest from '../vo/FragmentRequest';\n\nconst FRAGMENT_MODEL_LOADING = 'loading';\nconst FRAGMENT_MODEL_EXECUTED = 'executed';\nconst FRAGMENT_MODEL_CANCELED = 'canceled';\nconst FRAGMENT_MODEL_FAILED = 'failed';\n\nfunction FragmentModel(config) {\n\n    config = config || {};\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const dashMetrics = config.dashMetrics;\n    const fragmentLoader = config.fragmentLoader;\n    const debug = config.debug;\n    const streamInfo = config.streamInfo;\n    const type = config.type;\n\n    let instance,\n        logger,\n        executedRequests,\n        loadingRequests;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n        eventBus.on(events.LOADING_COMPLETED, onLoadingCompleted, instance);\n        eventBus.on(events.LOADING_DATA_PROGRESS, onLoadingInProgress, instance);\n        eventBus.on(events.LOADING_ABANDONED, onLoadingAborted, instance);\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function isFragmentLoaded(request) {\n        const isEqualComplete = function (req1, req2) {\n            return ((req1.action === FragmentRequest.ACTION_COMPLETE) && (req1.action === req2.action));\n        };\n\n        const isEqualMedia = function (req1, req2) {\n            return !isNaN(req1.index) && (req1.startTime === req2.startTime) && (req1.adaptationIndex === req2.adaptationIndex) && (req1.type === req2.type);\n        };\n\n        const isEqualInit = function (req1, req2) {\n            return isNaN(req1.index) && isNaN(req2.index) && (req1.quality === req2.quality);\n        };\n\n        const check = function (requests) {\n            let isLoaded = false;\n\n            requests.some(req => {\n                if (isEqualMedia(request, req) || isEqualInit(request, req) || isEqualComplete(request, req)) {\n                    isLoaded = true;\n                    return isLoaded;\n                }\n            });\n            return isLoaded;\n        };\n\n        if (!request) {\n            return false;\n        }\n\n        return check(executedRequests);\n    }\n\n    function isFragmentLoadedOrPending(request) {\n        let isLoaded = false;\n        let i = 0;\n        let req;\n\n        // First, check if the fragment has already been loaded\n        isLoaded = isFragmentLoaded(request);\n\n        // Then, check if the fragment is about to be loeaded\n        if (!isLoaded) {\n            for (i = 0; i < loadingRequests.length; i++) {\n                req = loadingRequests[i];\n                if ((request.url === req.url) && (request.startTime === req.startTime)) {\n                    isLoaded = true;\n                }\n            }\n        }\n\n        return isLoaded;\n    }\n\n    /**\n     *\n     * Gets an array of {@link FragmentRequest} objects\n     *\n     * @param {Object} filter The object with properties by which the method filters the requests to be returned.\n     *  the only mandatory property is state, which must be a value from\n     *  other properties should match the properties of {@link FragmentRequest}. E.g.:\n     *  getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: 0}) - returns\n     *  all the requests from executedRequests array where requests.quality = filter.quality\n     *\n     * @returns {Array}\n     * @memberof FragmentModel#\n     */\n    function getRequests(filter) {\n        const states = filter ? filter.state instanceof Array ? filter.state : [filter.state] : [];\n\n        let filteredRequests = [];\n        states.forEach(state => {\n            const requests = getRequestsForState(state);\n            filteredRequests = filteredRequests.concat(filterRequests(requests, filter));\n        });\n\n        return filteredRequests;\n    }\n\n    function getRequestThreshold(req) {\n        return isNaN(req.duration) ? 0.25 : Math.min(req.duration / 8, 0.5);\n    }\n\n    function removeExecutedRequestsBeforeTime(time) {\n        executedRequests = executedRequests.filter(req => {\n            const threshold = getRequestThreshold(req);\n            return isNaN(req.startTime) || (time !== undefined ? req.startTime >= time - threshold : false);\n        });\n    }\n\n    function removeExecutedRequestsAfterTime(time) {\n        executedRequests = executedRequests.filter(req => {\n            return isNaN(req.startTime) || (time !== undefined ? req.startTime < time : false);\n        });\n    }\n\n    function removeExecutedRequestsInTimeRange(start, end) {\n        if (end <= start + 0.5) {\n            return;\n        }\n\n        executedRequests = executedRequests.filter(req => {\n            const threshold = getRequestThreshold(req);\n            return (isNaN(req.startTime) || req.startTime >= (end - threshold)) ||\n                (isNaN(req.duration) || (req.startTime + req.duration) <= (start + threshold));\n        });\n    }\n\n    // Remove requests that are not \"represented\" by any of buffered ranges\n    function syncExecutedRequestsWithBufferedRange(bufferedRanges, streamDuration) {\n        if (!bufferedRanges || bufferedRanges.length === 0) {\n            removeExecutedRequestsBeforeTime();\n            return;\n        }\n\n        let start = 0;\n        for (let i = 0, ln = bufferedRanges.length; i < ln; i++) {\n            removeExecutedRequestsInTimeRange(start, bufferedRanges.start(i));\n            start = bufferedRanges.end(i);\n        }\n        if (streamDuration > 0) {\n            removeExecutedRequestsInTimeRange(start, streamDuration);\n        }\n    }\n\n    function abortRequests() {\n        logger.debug('abort requests');\n        fragmentLoader.abort();\n        loadingRequests = [];\n    }\n\n    function executeRequest(request) {\n        switch (request.action) {\n            case FragmentRequest.ACTION_COMPLETE:\n                executedRequests.push(request);\n                addSchedulingInfoMetrics(request, FRAGMENT_MODEL_EXECUTED);\n                logger.debug('STREAM_COMPLETED');\n                eventBus.trigger(events.STREAM_COMPLETED,\n                    { request: request },\n                    { streamId: request.mediaInfo.streamInfo.id, mediaType: request.mediaType }\n                );\n                break;\n            case FragmentRequest.ACTION_DOWNLOAD:\n                addSchedulingInfoMetrics(request, FRAGMENT_MODEL_LOADING);\n                loadingRequests.push(request);\n                loadCurrentFragment(request);\n                break;\n            default:\n                logger.warn('Unknown request action.');\n        }\n    }\n\n    function loadCurrentFragment(request) {\n        eventBus.trigger(events.FRAGMENT_LOADING_STARTED,\n            { request: request },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n        fragmentLoader.load(request);\n    }\n\n    function getRequestForTime(arr, time, threshold) {\n        // loop through the executed requests and pick the one for which the playback interval matches the given time\n        const lastIdx = arr.length - 1;\n        for (let i = lastIdx; i >= 0; i--) {\n            const req = arr[i];\n            const start = req.startTime;\n            const end = start + req.duration;\n            threshold = !isNaN(threshold) ? threshold : getRequestThreshold(req);\n            if ((!isNaN(start) && !isNaN(end) && ((time + threshold) >= start) && ((time - threshold) < end)) || (isNaN(start) && isNaN(time))) {\n                return req;\n            }\n        }\n        return null;\n    }\n\n    function filterRequests(arr, filter) {\n        // for time use a specific filtration function\n        if (filter.hasOwnProperty('time')) {\n            return [getRequestForTime(arr, filter.time, filter.threshold)];\n        }\n\n        return arr.filter(request => {\n            for (const prop in filter) {\n                if (prop === 'state') continue;\n                if (filter.hasOwnProperty(prop) && request[prop] != filter[prop]) return false;\n            }\n\n            return true;\n        });\n    }\n\n    function getRequestsForState(state) {\n        let requests;\n        switch (state) {\n            case FRAGMENT_MODEL_LOADING:\n                requests = loadingRequests;\n                break;\n            case FRAGMENT_MODEL_EXECUTED:\n                requests = executedRequests;\n                break;\n            default:\n                requests = [];\n        }\n        return requests;\n    }\n\n    function addSchedulingInfoMetrics(request, state) {\n        dashMetrics.addSchedulingInfo(request, state);\n        dashMetrics.addRequestsQueue(request.mediaType, loadingRequests, executedRequests);\n    }\n\n    function onLoadingCompleted(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        loadingRequests.splice(loadingRequests.indexOf(e.request), 1);\n\n        if (e.response && !e.error) {\n            executedRequests.push(e.request);\n        }\n\n        addSchedulingInfoMetrics(e.request, e.error ? FRAGMENT_MODEL_FAILED : FRAGMENT_MODEL_EXECUTED);\n\n        eventBus.trigger(events.FRAGMENT_LOADING_COMPLETED,\n            {\n                request: e.request,\n                response: e.response,\n                error: e.error,\n                sender: this\n            },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onLoadingInProgress(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        eventBus.trigger(events.FRAGMENT_LOADING_PROGRESS,\n            {\n                request: e.request,\n                response: e.response,\n                error: e.error,\n                sender: this\n            },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onLoadingAborted(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        eventBus.trigger(events.FRAGMENT_LOADING_ABANDONED,\n            { request: e.request },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function resetInitialSettings() {\n        executedRequests = [];\n        loadingRequests = [];\n    }\n\n    function reset() {\n        eventBus.off(events.LOADING_COMPLETED, onLoadingCompleted, this);\n        eventBus.off(events.LOADING_DATA_PROGRESS, onLoadingInProgress, this);\n        eventBus.off(events.LOADING_ABANDONED, onLoadingAborted, this);\n\n        if (fragmentLoader) {\n            fragmentLoader.reset();\n        }\n        resetInitialSettings();\n    }\n\n    function addExecutedRequest(request) {\n        executedRequests.push(request);\n    }\n\n    instance = {\n        getStreamId: getStreamId,\n        getType: getType,\n        getRequests: getRequests,\n        isFragmentLoaded: isFragmentLoaded,\n        isFragmentLoadedOrPending: isFragmentLoadedOrPending,\n        removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\n        removeExecutedRequestsAfterTime: removeExecutedRequestsAfterTime,\n        syncExecutedRequestsWithBufferedRange: syncExecutedRequestsWithBufferedRange,\n        abortRequests: abortRequests,\n        executeRequest: executeRequest,\n        reset: reset,\n        addExecutedRequest: addExecutedRequest\n    };\n\n    setup();\n    return instance;\n}\n\nFragmentModel.__dashjs_factory_name = 'FragmentModel';\nconst factory = FactoryMaker.getClassFactory(FragmentModel);\nfactory.FRAGMENT_MODEL_LOADING = FRAGMENT_MODEL_LOADING;\nfactory.FRAGMENT_MODEL_EXECUTED = FRAGMENT_MODEL_EXECUTED;\nfactory.FRAGMENT_MODEL_CANCELED = FRAGMENT_MODEL_CANCELED;\nfactory.FRAGMENT_MODEL_FAILED = FRAGMENT_MODEL_FAILED;\nFactoryMaker.updateClassFactory(FragmentModel.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}