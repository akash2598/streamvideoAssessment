{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction VideoModel() {\n  var instance = void 0,\n      logger = void 0,\n      element = void 0,\n      TTMLRenderingDiv = void 0,\n      previousPlaybackRate = void 0;\n  var VIDEO_MODEL_WRONG_ELEMENT_TYPE = 'element is not video or audio DOM type!';\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var stalledStreams = [];\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function initialize() {\n    eventBus.on(_Events2.default.PLAYBACK_PLAYING, onPlaying, this);\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.PLAYBACK_PLAYING, onPlaying, this);\n  }\n\n  function onPlaybackCanPlay() {\n    if (element) {\n      element.playbackRate = previousPlaybackRate || 1;\n      element.removeEventListener('canplay', onPlaybackCanPlay);\n    }\n  }\n\n  function setPlaybackRate(value) {\n    if (!element) return;\n\n    if (element.readyState <= 2 && value > 0) {\n      // If media element hasn't loaded enough data to play yet, wait until it has\n      element.addEventListener('canplay', onPlaybackCanPlay);\n    } else {\n      element.playbackRate = value;\n    }\n  } //TODO Move the DVR window calculations from MediaPlayer to Here.\n\n\n  function setCurrentTime(currentTime, stickToBuffered) {\n    if (element) {\n      //_currentTime = currentTime;\n      // We don't set the same currentTime because it can cause firing unexpected Pause event in IE11\n      // providing playbackRate property equals to zero.\n      if (element.currentTime == currentTime) return; // TODO Despite the fact that MediaSource 'open' event has been fired IE11 cannot set videoElement.currentTime\n      // immediately (it throws InvalidStateError). It seems that this is related to videoElement.readyState property\n      // Initially it is 0, but soon after 'open' event it goes to 1 and setting currentTime is allowed. Chrome allows to\n      // set currentTime even if readyState = 0.\n      // setTimeout is used to workaround InvalidStateError in IE11\n\n      try {\n        currentTime = stickToBuffered ? stickTimeToBuffered(currentTime) : currentTime;\n        element.currentTime = currentTime;\n      } catch (e) {\n        if (element.readyState === 0 && e.code === e.INVALID_STATE_ERR) {\n          setTimeout(function () {\n            element.currentTime = currentTime;\n          }, 400);\n        }\n      }\n    }\n  }\n\n  function stickTimeToBuffered(time) {\n    var buffered = getBufferRange();\n    var closestTime = time;\n    var closestDistance = 9999999999;\n\n    if (buffered) {\n      for (var i = 0; i < buffered.length; i++) {\n        var start = buffered.start(i);\n        var end = buffered.end(i);\n        var distanceToStart = Math.abs(start - time);\n        var distanceToEnd = Math.abs(end - time);\n\n        if (time >= start && time <= end) {\n          return time;\n        }\n\n        if (distanceToStart < closestDistance) {\n          closestDistance = distanceToStart;\n          closestTime = start;\n        }\n\n        if (distanceToEnd < closestDistance) {\n          closestDistance = distanceToEnd;\n          closestTime = end;\n        }\n      }\n    }\n\n    return closestTime;\n  }\n\n  function getElement() {\n    return element;\n  }\n\n  function setElement(value) {\n    //add check of value type\n    if (value === null || value === undefined || value && /^(VIDEO|AUDIO)$/i.test(value.nodeName)) {\n      element = value; // Workaround to force Firefox to fire the canplay event.\n\n      if (element) {\n        element.preload = 'auto';\n      }\n    } else {\n      throw VIDEO_MODEL_WRONG_ELEMENT_TYPE;\n    }\n  }\n\n  function setSource(source) {\n    if (element) {\n      if (source) {\n        element.src = source;\n      } else {\n        element.removeAttribute('src');\n        element.load();\n      }\n    }\n  }\n\n  function getSource() {\n    return element ? element.src : null;\n  }\n\n  function getTTMLRenderingDiv() {\n    return TTMLRenderingDiv;\n  }\n\n  function setTTMLRenderingDiv(div) {\n    TTMLRenderingDiv = div; // The styling will allow the captions to match the video window size and position.\n\n    TTMLRenderingDiv.style.position = 'absolute';\n    TTMLRenderingDiv.style.display = 'flex';\n    TTMLRenderingDiv.style.overflow = 'hidden';\n    TTMLRenderingDiv.style.pointerEvents = 'none';\n    TTMLRenderingDiv.style.top = 0;\n    TTMLRenderingDiv.style.left = 0;\n  }\n\n  function setStallState(type, state) {\n    stallStream(type, state);\n  }\n\n  function isStalled() {\n    return stalledStreams.length > 0;\n  }\n\n  function addStalledStream(type) {\n    var event = void 0;\n\n    if (type === null || !element || element.seeking || stalledStreams.indexOf(type) !== -1) {\n      return;\n    }\n\n    stalledStreams.push(type);\n\n    if (element && stalledStreams.length === 1) {\n      // Halt playback until nothing is stalled.\n      event = document.createEvent('Event');\n      event.initEvent('waiting', true, false);\n      previousPlaybackRate = element.playbackRate;\n      setPlaybackRate(0);\n      element.dispatchEvent(event);\n    }\n  }\n\n  function removeStalledStream(type) {\n    var index = stalledStreams.indexOf(type);\n    var event = void 0;\n\n    if (type === null) {\n      return;\n    }\n\n    if (index !== -1) {\n      stalledStreams.splice(index, 1);\n    } // If nothing is stalled resume playback.\n\n\n    if (element && isStalled() === false && element.playbackRate === 0) {\n      setPlaybackRate(previousPlaybackRate || 1);\n\n      if (!element.paused) {\n        event = document.createEvent('Event');\n        event.initEvent('playing', true, false);\n        element.dispatchEvent(event);\n      }\n    }\n  }\n\n  function stallStream(type, isStalled) {\n    if (isStalled) {\n      addStalledStream(type);\n    } else {\n      removeStalledStream(type);\n    }\n  } //Calling play on the element will emit playing - even if the stream is stalled. If the stream is stalled, emit a waiting event.\n\n\n  function onPlaying() {\n    if (element && isStalled() && element.playbackRate === 0) {\n      var event = document.createEvent('Event');\n      event.initEvent('waiting', true, false);\n      element.dispatchEvent(event);\n    }\n  }\n\n  function getPlaybackQuality() {\n    if (!element) {\n      return null;\n    }\n\n    var hasWebKit = 'webkitDroppedFrameCount' in element && 'webkitDecodedFrameCount' in element;\n    var hasQuality = ('getVideoPlaybackQuality' in element);\n    var result = null;\n\n    if (hasQuality) {\n      result = element.getVideoPlaybackQuality();\n    } else if (hasWebKit) {\n      result = {\n        droppedVideoFrames: element.webkitDroppedFrameCount,\n        totalVideoFrames: element.webkitDroppedFrameCount + element.webkitDecodedFrameCount,\n        creationTime: new Date()\n      };\n    }\n\n    return result;\n  }\n\n  function play() {\n    if (element) {\n      element.autoplay = true;\n      var p = element.play();\n\n      if (p && p.catch && typeof Promise !== 'undefined') {\n        p.catch(function (e) {\n          if (e.name === 'NotAllowedError') {\n            eventBus.trigger(_Events2.default.PLAYBACK_NOT_ALLOWED);\n          }\n\n          logger.warn('Caught pending play exception - continuing (' + e + ')');\n        });\n      }\n    }\n  }\n\n  function isPaused() {\n    return element ? element.paused : null;\n  }\n\n  function pause() {\n    if (element) {\n      element.pause();\n      element.autoplay = false;\n    }\n  }\n\n  function isSeeking() {\n    return element ? element.seeking : null;\n  }\n\n  function getTime() {\n    return element ? element.currentTime : null;\n  }\n\n  function getPlaybackRate() {\n    return element ? element.playbackRate : null;\n  }\n\n  function getPlayedRanges() {\n    return element ? element.played : null;\n  }\n\n  function getEnded() {\n    return element ? element.ended : null;\n  }\n\n  function addEventListener(eventName, eventCallBack) {\n    if (element) {\n      element.addEventListener(eventName, eventCallBack);\n    }\n  }\n\n  function removeEventListener(eventName, eventCallBack) {\n    if (element) {\n      element.removeEventListener(eventName, eventCallBack);\n    }\n  }\n\n  function getReadyState() {\n    return element ? element.readyState : NaN;\n  }\n\n  function getBufferRange() {\n    return element ? element.buffered : null;\n  }\n\n  function getClientWidth() {\n    return element ? element.clientWidth : NaN;\n  }\n\n  function getClientHeight() {\n    return element ? element.clientHeight : NaN;\n  }\n\n  function getVideoWidth() {\n    return element ? element.videoWidth : NaN;\n  }\n\n  function getVideoHeight() {\n    return element ? element.videoHeight : NaN;\n  }\n\n  function getVideoRelativeOffsetTop() {\n    var parentElement = element.parentNode.host || element.parentNode;\n    return parentElement ? element.getBoundingClientRect().top - parentElement.getBoundingClientRect().top : NaN;\n  }\n\n  function getVideoRelativeOffsetLeft() {\n    var parentElement = element.parentNode.host || element.parentNode;\n    return parentElement ? element.getBoundingClientRect().left - parentElement.getBoundingClientRect().left : NaN;\n  }\n\n  function getTextTracks() {\n    return element ? element.textTracks : [];\n  }\n\n  function getTextTrack(kind, label, lang, isTTML, isEmbedded) {\n    if (element) {\n      for (var i = 0; i < element.textTracks.length; i++) {\n        //label parameter could be a number (due to adaptationSet), but label, the attribute of textTrack, is a string => to modify...\n        //label could also be undefined (due to adaptationSet)\n        if (element.textTracks[i].kind === kind && (label ? element.textTracks[i].label == label : true) && element.textTracks[i].language === lang && element.textTracks[i].isTTML === isTTML && element.textTracks[i].isEmbedded === isEmbedded) {\n          return element.textTracks[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function addTextTrack(kind, label, lang, isTTML, isEmbedded) {\n    if (!element) {\n      return null;\n    } // check if track of same type has not been already created for previous stream\n    // then use it (no way to remove existing text track from video element)\n\n\n    var track = getTextTrack(kind, label, lang, isTTML, isEmbedded);\n\n    if (!track) {\n      track = element.addTextTrack(kind, label, lang);\n      track.isEmbedded = isEmbedded;\n      track.isTTML = isTTML;\n    }\n\n    return track;\n  }\n\n  function appendChild(childElement) {\n    if (element) {\n      element.appendChild(childElement); //in Chrome, we need to differenciate textTrack with same lang, kind and label but different format (vtt, ttml, etc...)\n\n      if (childElement.isTTML !== undefined) {\n        element.textTracks[element.textTracks.length - 1].isTTML = childElement.isTTML;\n        element.textTracks[element.textTracks.length - 1].isEmbedded = childElement.isEmbedded;\n      }\n    }\n  }\n\n  function removeChild(childElement) {\n    if (element) {\n      element.removeChild(childElement);\n    }\n  }\n\n  instance = {\n    initialize: initialize,\n    setCurrentTime: setCurrentTime,\n    play: play,\n    isPaused: isPaused,\n    pause: pause,\n    isStalled: isStalled,\n    isSeeking: isSeeking,\n    getTime: getTime,\n    getPlaybackRate: getPlaybackRate,\n    setPlaybackRate: setPlaybackRate,\n    getPlayedRanges: getPlayedRanges,\n    getEnded: getEnded,\n    setStallState: setStallState,\n    getElement: getElement,\n    setElement: setElement,\n    setSource: setSource,\n    getSource: getSource,\n    getTTMLRenderingDiv: getTTMLRenderingDiv,\n    setTTMLRenderingDiv: setTTMLRenderingDiv,\n    getPlaybackQuality: getPlaybackQuality,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    getReadyState: getReadyState,\n    getBufferRange: getBufferRange,\n    getClientWidth: getClientWidth,\n    getClientHeight: getClientHeight,\n    getTextTracks: getTextTracks,\n    getTextTrack: getTextTrack,\n    addTextTrack: addTextTrack,\n    appendChild: appendChild,\n    removeChild: removeChild,\n    getVideoWidth: getVideoWidth,\n    getVideoHeight: getVideoHeight,\n    getVideoRelativeOffsetTop: getVideoRelativeOffsetTop,\n    getVideoRelativeOffsetLeft: getVideoRelativeOffsetLeft,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nVideoModel.__dashjs_factory_name = 'VideoModel';\nexports.default = _FactoryMaker2.default.getSingletonFactory(VideoModel);","map":{"version":3,"sources":["../../../../../src/streaming/models/VideoModel.js"],"names":["instance","logger","element","TTMLRenderingDiv","previousPlaybackRate","VIDEO_MODEL_WRONG_ELEMENT_TYPE","context","eventBus","stalledStreams","Events","value","currentTime","stickToBuffered","stickTimeToBuffered","e","setTimeout","buffered","getBufferRange","closestTime","closestDistance","i","start","end","distanceToStart","Math","distanceToEnd","time","stallStream","event","type","document","setPlaybackRate","index","isStalled","addStalledStream","removeStalledStream","hasWebKit","hasQuality","result","droppedVideoFrames","totalVideoFrames","creationTime","p","parentElement","label","track","getTextTrack","childElement","initialize","setCurrentTime","play","isPaused","pause","isSeeking","getTime","getPlaybackRate","getPlayedRanges","getEnded","setStallState","getElement","setElement","setSource","getSource","getTTMLRenderingDiv","setTTMLRenderingDiv","getPlaybackQuality","addEventListener","removeEventListener","getReadyState","getClientWidth","getClientHeight","getTextTracks","addTextTrack","appendChild","removeChild","getVideoWidth","getVideoHeight","getVideoRelativeOffsetTop","getVideoRelativeOffsetLeft","reset","setup","VideoModel","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport Debug from '../../core/Debug';\n\nfunction VideoModel() {\n\n    let instance,\n        logger,\n        element,\n        TTMLRenderingDiv,\n        previousPlaybackRate;\n\n    const VIDEO_MODEL_WRONG_ELEMENT_TYPE = 'element is not video or audio DOM type!';\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const stalledStreams = [];\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function initialize() {\n        eventBus.on(Events.PLAYBACK_PLAYING, onPlaying, this);\n    }\n\n    function reset() {\n        eventBus.off(Events.PLAYBACK_PLAYING, onPlaying, this);\n    }\n\n    function onPlaybackCanPlay() {\n        if (element) {\n            element.playbackRate = previousPlaybackRate || 1;\n            element.removeEventListener('canplay', onPlaybackCanPlay);\n        }\n    }\n\n    function setPlaybackRate(value) {\n        if (!element) return;\n        if (element.readyState <= 2 && value > 0) {\n            // If media element hasn't loaded enough data to play yet, wait until it has\n            element.addEventListener('canplay', onPlaybackCanPlay);\n        } else {\n            element.playbackRate = value;\n        }\n    }\n\n    //TODO Move the DVR window calculations from MediaPlayer to Here.\n    function setCurrentTime(currentTime, stickToBuffered) {\n        if (element) {\n            //_currentTime = currentTime;\n\n            // We don't set the same currentTime because it can cause firing unexpected Pause event in IE11\n            // providing playbackRate property equals to zero.\n            if (element.currentTime == currentTime) return;\n\n            // TODO Despite the fact that MediaSource 'open' event has been fired IE11 cannot set videoElement.currentTime\n            // immediately (it throws InvalidStateError). It seems that this is related to videoElement.readyState property\n            // Initially it is 0, but soon after 'open' event it goes to 1 and setting currentTime is allowed. Chrome allows to\n            // set currentTime even if readyState = 0.\n            // setTimeout is used to workaround InvalidStateError in IE11\n            try {\n                currentTime = stickToBuffered ? stickTimeToBuffered(currentTime) : currentTime;\n                element.currentTime = currentTime;\n            } catch (e) {\n                if (element.readyState === 0 && e.code === e.INVALID_STATE_ERR) {\n                    setTimeout(function () {\n                        element.currentTime = currentTime;\n                    }, 400);\n                }\n            }\n        }\n    }\n\n    function stickTimeToBuffered(time) {\n        const buffered = getBufferRange();\n        let closestTime = time;\n        let closestDistance = 9999999999;\n        if (buffered) {\n            for (let i = 0; i < buffered.length; i++) {\n                const start = buffered.start(i);\n                const end = buffered.end(i);\n                const distanceToStart = Math.abs(start - time);\n                const distanceToEnd = Math.abs(end - time);\n\n                if (time >= start && time <= end) {\n                    return time;\n                }\n\n                if (distanceToStart < closestDistance) {\n                    closestDistance = distanceToStart;\n                    closestTime = start;\n                }\n\n                if (distanceToEnd < closestDistance) {\n                    closestDistance = distanceToEnd;\n                    closestTime = end;\n                }\n            }\n        }\n        return closestTime;\n    }\n\n    function getElement() {\n        return element;\n    }\n\n    function setElement(value) {\n        //add check of value type\n        if (value === null || value === undefined || (value && (/^(VIDEO|AUDIO)$/i).test(value.nodeName))) {\n            element = value;\n            // Workaround to force Firefox to fire the canplay event.\n            if (element) {\n                element.preload = 'auto';\n            }\n        } else {\n            throw VIDEO_MODEL_WRONG_ELEMENT_TYPE;\n        }\n    }\n\n    function setSource(source) {\n        if (element) {\n            if (source) {\n                element.src = source;\n            } else {\n                element.removeAttribute('src');\n                element.load();\n            }\n        }\n    }\n\n    function getSource() {\n        return element ? element.src : null;\n    }\n\n    function getTTMLRenderingDiv() {\n        return TTMLRenderingDiv;\n    }\n\n    function setTTMLRenderingDiv(div) {\n        TTMLRenderingDiv = div;\n        // The styling will allow the captions to match the video window size and position.\n        TTMLRenderingDiv.style.position = 'absolute';\n        TTMLRenderingDiv.style.display = 'flex';\n        TTMLRenderingDiv.style.overflow = 'hidden';\n        TTMLRenderingDiv.style.pointerEvents = 'none';\n        TTMLRenderingDiv.style.top = 0;\n        TTMLRenderingDiv.style.left = 0;\n    }\n\n    function setStallState(type, state) {\n        stallStream(type, state);\n    }\n\n    function isStalled() {\n        return (stalledStreams.length > 0);\n    }\n\n    function addStalledStream(type) {\n        let event;\n\n        if (type === null || !element || element.seeking || stalledStreams.indexOf(type) !== -1) {\n            return;\n        }\n\n        stalledStreams.push(type);\n        if (element && stalledStreams.length === 1) {\n            // Halt playback until nothing is stalled.\n            event = document.createEvent('Event');\n            event.initEvent('waiting', true, false);\n            previousPlaybackRate = element.playbackRate;\n            setPlaybackRate(0);\n            element.dispatchEvent(event);\n        }\n    }\n\n    function removeStalledStream(type) {\n        let index = stalledStreams.indexOf(type);\n        let event;\n\n        if (type === null) {\n            return;\n        }\n        if (index !== -1) {\n            stalledStreams.splice(index, 1);\n        }\n        // If nothing is stalled resume playback.\n        if (element && isStalled() === false && element.playbackRate === 0) {\n            setPlaybackRate(previousPlaybackRate || 1);\n            if (!element.paused) {\n                event = document.createEvent('Event');\n                event.initEvent('playing', true, false);\n                element.dispatchEvent(event);\n            }\n        }\n    }\n\n    function stallStream(type, isStalled) {\n        if (isStalled) {\n            addStalledStream(type);\n        } else {\n            removeStalledStream(type);\n        }\n    }\n\n    //Calling play on the element will emit playing - even if the stream is stalled. If the stream is stalled, emit a waiting event.\n    function onPlaying() {\n        if (element && isStalled() && element.playbackRate === 0) {\n            const event = document.createEvent('Event');\n            event.initEvent('waiting', true, false);\n            element.dispatchEvent(event);\n        }\n    }\n\n    function getPlaybackQuality() {\n        if (!element) { return null; }\n        let hasWebKit = ('webkitDroppedFrameCount' in element) && ('webkitDecodedFrameCount' in element);\n        let hasQuality = ('getVideoPlaybackQuality' in element);\n        let result = null;\n\n        if (hasQuality) {\n            result = element.getVideoPlaybackQuality();\n        } else if (hasWebKit) {\n            result = {\n                droppedVideoFrames: element.webkitDroppedFrameCount,\n                totalVideoFrames: element.webkitDroppedFrameCount + element.webkitDecodedFrameCount,\n                creationTime: new Date()\n            };\n        }\n\n        return result;\n    }\n\n    function play() {\n        if (element) {\n            element.autoplay = true;\n            const p = element.play();\n            if (p && p.catch && typeof Promise !== 'undefined') {\n                p.catch((e) => {\n                    if (e.name === 'NotAllowedError') {\n                        eventBus.trigger(Events.PLAYBACK_NOT_ALLOWED);\n                    }\n                    logger.warn(`Caught pending play exception - continuing (${e})`);\n                });\n            }\n        }\n    }\n\n    function isPaused() {\n        return element ? element.paused : null;\n    }\n\n    function pause() {\n        if (element) {\n            element.pause();\n            element.autoplay = false;\n        }\n    }\n\n    function isSeeking() {\n        return element ? element.seeking : null;\n    }\n\n    function getTime() {\n        return element ? element.currentTime : null;\n    }\n\n    function getPlaybackRate() {\n        return element ? element.playbackRate : null;\n    }\n\n    function getPlayedRanges() {\n        return element ? element.played : null;\n    }\n\n    function getEnded() {\n        return element ? element.ended : null;\n    }\n\n    function addEventListener(eventName, eventCallBack) {\n        if (element) {\n            element.addEventListener(eventName, eventCallBack);\n        }\n    }\n\n    function removeEventListener(eventName, eventCallBack) {\n        if (element) {\n            element.removeEventListener(eventName, eventCallBack);\n        }\n    }\n\n    function getReadyState() {\n        return element ? element.readyState : NaN;\n    }\n\n    function getBufferRange() {\n        return element ? element.buffered : null;\n    }\n\n    function getClientWidth() {\n        return element ? element.clientWidth : NaN;\n    }\n\n    function getClientHeight() {\n        return element ? element.clientHeight : NaN;\n    }\n\n    function getVideoWidth() {\n        return element ? element.videoWidth : NaN;\n    }\n\n    function getVideoHeight() {\n        return element ? element.videoHeight : NaN;\n    }\n\n    function getVideoRelativeOffsetTop() {\n        const parentElement = element.parentNode.host || element.parentNode;\n        return parentElement ? element.getBoundingClientRect().top - parentElement.getBoundingClientRect().top : NaN;\n    }\n\n    function getVideoRelativeOffsetLeft() {\n        const parentElement = element.parentNode.host || element.parentNode;\n        return parentElement ? element.getBoundingClientRect().left - parentElement.getBoundingClientRect().left : NaN;\n    }\n\n    function getTextTracks() {\n        return element ? element.textTracks : [];\n    }\n\n    function getTextTrack(kind, label, lang, isTTML, isEmbedded) {\n        if (element) {\n            for (let i = 0; i < element.textTracks.length; i++) {\n                //label parameter could be a number (due to adaptationSet), but label, the attribute of textTrack, is a string => to modify...\n                //label could also be undefined (due to adaptationSet)\n                if (element.textTracks[i].kind === kind && (label ? element.textTracks[i].label == label : true) &&\n                   element.textTracks[i].language === lang && element.textTracks[i].isTTML === isTTML && element.textTracks[i].isEmbedded === isEmbedded) {\n                    return element.textTracks[i];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    function addTextTrack(kind, label, lang, isTTML, isEmbedded) {\n        if (!element) {\n            return null;\n        }\n        // check if track of same type has not been already created for previous stream\n        // then use it (no way to remove existing text track from video element)\n        let track = getTextTrack(kind, label, lang, isTTML, isEmbedded);\n        if (!track) {\n            track = element.addTextTrack(kind, label, lang);\n            track.isEmbedded = isEmbedded;\n            track.isTTML = isTTML;\n        }\n        return track;\n    }\n\n    function appendChild(childElement) {\n        if (element) {\n            element.appendChild(childElement);\n            //in Chrome, we need to differenciate textTrack with same lang, kind and label but different format (vtt, ttml, etc...)\n            if (childElement.isTTML !== undefined) {\n                element.textTracks[element.textTracks.length - 1].isTTML = childElement.isTTML;\n                element.textTracks[element.textTracks.length - 1].isEmbedded = childElement.isEmbedded;\n            }\n        }\n    }\n\n    function removeChild(childElement) {\n        if (element) {\n            element.removeChild(childElement);\n        }\n    }\n\n    instance = {\n        initialize: initialize,\n        setCurrentTime: setCurrentTime,\n        play: play,\n        isPaused: isPaused,\n        pause: pause,\n        isStalled,\n        isSeeking: isSeeking,\n        getTime: getTime,\n        getPlaybackRate: getPlaybackRate,\n        setPlaybackRate: setPlaybackRate,\n        getPlayedRanges: getPlayedRanges,\n        getEnded: getEnded,\n        setStallState: setStallState,\n        getElement: getElement,\n        setElement: setElement,\n        setSource: setSource,\n        getSource: getSource,\n        getTTMLRenderingDiv: getTTMLRenderingDiv,\n        setTTMLRenderingDiv: setTTMLRenderingDiv,\n        getPlaybackQuality: getPlaybackQuality,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        getReadyState: getReadyState,\n        getBufferRange: getBufferRange,\n        getClientWidth: getClientWidth,\n        getClientHeight: getClientHeight,\n        getTextTracks: getTextTracks,\n        getTextTrack: getTextTrack,\n        addTextTrack: addTextTrack,\n        appendChild: appendChild,\n        removeChild: removeChild,\n        getVideoWidth: getVideoWidth,\n        getVideoHeight: getVideoHeight,\n        getVideoRelativeOffsetTop: getVideoRelativeOffsetTop,\n        getVideoRelativeOffsetLeft: getVideoRelativeOffsetLeft,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nVideoModel.__dashjs_factory_name = 'VideoModel';\nexport default FactoryMaker.getSingletonFactory(VideoModel);\n"]},"metadata":{},"sourceType":"script"}