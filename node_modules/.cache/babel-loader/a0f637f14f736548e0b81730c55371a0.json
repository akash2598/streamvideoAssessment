{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('./constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _MetricsConstants = require('./constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _FragmentModel = require('./models/FragmentModel');\n\nvar _FragmentModel2 = _interopRequireDefault(_FragmentModel);\n\nvar _BufferController = require('./controllers/BufferController');\n\nvar _BufferController2 = _interopRequireDefault(_BufferController);\n\nvar _TextBufferController = require('./text/TextBufferController');\n\nvar _TextBufferController2 = _interopRequireDefault(_TextBufferController);\n\nvar _ScheduleController = require('./controllers/ScheduleController');\n\nvar _ScheduleController2 = _interopRequireDefault(_ScheduleController);\n\nvar _RepresentationController = require('../dash/controllers/RepresentationController');\n\nvar _RepresentationController2 = _interopRequireDefault(_RepresentationController);\n\nvar _LiveEdgeFinder = require('./utils/LiveEdgeFinder');\n\nvar _LiveEdgeFinder2 = _interopRequireDefault(_LiveEdgeFinder);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _SupervisorTools = require('./utils/SupervisorTools');\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _DashHandler = require('../dash/DashHandler');\n\nvar _DashHandler2 = _interopRequireDefault(_DashHandler);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _DashJSError = require('./vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _RequestModifier = require('./utils/RequestModifier');\n\nvar _RequestModifier2 = _interopRequireDefault(_RequestModifier);\n\nvar _URLUtils = require('../streaming/utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nvar _BoxParser = require('./utils/BoxParser');\n\nvar _BoxParser2 = _interopRequireDefault(_BoxParser);\n\nvar _FragmentRequest = require('./vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _PlayList = require('./vo/metrics/PlayList');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction StreamProcessor(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var streamInfo = config.streamInfo;\n  var type = config.type;\n  var errHandler = config.errHandler;\n  var mimeType = config.mimeType;\n  var timelineConverter = config.timelineConverter;\n  var adapter = config.adapter;\n  var manifestModel = config.manifestModel;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var fragmentModel = config.fragmentModel;\n  var abrController = config.abrController;\n  var playbackController = config.playbackController;\n  var mediaController = config.mediaController;\n  var textController = config.textController;\n  var dashMetrics = config.dashMetrics;\n  var settings = config.settings;\n  var boxParser = config.boxParser;\n  var instance = void 0,\n      logger = void 0,\n      isDynamic = void 0,\n      mediaInfo = void 0,\n      mediaInfoArr = void 0,\n      bufferController = void 0,\n      scheduleController = void 0,\n      representationController = void 0,\n      liveEdgeFinder = void 0,\n      indexHandler = void 0,\n      bufferingTime = void 0,\n      bufferPruned = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n    eventBus.on(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance, {\n      priority: _EventBus2.default.EVENT_PRIORITY_HIGH\n    }); // High priority to be notified before Stream\n\n    eventBus.on(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.on(_Events2.default.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.on(_Events2.default.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n    eventBus.on(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n    eventBus.on(_Events2.default.BUFFER_CLEARED, onBufferCleared, instance);\n    eventBus.on(_Events2.default.QUOTA_EXCEEDED, onQuotaExceeded, instance);\n    eventBus.on(_Events2.default.SEEK_TARGET, onSeekTarget, instance);\n  }\n\n  function initialize(mediaSource, hasVideoTrack) {\n    indexHandler = (0, _DashHandler2.default)(context).create({\n      streamInfo: streamInfo,\n      type: type,\n      timelineConverter: timelineConverter,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      baseURLController: config.baseURLController,\n      errHandler: errHandler,\n      settings: settings,\n      boxParser: boxParser,\n      events: _Events2.default,\n      eventBus: eventBus,\n      errors: _Errors2.default,\n      debug: (0, _Debug2.default)(context).getInstance(),\n      requestModifier: (0, _RequestModifier2.default)(context).getInstance(),\n      dashConstants: _DashConstants2.default,\n      constants: _Constants2.default,\n      urlUtils: (0, _URLUtils2.default)(context).getInstance()\n    }); // Create live edge finder for dynamic streams\n\n    isDynamic = streamInfo.manifestInfo.isDynamic;\n\n    if (isDynamic) {\n      liveEdgeFinder = (0, _LiveEdgeFinder2.default)(context).create({\n        timelineConverter: timelineConverter\n      });\n    } // Create/initialize controllers\n\n\n    indexHandler.initialize(isDynamic);\n    abrController.registerStreamType(type, instance);\n    representationController = (0, _RepresentationController2.default)(context).create({\n      streamInfo: streamInfo,\n      type: type,\n      abrController: abrController,\n      dashMetrics: dashMetrics,\n      playbackController: playbackController,\n      timelineConverter: timelineConverter,\n      dashConstants: _DashConstants2.default,\n      events: _Events2.default,\n      eventBus: eventBus,\n      errors: _Errors2.default\n    });\n    bufferController = createBufferControllerForType(type);\n\n    if (bufferController) {\n      bufferController.initialize(mediaSource);\n    }\n\n    scheduleController = (0, _ScheduleController2.default)(context).create({\n      streamInfo: streamInfo,\n      type: type,\n      mimeType: mimeType,\n      adapter: adapter,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      fragmentModel: fragmentModel,\n      abrController: abrController,\n      playbackController: playbackController,\n      textController: textController,\n      mediaController: mediaController,\n      bufferController: bufferController,\n      settings: settings\n    });\n    scheduleController.initialize(hasVideoTrack);\n    bufferingTime = 0;\n    bufferPruned = false;\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function resetInitialSettings() {\n    mediaInfoArr = [];\n    mediaInfo = null;\n    bufferingTime = 0;\n  }\n\n  function reset(errored, keepBuffers) {\n    if (indexHandler) {\n      indexHandler.reset();\n    }\n\n    if (bufferController) {\n      bufferController.reset(errored, keepBuffers);\n      bufferController = null;\n    }\n\n    if (scheduleController) {\n      scheduleController.reset();\n      scheduleController = null;\n    }\n\n    if (representationController) {\n      representationController.reset();\n      representationController = null;\n    }\n\n    if (liveEdgeFinder) {\n      liveEdgeFinder.reset();\n      liveEdgeFinder = null;\n    }\n\n    if (abrController && !keepBuffers) {\n      abrController.unRegisterStreamType(type);\n    }\n\n    eventBus.off(_Events2.default.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.off(_Events2.default.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.off(_Events2.default.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n    eventBus.off(_Events2.default.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n    eventBus.off(_Events2.default.BUFFER_CLEARED, onBufferCleared, instance);\n    eventBus.off(_Events2.default.SEEK_TARGET, onSeekTarget, instance);\n    resetInitialSettings();\n    type = null;\n    streamInfo = null;\n  }\n\n  function isUpdating() {\n    return representationController ? representationController.isUpdating() : false;\n  }\n\n  function onDataUpdateCompleted(e) {\n    if (!e.error) {\n      // Update representation if no error\n      scheduleController.setCurrentRepresentation(adapter.convertDataToRepresentationInfo(e.currentRepresentation));\n    }\n\n    if (!e.error || e.error.code === _Errors2.default.SEGMENTS_UPDATE_FAILED_ERROR_CODE) {\n      // Update has been postponed, update nevertheless DVR info\n      var activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n\n      if (activeStreamId === streamInfo.id) {\n        addDVRMetric();\n      }\n    }\n  }\n\n  function onQualityChanged(e) {\n    var representationInfo = getRepresentationInfo(e.newQuality);\n    scheduleController.setCurrentRepresentation(representationInfo);\n    dashMetrics.pushPlayListTraceMetrics(new Date(), _PlayList.PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n    dashMetrics.createPlaylistTraceMetrics(representationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n  }\n\n  function onBufferLevelUpdated(e) {\n    dashMetrics.addBufferLevel(type, new Date(), e.bufferLevel * 1000);\n    var activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n\n    if (!manifestModel.getValue().doNotUpdateDVRWindowOnBufferUpdated && streamInfo.id === activeStreamId) {\n      addDVRMetric();\n    }\n  }\n\n  function onBufferLevelStateChanged(e) {\n    dashMetrics.addBufferState(type, e.state, scheduleController.getBufferTarget());\n\n    if (e.state === _MetricsConstants2.default.BUFFER_EMPTY && !playbackController.isSeeking()) {\n      // logger.info('Buffer is empty! Stalling!');\n      dashMetrics.pushPlayListTraceMetrics(new Date(), _PlayList.PlayListTrace.REBUFFERING_REASON);\n    }\n  }\n\n  function onBufferCleared(e) {\n    // Remove executed requests not buffered anymore\n    fragmentModel.syncExecutedRequestsWithBufferedRange(bufferController.getBuffer().getAllBufferRanges(), streamInfo.duration); // If buffer removed ahead current time (QuotaExceededError or automatic buffer pruning) then adjust current index handler time\n\n    if (e.from > playbackController.getTime()) {\n      bufferingTime = e.from;\n      bufferPruned = true;\n    }\n  }\n\n  function onQuotaExceeded(e) {\n    bufferingTime = e.quotaExceededTime;\n    bufferPruned = true;\n  }\n\n  function addDVRMetric() {\n    var manifestInfo = streamInfo.manifestInfo;\n    var isDynamic = manifestInfo.isDynamic;\n    var range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\n    dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\n  }\n\n  function getRepresentationController() {\n    return representationController;\n  }\n\n  function getBuffer() {\n    return bufferController ? bufferController.getBuffer() : null;\n  }\n\n  function setBuffer(buffer) {\n    bufferController.setBuffer(buffer);\n  }\n\n  function getBufferController() {\n    return bufferController;\n  }\n\n  function getFragmentModel() {\n    return fragmentModel;\n  }\n\n  function updateStreamInfo(newStreamInfo) {\n    streamInfo = newStreamInfo;\n\n    if (settings.get().streaming.useAppendWindow) {\n      bufferController.updateAppendWindow();\n    }\n  }\n\n  function getStreamInfo() {\n    return streamInfo;\n  }\n\n  function selectMediaInfo(newMediaInfo) {\n    if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || newMediaInfo.type === mediaInfo.type)) {\n      mediaInfo = newMediaInfo;\n    }\n\n    var newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\n    var voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n    if (representationController) {\n      var realAdaptation = representationController.getData();\n      var maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id);\n      var minIdx = abrController.getMinAllowedIndexFor(type);\n      var quality = void 0,\n          averageThroughput = void 0;\n      var bitrate = null;\n\n      if ((realAdaptation === null || realAdaptation.id != newRealAdaptation.id) && type !== _Constants2.default.FRAGMENTED_TEXT) {\n        averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\n        bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\n        quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\n      } else {\n        quality = abrController.getQualityFor(type);\n      }\n\n      if (minIdx !== undefined && quality < minIdx) {\n        quality = minIdx;\n      }\n\n      if (quality > maxQuality) {\n        quality = maxQuality;\n      }\n\n      indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\n      representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\n    }\n  }\n\n  function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\n    if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\n      mediaInfoArr.push(newMediaInfo);\n    }\n\n    if (selectNewMediaInfo) {\n      this.selectMediaInfo(newMediaInfo);\n    }\n  }\n\n  function getMediaInfoArr() {\n    return mediaInfoArr;\n  }\n\n  function getMediaInfo() {\n    return mediaInfo;\n  }\n\n  function getMediaSource() {\n    return bufferController.getMediaSource();\n  }\n\n  function setMediaSource(mediaSource) {\n    bufferController.setMediaSource(mediaSource, getMediaInfoArr());\n  }\n\n  function dischargePreBuffer() {\n    bufferController.dischargePreBuffer();\n  }\n\n  function getScheduleController() {\n    return scheduleController;\n  }\n  /**\n  * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\n  * Otherwise, this function will return the current voRepresentation used by the representationController.\n  * @param {number} quality - quality index of the voRepresentaion expected.\n  */\n\n\n  function getRepresentationInfo(quality) {\n    var voRepresentation = void 0;\n\n    if (quality !== undefined) {\n      (0, _SupervisorTools.checkInteger)(quality);\n      voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n    } else {\n      voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\n    }\n\n    return adapter.convertDataToRepresentationInfo(voRepresentation);\n  }\n\n  function isBufferingCompleted() {\n    return bufferController ? bufferController.getIsBufferingCompleted() : false;\n  }\n\n  function getBufferLevel() {\n    return bufferController ? bufferController.getBufferLevel() : 0;\n  }\n\n  function onInitFragmentNeeded(e) {\n    // Event propagation may have been stopped (see MssHandler)\n    if (!e.sender) return;\n    if (adapter.getIsTextTrack(mimeType) && !textController.isTextEnabled()) return;\n\n    if (bufferController && e.representationId) {\n      if (!bufferController.appendInitSegment(e.representationId)) {\n        // Init segment not in cache, send new request\n        var request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()) : null;\n        scheduleController.processInitRequest(request);\n      }\n    }\n  }\n\n  function onMediaFragmentNeeded(e) {\n    var request = void 0; // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n\n    if (!bufferController.getIsPruningInProgress()) {\n      request = findNextRequest(e.seekTarget, e.replacement);\n\n      if (request) {\n        scheduleController.setSeekTarget(NaN);\n\n        if (!e.replacement) {\n          if (!isNaN(request.startTime + request.duration)) {\n            bufferingTime = request.startTime + request.duration;\n          }\n\n          request.delayLoadingTime = new Date().getTime() + scheduleController.getTimeToLoadDelay();\n          scheduleController.setTimeToLoadDelay(0);\n        }\n      }\n    }\n\n    scheduleController.processMediaRequest(request);\n  }\n  /**\n  * Probe the next request. This is used in the CMCD model to get information about the upcoming request. Note: No actual request is performed here.\n  * @return {FragmentRequest|null}\n  */\n\n\n  function probeNextRequest() {\n    var representationInfo = getRepresentationInfo();\n    var representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\n    var request = indexHandler.getNextSegmentRequestIdempotent(getMediaInfo(), representation);\n    return request;\n  }\n\n  function findNextRequest(seekTarget, requestToReplace) {\n    var representationInfo = getRepresentationInfo();\n    var hasSeekTarget = !isNaN(seekTarget);\n    var currentTime = playbackController.getNormalizedTime();\n    var time = hasSeekTarget ? seekTarget : bufferingTime;\n    var bufferIsDivided = false;\n    var request = void 0;\n\n    if (isNaN(time) || getType() === _Constants2.default.FRAGMENTED_TEXT && !textController.isTextEnabled()) {\n      return null;\n    }\n    /**\n    * This is critical for IE/Safari/EDGE\n    * */\n\n\n    if (bufferController) {\n      var range = bufferController.getRangeAt(time);\n      var playingRange = bufferController.getRangeAt(currentTime);\n\n      if ((range !== null || playingRange !== null) && !hasSeekTarget) {\n        if (!range || playingRange && playingRange.start != range.start && playingRange.end != range.end) {\n          var hasDiscontinuities = bufferController.getBuffer().hasDiscontinuitiesAfter(currentTime);\n\n          if (hasDiscontinuities && getType() !== _Constants2.default.FRAGMENTED_TEXT) {\n            fragmentModel.removeExecutedRequestsAfterTime(playingRange.end);\n            bufferIsDivided = true;\n          }\n        }\n      }\n    }\n\n    if (requestToReplace) {\n      time = requestToReplace.startTime + requestToReplace.duration / 2;\n      request = getFragmentRequest(representationInfo, time, {\n        timeThreshold: 0,\n        ignoreIsFinished: true\n      });\n    } else {\n      // Use time just whenever is strictly needed\n      var useTime = hasSeekTarget || bufferPruned || bufferIsDivided;\n      request = getFragmentRequest(representationInfo, useTime ? time : undefined, {\n        keepIdx: !useTime\n      });\n      bufferPruned = false; // Then, check if this request was downloaded or not\n\n      while (request && request.action !== _FragmentRequest2.default.ACTION_COMPLETE && fragmentModel.isFragmentLoaded(request)) {\n        // loop until we found not loaded fragment, or no fragment\n        request = getFragmentRequest(representationInfo);\n      }\n    }\n\n    return request;\n  }\n\n  function onMediaFragmentLoaded(e) {\n    var chunk = e.chunk;\n    var bytes = chunk.bytes;\n    var quality = chunk.quality;\n    var currentRepresentation = getRepresentationInfo(quality);\n    var voRepresentation = representationController && currentRepresentation ? representationController.getRepresentationForQuality(currentRepresentation.quality) : null;\n    var eventStreamMedia = adapter.getEventsFor(currentRepresentation.mediaInfo);\n    var eventStreamTrack = adapter.getEventsFor(currentRepresentation, voRepresentation);\n\n    if (eventStreamMedia && eventStreamMedia.length > 0 || eventStreamTrack && eventStreamTrack.length > 0) {\n      var request = fragmentModel.getRequests({\n        state: _FragmentModel2.default.FRAGMENT_MODEL_EXECUTED,\n        quality: quality,\n        index: chunk.index\n      })[0];\n      var events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack);\n      eventBus.trigger(_Events2.default.INBAND_EVENTS, {\n        events: events\n      }, {\n        streamId: streamInfo.id\n      });\n    }\n  }\n\n  function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) {\n    try {\n      var eventStreams = {};\n      var events = [];\n      /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\n\n      var inbandEvents = mediaInbandEvents.concat(trackInbandEvents);\n\n      for (var i = 0, ln = inbandEvents.length; i < ln; i++) {\n        eventStreams[inbandEvents[i].schemeIdUri + '/' + inbandEvents[i].value] = inbandEvents[i];\n      }\n\n      var isoFile = (0, _BoxParser2.default)(context).getInstance().parse(data);\n      var eventBoxes = isoFile.getBoxes('emsg');\n\n      if (!eventBoxes || eventBoxes.length === 0) {\n        return events;\n      }\n\n      var sidx = isoFile.getBox('sidx');\n      var mediaAnchorTime = sidx && !isNaN(sidx.earliest_presentation_time) && !isNaN(sidx.timescale) ? sidx.earliest_presentation_time / sidx.timescale : request && !isNaN(request.mediaStartTime) ? request.mediaStartTime : 0;\n      var fragmentMediaStartTime = Math.max(mediaAnchorTime, 0);\n      var voRepresentation = representationController.getCurrentRepresentation();\n\n      for (var _i = 0, _ln = eventBoxes.length; _i < _ln; _i++) {\n        var event = adapter.getEvent(eventBoxes[_i], eventStreams, fragmentMediaStartTime, voRepresentation);\n\n        if (event) {\n          events.push(event);\n        }\n      }\n\n      return events;\n    } catch (e) {\n      return [];\n    }\n  }\n\n  function createBuffer(previousBuffers) {\n    return getBuffer() || bufferController ? bufferController.createBuffer(mediaInfoArr, previousBuffers) : null;\n  }\n\n  function switchTrackAsked() {\n    scheduleController.switchTrackAsked();\n  }\n\n  function createBufferControllerForType(type) {\n    var controller = null;\n\n    if (!type) {\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, _Errors2.default.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined'));\n      return null;\n    }\n\n    if (type === _Constants2.default.VIDEO || type === _Constants2.default.AUDIO) {\n      controller = (0, _BufferController2.default)(context).create({\n        streamInfo: streamInfo,\n        type: type,\n        mediaPlayerModel: mediaPlayerModel,\n        manifestModel: manifestModel,\n        fragmentModel: fragmentModel,\n        errHandler: errHandler,\n        mediaController: mediaController,\n        representationController: representationController,\n        adapter: adapter,\n        textController: textController,\n        abrController: abrController,\n        playbackController: playbackController,\n        settings: settings\n      });\n    } else {\n      controller = (0, _TextBufferController2.default)(context).create({\n        streamInfo: streamInfo,\n        type: type,\n        mimeType: mimeType,\n        mediaPlayerModel: mediaPlayerModel,\n        manifestModel: manifestModel,\n        fragmentModel: fragmentModel,\n        errHandler: errHandler,\n        mediaController: mediaController,\n        representationController: representationController,\n        adapter: adapter,\n        textController: textController,\n        abrController: abrController,\n        playbackController: playbackController,\n        settings: settings\n      });\n    }\n\n    return controller;\n  }\n\n  function getLiveStartTime() {\n    if (!isDynamic) return NaN;\n    if (!liveEdgeFinder) return NaN;\n    var liveStartTime = NaN;\n    var currentRepresentationInfo = getRepresentationInfo();\n    var liveEdge = liveEdgeFinder.getLiveEdge(currentRepresentationInfo);\n\n    if (isNaN(liveEdge)) {\n      return NaN;\n    }\n\n    var request = findRequestForLiveEdge(liveEdge, currentRepresentationInfo);\n\n    if (request) {\n      // When low latency mode is selected but browser doesn't support fetch\n      // start at the beginning of the segment to avoid consuming the whole buffer\n      if (settings.get().streaming.lowLatencyEnabled) {\n        liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n      } else {\n        liveStartTime = request.startTime;\n      }\n    }\n\n    return liveStartTime;\n  }\n\n  function findRequestForLiveEdge(liveEdge, currentRepresentationInfo) {\n    try {\n      var request = null;\n      var liveDelay = playbackController.getLiveDelay();\n      var dvrWindowSize = !isNaN(streamInfo.manifestInfo.DVRWindowSize) ? streamInfo.manifestInfo.DVRWindowSize : liveDelay;\n      var dvrWindowSafetyMargin = 0.1 * dvrWindowSize;\n      var startTime = void 0; // Make sure that we have at least a valid request for the end of the DVR window, otherwise we might try forever\n\n      if (!isFinite(dvrWindowSize) || getFragmentRequest(currentRepresentationInfo, liveEdge - dvrWindowSize + dvrWindowSafetyMargin, {\n        ignoreIsFinished: true\n      })) {\n        // Try to find a request as close as possible to the targeted live edge\n        while (!request && liveDelay <= dvrWindowSize) {\n          startTime = liveEdge - liveDelay;\n          request = getFragmentRequest(currentRepresentationInfo, startTime, {\n            ignoreIsFinished: true\n          });\n\n          if (!request) {\n            liveDelay += 1; // Increase by one second for each iteration\n          }\n        }\n      }\n\n      if (request) {\n        playbackController.setLiveDelay(liveDelay, true);\n      }\n\n      logger.debug('live edge: ' + liveEdge + ', live delay: ' + liveDelay + ', live target: ' + startTime);\n      return request;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function onSeekTarget(e) {\n    bufferingTime = e.time;\n    scheduleController.setSeekTarget(e.time);\n  }\n\n  function setBufferingTime(value) {\n    bufferingTime = value;\n  }\n\n  function resetIndexHandler() {\n    if (indexHandler) {\n      indexHandler.resetIndex();\n    }\n  }\n\n  function getInitRequest(quality) {\n    (0, _SupervisorTools.checkInteger)(quality);\n    var representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n    return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n  }\n\n  function getFragmentRequest(representationInfo, time, options) {\n    var fragRequest = null;\n\n    if (indexHandler) {\n      var representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null; // if time and options are undefined, it means the next segment is requested\n      // otherwise, the segment at this specific time is requested.\n\n      if (time !== undefined && options !== undefined) {\n        fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\n      } else {\n        fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\n      }\n    }\n\n    return fragRequest;\n  }\n\n  function finalisePlayList(time, reason) {\n    dashMetrics.pushPlayListTraceMetrics(time, reason);\n  }\n\n  instance = {\n    initialize: initialize,\n    getStreamId: getStreamId,\n    getType: getType,\n    isUpdating: isUpdating,\n    getBufferController: getBufferController,\n    getFragmentModel: getFragmentModel,\n    getScheduleController: getScheduleController,\n    getRepresentationController: getRepresentationController,\n    getRepresentationInfo: getRepresentationInfo,\n    getBufferLevel: getBufferLevel,\n    isBufferingCompleted: isBufferingCompleted,\n    createBuffer: createBuffer,\n    updateStreamInfo: updateStreamInfo,\n    getStreamInfo: getStreamInfo,\n    selectMediaInfo: selectMediaInfo,\n    addMediaInfo: addMediaInfo,\n    getLiveStartTime: getLiveStartTime,\n    switchTrackAsked: switchTrackAsked,\n    getMediaInfoArr: getMediaInfoArr,\n    getMediaInfo: getMediaInfo,\n    getMediaSource: getMediaSource,\n    setMediaSource: setMediaSource,\n    dischargePreBuffer: dischargePreBuffer,\n    getBuffer: getBuffer,\n    setBuffer: setBuffer,\n    setBufferingTime: setBufferingTime,\n    resetIndexHandler: resetIndexHandler,\n    getInitRequest: getInitRequest,\n    getFragmentRequest: getFragmentRequest,\n    finalisePlayList: finalisePlayList,\n    probeNextRequest: probeNextRequest,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\nexports.default = _FactoryMaker2.default.getClassFactory(StreamProcessor);","map":{"version":3,"sources":["../../../../src/streaming/StreamProcessor.js"],"names":["config","context","eventBus","streamInfo","type","errHandler","mimeType","timelineConverter","adapter","manifestModel","mediaPlayerModel","fragmentModel","abrController","playbackController","mediaController","textController","dashMetrics","settings","boxParser","instance","logger","isDynamic","mediaInfo","mediaInfoArr","bufferController","scheduleController","representationController","liveEdgeFinder","indexHandler","bufferingTime","bufferPruned","resetInitialSettings","Events","priority","EventBus","baseURLController","events","errors","Errors","debug","requestModifier","dashConstants","DashConstants","constants","Constants","urlUtils","createBufferControllerForType","e","activeStreamId","addDVRMetric","representationInfo","getRepresentationInfo","PlayListTrace","MetricsConstants","manifestInfo","range","getType","newMediaInfo","newRealAdaptation","voRepresentations","realAdaptation","maxQuality","minIdx","quality","averageThroughput","bitrate","getMediaInfoArr","voRepresentation","request","getMediaInfo","findNextRequest","isNaN","representation","hasSeekTarget","currentTime","time","bufferIsDivided","playingRange","hasDiscontinuities","requestToReplace","getFragmentRequest","timeThreshold","ignoreIsFinished","useTime","keepIdx","FragmentRequest","chunk","bytes","currentRepresentation","eventStreamMedia","eventStreamTrack","state","FragmentModel","index","handleInbandEvents","streamId","eventStreams","inbandEvents","mediaInbandEvents","i","ln","isoFile","eventBoxes","sidx","mediaAnchorTime","fragmentMediaStartTime","Math","event","getBuffer","controller","DashJSError","liveStartTime","currentRepresentationInfo","liveEdge","findRequestForLiveEdge","liveDelay","dvrWindowSize","dvrWindowSafetyMargin","startTime","isFinite","fragRequest","options","initialize","getStreamId","isUpdating","getBufferController","getFragmentModel","getScheduleController","getRepresentationController","getBufferLevel","isBufferingCompleted","createBuffer","updateStreamInfo","getStreamInfo","selectMediaInfo","addMediaInfo","getLiveStartTime","switchTrackAsked","getMediaSource","setMediaSource","dischargePreBuffer","setBuffer","setBufferingTime","resetIndexHandler","getInitRequest","finalisePlayList","probeNextRequest","reset","setup","StreamProcessor","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport MetricsConstants from './constants/MetricsConstants';\nimport FragmentModel from './models/FragmentModel';\nimport BufferController from './controllers/BufferController';\nimport TextBufferController from './text/TextBufferController';\nimport ScheduleController from './controllers/ScheduleController';\nimport RepresentationController from '../dash/controllers/RepresentationController';\nimport LiveEdgeFinder from './utils/LiveEdgeFinder';\nimport FactoryMaker from '../core/FactoryMaker';\nimport {checkInteger} from './utils/SupervisorTools';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport DashHandler from '../dash/DashHandler';\nimport Errors from '../core/errors/Errors';\nimport DashJSError from './vo/DashJSError';\nimport Debug from '../core/Debug';\nimport RequestModifier from './utils/RequestModifier';\nimport URLUtils from '../streaming/utils/URLUtils';\nimport BoxParser from './utils/BoxParser';\nimport FragmentRequest from './vo/FragmentRequest';\nimport {PlayListTrace} from './vo/metrics/PlayList';\n\nfunction StreamProcessor(config) {\n\n    config = config || {};\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let streamInfo = config.streamInfo;\n    let type = config.type;\n    let errHandler = config.errHandler;\n    let mimeType = config.mimeType;\n    let timelineConverter = config.timelineConverter;\n    let adapter = config.adapter;\n    let manifestModel = config.manifestModel;\n    let mediaPlayerModel = config.mediaPlayerModel;\n    let fragmentModel = config.fragmentModel;\n    let abrController = config.abrController;\n    let playbackController = config.playbackController;\n    let mediaController = config.mediaController;\n    let textController = config.textController;\n    let dashMetrics = config.dashMetrics;\n    let settings = config.settings;\n    let boxParser = config.boxParser;\n\n    let instance,\n        logger,\n        isDynamic,\n        mediaInfo,\n        mediaInfoArr,\n        bufferController,\n        scheduleController,\n        representationController,\n        liveEdgeFinder,\n        indexHandler,\n        bufferingTime,\n        bufferPruned;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance, { priority: EventBus.EVENT_PRIORITY_HIGH }); // High priority to be notified before Stream\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.on(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, instance);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, instance);\n        eventBus.on(Events.SEEK_TARGET, onSeekTarget, instance);\n    }\n\n    function initialize(mediaSource, hasVideoTrack) {\n        indexHandler = DashHandler(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            timelineConverter: timelineConverter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            baseURLController: config.baseURLController,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors,\n            debug: Debug(context).getInstance(),\n            requestModifier: RequestModifier(context).getInstance(),\n            dashConstants: DashConstants,\n            constants: Constants,\n            urlUtils: URLUtils(context).getInstance()\n        });\n\n        // Create live edge finder for dynamic streams\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        if (isDynamic) {\n            liveEdgeFinder = LiveEdgeFinder(context).create({\n                timelineConverter: timelineConverter\n            });\n        }\n\n        // Create/initialize controllers\n        indexHandler.initialize(isDynamic);\n        abrController.registerStreamType(type, instance);\n\n        representationController = RepresentationController(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            playbackController: playbackController,\n            timelineConverter: timelineConverter,\n            dashConstants: DashConstants,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors\n        });\n\n        bufferController = createBufferControllerForType(type);\n        if (bufferController) {\n            bufferController.initialize(mediaSource);\n        }\n\n        scheduleController = ScheduleController(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            mimeType: mimeType,\n            adapter: adapter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            fragmentModel: fragmentModel,\n            abrController: abrController,\n            playbackController: playbackController,\n            textController: textController,\n            mediaController: mediaController,\n            bufferController: bufferController,\n            settings: settings\n        });\n\n        scheduleController.initialize(hasVideoTrack);\n\n        bufferingTime = 0;\n        bufferPruned = false;\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function resetInitialSettings() {\n        mediaInfoArr = [];\n        mediaInfo = null;\n        bufferingTime = 0;\n    }\n\n    function reset(errored, keepBuffers) {\n        if (indexHandler) {\n            indexHandler.reset();\n        }\n\n        if (bufferController) {\n            bufferController.reset(errored, keepBuffers);\n            bufferController = null;\n        }\n\n        if (scheduleController) {\n            scheduleController.reset();\n            scheduleController = null;\n        }\n\n        if (representationController) {\n            representationController.reset();\n            representationController = null;\n        }\n\n        if (liveEdgeFinder) {\n            liveEdgeFinder.reset();\n            liveEdgeFinder = null;\n        }\n\n        if (abrController && !keepBuffers) {\n            abrController.unRegisterStreamType(type);\n        }\n\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.off(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, instance);\n        eventBus.off(Events.SEEK_TARGET, onSeekTarget, instance);\n\n        resetInitialSettings();\n        type = null;\n        streamInfo = null;\n    }\n\n    function isUpdating() {\n        return representationController ? representationController.isUpdating() : false;\n    }\n\n\n    function onDataUpdateCompleted(e) {\n        if (!e.error) {\n            // Update representation if no error\n            scheduleController.setCurrentRepresentation(adapter.convertDataToRepresentationInfo(e.currentRepresentation));\n        }\n        if (!e.error || e.error.code === Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE) {\n            // Update has been postponed, update nevertheless DVR info\n            const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n            if (activeStreamId === streamInfo.id) {\n                addDVRMetric();\n            }\n        }\n    }\n\n    function onQualityChanged(e) {\n        let representationInfo = getRepresentationInfo(e.newQuality);\n        scheduleController.setCurrentRepresentation(representationInfo);\n        dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n        dashMetrics.createPlaylistTraceMetrics(representationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n    }\n\n    function onBufferLevelUpdated(e) {\n        dashMetrics.addBufferLevel(type, new Date(), e.bufferLevel * 1000);\n        const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\n        if (!manifestModel.getValue().doNotUpdateDVRWindowOnBufferUpdated && streamInfo.id === activeStreamId) {\n            addDVRMetric();\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        dashMetrics.addBufferState(type, e.state, scheduleController.getBufferTarget());\n        if (e.state === MetricsConstants.BUFFER_EMPTY && !playbackController.isSeeking()) {\n            // logger.info('Buffer is empty! Stalling!');\n            dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\n        }\n    }\n\n    function onBufferCleared(e) {\n        // Remove executed requests not buffered anymore\n        fragmentModel.syncExecutedRequestsWithBufferedRange(\n            bufferController.getBuffer().getAllBufferRanges(),\n            streamInfo.duration);\n\n        // If buffer removed ahead current time (QuotaExceededError or automatic buffer pruning) then adjust current index handler time\n        if (e.from > playbackController.getTime()) {\n            bufferingTime = e.from;\n            bufferPruned = true;\n        }\n    }\n\n    function onQuotaExceeded(e) {\n        bufferingTime = e.quotaExceededTime;\n        bufferPruned = true;\n    }\n\n    function addDVRMetric() {\n        const manifestInfo = streamInfo.manifestInfo;\n        const isDynamic = manifestInfo.isDynamic;\n        const range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\n        dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\n    }\n\n    function getRepresentationController() {\n        return representationController;\n    }\n\n    function getBuffer() {\n        return bufferController ? bufferController.getBuffer() : null;\n    }\n\n    function setBuffer(buffer) {\n        bufferController.setBuffer(buffer);\n    }\n\n    function getBufferController() {\n        return bufferController;\n    }\n\n    function getFragmentModel() {\n        return fragmentModel;\n    }\n\n    function updateStreamInfo(newStreamInfo) {\n        streamInfo = newStreamInfo;\n        if (settings.get().streaming.useAppendWindow) {\n            bufferController.updateAppendWindow();\n        }\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function selectMediaInfo(newMediaInfo) {\n        if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || (newMediaInfo.type === mediaInfo.type))) {\n            mediaInfo = newMediaInfo;\n        }\n\n        const newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\n        const voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n        if (representationController) {\n            const realAdaptation = representationController.getData();\n            const maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id);\n            const minIdx = abrController.getMinAllowedIndexFor(type);\n\n            let quality,\n                averageThroughput;\n            let bitrate = null;\n\n            if ((realAdaptation === null || (realAdaptation.id != newRealAdaptation.id)) && type !== Constants.FRAGMENTED_TEXT) {\n                averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\n                bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\n                quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\n            } else {\n                quality = abrController.getQualityFor(type);\n            }\n\n            if (minIdx !== undefined && quality < minIdx) {\n                quality = minIdx;\n            }\n            if (quality > maxQuality) {\n                quality = maxQuality;\n            }\n            indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\n            representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\n        }\n    }\n\n    function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\n        if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\n            mediaInfoArr.push(newMediaInfo);\n        }\n\n        if (selectNewMediaInfo) {\n            this.selectMediaInfo(newMediaInfo);\n        }\n    }\n\n    function getMediaInfoArr() {\n        return mediaInfoArr;\n    }\n\n    function getMediaInfo() {\n        return mediaInfo;\n    }\n\n    function getMediaSource() {\n        return bufferController.getMediaSource();\n    }\n\n    function setMediaSource(mediaSource) {\n        bufferController.setMediaSource(mediaSource, getMediaInfoArr());\n    }\n\n    function dischargePreBuffer() {\n        bufferController.dischargePreBuffer();\n    }\n\n    function getScheduleController() {\n        return scheduleController;\n    }\n\n    /**\n     * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\n     * Otherwise, this function will return the current voRepresentation used by the representationController.\n     * @param {number} quality - quality index of the voRepresentaion expected.\n     */\n    function getRepresentationInfo(quality) {\n        let voRepresentation;\n\n        if (quality !== undefined) {\n            checkInteger(quality);\n            voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        } else {\n            voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\n        }\n\n        return adapter.convertDataToRepresentationInfo(voRepresentation);\n    }\n\n    function isBufferingCompleted() {\n        return bufferController ? bufferController.getIsBufferingCompleted() : false;\n    }\n\n    function getBufferLevel() {\n        return bufferController ? bufferController.getBufferLevel() : 0;\n    }\n\n    function onInitFragmentNeeded(e) {\n        // Event propagation may have been stopped (see MssHandler)\n        if (!e.sender) return;\n\n        if (adapter.getIsTextTrack(mimeType) && !textController.isTextEnabled()) return;\n\n        if (bufferController && e.representationId) {\n            if (!bufferController.appendInitSegment(e.representationId)) {\n                // Init segment not in cache, send new request\n                const request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()) : null;\n                scheduleController.processInitRequest(request);\n            }\n        }\n    }\n\n    function onMediaFragmentNeeded(e) {\n        let request;\n\n        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n        if (!bufferController.getIsPruningInProgress()) {\n            request = findNextRequest(e.seekTarget, e.replacement);\n            if (request) {\n                scheduleController.setSeekTarget(NaN);\n                if (!e.replacement) {\n                    if (!isNaN(request.startTime + request.duration)) {\n                        bufferingTime = request.startTime + request.duration;\n                    }\n                    request.delayLoadingTime = new Date().getTime() + scheduleController.getTimeToLoadDelay();\n                    scheduleController.setTimeToLoadDelay(0);\n                }\n            }\n        }\n\n        scheduleController.processMediaRequest(request);\n    }\n\n    /**\n     * Probe the next request. This is used in the CMCD model to get information about the upcoming request. Note: No actual request is performed here.\n     * @return {FragmentRequest|null}\n     */\n    function probeNextRequest() {\n        const representationInfo = getRepresentationInfo();\n\n        const representation = representationController && representationInfo ?\n            representationController.getRepresentationForQuality(representationInfo.quality) : null;\n\n        let request = indexHandler.getNextSegmentRequestIdempotent(\n            getMediaInfo(),\n            representation\n        );\n\n        return request;\n    }\n\n    function findNextRequest(seekTarget, requestToReplace) {\n        const representationInfo = getRepresentationInfo();\n        const hasSeekTarget = !isNaN(seekTarget);\n        const currentTime = playbackController.getNormalizedTime();\n        let time = hasSeekTarget ? seekTarget : bufferingTime;\n        let bufferIsDivided = false;\n        let request;\n\n        if (isNaN(time) || (getType() === Constants.FRAGMENTED_TEXT && !textController.isTextEnabled())) {\n            return null;\n        }\n        /**\n         * This is critical for IE/Safari/EDGE\n         * */\n        if (bufferController) {\n            let range = bufferController.getRangeAt(time);\n            const playingRange = bufferController.getRangeAt(currentTime);\n            if ((range !== null || playingRange !== null) && !hasSeekTarget) {\n                if (!range || (playingRange && playingRange.start != range.start && playingRange.end != range.end)) {\n                    const hasDiscontinuities = bufferController.getBuffer().hasDiscontinuitiesAfter(currentTime);\n                    if (hasDiscontinuities && getType() !== Constants.FRAGMENTED_TEXT) {\n                        fragmentModel.removeExecutedRequestsAfterTime(playingRange.end);\n                        bufferIsDivided = true;\n                    }\n                }\n            }\n        }\n\n        if (requestToReplace) {\n            time = requestToReplace.startTime + (requestToReplace.duration / 2);\n            request = getFragmentRequest(representationInfo, time, {\n                timeThreshold: 0,\n                ignoreIsFinished: true\n            });\n        } else {\n            // Use time just whenever is strictly needed\n            const useTime = hasSeekTarget || bufferPruned || bufferIsDivided;\n            request = getFragmentRequest(representationInfo,\n                useTime ? time : undefined, {\n                    keepIdx: !useTime\n                });\n            bufferPruned = false;\n\n            // Then, check if this request was downloaded or not\n            while (request && request.action !== FragmentRequest.ACTION_COMPLETE && fragmentModel.isFragmentLoaded(request)) {\n                // loop until we found not loaded fragment, or no fragment\n                request = getFragmentRequest(representationInfo);\n            }\n        }\n\n        return request;\n    }\n\n    function onMediaFragmentLoaded(e) {\n        const chunk = e.chunk;\n\n        const bytes = chunk.bytes;\n        const quality = chunk.quality;\n        const currentRepresentation = getRepresentationInfo(quality);\n\n        const voRepresentation = representationController && currentRepresentation ? representationController.getRepresentationForQuality(currentRepresentation.quality) : null;\n        const eventStreamMedia = adapter.getEventsFor(currentRepresentation.mediaInfo);\n        const eventStreamTrack = adapter.getEventsFor(currentRepresentation, voRepresentation);\n\n        if (eventStreamMedia && eventStreamMedia.length > 0 || eventStreamTrack && eventStreamTrack.length > 0) {\n            const request = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                quality: quality,\n                index: chunk.index\n            })[0];\n\n            const events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack);\n            eventBus.trigger(Events.INBAND_EVENTS,\n                { events: events },\n                { streamId: streamInfo.id }\n            );\n        }\n    }\n\n    function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) {\n        try {\n            const eventStreams = {};\n            const events = [];\n\n            /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\n            const inbandEvents = mediaInbandEvents.concat(trackInbandEvents);\n            for (let i = 0, ln = inbandEvents.length; i < ln; i++) {\n                eventStreams[inbandEvents[i].schemeIdUri + '/' + inbandEvents[i].value] = inbandEvents[i];\n            }\n\n            const isoFile = BoxParser(context).getInstance().parse(data);\n            const eventBoxes = isoFile.getBoxes('emsg');\n\n            if (!eventBoxes || eventBoxes.length === 0) {\n                return events;\n            }\n\n            const sidx = isoFile.getBox('sidx');\n            const mediaAnchorTime = sidx && !isNaN(sidx.earliest_presentation_time) && !isNaN(sidx.timescale) ? sidx.earliest_presentation_time / sidx.timescale : request && !isNaN(request.mediaStartTime) ? request.mediaStartTime : 0;\n            const fragmentMediaStartTime = Math.max(mediaAnchorTime, 0);\n            const voRepresentation = representationController.getCurrentRepresentation();\n\n            for (let i = 0, ln = eventBoxes.length; i < ln; i++) {\n                const event = adapter.getEvent(eventBoxes[i], eventStreams, fragmentMediaStartTime, voRepresentation);\n\n                if (event) {\n                    events.push(event);\n                }\n            }\n\n            return events;\n        } catch (e) {\n            return [];\n        }\n    }\n\n    function createBuffer(previousBuffers) {\n        return (getBuffer() || bufferController ? bufferController.createBuffer(mediaInfoArr, previousBuffers) : null);\n    }\n\n    function switchTrackAsked() {\n        scheduleController.switchTrackAsked();\n    }\n\n    function createBufferControllerForType(type) {\n        let controller = null;\n\n        if (!type) {\n            errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined'));\n            return null;\n        }\n\n        if (type === Constants.VIDEO || type === Constants.AUDIO) {\n            controller = BufferController(context).create({\n                streamInfo: streamInfo,\n                type: type,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                mediaController: mediaController,\n                representationController: representationController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                settings: settings\n            });\n        } else {\n            controller = TextBufferController(context).create({\n                streamInfo: streamInfo,\n                type: type,\n                mimeType: mimeType,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                mediaController: mediaController,\n                representationController: representationController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                settings: settings\n            });\n        }\n\n        return controller;\n    }\n\n\n    function getLiveStartTime() {\n        if (!isDynamic) return NaN;\n        if (!liveEdgeFinder) return NaN;\n\n        let liveStartTime = NaN;\n        const currentRepresentationInfo = getRepresentationInfo();\n        const liveEdge = liveEdgeFinder.getLiveEdge(currentRepresentationInfo);\n\n        if (isNaN(liveEdge)) {\n            return NaN;\n        }\n\n        const request = findRequestForLiveEdge(liveEdge, currentRepresentationInfo);\n\n        if (request) {\n            // When low latency mode is selected but browser doesn't support fetch\n            // start at the beginning of the segment to avoid consuming the whole buffer\n            if (settings.get().streaming.lowLatencyEnabled) {\n                liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n            } else {\n                liveStartTime = request.startTime;\n            }\n        }\n\n        return liveStartTime;\n    }\n\n    function findRequestForLiveEdge(liveEdge, currentRepresentationInfo) {\n        try {\n            let request = null;\n            let liveDelay = playbackController.getLiveDelay();\n            const dvrWindowSize = !isNaN(streamInfo.manifestInfo.DVRWindowSize) ? streamInfo.manifestInfo.DVRWindowSize : liveDelay;\n            const dvrWindowSafetyMargin = 0.1 * dvrWindowSize;\n            let startTime;\n\n            // Make sure that we have at least a valid request for the end of the DVR window, otherwise we might try forever\n            if (!isFinite(dvrWindowSize) || getFragmentRequest(currentRepresentationInfo, liveEdge - dvrWindowSize + dvrWindowSafetyMargin, {\n                ignoreIsFinished: true\n            })) {\n\n                // Try to find a request as close as possible to the targeted live edge\n                while (!request && liveDelay <= dvrWindowSize) {\n                    startTime = liveEdge - liveDelay;\n                    request = getFragmentRequest(currentRepresentationInfo, startTime, {\n                        ignoreIsFinished: true\n                    });\n                    if (!request) {\n                        liveDelay += 1; // Increase by one second for each iteration\n                    }\n                }\n            }\n\n            if (request) {\n                playbackController.setLiveDelay(liveDelay, true);\n            }\n            logger.debug('live edge: ' + liveEdge + ', live delay: ' + liveDelay + ', live target: ' + startTime);\n            return request;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function onSeekTarget(e) {\n        bufferingTime = e.time;\n        scheduleController.setSeekTarget(e.time);\n    }\n\n    function setBufferingTime(value) {\n        bufferingTime = value;\n    }\n\n    function resetIndexHandler() {\n        if (indexHandler) {\n            indexHandler.resetIndex();\n        }\n    }\n\n    function getInitRequest(quality) {\n        checkInteger(quality);\n        const representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n    }\n\n    function getFragmentRequest(representationInfo, time, options) {\n        let fragRequest = null;\n\n        if (indexHandler) {\n            const representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\n\n            // if time and options are undefined, it means the next segment is requested\n            // otherwise, the segment at this specific time is requested.\n            if (time !== undefined && options !== undefined) {\n                fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\n            } else {\n                fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\n            }\n        }\n\n        return fragRequest;\n    }\n\n    function finalisePlayList(time, reason) {\n        dashMetrics.pushPlayListTraceMetrics(time, reason);\n    }\n\n    instance = {\n        initialize: initialize,\n        getStreamId: getStreamId,\n        getType: getType,\n        isUpdating: isUpdating,\n        getBufferController: getBufferController,\n        getFragmentModel: getFragmentModel,\n        getScheduleController: getScheduleController,\n        getRepresentationController: getRepresentationController,\n        getRepresentationInfo: getRepresentationInfo,\n        getBufferLevel: getBufferLevel,\n        isBufferingCompleted: isBufferingCompleted,\n        createBuffer: createBuffer,\n        updateStreamInfo: updateStreamInfo,\n        getStreamInfo: getStreamInfo,\n        selectMediaInfo: selectMediaInfo,\n        addMediaInfo: addMediaInfo,\n        getLiveStartTime: getLiveStartTime,\n        switchTrackAsked: switchTrackAsked,\n        getMediaInfoArr: getMediaInfoArr,\n        getMediaInfo: getMediaInfo,\n        getMediaSource: getMediaSource,\n        setMediaSource: setMediaSource,\n        dischargePreBuffer: dischargePreBuffer,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        setBufferingTime: setBufferingTime,\n        resetIndexHandler: resetIndexHandler,\n        getInitRequest: getInitRequest,\n        getFragmentRequest: getFragmentRequest,\n        finalisePlayList: finalisePlayList,\n        probeNextRequest: probeNextRequest,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\nexport default FactoryMaker.getClassFactory(StreamProcessor);\n"]},"metadata":{},"sourceType":"script"}