{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EventBus = require('../../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _SwitchRequest = require('../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _Constants = require('../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction InsufficientBufferRule(config) {\n  config = config || {};\n  var INSUFFICIENT_BUFFER_SAFETY_FACTOR = 0.5;\n  var SEGMENT_IGNORE_COUNT = 2;\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var dashMetrics = config.dashMetrics;\n  var instance = void 0,\n      logger = void 0,\n      bufferStateDict = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    eventBus.on(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onEndFragment, instance);\n  }\n\n  function checkConfig() {\n    if (!dashMetrics || !dashMetrics.hasOwnProperty('getCurrentBufferLevel') || !dashMetrics.hasOwnProperty('getCurrentBufferState')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n  /*\n  * InsufficientBufferRule does not kick in before the first BUFFER_LOADED event happens. This is reset at every seek.\n  *\n  * If a BUFFER_EMPTY event happens, then InsufficientBufferRule returns switchRequest.quality=0 until BUFFER_LOADED happens.\n  *\n  * Otherwise InsufficientBufferRule gives a maximum bitrate depending on throughput and bufferLevel such that\n  * a whole fragment can be downloaded before the buffer runs out, subject to a conservative safety factor of 0.5.\n  * If the bufferLevel is low, then InsufficientBufferRule avoids rebuffering risk.\n  * If the bufferLevel is high, then InsufficientBufferRule give a high MaxIndex allowing other rules to take over.\n  */\n\n\n  function getMaxIndex(rulesContext) {\n    var switchRequest = (0, _SwitchRequest2.default)(context).create();\n\n    if (!rulesContext || !rulesContext.hasOwnProperty('getMediaType')) {\n      return switchRequest;\n    }\n\n    checkConfig();\n    var mediaType = rulesContext.getMediaType();\n    var currentBufferState = dashMetrics.getCurrentBufferState(mediaType);\n    var representationInfo = rulesContext.getRepresentationInfo();\n    var fragmentDuration = representationInfo.fragmentDuration; // Don't ask for a bitrate change if there is not info about buffer state or if fragmentDuration is not defined\n\n    if (shouldIgnore(mediaType) || !fragmentDuration) {\n      return switchRequest;\n    }\n\n    if (currentBufferState && currentBufferState.state === _MetricsConstants2.default.BUFFER_EMPTY) {\n      logger.debug('[' + mediaType + '] Switch to index 0; buffer is empty.');\n      switchRequest.quality = 0;\n      switchRequest.reason = 'InsufficientBufferRule: Buffer is empty';\n    } else {\n      var mediaInfo = rulesContext.getMediaInfo();\n      var abrController = rulesContext.getAbrController();\n      var throughputHistory = abrController.getThroughputHistory();\n      var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n      var throughput = throughputHistory.getAverageThroughput(mediaType);\n      var latency = throughputHistory.getAverageLatency(mediaType);\n      var bitrate = throughput * (bufferLevel / fragmentDuration) * INSUFFICIENT_BUFFER_SAFETY_FACTOR;\n      switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, bitrate, latency);\n      switchRequest.reason = 'InsufficientBufferRule: being conservative to avoid immediate rebuffering';\n    }\n\n    return switchRequest;\n  }\n\n  function shouldIgnore(mediaType) {\n    return bufferStateDict[mediaType].ignoreCount > 0;\n  }\n\n  function resetInitialSettings() {\n    bufferStateDict = {};\n    bufferStateDict[_Constants2.default.VIDEO] = {\n      ignoreCount: SEGMENT_IGNORE_COUNT\n    };\n    bufferStateDict[_Constants2.default.AUDIO] = {\n      ignoreCount: SEGMENT_IGNORE_COUNT\n    };\n  }\n\n  function onPlaybackSeeking() {\n    resetInitialSettings();\n  }\n\n  function onEndFragment(e) {\n    if (!isNaN(e.startTime) && (e.mediaType === _Constants2.default.AUDIO || e.mediaType === _Constants2.default.VIDEO)) {\n      if (bufferStateDict[e.mediaType].ignoreCount > 0) {\n        bufferStateDict[e.mediaType].ignoreCount--;\n      }\n    }\n  }\n\n  function reset() {\n    resetInitialSettings();\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    eventBus.off(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onEndFragment, instance);\n  }\n\n  instance = {\n    getMaxIndex: getMaxIndex,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nInsufficientBufferRule.__dashjs_factory_name = 'InsufficientBufferRule';\nexports.default = _FactoryMaker2.default.getClassFactory(InsufficientBufferRule);","map":{"version":3,"sources":["../../../../../../src/streaming/rules/abr/InsufficientBufferRule.js"],"names":["config","INSUFFICIENT_BUFFER_SAFETY_FACTOR","SEGMENT_IGNORE_COUNT","context","eventBus","dashMetrics","instance","logger","bufferStateDict","resetInitialSettings","Events","Constants","switchRequest","rulesContext","checkConfig","mediaType","currentBufferState","representationInfo","fragmentDuration","shouldIgnore","MetricsConstants","mediaInfo","abrController","throughputHistory","bufferLevel","throughput","latency","bitrate","ignoreCount","isNaN","e","getMaxIndex","reset","setup","InsufficientBufferRule","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport Debug from '../../../core/Debug';\nimport SwitchRequest from '../SwitchRequest';\nimport Constants from '../../constants/Constants';\nimport MetricsConstants from '../../constants/MetricsConstants';\n\nfunction InsufficientBufferRule(config) {\n\n    config = config || {};\n    const INSUFFICIENT_BUFFER_SAFETY_FACTOR = 0.5;\n    const SEGMENT_IGNORE_COUNT = 2;\n\n    const context = this.context;\n\n    const eventBus = EventBus(context).getInstance();\n    const dashMetrics = config.dashMetrics;\n\n    let instance,\n        logger,\n        bufferStateDict;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onEndFragment, instance);\n    }\n\n    function checkConfig() {\n        if (!dashMetrics || !dashMetrics.hasOwnProperty('getCurrentBufferLevel') || !dashMetrics.hasOwnProperty('getCurrentBufferState')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    /*\n     * InsufficientBufferRule does not kick in before the first BUFFER_LOADED event happens. This is reset at every seek.\n     *\n     * If a BUFFER_EMPTY event happens, then InsufficientBufferRule returns switchRequest.quality=0 until BUFFER_LOADED happens.\n     *\n     * Otherwise InsufficientBufferRule gives a maximum bitrate depending on throughput and bufferLevel such that\n     * a whole fragment can be downloaded before the buffer runs out, subject to a conservative safety factor of 0.5.\n     * If the bufferLevel is low, then InsufficientBufferRule avoids rebuffering risk.\n     * If the bufferLevel is high, then InsufficientBufferRule give a high MaxIndex allowing other rules to take over.\n     */\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaType')) {\n            return switchRequest;\n        }\n\n        checkConfig();\n\n        const mediaType = rulesContext.getMediaType();\n        const currentBufferState = dashMetrics.getCurrentBufferState(mediaType);\n        const representationInfo = rulesContext.getRepresentationInfo();\n        const fragmentDuration = representationInfo.fragmentDuration;\n\n        // Don't ask for a bitrate change if there is not info about buffer state or if fragmentDuration is not defined\n        if (shouldIgnore(mediaType) || !fragmentDuration) {\n            return switchRequest;\n        }\n\n        if (currentBufferState && currentBufferState.state === MetricsConstants.BUFFER_EMPTY) {\n            logger.debug('[' + mediaType + '] Switch to index 0; buffer is empty.');\n            switchRequest.quality = 0;\n            switchRequest.reason = 'InsufficientBufferRule: Buffer is empty';\n        } else {\n            const mediaInfo = rulesContext.getMediaInfo();\n            const abrController = rulesContext.getAbrController();\n            const throughputHistory = abrController.getThroughputHistory();\n\n            const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n            const throughput = throughputHistory.getAverageThroughput(mediaType);\n            const latency = throughputHistory.getAverageLatency(mediaType);\n            const bitrate = throughput * (bufferLevel / fragmentDuration) * INSUFFICIENT_BUFFER_SAFETY_FACTOR;\n\n            switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, bitrate, latency);\n            switchRequest.reason = 'InsufficientBufferRule: being conservative to avoid immediate rebuffering';\n        }\n\n        return switchRequest;\n    }\n\n    function shouldIgnore(mediaType) {\n        return bufferStateDict[mediaType].ignoreCount > 0;\n    }\n\n    function resetInitialSettings() {\n        bufferStateDict = {};\n        bufferStateDict[Constants.VIDEO] = {ignoreCount: SEGMENT_IGNORE_COUNT};\n        bufferStateDict[Constants.AUDIO] = {ignoreCount: SEGMENT_IGNORE_COUNT};\n    }\n\n    function onPlaybackSeeking() {\n        resetInitialSettings();\n    }\n\n    function onEndFragment(e) {\n        if (!isNaN(e.startTime) && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            if (bufferStateDict[e.mediaType].ignoreCount > 0) {\n                bufferStateDict[e.mediaType].ignoreCount--;\n            }\n        }\n    }\n\n    function reset() {\n        resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onEndFragment, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nInsufficientBufferRule.__dashjs_factory_name = 'InsufficientBufferRule';\nexport default FactoryMaker.getClassFactory(InsufficientBufferRule);\n"]},"metadata":{},"sourceType":"script"}