{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MediaPlayer = require('./MediaPlayer');\n\nvar _MediaPlayer2 = _interopRequireDefault(_MediaPlayer);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction MediaPlayerFactory() {\n  /**\n  * mime-type identifier for any source content to be accepted as a dash manifest by the create() method.\n  * @type {string}\n  */\n  var SUPPORTED_MIME_TYPE = 'application/dash+xml';\n  var logger = void 0;\n  /**\n  *  A new MediaPlayer is instantiated for the supplied videoElement and optional source and context.  If no context is provided,\n  *  a default DashContext is used. If no source is provided, the videoElement is interrogated to extract the first source whose\n  *  type is application/dash+xml.\n  * The autoplay property of the videoElement is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched.\n  * @param {HTMLMediaElement} video\n  * @param {HTMLSourceElement} source\n  * @param {Object} context\n  * @returns {MediaPlayer|null}\n  */\n\n  function create(video, source, context) {\n    if (!video || !/^VIDEO$/i.test(video.nodeName)) return null;\n    if (video._dashjs_player) return video._dashjs_player;\n    var player = void 0;\n    var videoID = video.id || video.name || 'video element';\n    source = source || [].slice.call(video.querySelectorAll('source')).filter(function (s) {\n      return s.type == SUPPORTED_MIME_TYPE;\n    })[0];\n\n    if (!source && video.src) {\n      source = document.createElement('source');\n      source.src = video.src;\n    } else if (!source && !video.src) {\n      return null;\n    }\n\n    context = context || {};\n    player = (0, _MediaPlayer2.default)(context).create();\n    player.initialize(video, source.src, video.autoplay);\n\n    if (!logger) {\n      logger = player.getDebug().getLogger();\n    }\n\n    logger.debug('Converted ' + videoID + ' to dash.js player and added content: ' + source.src); // Store a reference to the player on the video element so it can be gotten at for debugging and so we know its\n    // already been setup.\n\n    video._dashjs_player = player;\n    return player;\n  }\n  /**\n  * Searches the provided scope for all instances of the indicated selector. If no scope is provided, document is used. If no selector is\n  * specified, [data-dashjs-player] is used. The declarative setup also looks for source elements with the type attribute set to 'application/dash+xml'.\n  * It then looks for those video elements which have a source element defined with a type matching 'application/dash+xml'.\n  * A new MediaPlayer is instantiated for each matching video element and the appropriate source is assigned.\n  * The autoplay property of the video element is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched.\n  * Returns an array holding all the MediaPlayer instances that were added by this method.\n  * @param {string} selector - CSS selector\n  * @param {Object} scope\n  * @returns {Array} an array of MediaPlayer objects\n  */\n\n\n  function createAll(selector, scope) {\n    var aPlayers = [];\n    selector = selector || '[data-dashjs-player]';\n    scope = scope || document;\n    var videos = scope.querySelectorAll(selector);\n\n    for (var i = 0; i < videos.length; i++) {\n      var player = create(videos[i], null);\n      aPlayers.push(player);\n    }\n\n    var sources = scope.querySelectorAll('source[type=\"' + SUPPORTED_MIME_TYPE + '\"]');\n\n    for (var _i = 0; _i < sources.length; _i++) {\n      var video = findVideo(sources[_i]);\n\n      var _player = create(video, null);\n\n      aPlayers.push(_player);\n    }\n\n    return aPlayers;\n  }\n\n  function findVideo(el) {\n    if (/^VIDEO$/i.test(el.nodeName)) {\n      return el;\n    } else {\n      return findVideo(el.parentNode);\n    }\n  }\n\n  return {\n    create: create,\n    createAll: createAll\n  };\n}\n\nvar instance = MediaPlayerFactory();\nvar loadInterval = void 0;\n\nfunction loadHandler() {\n  window.removeEventListener('load', loadHandler);\n  instance.createAll();\n}\n\nfunction loadIntervalHandler() {\n  if (window.dashjs) {\n    window.clearInterval(loadInterval);\n    instance.createAll();\n  }\n}\n\nvar avoidAutoCreate = typeof window !== 'undefined' && window && window.dashjs && window.dashjs.skipAutoCreate;\n\nif (!avoidAutoCreate && typeof window !== 'undefined' && window && window.addEventListener) {\n  if (window.document.readyState === 'complete') {\n    if (window.dashjs) {\n      instance.createAll();\n    } else {\n      // If loaded asynchronously, window.readyState may be 'complete' even if dashjs hasn't loaded yet\n      loadInterval = window.setInterval(loadIntervalHandler, 500);\n    }\n  } else {\n    window.addEventListener('load', loadHandler);\n  }\n}\n\nexports.default = instance;","map":{"version":3,"sources":["../../../../src/streaming/MediaPlayerFactory.js"],"names":["SUPPORTED_MIME_TYPE","logger","video","player","videoID","source","s","document","context","aPlayers","selector","scope","videos","i","create","sources","findVideo","el","createAll","instance","MediaPlayerFactory","loadInterval","window","avoidAutoCreate"],"mappings":"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","sourcesContent":["import MediaPlayer from './MediaPlayer';\n\nfunction MediaPlayerFactory() {\n    /**\n     * mime-type identifier for any source content to be accepted as a dash manifest by the create() method.\n     * @type {string}\n     */\n    const SUPPORTED_MIME_TYPE = 'application/dash+xml';\n\n    let logger;\n\n    /**\n     *  A new MediaPlayer is instantiated for the supplied videoElement and optional source and context.  If no context is provided,\n     *  a default DashContext is used. If no source is provided, the videoElement is interrogated to extract the first source whose\n     *  type is application/dash+xml.\n     * The autoplay property of the videoElement is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched.\n     * @param {HTMLMediaElement} video\n     * @param {HTMLSourceElement} source\n     * @param {Object} context\n     * @returns {MediaPlayer|null}\n     */\n    function create(video, source, context) {\n        if (!video || !(/^VIDEO$/i).test(video.nodeName)) return null;\n\n        if (video._dashjs_player) return video._dashjs_player;\n\n        let player;\n        let videoID = (video.id || video.name || 'video element');\n\n        source = source || [].slice.call(video.querySelectorAll('source')).filter(function (s) {\n                return s.type == SUPPORTED_MIME_TYPE;\n            })[0];\n        if (!source && video.src) {\n            source = document.createElement('source');\n            source.src = video.src;\n        } else if (!source && !video.src) {\n            return null;\n        }\n\n        context = context || {};\n        player = MediaPlayer(context).create();\n        player.initialize(video, source.src, video.autoplay);\n\n        if (!logger) {\n            logger = player.getDebug().getLogger();\n        }\n        logger.debug('Converted ' + videoID + ' to dash.js player and added content: ' + source.src);\n\n        // Store a reference to the player on the video element so it can be gotten at for debugging and so we know its\n        // already been setup.\n        video._dashjs_player = player;\n\n        return player;\n    }\n\n    /**\n     * Searches the provided scope for all instances of the indicated selector. If no scope is provided, document is used. If no selector is\n     * specified, [data-dashjs-player] is used. The declarative setup also looks for source elements with the type attribute set to 'application/dash+xml'.\n     * It then looks for those video elements which have a source element defined with a type matching 'application/dash+xml'.\n     * A new MediaPlayer is instantiated for each matching video element and the appropriate source is assigned.\n     * The autoplay property of the video element is preserved. Any preload attribute is ignored. This method should be called after the page onLoad event is dispatched.\n     * Returns an array holding all the MediaPlayer instances that were added by this method.\n     * @param {string} selector - CSS selector\n     * @param {Object} scope\n     * @returns {Array} an array of MediaPlayer objects\n     */\n    function createAll(selector, scope) {\n        let aPlayers = [];\n        selector = selector || '[data-dashjs-player]';\n        scope = scope || document;\n        let videos = scope.querySelectorAll(selector);\n        for (let i = 0; i < videos.length; i++) {\n            let player = create(videos[i], null);\n            aPlayers.push(player);\n        }\n\n        let sources = scope.querySelectorAll('source[type=\"' + SUPPORTED_MIME_TYPE + '\"]');\n        for (let i = 0; i < sources.length; i++) {\n            let video = findVideo(sources[i]);\n            let player = create(video, null);\n            aPlayers.push(player);\n        }\n\n        return aPlayers;\n    }\n\n    function findVideo(el) {\n        if ((/^VIDEO$/i).test(el.nodeName)) {\n            return el;\n        } else {\n            return findVideo(el.parentNode);\n        }\n    }\n\n    return {\n        create: create,\n        createAll: createAll\n    };\n}\n\nlet instance = MediaPlayerFactory();\nlet loadInterval;\n\nfunction loadHandler() {\n    window.removeEventListener('load', loadHandler);\n    instance.createAll();\n}\n\nfunction loadIntervalHandler() {\n    if (window.dashjs) {\n        window.clearInterval(loadInterval);\n        instance.createAll();\n    }\n}\n\nlet avoidAutoCreate = typeof window !== 'undefined' && window && window.dashjs && window.dashjs.skipAutoCreate;\n\nif (!avoidAutoCreate && typeof window !== 'undefined' && window && window.addEventListener) {\n    if (window.document.readyState === 'complete') {\n        if (window.dashjs) {\n            instance.createAll();\n        } else {\n            // If loaded asynchronously, window.readyState may be 'complete' even if dashjs hasn't loaded yet\n            loadInterval = window.setInterval(loadIntervalHandler, 500);\n        }\n    } else {\n        window.addEventListener('load', loadHandler);\n    }\n}\n\nexport default instance;\n"]},"metadata":{},"sourceType":"script"}