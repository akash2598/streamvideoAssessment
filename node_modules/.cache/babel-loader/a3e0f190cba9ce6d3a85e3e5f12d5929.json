{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unescapeDollarsInTemplate = unescapeDollarsInTemplate;\nexports.replaceIDForTemplate = replaceIDForTemplate;\nexports.replaceTokenForTemplate = replaceTokenForTemplate;\nexports.getIndexBasedSegment = getIndexBasedSegment;\nexports.getTimeBasedSegment = getTimeBasedSegment;\n\nvar _Segment = require('./../vo/Segment');\n\nvar _Segment2 = _interopRequireDefault(_Segment);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction zeroPadToLength(numStr, minStrLength) {\n  while (numStr.length < minStrLength) {\n    numStr = '0' + numStr;\n  }\n\n  return numStr;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction getNumberForSegment(segment, segmentIndex) {\n  return segment.representation.startNumber + segmentIndex;\n}\n\nfunction unescapeDollarsInTemplate(url) {\n  return url ? url.split('$$').join('$') : url;\n}\n\nfunction replaceIDForTemplate(url, value) {\n  if (!value || !url || url.indexOf('$RepresentationID$') === -1) {\n    return url;\n  }\n\n  var v = value.toString();\n  return url.split('$RepresentationID$').join(v);\n}\n\nfunction replaceTokenForTemplate(url, token, value) {\n  var formatTag = '%0';\n  var startPos = void 0,\n      endPos = void 0,\n      formatTagPos = void 0,\n      specifier = void 0,\n      width = void 0,\n      paddedValue = void 0;\n  var tokenLen = token.length;\n  var formatTagLen = formatTag.length;\n\n  if (!url) {\n    return url;\n  } // keep looping round until all instances of <token> have been\n  // replaced. once that has happened, startPos below will be -1\n  // and the completed url will be returned.\n\n\n  while (true) {\n    // check if there is a valid $<token>...$ identifier\n    // if not, return the url as is.\n    startPos = url.indexOf('$' + token);\n\n    if (startPos < 0) {\n      return url;\n    } // the next '$' must be the end of the identifier\n    // if there isn't one, return the url as is.\n\n\n    endPos = url.indexOf('$', startPos + tokenLen);\n\n    if (endPos < 0) {\n      return url;\n    } // now see if there is an additional format tag suffixed to\n    // the identifier within the enclosing '$' characters\n\n\n    formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n\n    if (formatTagPos > startPos && formatTagPos < endPos) {\n      specifier = url.charAt(endPos - 1);\n      width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10); // support the minimum specifiers required by IEEE 1003.1\n      // (d, i , o, u, x, and X) for completeness\n\n      switch (specifier) {\n        // treat all int types as uint,\n        // hence deliberate fallthrough\n        case 'd':\n        case 'i':\n        case 'u':\n          paddedValue = zeroPadToLength(value.toString(), width);\n          break;\n\n        case 'x':\n          paddedValue = zeroPadToLength(value.toString(16), width);\n          break;\n\n        case 'X':\n          paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n          break;\n\n        case 'o':\n          paddedValue = zeroPadToLength(value.toString(8), width);\n          break;\n\n        default:\n          return url;\n      }\n    } else {\n      paddedValue = value;\n    }\n\n    url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n  }\n}\n\nfunction getSegment(representation, duration, presentationStartTime, mediaStartTime, availabilityStartTime, timelineConverter, presentationEndTime, isDynamic, index) {\n  var seg = new _Segment2.default();\n  seg.representation = representation;\n  seg.duration = duration;\n  seg.presentationStartTime = presentationStartTime;\n  seg.mediaStartTime = mediaStartTime;\n  seg.availabilityStartTime = availabilityStartTime;\n  seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n  seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n  seg.replacementNumber = getNumberForSegment(seg, index);\n  seg.availabilityIdx = index;\n  return seg;\n}\n\nfunction isSegmentAvailable(timelineConverter, representation, segment, isDynamic) {\n  var periodEnd = timelineConverter.getPeriodEnd(representation, isDynamic);\n  var periodRelativeEnd = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, periodEnd);\n  var segmentTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, segment.presentationStartTime);\n\n  if (segmentTime >= periodRelativeEnd) {\n    if (isDynamic) {\n      // segment is not available in current period, but it may be segment available in another period that current one (in DVR window)\n      // if not (time > segmentAvailabilityRange.end), then return false\n      if (representation.segmentAvailabilityRange && segment.presentationStartTime >= representation.segmentAvailabilityRange.end) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n  var duration = void 0,\n      presentationStartTime = void 0,\n      presentationEndTime = void 0;\n  duration = representation.segmentDuration;\n  /*\n  * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n  * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n  * in the same way as for the last Media Segment in the Representation.\n  */\n\n  if (isNaN(duration)) {\n    duration = representation.adaptation.period.duration;\n  }\n\n  presentationStartTime = parseFloat((representation.adaptation.period.start + index * duration).toFixed(5));\n  presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n  var segment = getSegment(representation, duration, presentationStartTime, timelineConverter.calcMediaTimeFromPresentationTime(presentationStartTime, representation), timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic), timelineConverter, presentationEndTime, isDynamic, index);\n\n  if (!isSegmentAvailable(timelineConverter, representation, segment, isDynamic)) {\n    return null;\n  }\n\n  return segment;\n}\n\nfunction getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n  var scaledTime = time / fTimescale;\n  var scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n  var presentationStartTime = void 0,\n      presentationEndTime = void 0,\n      seg = void 0;\n  presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n  presentationEndTime = presentationStartTime + scaledDuration;\n  seg = getSegment(representation, scaledDuration, presentationStartTime, scaledTime, representation.adaptation.period.mpd.manifest.loadedTime, timelineConverter, presentationEndTime, isDynamic, index);\n\n  if (!isSegmentAvailable(timelineConverter, representation, seg, isDynamic)) {\n    return null;\n  }\n\n  seg.replacementTime = tManifest ? tManifest : time;\n  url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n  url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n  seg.media = url;\n  seg.mediaRange = range;\n  return seg;\n}","map":{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":["numStr","segment","unescapeDollarsInTemplate","url","replaceIDForTemplate","v","value","replaceTokenForTemplate","formatTag","startPos","endPos","formatTagPos","specifier","width","paddedValue","tokenLen","token","formatTagLen","parseInt","zeroPadToLength","seg","Segment","timelineConverter","representation","getNumberForSegment","periodEnd","periodRelativeEnd","segmentTime","getIndexBasedSegment","duration","presentationStartTime","presentationEndTime","isNaN","parseFloat","index","getSegment","isSegmentAvailable","getTimeBasedSegment","scaledTime","time","scaledDuration","Math","tManifest"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Segment from './../vo/Segment';\n\nfunction zeroPadToLength(numStr, minStrLength) {\n    while (numStr.length < minStrLength) {\n        numStr = '0' + numStr;\n    }\n    return numStr;\n}\n\nfunction getNumberForSegment(segment, segmentIndex) {\n    return segment.representation.startNumber + segmentIndex;\n}\n\nexport function unescapeDollarsInTemplate(url) {\n    return url ? url.split('$$').join('$') : url;\n}\n\nexport function replaceIDForTemplate(url, value) {\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) {\n        return url;\n    }\n    let v = value.toString();\n    return url.split('$RepresentationID$').join(v);\n}\n\nexport function replaceTokenForTemplate(url, token, value) {\n    const formatTag = '%0';\n\n    let startPos,\n        endPos,\n        formatTagPos,\n        specifier,\n        width,\n        paddedValue;\n\n    const tokenLen = token.length;\n    const formatTagLen = formatTag.length;\n\n    if (!url) {\n        return url;\n    }\n\n    // keep looping round until all instances of <token> have been\n    // replaced. once that has happened, startPos below will be -1\n    // and the completed url will be returned.\n    while (true) {\n\n        // check if there is a valid $<token>...$ identifier\n        // if not, return the url as is.\n        startPos = url.indexOf('$' + token);\n        if (startPos < 0) {\n            return url;\n        }\n\n        // the next '$' must be the end of the identifier\n        // if there isn't one, return the url as is.\n        endPos = url.indexOf('$', startPos + tokenLen);\n        if (endPos < 0) {\n            return url;\n        }\n\n        // now see if there is an additional format tag suffixed to\n        // the identifier within the enclosing '$' characters\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n        if (formatTagPos > startPos && formatTagPos < endPos) {\n\n            specifier = url.charAt(endPos - 1);\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n            // support the minimum specifiers required by IEEE 1003.1\n            // (d, i , o, u, x, and X) for completeness\n            switch (specifier) {\n                // treat all int types as uint,\n                // hence deliberate fallthrough\n                case 'd':\n                case 'i':\n                case 'u':\n                    paddedValue = zeroPadToLength(value.toString(), width);\n                    break;\n                case 'x':\n                    paddedValue = zeroPadToLength(value.toString(16), width);\n                    break;\n                case 'X':\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                    break;\n                case 'o':\n                    paddedValue = zeroPadToLength(value.toString(8), width);\n                    break;\n                default:\n                    return url;\n            }\n        } else {\n            paddedValue = value;\n        }\n\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n    }\n}\n\nfunction getSegment(representation, duration, presentationStartTime, mediaStartTime, availabilityStartTime,\n                    timelineConverter, presentationEndTime, isDynamic, index) {\n    let seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = duration;\n    seg.presentationStartTime = presentationStartTime;\n    seg.mediaStartTime = mediaStartTime;\n    seg.availabilityStartTime = availabilityStartTime;\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n    seg.replacementNumber = getNumberForSegment(seg, index);\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nfunction isSegmentAvailable(timelineConverter, representation, segment, isDynamic) {\n    const periodEnd = timelineConverter.getPeriodEnd(representation, isDynamic);\n    const periodRelativeEnd = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, periodEnd);\n\n    const segmentTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, segment.presentationStartTime);\n    if (segmentTime >= periodRelativeEnd) {\n        if (isDynamic) {\n            // segment is not available in current period, but it may be segment available in another period that current one (in DVR window)\n            // if not (time > segmentAvailabilityRange.end), then return false\n            if (representation.segmentAvailabilityRange && segment.presentationStartTime >= representation.segmentAvailabilityRange.end) {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n    let duration,\n        presentationStartTime,\n        presentationEndTime;\n\n    duration = representation.segmentDuration;\n\n    /*\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n     * in the same way as for the last Media Segment in the Representation.\n     */\n    if (isNaN(duration)) {\n        duration = representation.adaptation.period.duration;\n    }\n\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n\n    const segment = getSegment(representation, duration, presentationStartTime,\n        timelineConverter.calcMediaTimeFromPresentationTime(presentationStartTime, representation),\n        timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic),\n        timelineConverter, presentationEndTime, isDynamic, index);\n\n    if (!isSegmentAvailable(timelineConverter, representation, segment, isDynamic)) {\n        return null;\n    }\n\n    return segment;\n}\n\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n    const scaledTime = time / fTimescale;\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n\n    let presentationStartTime,\n        presentationEndTime,\n        seg;\n\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n    presentationEndTime = presentationStartTime + scaledDuration;\n\n    seg = getSegment(representation, scaledDuration, presentationStartTime,\n        scaledTime,\n        representation.adaptation.period.mpd.manifest.loadedTime,\n        timelineConverter, presentationEndTime, isDynamic, index);\n\n    if (!isSegmentAvailable(timelineConverter, representation, seg, isDynamic)) {\n        return null;\n    }\n\n    seg.replacementTime = tManifest ? tManifest : time;\n\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n    seg.media = url;\n    seg.mediaRange = range;\n\n    return seg;\n}\n"]},"metadata":{},"sourceType":"script"}