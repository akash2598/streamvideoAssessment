{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ThroughputRule = require('./ThroughputRule');\n\nvar _ThroughputRule2 = _interopRequireDefault(_ThroughputRule);\n\nvar _InsufficientBufferRule = require('./InsufficientBufferRule');\n\nvar _InsufficientBufferRule2 = _interopRequireDefault(_InsufficientBufferRule);\n\nvar _AbandonRequestsRule = require('./AbandonRequestsRule');\n\nvar _AbandonRequestsRule2 = _interopRequireDefault(_AbandonRequestsRule);\n\nvar _DroppedFramesRule = require('./DroppedFramesRule');\n\nvar _DroppedFramesRule2 = _interopRequireDefault(_DroppedFramesRule);\n\nvar _SwitchHistoryRule = require('./SwitchHistoryRule');\n\nvar _SwitchHistoryRule2 = _interopRequireDefault(_SwitchHistoryRule);\n\nvar _BolaRule = require('./BolaRule');\n\nvar _BolaRule2 = _interopRequireDefault(_BolaRule);\n\nvar _L2ARule = require('./L2ARule.js');\n\nvar _L2ARule2 = _interopRequireDefault(_L2ARule);\n\nvar _LoLpRule = require('./lolp/LoLpRule.js');\n\nvar _LoLpRule2 = _interopRequireDefault(_LoLpRule);\n\nvar _FactoryMaker = require('../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _SwitchRequest = require('../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _Constants = require('../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar QUALITY_SWITCH_RULES = 'qualitySwitchRules';\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar ABANDON_FRAGMENT_RULES = 'abandonFragmentRules';\n\nfunction ABRRulesCollection(config) {\n  config = config || {};\n  var context = this.context;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var dashMetrics = config.dashMetrics;\n  var settings = config.settings;\n  var instance = void 0,\n      qualitySwitchRules = void 0,\n      abandonFragmentRules = void 0;\n\n  function initialize() {\n    qualitySwitchRules = [];\n    abandonFragmentRules = [];\n\n    if (settings.get().streaming.abr.useDefaultABRRules) {\n      // If L2A is used we only need this one rule\n      if (settings.get().streaming.abr.ABRStrategy === _Constants2.default.ABR_STRATEGY_L2A) {\n        qualitySwitchRules.push((0, _L2ARule2.default)(context).create({\n          dashMetrics: dashMetrics,\n          mediaPlayerModel: mediaPlayerModel,\n          settings: settings\n        }));\n      } // If LoLP is used we only need this one rule\n      else if (settings.get().streaming.abr.ABRStrategy === _Constants2.default.ABR_STRATEGY_LoLP) {\n          qualitySwitchRules.push((0, _LoLpRule2.default)(context).create({\n            dashMetrics: dashMetrics\n          }));\n        } else {\n          // Only one of BolaRule and ThroughputRule will give a switchRequest.quality !== SwitchRequest.NO_CHANGE.\n          // This is controlled by useBufferOccupancyABR mechanism in AbrController.\n          qualitySwitchRules.push((0, _BolaRule2.default)(context).create({\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            settings: settings\n          }));\n          qualitySwitchRules.push((0, _ThroughputRule2.default)(context).create({\n            dashMetrics: dashMetrics\n          }));\n          qualitySwitchRules.push((0, _InsufficientBufferRule2.default)(context).create({\n            dashMetrics: dashMetrics\n          }));\n          qualitySwitchRules.push((0, _SwitchHistoryRule2.default)(context).create());\n          qualitySwitchRules.push((0, _DroppedFramesRule2.default)(context).create());\n          abandonFragmentRules.push((0, _AbandonRequestsRule2.default)(context).create({\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            settings: settings\n          }));\n        }\n    } // add custom ABR rules if any\n\n\n    var customRules = mediaPlayerModel.getABRCustomRules();\n    customRules.forEach(function (rule) {\n      if (rule.type === QUALITY_SWITCH_RULES) {\n        qualitySwitchRules.push(rule.rule(context).create());\n      }\n\n      if (rule.type === ABANDON_FRAGMENT_RULES) {\n        abandonFragmentRules.push(rule.rule(context).create());\n      }\n    });\n  }\n\n  function getActiveRules(srArray) {\n    return srArray.filter(function (sr) {\n      return sr.quality > _SwitchRequest2.default.NO_CHANGE;\n    });\n  }\n  /**\n  *\n  * @param {array} srArray\n  * @return {object} SwitchRequest\n  */\n\n\n  function getMinSwitchRequest(srArray) {\n    var values = {};\n    var newSwitchReq = null;\n    var i = void 0,\n        len = void 0,\n        req = void 0,\n        quality = void 0,\n        reason = void 0;\n\n    if (srArray.length === 0) {\n      return;\n    }\n\n    values[_SwitchRequest2.default.PRIORITY.STRONG] = {\n      quality: _SwitchRequest2.default.NO_CHANGE,\n      reason: null\n    };\n    values[_SwitchRequest2.default.PRIORITY.WEAK] = {\n      quality: _SwitchRequest2.default.NO_CHANGE,\n      reason: null\n    };\n    values[_SwitchRequest2.default.PRIORITY.DEFAULT] = {\n      quality: _SwitchRequest2.default.NO_CHANGE,\n      reason: null\n    };\n\n    for (i = 0, len = srArray.length; i < len; i += 1) {\n      req = srArray[i];\n\n      if (req.quality !== _SwitchRequest2.default.NO_CHANGE) {\n        // We only use the new quality in case it is lower than the already saved one or if no new quality has been selected for the respective priority\n        if (values[req.priority].quality === _SwitchRequest2.default.NO_CHANGE || values[req.priority].quality > req.quality) {\n          values[req.priority].quality = req.quality;\n          values[req.priority].reason = req.reason || null;\n        }\n      }\n    }\n\n    if (values[_SwitchRequest2.default.PRIORITY.WEAK].quality !== _SwitchRequest2.default.NO_CHANGE) {\n      newSwitchReq = values[_SwitchRequest2.default.PRIORITY.WEAK];\n    }\n\n    if (values[_SwitchRequest2.default.PRIORITY.DEFAULT].quality !== _SwitchRequest2.default.NO_CHANGE) {\n      newSwitchReq = values[_SwitchRequest2.default.PRIORITY.DEFAULT];\n    }\n\n    if (values[_SwitchRequest2.default.PRIORITY.STRONG].quality !== _SwitchRequest2.default.NO_CHANGE) {\n      newSwitchReq = values[_SwitchRequest2.default.PRIORITY.STRONG];\n    }\n\n    if (newSwitchReq) {\n      quality = newSwitchReq.quality;\n      reason = newSwitchReq.reason;\n    }\n\n    return (0, _SwitchRequest2.default)(context).create(quality, reason);\n  }\n\n  function getMaxQuality(rulesContext) {\n    var switchRequestArray = qualitySwitchRules.map(function (rule) {\n      return rule.getMaxIndex(rulesContext);\n    });\n    var activeRules = getActiveRules(switchRequestArray);\n    var maxQuality = getMinSwitchRequest(activeRules);\n    return maxQuality || (0, _SwitchRequest2.default)(context).create();\n  }\n\n  function shouldAbandonFragment(rulesContext) {\n    var abandonRequestArray = abandonFragmentRules.map(function (rule) {\n      return rule.shouldAbandon(rulesContext);\n    });\n    var activeRules = getActiveRules(abandonRequestArray);\n    var shouldAbandon = getMinSwitchRequest(activeRules);\n    return shouldAbandon || (0, _SwitchRequest2.default)(context).create();\n  }\n\n  function reset() {\n    [qualitySwitchRules, abandonFragmentRules].forEach(function (rules) {\n      if (rules && rules.length) {\n        rules.forEach(function (rule) {\n          return rule.reset && rule.reset();\n        });\n      }\n    });\n    qualitySwitchRules = [];\n    abandonFragmentRules = [];\n  }\n\n  function getQualitySwitchRules() {\n    return qualitySwitchRules;\n  }\n\n  instance = {\n    initialize: initialize,\n    reset: reset,\n    getMaxQuality: getMaxQuality,\n    getMinSwitchRequest: getMinSwitchRequest,\n    shouldAbandonFragment: shouldAbandonFragment,\n    getQualitySwitchRules: getQualitySwitchRules\n  };\n  return instance;\n}\n\nABRRulesCollection.__dashjs_factory_name = 'ABRRulesCollection';\n\nvar factory = _FactoryMaker2.default.getClassFactory(ABRRulesCollection);\n\nfactory.QUALITY_SWITCH_RULES = QUALITY_SWITCH_RULES;\nfactory.ABANDON_FRAGMENT_RULES = ABANDON_FRAGMENT_RULES;\n\n_FactoryMaker2.default.updateSingletonFactory(ABRRulesCollection.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../../src/streaming/rules/abr/ABRRulesCollection.js"],"names":["QUALITY_SWITCH_RULES","ABANDON_FRAGMENT_RULES","config","context","mediaPlayerModel","dashMetrics","settings","instance","qualitySwitchRules","abandonFragmentRules","Constants","customRules","rule","srArray","sr","SwitchRequest","values","newSwitchReq","i","len","req","quality","reason","switchRequestArray","activeRules","getActiveRules","maxQuality","getMinSwitchRequest","abandonRequestArray","shouldAbandon","rules","initialize","reset","getMaxQuality","shouldAbandonFragment","getQualitySwitchRules","ABRRulesCollection","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport ThroughputRule from './ThroughputRule';\nimport InsufficientBufferRule from './InsufficientBufferRule';\nimport AbandonRequestsRule from './AbandonRequestsRule';\nimport DroppedFramesRule from './DroppedFramesRule';\nimport SwitchHistoryRule from './SwitchHistoryRule';\nimport BolaRule from './BolaRule';\nimport L2ARule from './L2ARule.js';\nimport LoLPRule from './lolp/LoLpRule.js';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport SwitchRequest from '../SwitchRequest';\nimport Constants from '../../constants/Constants';\n\nconst QUALITY_SWITCH_RULES = 'qualitySwitchRules';\nconst ABANDON_FRAGMENT_RULES = 'abandonFragmentRules';\n\n\nfunction ABRRulesCollection(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const dashMetrics = config.dashMetrics;\n    const settings = config.settings;\n\n    let instance,\n        qualitySwitchRules,\n        abandonFragmentRules;\n\n    function initialize() {\n        qualitySwitchRules = [];\n        abandonFragmentRules = [];\n\n        if (settings.get().streaming.abr.useDefaultABRRules) {\n\n            // If L2A is used we only need this one rule\n            if (settings.get().streaming.abr.ABRStrategy === Constants.ABR_STRATEGY_L2A) {\n                qualitySwitchRules.push(\n                    L2ARule(context).create({\n                        dashMetrics: dashMetrics,\n                        mediaPlayerModel: mediaPlayerModel,\n                        settings: settings\n                    })\n                );\n            }\n            // If LoLP is used we only need this one rule\n            else if (settings.get().streaming.abr.ABRStrategy === Constants.ABR_STRATEGY_LoLP) {\n                qualitySwitchRules.push(\n                    LoLPRule(context).create({\n                        dashMetrics: dashMetrics\n                    })\n                );\n            } else {\n                // Only one of BolaRule and ThroughputRule will give a switchRequest.quality !== SwitchRequest.NO_CHANGE.\n                // This is controlled by useBufferOccupancyABR mechanism in AbrController.\n                qualitySwitchRules.push(\n                    BolaRule(context).create({\n                        dashMetrics: dashMetrics,\n                        mediaPlayerModel: mediaPlayerModel,\n                        settings: settings\n                    })\n                );\n\n                qualitySwitchRules.push(\n                    ThroughputRule(context).create({\n                        dashMetrics: dashMetrics\n                    })\n                );\n                qualitySwitchRules.push(\n                    InsufficientBufferRule(context).create({\n                        dashMetrics: dashMetrics\n                    })\n                );\n                qualitySwitchRules.push(\n                    SwitchHistoryRule(context).create()\n                );\n                qualitySwitchRules.push(\n                    DroppedFramesRule(context).create()\n                );\n\n                abandonFragmentRules.push(\n                    AbandonRequestsRule(context).create({\n                        dashMetrics: dashMetrics,\n                        mediaPlayerModel: mediaPlayerModel,\n                        settings: settings\n                    })\n                );\n            }\n        }\n\n        // add custom ABR rules if any\n        const customRules = mediaPlayerModel.getABRCustomRules();\n        customRules.forEach(function (rule) {\n            if (rule.type === QUALITY_SWITCH_RULES) {\n                qualitySwitchRules.push(rule.rule(context).create());\n            }\n\n            if (rule.type === ABANDON_FRAGMENT_RULES) {\n                abandonFragmentRules.push(rule.rule(context).create());\n            }\n        });\n    }\n\n    function getActiveRules(srArray) {\n        return srArray.filter(sr => sr.quality > SwitchRequest.NO_CHANGE);\n    }\n\n    /**\n     *\n     * @param {array} srArray\n     * @return {object} SwitchRequest\n     */\n    function getMinSwitchRequest(srArray) {\n        const values = {};\n        let newSwitchReq = null;\n        let i,\n            len,\n            req,\n            quality,\n            reason;\n\n        if (srArray.length === 0) {\n            return;\n        }\n\n        values[SwitchRequest.PRIORITY.STRONG] = { quality: SwitchRequest.NO_CHANGE, reason: null };\n        values[SwitchRequest.PRIORITY.WEAK] = { quality: SwitchRequest.NO_CHANGE, reason: null };\n        values[SwitchRequest.PRIORITY.DEFAULT] = { quality: SwitchRequest.NO_CHANGE, reason: null };\n\n        for (i = 0, len = srArray.length; i < len; i += 1) {\n            req = srArray[i];\n            if (req.quality !== SwitchRequest.NO_CHANGE) {\n                // We only use the new quality in case it is lower than the already saved one or if no new quality has been selected for the respective priority\n                if (values[req.priority].quality === SwitchRequest.NO_CHANGE || values[req.priority].quality > req.quality) {\n                    values[req.priority].quality = req.quality;\n                    values[req.priority].reason = req.reason || null;\n                }\n            }\n        }\n\n        if (values[SwitchRequest.PRIORITY.WEAK].quality !== SwitchRequest.NO_CHANGE) {\n            newSwitchReq = values[SwitchRequest.PRIORITY.WEAK];\n        }\n\n        if (values[SwitchRequest.PRIORITY.DEFAULT].quality !== SwitchRequest.NO_CHANGE) {\n            newSwitchReq = values[SwitchRequest.PRIORITY.DEFAULT];\n        }\n\n        if (values[SwitchRequest.PRIORITY.STRONG].quality !== SwitchRequest.NO_CHANGE) {\n            newSwitchReq = values[SwitchRequest.PRIORITY.STRONG];\n        }\n\n        if (newSwitchReq) {\n            quality = newSwitchReq.quality;\n            reason = newSwitchReq.reason;\n        }\n\n        return SwitchRequest(context).create(quality, reason);\n    }\n\n    function getMaxQuality(rulesContext) {\n        const switchRequestArray = qualitySwitchRules.map(rule => rule.getMaxIndex(rulesContext));\n        const activeRules = getActiveRules(switchRequestArray);\n        const maxQuality = getMinSwitchRequest(activeRules);\n\n        return maxQuality || SwitchRequest(context).create();\n    }\n\n    function shouldAbandonFragment(rulesContext) {\n        const abandonRequestArray = abandonFragmentRules.map(rule => rule.shouldAbandon(rulesContext));\n        const activeRules = getActiveRules(abandonRequestArray);\n        const shouldAbandon = getMinSwitchRequest(activeRules);\n\n        return shouldAbandon || SwitchRequest(context).create();\n    }\n\n    function reset() {\n        [qualitySwitchRules, abandonFragmentRules].forEach(rules => {\n            if (rules && rules.length) {\n                rules.forEach(rule => rule.reset && rule.reset());\n            }\n        });\n        qualitySwitchRules = [];\n        abandonFragmentRules = [];\n    }\n\n    function getQualitySwitchRules() {\n        return qualitySwitchRules;\n    }\n\n    instance = {\n        initialize,\n        reset,\n        getMaxQuality,\n        getMinSwitchRequest,\n        shouldAbandonFragment,\n        getQualitySwitchRules\n    };\n\n    return instance;\n}\n\nABRRulesCollection.__dashjs_factory_name = 'ABRRulesCollection';\nconst factory = FactoryMaker.getClassFactory(ABRRulesCollection);\nfactory.QUALITY_SWITCH_RULES = QUALITY_SWITCH_RULES;\nfactory.ABANDON_FRAGMENT_RULES = ABANDON_FRAGMENT_RULES;\nFactoryMaker.updateSingletonFactory(ABRRulesCollection.__dashjs_factory_name, factory);\n\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}