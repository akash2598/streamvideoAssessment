{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EventsBase2 = require('../core/events/EventsBase');\n\nvar _EventsBase3 = _interopRequireDefault(_EventsBase2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* @class\n* @implements EventsBase\n*/\n\n\nvar MediaPlayerEvents = function (_EventsBase) {\n  _inherits(MediaPlayerEvents, _EventsBase);\n  /**\n  * @description Public facing external events to be used when developing a player that implements dash.js.\n  */\n\n\n  function MediaPlayerEvents() {\n    _classCallCheck(this, MediaPlayerEvents);\n    /**\n    * Triggered when playback will not start yet\n    * as the MPD's availabilityStartTime is in the future.\n    * Check delay property in payload to determine time before playback will start.\n    * @event MediaPlayerEvents#AST_IN_FUTURE\n    */\n\n\n    var _this = _possibleConstructorReturn(this, (MediaPlayerEvents.__proto__ || Object.getPrototypeOf(MediaPlayerEvents)).call(this));\n\n    _this.AST_IN_FUTURE = 'astInFuture';\n    /**\n    * Triggered when the video element's buffer state changes to stalled.\n    * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n    * @event MediaPlayerEvents#BUFFER_EMPTY\n    */\n\n    _this.BUFFER_EMPTY = 'bufferStalled';\n    /**\n    * Triggered when the video element's buffer state changes to loaded.\n    * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n    * @event MediaPlayerEvents#BUFFER_LOADED\n    */\n\n    _this.BUFFER_LOADED = 'bufferLoaded';\n    /**\n    * Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state.\n    * @event MediaPlayerEvents#BUFFER_LEVEL_STATE_CHANGED\n    */\n\n    _this.BUFFER_LEVEL_STATE_CHANGED = 'bufferStateChanged';\n    /**\n    * Triggered when a dynamic stream changed to static (transition phase between Live and On-Demand).\n    * @event MediaPlayerEvents#DYNAMIC_TO_STATIC\n    */\n\n    _this.DYNAMIC_TO_STATIC = 'dynamicToStatic';\n    /**\n    * Triggered when there is an error from the element or MSE source buffer.\n    * @event MediaPlayerEvents#ERROR\n    */\n\n    _this.ERROR = 'error';\n    /**\n    * Triggered when a fragment download has completed.\n    * @event MediaPlayerEvents#FRAGMENT_LOADING_COMPLETED\n    */\n\n    _this.FRAGMENT_LOADING_COMPLETED = 'fragmentLoadingCompleted';\n    /**\n    * Triggered when a partial fragment download has completed.\n    * @event MediaPlayerEvents#FRAGMENT_LOADING_PROGRESS\n    */\n\n    _this.FRAGMENT_LOADING_PROGRESS = 'fragmentLoadingProgress';\n    /**\n    * Triggered when a fragment download has started.\n    * @event MediaPlayerEvents#FRAGMENT_LOADING_STARTED\n    */\n\n    _this.FRAGMENT_LOADING_STARTED = 'fragmentLoadingStarted';\n    /**\n    * Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule..\n    * @event MediaPlayerEvents#FRAGMENT_LOADING_ABANDONED\n    */\n\n    _this.FRAGMENT_LOADING_ABANDONED = 'fragmentLoadingAbandoned';\n    /**\n    * Triggered when {@link module:Debug} logger methods are called.\n    * @event MediaPlayerEvents#LOG\n    */\n\n    _this.LOG = 'log'; //TODO refactor with internal event\n\n    /**\n             * Triggered when the manifest load is complete\n             * @event MediaPlayerEvents#MANIFEST_LOADED\n             */\n\n    _this.MANIFEST_LOADED = 'manifestLoaded';\n    /**\n    * Triggered anytime there is a change to the overall metrics.\n    * @event MediaPlayerEvents#METRICS_CHANGED\n    */\n\n    _this.METRICS_CHANGED = 'metricsChanged';\n    /**\n    * Triggered when an individual metric is added, updated or cleared.\n    * @event MediaPlayerEvents#METRIC_CHANGED\n    */\n\n    _this.METRIC_CHANGED = 'metricChanged';\n    /**\n    * Triggered every time a new metric is added.\n    * @event MediaPlayerEvents#METRIC_ADDED\n    */\n\n    _this.METRIC_ADDED = 'metricAdded';\n    /**\n    * Triggered every time a metric is updated.\n    * @event MediaPlayerEvents#METRIC_UPDATED\n    */\n\n    _this.METRIC_UPDATED = 'metricUpdated';\n    /**\n    * Triggered at the stream end of a period.\n    * @event MediaPlayerEvents#PERIOD_SWITCH_COMPLETED\n    */\n\n    _this.PERIOD_SWITCH_COMPLETED = 'periodSwitchCompleted';\n    /**\n    * Triggered when a new period starts.\n    * @event MediaPlayerEvents#PERIOD_SWITCH_STARTED\n    */\n\n    _this.PERIOD_SWITCH_STARTED = 'periodSwitchStarted';\n    /**\n    * Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules.\n    * @event MediaPlayerEvents#QUALITY_CHANGE_REQUESTED\n    */\n\n    _this.QUALITY_CHANGE_REQUESTED = 'qualityChangeRequested';\n    /**\n    * Triggered when the new ABR quality is being rendered on-screen.\n    * @event MediaPlayerEvents#QUALITY_CHANGE_RENDERED\n    */\n\n    _this.QUALITY_CHANGE_RENDERED = 'qualityChangeRendered';\n    /**\n    * Triggered when the new track is being rendered.\n    * @event MediaPlayerEvents#TRACK_CHANGE_RENDERED\n    */\n\n    _this.TRACK_CHANGE_RENDERED = 'trackChangeRendered';\n    /**\n    * Triggered when the source is setup and ready.\n    * @event MediaPlayerEvents#SOURCE_INITIALIZED\n    */\n\n    _this.SOURCE_INITIALIZED = 'sourceInitialized';\n    /**\n    * Triggered when a stream (period) is being loaded\n    * @event MediaPlayerEvents#STREAM_INITIALIZING\n    */\n\n    _this.STREAM_INITIALIZING = 'streamInitializing';\n    /**\n    * Triggered when a stream (period) is loaded\n    * @event MediaPlayerEvents#STREAM_UPDATED\n    */\n\n    _this.STREAM_UPDATED = 'streamUpdated';\n    /**\n    * Triggered when a stream (period) is updated\n    * @event MediaPlayerEvents#STREAM_INITIALIZED\n    */\n\n    _this.STREAM_INITIALIZED = 'streamInitialized';\n    /**\n    * Triggered when the player has been reset.\n    * @event MediaPlayerEvents#STREAM_TEARDOWN_COMPLETE\n    */\n\n    _this.STREAM_TEARDOWN_COMPLETE = 'streamTeardownComplete';\n    /**\n    * Triggered once all text tracks detected in the MPD are added to the video element.\n    * @event MediaPlayerEvents#TEXT_TRACKS_ADDED\n    */\n\n    _this.TEXT_TRACKS_ADDED = 'allTextTracksAdded';\n    /**\n    * Triggered when a text track is added to the video element's TextTrackList\n    * @event MediaPlayerEvents#TEXT_TRACK_ADDED\n    */\n\n    _this.TEXT_TRACK_ADDED = 'textTrackAdded';\n    /**\n    * Triggered when a ttml chunk is parsed.\n    * @event MediaPlayerEvents#TTML_PARSED\n    */\n\n    _this.TTML_PARSED = 'ttmlParsed';\n    /**\n    * Triggered when a ttml chunk has to be parsed.\n    * @event MediaPlayerEvents#TTML_TO_PARSE\n    */\n\n    _this.TTML_TO_PARSE = 'ttmlToParse';\n    /**\n    * Triggered when a caption is rendered.\n    * @event MediaPlayerEvents#CAPTION_RENDERED\n    */\n\n    _this.CAPTION_RENDERED = 'captionRendered';\n    /**\n    * Triggered when the caption container is resized.\n    * @event MediaPlayerEvents#CAPTION_CONTAINER_RESIZE\n    */\n\n    _this.CAPTION_CONTAINER_RESIZE = 'captionContainerResize';\n    /**\n    * Sent when enough data is available that the media can be played,\n    * at least for a couple of frames.  This corresponds to the\n    * HAVE_ENOUGH_DATA readyState.\n    * @event MediaPlayerEvents#CAN_PLAY\n    */\n\n    _this.CAN_PLAY = 'canPlay';\n    /**\n    * Sent when playback completes.\n    * @event MediaPlayerEvents#PLAYBACK_ENDED\n    */\n\n    _this.PLAYBACK_ENDED = 'playbackEnded';\n    /**\n    * Sent when an error occurs.  The element's error\n    * attribute contains more information.\n    * @event MediaPlayerEvents#PLAYBACK_ERROR\n    */\n\n    _this.PLAYBACK_ERROR = 'playbackError';\n    /**\n    * Sent when playback is not allowed (for example if user gesture is needed).\n    * @event MediaPlayerEvents#PLAYBACK_NOT_ALLOWED\n    */\n\n    _this.PLAYBACK_NOT_ALLOWED = 'playbackNotAllowed';\n    /**\n    * The media's metadata has finished loading; all attributes now\n    * contain as much useful information as they're going to.\n    * @event MediaPlayerEvents#PLAYBACK_METADATA_LOADED\n    */\n\n    _this.PLAYBACK_METADATA_LOADED = 'playbackMetaDataLoaded';\n    /**\n    * Sent when playback is paused.\n    * @event MediaPlayerEvents#PLAYBACK_PAUSED\n    */\n\n    _this.PLAYBACK_PAUSED = 'playbackPaused';\n    /**\n    * Sent when the media begins to play (either for the first time, after having been paused,\n    * or after ending and then restarting).\n    *\n    * @event MediaPlayerEvents#PLAYBACK_PLAYING\n    */\n\n    _this.PLAYBACK_PLAYING = 'playbackPlaying';\n    /**\n    * Sent periodically to inform interested parties of progress downloading\n    * the media. Information about the current amount of the media that has\n    * been downloaded is available in the media element's buffered attribute.\n    * @event MediaPlayerEvents#PLAYBACK_PROGRESS\n    */\n\n    _this.PLAYBACK_PROGRESS = 'playbackProgress';\n    /**\n    * Sent when the playback speed changes.\n    * @event MediaPlayerEvents#PLAYBACK_RATE_CHANGED\n    */\n\n    _this.PLAYBACK_RATE_CHANGED = 'playbackRateChanged';\n    /**\n    * Sent when a seek operation completes.\n    * @event MediaPlayerEvents#PLAYBACK_SEEKED\n    */\n\n    _this.PLAYBACK_SEEKED = 'playbackSeeked';\n    /**\n    * Sent when a seek operation begins.\n    * @event MediaPlayerEvents#PLAYBACK_SEEKING\n    */\n\n    _this.PLAYBACK_SEEKING = 'playbackSeeking';\n    /**\n    * Sent when a seek operation has been asked.\n    * @event MediaPlayerEvents#PLAYBACK_SEEK_ASKED\n    */\n\n    _this.PLAYBACK_SEEK_ASKED = 'playbackSeekAsked';\n    /**\n    * Sent when the video element reports stalled\n    * @event MediaPlayerEvents#PLAYBACK_STALLED\n    */\n\n    _this.PLAYBACK_STALLED = 'playbackStalled';\n    /**\n    * Sent when playback of the media starts after having been paused;\n    * that is, when playback is resumed after a prior pause event.\n    *\n    * @event MediaPlayerEvents#PLAYBACK_STARTED\n    */\n\n    _this.PLAYBACK_STARTED = 'playbackStarted';\n    /**\n    * The time indicated by the element's currentTime attribute has changed.\n    * @event MediaPlayerEvents#PLAYBACK_TIME_UPDATED\n    */\n\n    _this.PLAYBACK_TIME_UPDATED = 'playbackTimeUpdated';\n    /**\n    * Sent when the media playback has stopped because of a temporary lack of data.\n    *\n    * @event MediaPlayerEvents#PLAYBACK_WAITING\n    */\n\n    _this.PLAYBACK_WAITING = 'playbackWaiting';\n    /**\n    * Manifest validity changed - As a result of an MPD validity expiration event.\n    * @event MediaPlayerEvents#MANIFEST_VALIDITY_CHANGED\n    */\n\n    _this.MANIFEST_VALIDITY_CHANGED = 'manifestValidityChanged';\n    /**\n    * A gap occured in the timeline which requires a seek to the next period\n    * @event MediaPlayerEvents#GAP_CAUSED_SEEK_TO_PERIOD_END\n    */\n\n    _this.GAP_CAUSED_SEEK_TO_PERIOD_END = 'gapCausedSeekToPeriodEnd';\n    /**\n    * A gap occured in the timeline which requires an internal seek\n    * @event MediaPlayerEvents#GAP_CAUSED_INTERNAL_SEEK\n    */\n\n    _this.GAP_CAUSED_INTERNAL_SEEK = 'gapCausedInternalSeek';\n    /**\n    * Dash events are triggered at their respective start points on the timeline.\n    * @event MediaPlayerEvents#EVENT_MODE_ON_START\n    */\n\n    _this.EVENT_MODE_ON_START = 'eventModeOnStart';\n    /**\n    * Dash events are triggered as soon as they were parsed.\n    * @event MediaPlayerEvents#EVENT_MODE_ON_RECEIVE\n    */\n\n    _this.EVENT_MODE_ON_RECEIVE = 'eventModeOnReceive';\n    /**\n    * Event that is dispatched whenever the player encounters a potential conformance validation that might lead to unexpected/not optimal behavior\n    * @event MediaPlayerEvents#CONFORMANCE_VIOLATION\n    */\n\n    _this.CONFORMANCE_VIOLATION = 'conformanceViolation';\n    return _this;\n  }\n\n  return MediaPlayerEvents;\n}(_EventsBase3.default);\n\nvar mediaPlayerEvents = new MediaPlayerEvents();\nexports.default = mediaPlayerEvents;","map":{"version":3,"sources":["../../../../src/streaming/MediaPlayerEvents.js"],"names":["MediaPlayerEvents","EventsBase","mediaPlayerEvents"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventsBase from '../core/events/EventsBase';\n\n/**\n * @class\n * @implements EventsBase\n */\nclass MediaPlayerEvents extends EventsBase {\n\n    /**\n     * @description Public facing external events to be used when developing a player that implements dash.js.\n     */\n    constructor() {\n        super();\n        /**\n         * Triggered when playback will not start yet\n         * as the MPD's availabilityStartTime is in the future.\n         * Check delay property in payload to determine time before playback will start.\n         * @event MediaPlayerEvents#AST_IN_FUTURE\n         */\n        this.AST_IN_FUTURE = 'astInFuture';\n\n        /**\n         * Triggered when the video element's buffer state changes to stalled.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_EMPTY\n         */\n        this.BUFFER_EMPTY = 'bufferStalled';\n\n        /**\n         * Triggered when the video element's buffer state changes to loaded.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_LOADED\n         */\n        this.BUFFER_LOADED = 'bufferLoaded';\n\n        /**\n         * Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state.\n         * @event MediaPlayerEvents#BUFFER_LEVEL_STATE_CHANGED\n         */\n        this.BUFFER_LEVEL_STATE_CHANGED = 'bufferStateChanged';\n\n        /**\n         * Triggered when a dynamic stream changed to static (transition phase between Live and On-Demand).\n         * @event MediaPlayerEvents#DYNAMIC_TO_STATIC\n         */\n        this.DYNAMIC_TO_STATIC = 'dynamicToStatic';\n\n        /**\n         * Triggered when there is an error from the element or MSE source buffer.\n         * @event MediaPlayerEvents#ERROR\n         */\n        this.ERROR = 'error';\n        /**\n         * Triggered when a fragment download has completed.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_COMPLETED\n         */\n        this.FRAGMENT_LOADING_COMPLETED = 'fragmentLoadingCompleted';\n\n        /**\n         * Triggered when a partial fragment download has completed.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_PROGRESS\n         */\n        this.FRAGMENT_LOADING_PROGRESS = 'fragmentLoadingProgress';\n        /**\n         * Triggered when a fragment download has started.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_STARTED\n         */\n        this.FRAGMENT_LOADING_STARTED = 'fragmentLoadingStarted';\n\n        /**\n         * Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule..\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_ABANDONED\n         */\n        this.FRAGMENT_LOADING_ABANDONED = 'fragmentLoadingAbandoned';\n\n        /**\n         * Triggered when {@link module:Debug} logger methods are called.\n         * @event MediaPlayerEvents#LOG\n         */\n        this.LOG = 'log';\n\n        //TODO refactor with internal event\n        /**\n         * Triggered when the manifest load is complete\n         * @event MediaPlayerEvents#MANIFEST_LOADED\n         */\n        this.MANIFEST_LOADED = 'manifestLoaded';\n\n        /**\n         * Triggered anytime there is a change to the overall metrics.\n         * @event MediaPlayerEvents#METRICS_CHANGED\n         */\n        this.METRICS_CHANGED = 'metricsChanged';\n\n        /**\n         * Triggered when an individual metric is added, updated or cleared.\n         * @event MediaPlayerEvents#METRIC_CHANGED\n         */\n        this.METRIC_CHANGED = 'metricChanged';\n\n        /**\n         * Triggered every time a new metric is added.\n         * @event MediaPlayerEvents#METRIC_ADDED\n         */\n        this.METRIC_ADDED = 'metricAdded';\n\n        /**\n         * Triggered every time a metric is updated.\n         * @event MediaPlayerEvents#METRIC_UPDATED\n         */\n        this.METRIC_UPDATED = 'metricUpdated';\n\n        /**\n         * Triggered at the stream end of a period.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_COMPLETED\n         */\n        this.PERIOD_SWITCH_COMPLETED = 'periodSwitchCompleted';\n\n        /**\n         * Triggered when a new period starts.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_STARTED\n         */\n        this.PERIOD_SWITCH_STARTED = 'periodSwitchStarted';\n\n        /**\n         * Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_REQUESTED\n         */\n        this.QUALITY_CHANGE_REQUESTED = 'qualityChangeRequested';\n\n        /**\n         * Triggered when the new ABR quality is being rendered on-screen.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_RENDERED\n         */\n        this.QUALITY_CHANGE_RENDERED = 'qualityChangeRendered';\n\n        /**\n         * Triggered when the new track is being rendered.\n         * @event MediaPlayerEvents#TRACK_CHANGE_RENDERED\n         */\n        this.TRACK_CHANGE_RENDERED = 'trackChangeRendered';\n\n        /**\n         * Triggered when the source is setup and ready.\n         * @event MediaPlayerEvents#SOURCE_INITIALIZED\n         */\n        this.SOURCE_INITIALIZED = 'sourceInitialized';\n\n        /**\n         * Triggered when a stream (period) is being loaded\n         * @event MediaPlayerEvents#STREAM_INITIALIZING\n         */\n        this.STREAM_INITIALIZING = 'streamInitializing';\n\n        /**\n         * Triggered when a stream (period) is loaded\n         * @event MediaPlayerEvents#STREAM_UPDATED\n         */\n        this.STREAM_UPDATED = 'streamUpdated';\n\n        /**\n         * Triggered when a stream (period) is updated\n         * @event MediaPlayerEvents#STREAM_INITIALIZED\n         */\n        this.STREAM_INITIALIZED = 'streamInitialized';\n\n        /**\n         * Triggered when the player has been reset.\n         * @event MediaPlayerEvents#STREAM_TEARDOWN_COMPLETE\n         */\n        this.STREAM_TEARDOWN_COMPLETE = 'streamTeardownComplete';\n\n        /**\n         * Triggered once all text tracks detected in the MPD are added to the video element.\n         * @event MediaPlayerEvents#TEXT_TRACKS_ADDED\n         */\n        this.TEXT_TRACKS_ADDED = 'allTextTracksAdded';\n\n        /**\n         * Triggered when a text track is added to the video element's TextTrackList\n         * @event MediaPlayerEvents#TEXT_TRACK_ADDED\n         */\n        this.TEXT_TRACK_ADDED = 'textTrackAdded';\n\n        /**\n         * Triggered when a ttml chunk is parsed.\n         * @event MediaPlayerEvents#TTML_PARSED\n         */\n        this.TTML_PARSED = 'ttmlParsed';\n\n        /**\n         * Triggered when a ttml chunk has to be parsed.\n         * @event MediaPlayerEvents#TTML_TO_PARSE\n         */\n        this.TTML_TO_PARSE = 'ttmlToParse';\n\n        /**\n         * Triggered when a caption is rendered.\n         * @event MediaPlayerEvents#CAPTION_RENDERED\n         */\n        this.CAPTION_RENDERED = 'captionRendered';\n\n        /**\n         * Triggered when the caption container is resized.\n         * @event MediaPlayerEvents#CAPTION_CONTAINER_RESIZE\n         */\n        this.CAPTION_CONTAINER_RESIZE = 'captionContainerResize';\n\n        /**\n         * Sent when enough data is available that the media can be played,\n         * at least for a couple of frames.  This corresponds to the\n         * HAVE_ENOUGH_DATA readyState.\n         * @event MediaPlayerEvents#CAN_PLAY\n         */\n        this.CAN_PLAY = 'canPlay';\n\n        /**\n         * Sent when playback completes.\n         * @event MediaPlayerEvents#PLAYBACK_ENDED\n         */\n        this.PLAYBACK_ENDED = 'playbackEnded';\n\n        /**\n         * Sent when an error occurs.  The element's error\n         * attribute contains more information.\n         * @event MediaPlayerEvents#PLAYBACK_ERROR\n         */\n        this.PLAYBACK_ERROR = 'playbackError';\n\n        /**\n         * Sent when playback is not allowed (for example if user gesture is needed).\n         * @event MediaPlayerEvents#PLAYBACK_NOT_ALLOWED\n         */\n        this.PLAYBACK_NOT_ALLOWED = 'playbackNotAllowed';\n\n        /**\n         * The media's metadata has finished loading; all attributes now\n         * contain as much useful information as they're going to.\n         * @event MediaPlayerEvents#PLAYBACK_METADATA_LOADED\n         */\n        this.PLAYBACK_METADATA_LOADED = 'playbackMetaDataLoaded';\n\n        /**\n         * Sent when playback is paused.\n         * @event MediaPlayerEvents#PLAYBACK_PAUSED\n         */\n        this.PLAYBACK_PAUSED = 'playbackPaused';\n\n        /**\n         * Sent when the media begins to play (either for the first time, after having been paused,\n         * or after ending and then restarting).\n         *\n         * @event MediaPlayerEvents#PLAYBACK_PLAYING\n         */\n        this.PLAYBACK_PLAYING = 'playbackPlaying';\n\n        /**\n         * Sent periodically to inform interested parties of progress downloading\n         * the media. Information about the current amount of the media that has\n         * been downloaded is available in the media element's buffered attribute.\n         * @event MediaPlayerEvents#PLAYBACK_PROGRESS\n         */\n        this.PLAYBACK_PROGRESS = 'playbackProgress';\n\n        /**\n         * Sent when the playback speed changes.\n         * @event MediaPlayerEvents#PLAYBACK_RATE_CHANGED\n         */\n        this.PLAYBACK_RATE_CHANGED = 'playbackRateChanged';\n\n        /**\n         * Sent when a seek operation completes.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKED\n         */\n        this.PLAYBACK_SEEKED = 'playbackSeeked';\n\n        /**\n         * Sent when a seek operation begins.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKING\n         */\n        this.PLAYBACK_SEEKING = 'playbackSeeking';\n\n        /**\n         * Sent when a seek operation has been asked.\n         * @event MediaPlayerEvents#PLAYBACK_SEEK_ASKED\n         */\n        this.PLAYBACK_SEEK_ASKED = 'playbackSeekAsked';\n\n        /**\n         * Sent when the video element reports stalled\n         * @event MediaPlayerEvents#PLAYBACK_STALLED\n         */\n        this.PLAYBACK_STALLED = 'playbackStalled';\n\n        /**\n         * Sent when playback of the media starts after having been paused;\n         * that is, when playback is resumed after a prior pause event.\n         *\n         * @event MediaPlayerEvents#PLAYBACK_STARTED\n         */\n        this.PLAYBACK_STARTED = 'playbackStarted';\n\n        /**\n         * The time indicated by the element's currentTime attribute has changed.\n         * @event MediaPlayerEvents#PLAYBACK_TIME_UPDATED\n         */\n        this.PLAYBACK_TIME_UPDATED = 'playbackTimeUpdated';\n\n        /**\n         * Sent when the media playback has stopped because of a temporary lack of data.\n         *\n         * @event MediaPlayerEvents#PLAYBACK_WAITING\n         */\n        this.PLAYBACK_WAITING = 'playbackWaiting';\n\n        /**\n         * Manifest validity changed - As a result of an MPD validity expiration event.\n         * @event MediaPlayerEvents#MANIFEST_VALIDITY_CHANGED\n         */\n        this.MANIFEST_VALIDITY_CHANGED = 'manifestValidityChanged';\n\n        /**\n         * A gap occured in the timeline which requires a seek to the next period\n         * @event MediaPlayerEvents#GAP_CAUSED_SEEK_TO_PERIOD_END\n         */\n        this.GAP_CAUSED_SEEK_TO_PERIOD_END = 'gapCausedSeekToPeriodEnd';\n\n        /**\n         * A gap occured in the timeline which requires an internal seek\n         * @event MediaPlayerEvents#GAP_CAUSED_INTERNAL_SEEK\n         */\n        this.GAP_CAUSED_INTERNAL_SEEK = 'gapCausedInternalSeek';\n\n        /**\n         * Dash events are triggered at their respective start points on the timeline.\n         * @event MediaPlayerEvents#EVENT_MODE_ON_START\n         */\n        this.EVENT_MODE_ON_START = 'eventModeOnStart';\n\n        /**\n         * Dash events are triggered as soon as they were parsed.\n         * @event MediaPlayerEvents#EVENT_MODE_ON_RECEIVE\n         */\n        this.EVENT_MODE_ON_RECEIVE = 'eventModeOnReceive';\n\n        /**\n         * Event that is dispatched whenever the player encounters a potential conformance validation that might lead to unexpected/not optimal behavior\n         * @event MediaPlayerEvents#CONFORMANCE_VIOLATION\n         */\n        this.CONFORMANCE_VIOLATION = 'conformanceViolation';\n    }\n}\n\nlet mediaPlayerEvents = new MediaPlayerEvents();\nexport default mediaPlayerEvents;\n"]},"metadata":{},"sourceType":"script"}