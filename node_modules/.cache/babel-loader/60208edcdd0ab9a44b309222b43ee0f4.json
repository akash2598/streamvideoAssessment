{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* This is a sink that is used to temporarily hold onto media chunks before a video element is added.\n* The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\n*\n* @class PreBufferSink\n* @ignore\n* @implements FragmentSink\n*/\n\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction PreBufferSink(onAppendedCallback) {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      outstandingInit = void 0;\n  var chunks = [];\n  var onAppended = onAppendedCallback;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function reset() {\n    chunks = [];\n    outstandingInit = null;\n    onAppended = null;\n  }\n\n  function append(chunk) {\n    if (chunk.segmentType !== 'InitializationSegment') {\n      //Init segments are stored in the initCache.\n      chunks.push(chunk);\n      chunks.sort(function (a, b) {\n        return a.start - b.start;\n      });\n      outstandingInit = null;\n    } else {\n      //We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\n      outstandingInit = chunk;\n    }\n\n    logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\n\n    if (onAppended) {\n      onAppended({\n        chunk: chunk\n      });\n    }\n  }\n\n  function remove(start, end) {\n    chunks = chunks.filter(function (a) {\n      return !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start));\n    }); //The opposite of the getChunks predicate.\n  } //Nothing async, nothing to abort.\n\n\n  function abort() {}\n\n  function getAllBufferRanges() {\n    var ranges = [];\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n\n      if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\n        ranges.push({\n          start: chunk.start,\n          end: chunk.end\n        });\n      } else {\n        ranges[ranges.length - 1].end = chunk.end;\n      }\n    } //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\n\n\n    var timeranges = {\n      start: function start(n) {\n        return ranges[n].start;\n      },\n      end: function end(n) {\n        return ranges[n].end;\n      }\n    };\n    Object.defineProperty(timeranges, 'length', {\n      get: function get() {\n        return ranges.length;\n      }\n    });\n    return timeranges;\n  }\n\n  function hasDiscontinuitiesAfter() {\n    return false;\n  }\n\n  function updateTimestampOffset() {// Nothing to do\n  }\n\n  function getBuffer() {\n    return this;\n  }\n  /**\n  * Return the all chunks in the buffer the lie between times start and end.\n  * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\n  * Chunks are removed from the buffer when they are discharged.\n  * @function PreBufferSink#discharge\n  * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n  * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n  * @returns {Array} The set of chunks from the buffer within the time ranges.\n  */\n\n\n  function discharge(start, end) {\n    var result = getChunksAt(start, end);\n\n    if (outstandingInit) {\n      result.push(outstandingInit);\n      outstandingInit = null;\n    }\n\n    remove(start, end);\n    return result;\n  }\n\n  function getChunksAt(start, end) {\n    return chunks.filter(function (a) {\n      return (isNaN(end) || a.start < end) && (isNaN(start) || a.end > start);\n    });\n  }\n\n  function waitForUpdateEnd(callback) {\n    callback();\n  }\n\n  instance = {\n    getAllBufferRanges: getAllBufferRanges,\n    append: append,\n    remove: remove,\n    abort: abort,\n    discharge: discharge,\n    reset: reset,\n    updateTimestampOffset: updateTimestampOffset,\n    hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n    waitForUpdateEnd: waitForUpdateEnd,\n    getBuffer: getBuffer\n  };\n  setup();\n  return instance;\n}\n\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\n\nvar factory = _FactoryMaker2.default.getClassFactory(PreBufferSink);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../src/streaming/PreBufferSink.js"],"names":["context","instance","logger","outstandingInit","chunks","onAppended","chunk","a","b","isNaN","ranges","i","start","end","timeranges","Object","get","result","getChunksAt","remove","callback","getAllBufferRanges","append","abort","discharge","reset","updateTimestampOffset","hasDiscontinuitiesAfter","waitForUpdateEnd","getBuffer","setup","PreBufferSink","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport FactoryMaker from '../core/FactoryMaker';\n\n/**\n * This is a sink that is used to temporarily hold onto media chunks before a video element is added.\n * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\n *\n * @class PreBufferSink\n * @ignore\n * @implements FragmentSink\n */\nfunction PreBufferSink(onAppendedCallback) {\n    const context = this.context;\n\n    let instance,\n        logger,\n        outstandingInit;\n    let chunks = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function reset() {\n        chunks = [];\n        outstandingInit = null;\n        onAppended = null;\n    }\n\n    function append(chunk) {\n        if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache.\n            chunks.push(chunk);\n            chunks.sort(function (a, b) { return a.start - b.start; });\n            outstandingInit = null;\n        } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\n            outstandingInit = chunk;\n        }\n\n        logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\n        if (onAppended) {\n            onAppended({\n                chunk: chunk\n            });\n        }\n    }\n\n    function remove(start, end) {\n        chunks = chunks.filter( a => !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start))); //The opposite of the getChunks predicate.\n    }\n\n    //Nothing async, nothing to abort.\n    function abort() {\n    }\n\n    function getAllBufferRanges() {\n        let ranges = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            let chunk = chunks[i];\n            if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\n                ranges.push({ start: chunk.start, end: chunk.end });\n            } else {\n                ranges[ranges.length - 1].end = chunk.end;\n            }\n        }\n\n        //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\n        const timeranges = {\n            start: function (n) {\n                return ranges[n].start;\n            },\n            end: function (n) {\n                return ranges[n].end;\n            }\n        };\n\n        Object.defineProperty(timeranges, 'length', {\n            get: function () {\n                return ranges.length;\n            }\n        });\n\n        return timeranges;\n    }\n\n    function hasDiscontinuitiesAfter() {\n        return false;\n    }\n\n    function updateTimestampOffset() {\n        // Nothing to do\n    }\n\n    function getBuffer() {\n        return this;\n    }\n\n    /**\n     * Return the all chunks in the buffer the lie between times start and end.\n     * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\n     * Chunks are removed from the buffer when they are discharged.\n     * @function PreBufferSink#discharge\n     * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @returns {Array} The set of chunks from the buffer within the time ranges.\n     */\n    function discharge(start, end) {\n        const result = getChunksAt(start, end);\n        if (outstandingInit) {\n            result.push(outstandingInit);\n            outstandingInit = null;\n        }\n\n        remove(start, end);\n\n        return result;\n    }\n\n    function getChunksAt(start, end) {\n        return chunks.filter( a => ((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start)) );\n    }\n\n    function waitForUpdateEnd(callback) {\n        callback();\n    }\n\n    instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        append: append,\n        remove: remove,\n        abort: abort,\n        discharge: discharge,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n        waitForUpdateEnd: waitForUpdateEnd,\n        getBuffer: getBuffer\n    };\n\n    setup();\n\n    return instance;\n}\n\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\nconst factory = FactoryMaker.getClassFactory(PreBufferSink);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}