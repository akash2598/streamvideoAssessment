{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nvar WEIGHT_SELECTION_MODES = {\n  MANUAL: 'manual_weight_selection',\n  RANDOM: 'random_weight_selection',\n  DYNAMIC: 'dynamic_weight_selection'\n};\n\nfunction LearningAbrController() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      somBitrateNeurons = void 0,\n      bitrateNormalizationFactor = void 0,\n      latencyNormalizationFactor = void 0,\n      minBitrate = void 0,\n      minBitrateNeuron = void 0,\n      weights = void 0,\n      sortedCenters = void 0,\n      weightSelectionMode = void 0;\n  /**\n  * Setup the class\n  */\n\n  function _setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n\n    _resetInitialSettings();\n  }\n  /**\n  * Reset all values\n  */\n\n\n  function reset() {\n    _resetInitialSettings();\n  }\n  /**\n  * Reset to initial settings\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    somBitrateNeurons = null;\n    bitrateNormalizationFactor = 1;\n    latencyNormalizationFactor = 100;\n    minBitrate = 0;\n    minBitrateNeuron = null;\n    weights = null;\n    sortedCenters = null;\n    weightSelectionMode = WEIGHT_SELECTION_MODES.DYNAMIC;\n  }\n  /**\n  * Returns the maximum throughput\n  * @return {number}\n  * @private\n  */\n\n\n  function _getMaxThroughput() {\n    var maxThroughput = 0;\n\n    if (somBitrateNeurons) {\n      for (var i = 0; i < somBitrateNeurons.length; i++) {\n        var neuron = somBitrateNeurons[i];\n\n        if (neuron.state.throughput > maxThroughput) {\n          maxThroughput = neuron.state.throughput;\n        }\n      }\n    }\n\n    return maxThroughput;\n  }\n  /**\n  *\n  * @param {array} w\n  * @return {number}\n  * @private\n  */\n\n\n  function _getMagnitude(w) {\n    var magnitude = w.map(function (x) {\n      return Math.pow(x, 2);\n    }).reduce(function (sum, now) {\n      return sum + now;\n    });\n    return Math.sqrt(magnitude);\n  }\n  /**\n  *\n  * @param {array} a\n  * @param {array} b\n  * @param {array} w\n  * @return {number}\n  * @private\n  */\n\n\n  function _getDistance(a, b, w) {\n    var sum = a.map(function (x, i) {\n      return w[i] * Math.pow(x - b[i], 2);\n    }) // square the difference*w\n    .reduce(function (sum, now) {\n      return sum + now;\n    }); // sum\n\n    var sign = sum < 0 ? -1 : 1;\n    return sign * Math.sqrt(Math.abs(sum));\n  }\n  /**\n  *\n  * @param {object} a\n  * @param {object} b\n  * @return {number}\n  * @private\n  */\n\n\n  function _getNeuronDistance(a, b) {\n    var aState = [a.state.throughput, a.state.latency, a.state.rebuffer, a.state.switch];\n    var bState = [b.state.throughput, b.state.latency, b.state.rebuffer, b.state.switch];\n    return _getDistance(aState, bState, [1, 1, 1, 1]);\n  }\n  /**\n  *\n  * @param {object} winnerNeuron\n  * @param {array} somElements\n  * @param {array} x\n  * @private\n  */\n\n\n  function _updateNeurons(winnerNeuron, somElements, x) {\n    for (var i = 0; i < somElements.length; i++) {\n      var somNeuron = somElements[i];\n      var sigma = 0.1;\n\n      var neuronDistance = _getNeuronDistance(somNeuron, winnerNeuron);\n\n      var neighbourHood = Math.exp(-1 * Math.pow(neuronDistance, 2) / (2 * Math.pow(sigma, 2)));\n\n      _updateNeuronState(somNeuron, x, neighbourHood);\n    }\n  }\n  /**\n  *\n  * @param {object} neuron\n  * @param {array} x\n  * @param {object} neighbourHood\n  * @private\n  */\n\n\n  function _updateNeuronState(neuron, x, neighbourHood) {\n    var state = neuron.state;\n    var w = [0.01, 0.01, 0.01, 0.01]; // learning rate\n\n    state.throughput = state.throughput + (x[0] - state.throughput) * w[0] * neighbourHood;\n    state.latency = state.latency + (x[1] - state.latency) * w[1] * neighbourHood;\n    state.rebuffer = state.rebuffer + (x[2] - state.rebuffer) * w[2] * neighbourHood;\n    state.switch = state.switch + (x[3] - state.switch) * w[3] * neighbourHood;\n  }\n  /**\n  *\n  * @param {object} currentNeuron\n  * @param {number} currentThroughput\n  * @return {object}\n  * @private\n  */\n\n\n  function _getDownShiftNeuron(currentNeuron, currentThroughput) {\n    var maxSuitableBitrate = 0;\n    var result = currentNeuron;\n\n    if (somBitrateNeurons) {\n      for (var i = 0; i < somBitrateNeurons.length; i++) {\n        var n = somBitrateNeurons[i];\n\n        if (n.bitrate < currentNeuron.bitrate && n.bitrate > maxSuitableBitrate && currentThroughput > n.bitrate) {\n          // possible downshiftable neuron\n          maxSuitableBitrate = n.bitrate;\n          result = n;\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n  *\n  * @param {object} mediaInfo\n  * @param {number} throughput\n  * @param {number} latency\n  * @param {number} bufferSize\n  * @param {number} playbackRate\n  * @param {number} currentQualityIndex\n  * @param {object} dynamicWeightsSelector\n  * @return {null|*}\n  */\n\n\n  function getNextQuality(mediaInfo, throughput, latency, bufferSize, playbackRate, currentQualityIndex, dynamicWeightsSelector) {\n    // For Dynamic Weights Selector\n    var currentLatency = latency;\n    var currentBuffer = bufferSize;\n    var currentThroughput = throughput;\n\n    var somElements = _getSomBitrateNeurons(mediaInfo); // normalize throughput\n\n\n    var throughputNormalized = throughput / bitrateNormalizationFactor; // saturate values higher than 1\n\n    if (throughputNormalized > 1) {\n      throughputNormalized = _getMaxThroughput();\n    } // normalize latency\n\n\n    latency = latency / latencyNormalizationFactor;\n    var targetLatency = 0;\n    var targetRebufferLevel = 0;\n    var targetSwitch = 0; // 10K + video encoding is the recommended throughput\n\n    var throughputDelta = 10000;\n    logger.debug('getNextQuality called throughput:' + throughputNormalized + ' latency:' + latency + ' bufferSize:' + bufferSize + ' currentQualityIndex:' + currentQualityIndex + ' playbackRate:' + playbackRate);\n    var currentNeuron = somElements[currentQualityIndex];\n    var downloadTime = currentNeuron.bitrate * dynamicWeightsSelector.getSegmentDuration() / currentThroughput;\n    var rebuffer = Math.max(0, downloadTime - currentBuffer); // check buffer for possible stall\n\n    if (currentBuffer - downloadTime < dynamicWeightsSelector.getMinBuffer()) {\n      logger.debug('Buffer is low for bitrate= ' + currentNeuron.bitrate + ' downloadTime=' + downloadTime + ' currentBuffer=' + currentBuffer + ' rebuffer=' + rebuffer);\n      return _getDownShiftNeuron(currentNeuron, currentThroughput).qualityIndex;\n    }\n\n    switch (weightSelectionMode) {\n      case WEIGHT_SELECTION_MODES.MANUAL:\n        _manualWeightSelection();\n\n        break;\n\n      case WEIGHT_SELECTION_MODES.RANDOM:\n        _randomWeightSelection(somElements);\n\n        break;\n\n      case WEIGHT_SELECTION_MODES.DYNAMIC:\n        _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n        break;\n\n      default:\n        _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n    }\n\n    var minDistance = null;\n    var minIndex = null;\n    var winnerNeuron = null;\n    var winnerWeights = null;\n\n    for (var i = 0; i < somElements.length; i++) {\n      var somNeuron = somElements[i];\n      var somNeuronState = somNeuron.state;\n      var somData = [somNeuronState.throughput, somNeuronState.latency, somNeuronState.rebuffer, somNeuronState.switch];\n      var distanceWeights = weights.slice();\n      var nextBuffer = dynamicWeightsSelector.getNextBufferWithBitrate(somNeuron.bitrate, currentBuffer, currentThroughput);\n      var isBufferLow = nextBuffer < dynamicWeightsSelector.getMinBuffer();\n\n      if (isBufferLow) {\n        logger.debug('Buffer is low for bitrate=' + somNeuron.bitrate + ' downloadTime=' + downloadTime + ' currentBuffer=' + currentBuffer + ' nextBuffer=' + nextBuffer);\n      } // special condition downshift immediately\n\n\n      if (somNeuron.bitrate > throughput - throughputDelta || isBufferLow) {\n        if (somNeuron.bitrate !== minBitrate) {\n          // encourage to pick smaller bitrates throughputWeight=100\n          distanceWeights[0] = 100;\n        }\n      } // calculate the distance with the target\n\n\n      var distance = _getDistance(somData, [throughputNormalized, targetLatency, targetRebufferLevel, targetSwitch], distanceWeights);\n\n      if (minDistance === null || distance < minDistance) {\n        minDistance = distance;\n        minIndex = somNeuron.qualityIndex;\n        winnerNeuron = somNeuron;\n        winnerWeights = distanceWeights;\n      }\n    } // update current neuron and the neighbourhood with the calculated QoE\n    // will punish current if it is not picked\n\n\n    var bitrateSwitch = Math.abs(currentNeuron.bitrate - winnerNeuron.bitrate) / bitrateNormalizationFactor;\n\n    _updateNeurons(currentNeuron, somElements, [throughputNormalized, latency, rebuffer, bitrateSwitch]); // update bmu and  neighbours with targetQoE=1, targetLatency=0\n\n\n    _updateNeurons(winnerNeuron, somElements, [throughputNormalized, targetLatency, targetRebufferLevel, bitrateSwitch]);\n\n    return minIndex;\n  }\n  /**\n  * Option 1: Manual weights\n  * @private\n  */\n\n\n  function _manualWeightSelection() {\n    var throughputWeight = 0.4;\n    var latencyWeight = 0.4;\n    var bufferWeight = 0.4;\n    var switchWeight = 0.4;\n    weights = [throughputWeight, latencyWeight, bufferWeight, switchWeight]; // throughput, latency, buffer, switch\n  }\n  /**\n      * Option 2: Random (Xavier) weights\n      * @param {array} somElements\n      * @private\n      */\n\n\n  function _randomWeightSelection(somElements) {\n    weights = _getXavierWeights(somElements.length, 4);\n  }\n  /**\n  * Dynamic Weight Selector weights\n  * @param {object} dynamicWeightsSelector\n  * @param {array} somElements\n  * @param {number} currentLatency\n  * @param {number} currentBuffer\n  * @param {number} rebuffer\n  * @param {number} currentThroughput\n  * @param {number} playbackRate\n  * @private\n  */\n\n\n  function _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate) {\n    if (!weights) {\n      weights = sortedCenters[sortedCenters.length - 1];\n    } // Dynamic Weights Selector (step 2/2: find weights)\n\n\n    var weightVector = dynamicWeightsSelector.findWeightVector(somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n    if (weightVector !== null && weightVector !== -1) {\n      // null: something went wrong, -1: constraints not met\n      weights = weightVector;\n    }\n  }\n  /**\n  *\n  * @param {number }neuronCount\n  * @param {number }weightCount\n  * @return {array}\n  * @private\n  */\n\n\n  function _getXavierWeights(neuronCount, weightCount) {\n    var W = [];\n    var upperBound = Math.sqrt(2 / neuronCount);\n\n    for (var i = 0; i < weightCount; i++) {\n      W.push(Math.random() * upperBound);\n    }\n\n    weights = W;\n    return weights;\n  }\n  /**\n  *\n  * @param {object} mediaInfo\n  * @return {array}\n  * @private\n  */\n\n\n  function _getSomBitrateNeurons(mediaInfo) {\n    if (!somBitrateNeurons) {\n      somBitrateNeurons = [];\n      var bitrateList = mediaInfo.bitrateList;\n      var bitrateVector = [];\n      minBitrate = bitrateList[0].bandwidth;\n      bitrateList.forEach(function (element) {\n        bitrateVector.push(element.bandwidth);\n\n        if (element.bandwidth < minBitrate) {\n          minBitrate = element.bandwidth;\n        }\n      });\n      bitrateNormalizationFactor = _getMagnitude(bitrateVector);\n\n      for (var i = 0; i < bitrateList.length; i++) {\n        var neuron = {\n          qualityIndex: i,\n          bitrate: bitrateList[i].bandwidth,\n          state: {\n            // normalize throughputs\n            throughput: bitrateList[i].bandwidth / bitrateNormalizationFactor,\n            latency: 0,\n            rebuffer: 0,\n            switch: 0\n          }\n        };\n        somBitrateNeurons.push(neuron);\n\n        if (neuron.bitrate === minBitrate) {\n          minBitrateNeuron = neuron;\n        }\n      }\n\n      sortedCenters = _getInitialKmeansPlusPlusCenters(somBitrateNeurons);\n    }\n\n    return somBitrateNeurons;\n  }\n  /**\n  *\n  * @param {number} size\n  * @return {array}\n  * @private\n  */\n\n\n  function _getRandomData(size) {\n    var dataArray = [];\n\n    for (var i = 0; i < size; i++) {\n      var data = [Math.random() * _getMaxThroughput(), //throughput\n      Math.random(), //latency\n      Math.random(), //buffersize\n      Math.random() //switch\n      ];\n      dataArray.push(data);\n    }\n\n    return dataArray;\n  }\n  /**\n  *\n  * @param {array} somElements\n  * @return {array}\n  * @private\n  */\n\n\n  function _getInitialKmeansPlusPlusCenters(somElements) {\n    var centers = [];\n\n    var randomDataSet = _getRandomData(Math.pow(somElements.length, 2));\n\n    centers.push(randomDataSet[0]);\n    var distanceWeights = [1, 1, 1, 1];\n\n    for (var k = 1; k < somElements.length; k++) {\n      var nextPoint = null;\n      var _maxDistance = null;\n\n      for (var i = 0; i < randomDataSet.length; i++) {\n        var currentPoint = randomDataSet[i];\n        var minDistance = null;\n\n        for (var j = 0; j < centers.length; j++) {\n          var distance = _getDistance(currentPoint, centers[j], distanceWeights);\n\n          if (minDistance === null || distance < minDistance) {\n            minDistance = distance;\n          }\n        }\n\n        if (_maxDistance === null || minDistance > _maxDistance) {\n          nextPoint = currentPoint;\n          _maxDistance = minDistance;\n        }\n      }\n\n      centers.push(nextPoint);\n    } // find the least similar center\n\n\n    var maxDistance = null;\n    var leastSimilarIndex = null;\n\n    for (var _i = 0; _i < centers.length; _i++) {\n      var _distance = 0;\n\n      for (var _j = 0; _j < centers.length; _j++) {\n        if (_i === _j) continue;\n        _distance += _getDistance(centers[_i], centers[_j], distanceWeights);\n      }\n\n      if (maxDistance === null || _distance > maxDistance) {\n        maxDistance = _distance;\n        leastSimilarIndex = _i;\n      }\n    } // move centers to sortedCenters\n\n\n    var sortedCenters = [];\n    sortedCenters.push(centers[leastSimilarIndex]);\n    centers.splice(leastSimilarIndex, 1);\n\n    while (centers.length > 0) {\n      var _minDistance = null;\n      var minIndex = null;\n\n      for (var _i2 = 0; _i2 < centers.length; _i2++) {\n        var _distance2 = _getDistance(sortedCenters[0], centers[_i2], distanceWeights);\n\n        if (_minDistance === null || _distance2 < _minDistance) {\n          _minDistance = _distance2;\n          minIndex = _i2;\n        }\n      }\n\n      sortedCenters.push(centers[minIndex]);\n      centers.splice(minIndex, 1);\n    }\n\n    return sortedCenters;\n  }\n\n  instance = {\n    getNextQuality: getNextQuality,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n\nLearningAbrController.__dashjs_factory_name = 'LearningAbrController';\nexports.default = _FactoryMaker2.default.getClassFactory(LearningAbrController);","map":{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LearningAbrController.js"],"names":["WEIGHT_SELECTION_MODES","MANUAL","RANDOM","DYNAMIC","context","instance","logger","somBitrateNeurons","bitrateNormalizationFactor","latencyNormalizationFactor","minBitrate","minBitrateNeuron","weights","sortedCenters","weightSelectionMode","_resetInitialSettings","maxThroughput","i","neuron","magnitude","w","Math","sum","x","b","sign","aState","a","bState","_getDistance","somElements","somNeuron","sigma","neuronDistance","_getNeuronDistance","neighbourHood","_updateNeuronState","state","maxSuitableBitrate","result","n","currentNeuron","currentThroughput","currentLatency","currentBuffer","_getSomBitrateNeurons","throughputNormalized","throughput","_getMaxThroughput","latency","targetLatency","targetRebufferLevel","targetSwitch","throughputDelta","downloadTime","dynamicWeightsSelector","rebuffer","_getDownShiftNeuron","_manualWeightSelection","_randomWeightSelection","_dynamicWeightSelection","minDistance","minIndex","winnerNeuron","winnerWeights","somNeuronState","somData","distanceWeights","nextBuffer","isBufferLow","distance","bitrateSwitch","_updateNeurons","throughputWeight","latencyWeight","bufferWeight","switchWeight","_getXavierWeights","weightVector","W","upperBound","bitrateList","mediaInfo","bitrateVector","element","_getMagnitude","qualityIndex","bitrate","switch","_getInitialKmeansPlusPlusCenters","dataArray","data","centers","randomDataSet","_getRandomData","k","nextPoint","maxDistance","currentPoint","j","leastSimilarIndex","getNextQuality","reset","_setup","LearningAbrController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport FactoryMaker from '../../../../core/FactoryMaker';\nimport Debug from '../../../../core/Debug';\n\nconst WEIGHT_SELECTION_MODES = {\n    MANUAL: 'manual_weight_selection',\n    RANDOM: 'random_weight_selection',\n    DYNAMIC: 'dynamic_weight_selection'\n};\n\nfunction LearningAbrController() {\n    const context = this.context;\n\n    let instance,\n        logger,\n        somBitrateNeurons,\n        bitrateNormalizationFactor,\n        latencyNormalizationFactor,\n        minBitrate,\n        minBitrateNeuron,\n        weights,\n        sortedCenters,\n        weightSelectionMode;\n\n    /**\n     * Setup the class\n     */\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n    }\n\n    /**\n     * Reset all values\n     */\n    function reset() {\n        _resetInitialSettings();\n    }\n\n    /**\n     * Reset to initial settings\n     * @private\n     */\n    function _resetInitialSettings() {\n        somBitrateNeurons = null;\n        bitrateNormalizationFactor = 1;\n        latencyNormalizationFactor = 100;\n        minBitrate = 0;\n        minBitrateNeuron = null;\n        weights = null;\n        sortedCenters = null;\n        weightSelectionMode = WEIGHT_SELECTION_MODES.DYNAMIC;\n    }\n\n    /**\n     * Returns the maximum throughput\n     * @return {number}\n     * @private\n     */\n    function _getMaxThroughput() {\n        let maxThroughput = 0;\n\n        if (somBitrateNeurons) {\n            for (let i = 0; i < somBitrateNeurons.length; i++) {\n                let neuron = somBitrateNeurons[i];\n                if (neuron.state.throughput > maxThroughput) {\n                    maxThroughput = neuron.state.throughput;\n                }\n            }\n        }\n\n        return maxThroughput;\n    }\n\n    /**\n     *\n     * @param {array} w\n     * @return {number}\n     * @private\n     */\n    function _getMagnitude(w) {\n        const magnitude = w.map((x) => (Math.pow(x, 2))).reduce((sum, now) => sum + now);\n\n        return Math.sqrt(magnitude);\n    }\n\n    /**\n     *\n     * @param {array} a\n     * @param {array} b\n     * @param {array} w\n     * @return {number}\n     * @private\n     */\n    function _getDistance(a, b, w) {\n        let sum = a\n            .map((x, i) => (w[i] * (Math.pow(x - b[i], 2)))) // square the difference*w\n            .reduce((sum, now) => sum + now); // sum\n        let sign = (sum < 0) ? -1 : 1;\n\n        return sign * Math.sqrt(Math.abs(sum));\n    }\n\n    /**\n     *\n     * @param {object} a\n     * @param {object} b\n     * @return {number}\n     * @private\n     */\n    function _getNeuronDistance(a, b) {\n        let aState = [a.state.throughput, a.state.latency, a.state.rebuffer, a.state.switch];\n        let bState = [b.state.throughput, b.state.latency, b.state.rebuffer, b.state.switch];\n\n        return _getDistance(aState, bState, [1, 1, 1, 1]);\n    }\n\n    /**\n     *\n     * @param {object} winnerNeuron\n     * @param {array} somElements\n     * @param {array} x\n     * @private\n     */\n    function _updateNeurons(winnerNeuron, somElements, x) {\n        for (let i = 0; i < somElements.length; i++) {\n            let somNeuron = somElements[i];\n            let sigma = 0.1;\n            const neuronDistance = _getNeuronDistance(somNeuron, winnerNeuron);\n            let neighbourHood = Math.exp(-1 * Math.pow(neuronDistance, 2) / (2 * Math.pow(sigma, 2)));\n            _updateNeuronState(somNeuron, x, neighbourHood);\n        }\n    }\n\n    /**\n     *\n     * @param {object} neuron\n     * @param {array} x\n     * @param {object} neighbourHood\n     * @private\n     */\n    function _updateNeuronState(neuron, x, neighbourHood) {\n        let state = neuron.state;\n        let w = [0.01, 0.01, 0.01, 0.01]; // learning rate\n\n        state.throughput = state.throughput + (x[0] - state.throughput) * w[0] * neighbourHood;\n        state.latency = state.latency + (x[1] - state.latency) * w[1] * neighbourHood;\n        state.rebuffer = state.rebuffer + (x[2] - state.rebuffer) * w[2] * neighbourHood;\n        state.switch = state.switch + (x[3] - state.switch) * w[3] * neighbourHood;\n    }\n\n    /**\n     *\n     * @param {object} currentNeuron\n     * @param {number} currentThroughput\n     * @return {object}\n     * @private\n     */\n    function _getDownShiftNeuron(currentNeuron, currentThroughput) {\n        let maxSuitableBitrate = 0;\n        let result = currentNeuron;\n\n        if (somBitrateNeurons) {\n            for (let i = 0; i < somBitrateNeurons.length; i++) {\n                let n = somBitrateNeurons[i];\n                if (n.bitrate < currentNeuron.bitrate && n.bitrate > maxSuitableBitrate && currentThroughput > n.bitrate) {\n                    // possible downshiftable neuron\n                    maxSuitableBitrate = n.bitrate;\n                    result = n;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {object} mediaInfo\n     * @param {number} throughput\n     * @param {number} latency\n     * @param {number} bufferSize\n     * @param {number} playbackRate\n     * @param {number} currentQualityIndex\n     * @param {object} dynamicWeightsSelector\n     * @return {null|*}\n     */\n    function getNextQuality(mediaInfo, throughput, latency, bufferSize, playbackRate, currentQualityIndex, dynamicWeightsSelector) {\n        // For Dynamic Weights Selector\n        let currentLatency = latency;\n        let currentBuffer = bufferSize;\n        let currentThroughput = throughput;\n\n        let somElements = _getSomBitrateNeurons(mediaInfo);\n        // normalize throughput\n        let throughputNormalized = throughput / bitrateNormalizationFactor;\n        // saturate values higher than 1\n        if (throughputNormalized > 1) {\n            throughputNormalized = _getMaxThroughput();\n        }\n        // normalize latency\n        latency = latency / latencyNormalizationFactor;\n\n        const targetLatency = 0;\n        const targetRebufferLevel = 0;\n        const targetSwitch = 0;\n        // 10K + video encoding is the recommended throughput\n        const throughputDelta = 10000;\n\n        logger.debug(`getNextQuality called throughput:${throughputNormalized} latency:${latency} bufferSize:${bufferSize} currentQualityIndex:${currentQualityIndex} playbackRate:${playbackRate}`);\n\n        let currentNeuron = somElements[currentQualityIndex];\n        let downloadTime = (currentNeuron.bitrate * dynamicWeightsSelector.getSegmentDuration()) / currentThroughput;\n        let rebuffer = Math.max(0, (downloadTime - currentBuffer));\n\n        // check buffer for possible stall\n        if (currentBuffer - downloadTime < dynamicWeightsSelector.getMinBuffer()) {\n            logger.debug(`Buffer is low for bitrate= ${currentNeuron.bitrate} downloadTime=${downloadTime} currentBuffer=${currentBuffer} rebuffer=${rebuffer}`);\n            return _getDownShiftNeuron(currentNeuron, currentThroughput).qualityIndex;\n        }\n\n        switch (weightSelectionMode) {\n            case WEIGHT_SELECTION_MODES.MANUAL:\n                _manualWeightSelection();\n                break;\n            case WEIGHT_SELECTION_MODES.RANDOM:\n                _randomWeightSelection(somElements);\n                break;\n            case WEIGHT_SELECTION_MODES.DYNAMIC:\n                _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n                break;\n            default:\n                _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n\n        }\n\n        let minDistance = null;\n        let minIndex = null;\n        let winnerNeuron = null;\n        let winnerWeights = null;\n\n        for (let i = 0; i < somElements.length; i++) {\n            let somNeuron = somElements[i];\n            let somNeuronState = somNeuron.state;\n            let somData = [somNeuronState.throughput,\n                somNeuronState.latency,\n                somNeuronState.rebuffer,\n                somNeuronState.switch];\n\n            let distanceWeights = weights.slice();\n            let nextBuffer = dynamicWeightsSelector.getNextBufferWithBitrate(somNeuron.bitrate, currentBuffer, currentThroughput);\n            let isBufferLow = nextBuffer < dynamicWeightsSelector.getMinBuffer();\n            if (isBufferLow) {\n                logger.debug(`Buffer is low for bitrate=${somNeuron.bitrate} downloadTime=${downloadTime} currentBuffer=${currentBuffer} nextBuffer=${nextBuffer}`);\n            }\n            // special condition downshift immediately\n            if (somNeuron.bitrate > throughput - throughputDelta || isBufferLow) {\n                if (somNeuron.bitrate !== minBitrate) {\n                    // encourage to pick smaller bitrates throughputWeight=100\n                    distanceWeights[0] = 100;\n                }\n            }\n\n            // calculate the distance with the target\n            let distance = _getDistance(somData, [throughputNormalized, targetLatency, targetRebufferLevel, targetSwitch], distanceWeights);\n            if (minDistance === null || distance < minDistance) {\n                minDistance = distance;\n                minIndex = somNeuron.qualityIndex;\n                winnerNeuron = somNeuron;\n                winnerWeights = distanceWeights;\n            }\n        }\n\n        // update current neuron and the neighbourhood with the calculated QoE\n        // will punish current if it is not picked\n        let bitrateSwitch = Math.abs(currentNeuron.bitrate - winnerNeuron.bitrate) / bitrateNormalizationFactor;\n        _updateNeurons(currentNeuron, somElements, [throughputNormalized, latency, rebuffer, bitrateSwitch]);\n\n        // update bmu and  neighbours with targetQoE=1, targetLatency=0\n        _updateNeurons(winnerNeuron, somElements, [throughputNormalized, targetLatency, targetRebufferLevel, bitrateSwitch]);\n\n        return minIndex;\n    }\n\n    /**\n     * Option 1: Manual weights\n     * @private\n     */\n    function _manualWeightSelection() {\n        let throughputWeight = 0.4;\n        let latencyWeight = 0.4;\n        let bufferWeight = 0.4;\n        let switchWeight = 0.4;\n\n        weights = [throughputWeight, latencyWeight, bufferWeight, switchWeight]; // throughput, latency, buffer, switch\n    }\n\n    /**\n     * Option 2: Random (Xavier) weights\n     * @param {array} somElements\n     * @private\n     */\n    function _randomWeightSelection(somElements) {\n        weights = _getXavierWeights(somElements.length, 4);\n    }\n\n    /**\n     * Dynamic Weight Selector weights\n     * @param {object} dynamicWeightsSelector\n     * @param {array} somElements\n     * @param {number} currentLatency\n     * @param {number} currentBuffer\n     * @param {number} rebuffer\n     * @param {number} currentThroughput\n     * @param {number} playbackRate\n     * @private\n     */\n    function _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate) {\n        if (!weights) {\n            weights = sortedCenters[sortedCenters.length - 1];\n        }\n        // Dynamic Weights Selector (step 2/2: find weights)\n        let weightVector = dynamicWeightsSelector.findWeightVector(somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\n        if (weightVector !== null && weightVector !== -1) {   // null: something went wrong, -1: constraints not met\n            weights = weightVector;\n        }\n    }\n\n    /**\n     *\n     * @param {number }neuronCount\n     * @param {number }weightCount\n     * @return {array}\n     * @private\n     */\n    function _getXavierWeights(neuronCount, weightCount) {\n        let W = [];\n        let upperBound = Math.sqrt((2 / neuronCount));\n\n        for (let i = 0; i < weightCount; i++) {\n            W.push(Math.random() * upperBound);\n        }\n\n        weights = W;\n\n        return weights;\n    }\n\n    /**\n     *\n     * @param {object} mediaInfo\n     * @return {array}\n     * @private\n     */\n    function _getSomBitrateNeurons(mediaInfo) {\n        if (!somBitrateNeurons) {\n            somBitrateNeurons = [];\n            const bitrateList = mediaInfo.bitrateList;\n            let bitrateVector = [];\n            minBitrate = bitrateList[0].bandwidth;\n\n            bitrateList.forEach(element => {\n                bitrateVector.push(element.bandwidth);\n                if (element.bandwidth < minBitrate) {\n                    minBitrate = element.bandwidth;\n                }\n            });\n            bitrateNormalizationFactor = _getMagnitude(bitrateVector);\n\n            for (let i = 0; i < bitrateList.length; i++) {\n                let neuron = {\n                    qualityIndex: i,\n                    bitrate: bitrateList[i].bandwidth,\n                    state: {\n                        // normalize throughputs\n                        throughput: bitrateList[i].bandwidth / bitrateNormalizationFactor,\n                        latency: 0,\n                        rebuffer: 0,\n                        switch: 0\n                    }\n                };\n                somBitrateNeurons.push(neuron);\n                if (neuron.bitrate === minBitrate) {\n                    minBitrateNeuron = neuron;\n                }\n            }\n\n            sortedCenters = _getInitialKmeansPlusPlusCenters(somBitrateNeurons);\n        }\n\n        return somBitrateNeurons;\n    }\n\n    /**\n     *\n     * @param {number} size\n     * @return {array}\n     * @private\n     */\n    function _getRandomData(size) {\n        let dataArray = [];\n\n        for (let i = 0; i < size; i++) {\n            let data = [\n                Math.random() * _getMaxThroughput(), //throughput\n                Math.random(), //latency\n                Math.random(), //buffersize\n                Math.random() //switch\n            ];\n            dataArray.push(data);\n        }\n\n        return dataArray;\n    }\n\n    /**\n     *\n     * @param {array} somElements\n     * @return {array}\n     * @private\n     */\n    function _getInitialKmeansPlusPlusCenters(somElements) {\n        let centers = [];\n        let randomDataSet = _getRandomData(Math.pow(somElements.length, 2));\n        centers.push(randomDataSet[0]);\n        let distanceWeights = [1, 1, 1, 1];\n\n        for (let k = 1; k < somElements.length; k++) {\n            let nextPoint = null;\n            let maxDistance = null;\n            for (let i = 0; i < randomDataSet.length; i++) {\n                let currentPoint = randomDataSet[i];\n                let minDistance = null;\n                for (let j = 0; j < centers.length; j++) {\n                    let distance = _getDistance(currentPoint, centers[j], distanceWeights);\n                    if (minDistance === null || distance < minDistance) {\n                        minDistance = distance;\n                    }\n                }\n                if (maxDistance === null || minDistance > maxDistance) {\n                    nextPoint = currentPoint;\n                    maxDistance = minDistance;\n                }\n            }\n            centers.push(nextPoint);\n        }\n\n        // find the least similar center\n        let maxDistance = null;\n        let leastSimilarIndex = null;\n        for (let i = 0; i < centers.length; i++) {\n            let distance = 0;\n            for (let j = 0; j < centers.length; j++) {\n                if (i === j) continue;\n                distance += _getDistance(centers[i], centers[j], distanceWeights);\n            }\n            if (maxDistance === null || distance > maxDistance) {\n                maxDistance = distance;\n                leastSimilarIndex = i;\n            }\n        }\n\n        // move centers to sortedCenters\n        let sortedCenters = [];\n        sortedCenters.push(centers[leastSimilarIndex]);\n        centers.splice(leastSimilarIndex, 1);\n        while (centers.length > 0) {\n            let minDistance = null;\n            let minIndex = null;\n            for (let i = 0; i < centers.length; i++) {\n                let distance = _getDistance(sortedCenters[0], centers[i], distanceWeights);\n                if (minDistance === null || distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = i;\n                }\n            }\n            sortedCenters.push(centers[minIndex]);\n            centers.splice(minIndex, 1);\n        }\n\n        return sortedCenters;\n    }\n\n    instance = {\n        getNextQuality,\n        reset\n    };\n\n    _setup();\n    return instance;\n}\n\nLearningAbrController.__dashjs_factory_name = 'LearningAbrController';\nexport default FactoryMaker.getClassFactory(LearningAbrController);\n"]},"metadata":{},"sourceType":"script"}