{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('./FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _MediaPlayerEvents = require('../streaming/MediaPlayerEvents');\n\nvar _MediaPlayerEvents2 = _interopRequireDefault(_MediaPlayerEvents);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar EVENT_PRIORITY_LOW = 0;\nvar EVENT_PRIORITY_HIGH = 5000;\n\nfunction EventBus() {\n  var handlers = {};\n\n  function on(type, listener, scope) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (!type) {\n      throw new Error('event type cannot be null or undefined');\n    }\n\n    if (!listener || typeof listener !== 'function') {\n      throw new Error('listener must be a function: ' + listener);\n    }\n\n    var priority = options.priority || EVENT_PRIORITY_LOW;\n    if (getHandlerIdx(type, listener, scope) >= 0) return;\n    handlers[type] = handlers[type] || [];\n    var handler = {\n      callback: listener,\n      scope: scope,\n      priority: priority\n    };\n\n    if (scope && scope.getStreamId) {\n      handler.streamId = scope.getStreamId();\n    }\n\n    if (scope && scope.getType) {\n      handler.mediaType = scope.getType();\n    }\n\n    if (options && options.mode) {\n      handler.mode = options.mode;\n    }\n\n    var inserted = handlers[type].some(function (item, idx) {\n      if (item && priority > item.priority) {\n        handlers[type].splice(idx, 0, handler);\n        return true;\n      }\n    });\n\n    if (!inserted) {\n      handlers[type].push(handler);\n    }\n  }\n\n  function off(type, listener, scope) {\n    if (!type || !listener || !handlers[type]) return;\n    var idx = getHandlerIdx(type, listener, scope);\n    if (idx < 0) return;\n    handlers[type][idx] = null;\n  }\n\n  function trigger(type) {\n    var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var filters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!type || !handlers[type]) return;\n    payload = payload || {};\n    if (payload.hasOwnProperty('type')) throw new Error('\\'type\\' is a reserved word for event dispatching');\n    payload.type = type;\n\n    if (filters.streamId) {\n      payload.streamId = filters.streamId;\n    }\n\n    if (filters.mediaType) {\n      payload.mediaType = filters.mediaType;\n    }\n\n    handlers[type].filter(function (handler) {\n      if (!handler) {\n        return false;\n      }\n\n      if (filters.streamId && handler.streamId && handler.streamId !== filters.streamId) {\n        return false;\n      }\n\n      if (filters.mediaType && handler.mediaType && handler.mediaType !== filters.mediaType) {\n        return false;\n      } // This is used for dispatching DASH events. By default we use the onStart mode. Consequently we filter everything that has a non matching mode and the onReceive events for handlers that did not specify a mode.\n\n\n      if (filters.mode && handler.mode && handler.mode !== filters.mode || !handler.mode && filters.mode && filters.mode === _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE) {\n        return false;\n      }\n\n      return true;\n    }).forEach(function (handler) {\n      return handler && handler.callback.call(handler.scope, payload);\n    });\n  }\n\n  function getHandlerIdx(type, listener, scope) {\n    var idx = -1;\n    if (!handlers[type]) return idx;\n    handlers[type].some(function (item, index) {\n      if (item && item.callback === listener && (!scope || scope === item.scope)) {\n        idx = index;\n        return true;\n      }\n    });\n    return idx;\n  }\n\n  function reset() {\n    handlers = {};\n  }\n\n  var instance = {\n    on: on,\n    off: off,\n    trigger: trigger,\n    reset: reset\n  };\n  return instance;\n}\n\nEventBus.__dashjs_factory_name = 'EventBus';\n\nvar factory = _FactoryMaker2.default.getSingletonFactory(EventBus);\n\nfactory.EVENT_PRIORITY_LOW = EVENT_PRIORITY_LOW;\nfactory.EVENT_PRIORITY_HIGH = EVENT_PRIORITY_HIGH;\n\n_FactoryMaker2.default.updateSingletonFactory(EventBus.__dashjs_factory_name, factory);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../src/core/EventBus.js"],"names":["EVENT_PRIORITY_LOW","EVENT_PRIORITY_HIGH","handlers","options","priority","getHandlerIdx","handler","callback","scope","inserted","item","idx","payload","filters","MediaPlayerEvents","instance","on","off","trigger","reset","EventBus","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from './FactoryMaker';\nimport MediaPlayerEvents from '../streaming/MediaPlayerEvents';\n\nconst EVENT_PRIORITY_LOW = 0;\nconst EVENT_PRIORITY_HIGH = 5000;\n\nfunction EventBus() {\n\n    let handlers = {};\n\n    function on(type, listener, scope, options = {}) {\n\n        if (!type) {\n            throw new Error('event type cannot be null or undefined');\n        }\n        if (!listener || typeof (listener) !== 'function') {\n            throw new Error('listener must be a function: ' + listener);\n        }\n\n        let priority = options.priority || EVENT_PRIORITY_LOW;\n\n        if (getHandlerIdx(type, listener, scope) >= 0) return;\n\n        handlers[type] = handlers[type] || [];\n\n        const handler = {\n            callback: listener,\n            scope,\n            priority\n        };\n\n        if (scope && scope.getStreamId) {\n            handler.streamId = scope.getStreamId();\n        }\n        if (scope && scope.getType) {\n            handler.mediaType = scope.getType();\n        }\n        if (options && options.mode) {\n            handler.mode = options.mode;\n        }\n\n        const inserted = handlers[type].some((item, idx) => {\n            if (item && priority > item.priority) {\n                handlers[type].splice(idx, 0, handler);\n                return true;\n            }\n        });\n\n        if (!inserted) {\n            handlers[type].push(handler);\n        }\n    }\n\n    function off(type, listener, scope) {\n        if (!type || !listener || !handlers[type]) return;\n        const idx = getHandlerIdx(type, listener, scope);\n        if (idx < 0) return;\n        handlers[type][idx] = null;\n    }\n\n    function trigger(type, payload = {}, filters = {}) {\n        if (!type || !handlers[type]) return;\n\n        payload = payload || {};\n\n        if (payload.hasOwnProperty('type')) throw new Error('\\'type\\' is a reserved word for event dispatching');\n\n        payload.type = type;\n\n        if (filters.streamId) {\n            payload.streamId = filters.streamId;\n        }\n        if (filters.mediaType) {\n            payload.mediaType = filters.mediaType;\n        }\n\n        handlers[type]\n            .filter((handler) => {\n                if (!handler) {\n                    return false;\n                }\n                if (filters.streamId && handler.streamId && handler.streamId !== filters.streamId) {\n                    return false;\n                }\n                if (filters.mediaType && handler.mediaType && handler.mediaType !== filters.mediaType) {\n                    return false;\n                }\n                // This is used for dispatching DASH events. By default we use the onStart mode. Consequently we filter everything that has a non matching mode and the onReceive events for handlers that did not specify a mode.\n                if ((filters.mode && handler.mode && handler.mode !== filters.mode) || (!handler.mode && filters.mode && filters.mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE)) {\n                    return false;\n                }\n                return true;\n            })\n            .forEach(handler => handler && handler.callback.call(handler.scope, payload));\n    }\n\n    function getHandlerIdx(type, listener, scope) {\n\n        let idx = -1;\n\n        if (!handlers[type]) return idx;\n\n        handlers[type].some((item, index) => {\n            if (item && item.callback === listener && (!scope || scope === item.scope)) {\n                idx = index;\n                return true;\n            }\n        });\n        return idx;\n    }\n\n    function reset() {\n        handlers = {};\n    }\n\n    const instance = {\n        on: on,\n        off: off,\n        trigger: trigger,\n        reset: reset\n    };\n\n    return instance;\n}\n\nEventBus.__dashjs_factory_name = 'EventBus';\nconst factory = FactoryMaker.getSingletonFactory(EventBus);\nfactory.EVENT_PRIORITY_LOW = EVENT_PRIORITY_LOW;\nfactory.EVENT_PRIORITY_HIGH = EVENT_PRIORITY_HIGH;\nFactoryMaker.updateSingletonFactory(EventBus.__dashjs_factory_name, factory);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}