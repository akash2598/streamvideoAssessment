{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _TextSourceBuffer = require('./TextSourceBuffer');\n\nvar _TextSourceBuffer2 = _interopRequireDefault(_TextSourceBuffer);\n\nvar _TextTracks = require('./TextTracks');\n\nvar _TextTracks2 = _interopRequireDefault(_TextTracks);\n\nvar _VTTParser = require('../utils/VTTParser');\n\nvar _VTTParser2 = _interopRequireDefault(_VTTParser);\n\nvar _TTMLParser = require('../utils/TTMLParser');\n\nvar _TTMLParser2 = _interopRequireDefault(_TTMLParser);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _SupervisorTools = require('../utils/SupervisorTools');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction TextController() {\n  var context = this.context;\n  var instance = void 0,\n      textSourceBuffer = void 0,\n      errHandler = void 0,\n      adapter = void 0,\n      manifestModel = void 0,\n      mediaController = void 0,\n      videoModel = void 0,\n      streamController = void 0,\n      textTracks = void 0,\n      vttParser = void 0,\n      ttmlParser = void 0,\n      eventBus = void 0,\n      defaultSettings = void 0,\n      initialSettingsSet = void 0,\n      lastEnabledIndex = void 0,\n      textDefaultEnabled = void 0,\n      // this is used for default settings (each time a file is loaded, we check value of this settings )\n  allTracksAreDisabled = void 0,\n      // this is used for one session (when a file has been loaded, we use this settings to enable/disable text)\n  forceTextStreaming = void 0,\n      textTracksAdded = void 0,\n      disableTextBeforeTextTracksAdded = void 0,\n      previousPeriodSelectedTrack = void 0;\n\n  function setup() {\n    defaultSettings = null;\n    lastEnabledIndex = -1;\n    forceTextStreaming = false;\n    textTracksAdded = false;\n    initialSettingsSet = false;\n    disableTextBeforeTextTracksAdded = false;\n    textTracks = (0, _TextTracks2.default)(context).getInstance();\n    vttParser = (0, _VTTParser2.default)(context).getInstance();\n    ttmlParser = (0, _TTMLParser2.default)(context).getInstance();\n    textSourceBuffer = (0, _TextSourceBuffer2.default)(context).getInstance();\n    eventBus = (0, _EventBus2.default)(context).getInstance();\n    textTracks.initialize();\n    eventBus.on(_Events2.default.TEXT_TRACKS_QUEUE_INITIALIZED, onTextTracksAdded, instance);\n    eventBus.on(_Events2.default.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    /*\n    * register those event callbacks in order to detect switch of periods and set\n    * correctly the selected track index in the new period.\n    * there is different cases :\n    *   - switch occurs after a seek command from the user\n    *   - switch occurs but codecs in streams are different\n    *   - switch occurs and codecs in streams are not different\n    */\n\n    eventBus.on(_Events2.default.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n    eventBus.on(_Events2.default.STREAM_COMPLETED, onStreamCompleted, instance);\n    eventBus.on(_Events2.default.PERIOD_SWITCH_COMPLETED, onPeriodSwitchCompleted, instance);\n    resetInitialSettings();\n  }\n\n  function onPeriodSwitchStarted(e) {\n    if (previousPeriodSelectedTrack === undefined && e.fromStreamInfo !== null\n    /* test if this is the first period */\n    ) {\n        previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n      }\n  }\n\n  function onStreamCompleted() {\n    if (previousPeriodSelectedTrack === undefined) {\n      previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n    }\n  }\n\n  function onPeriodSwitchCompleted() {\n    if (previousPeriodSelectedTrack !== undefined) {\n      this.setTextTrack(previousPeriodSelectedTrack);\n      previousPeriodSelectedTrack = undefined;\n    }\n  }\n\n  function setConfig(config) {\n    if (!config) {\n      return;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.manifestModel) {\n      manifestModel = config.manifestModel;\n    }\n\n    if (config.mediaController) {\n      mediaController = config.mediaController;\n    }\n\n    if (config.videoModel) {\n      videoModel = config.videoModel;\n    }\n\n    if (config.streamController) {\n      streamController = config.streamController;\n    }\n\n    if (config.textTracks) {\n      textTracks = config.textTracks;\n    }\n\n    if (config.vttParser) {\n      vttParser = config.vttParser;\n    }\n\n    if (config.ttmlParser) {\n      ttmlParser = config.ttmlParser;\n    } // create config for source buffer\n\n\n    textSourceBuffer.setConfig({\n      errHandler: errHandler,\n      adapter: adapter,\n      manifestModel: manifestModel,\n      mediaController: mediaController,\n      videoModel: videoModel,\n      streamController: streamController,\n      textTracks: textTracks,\n      vttParser: vttParser,\n      ttmlParser: ttmlParser\n    });\n  }\n\n  function getTextSourceBuffer() {\n    return textSourceBuffer;\n  }\n\n  function getAllTracksAreDisabled() {\n    return allTracksAreDisabled;\n  }\n\n  function addEmbeddedTrack(mediaInfo) {\n    textSourceBuffer.addEmbeddedTrack(mediaInfo);\n  }\n\n  function setTextDefaultLanguage(lang) {\n    (0, _SupervisorTools.checkParameterType)(lang, 'string');\n\n    if (!defaultSettings) {\n      defaultSettings = {};\n    }\n\n    defaultSettings.lang = lang;\n    initialSettingsSet = true;\n  }\n\n  function setInitialSettings(settings) {\n    defaultSettings = settings;\n    initialSettingsSet = true;\n  }\n\n  function getTextDefaultLanguage() {\n    return defaultSettings && defaultSettings.lang || '';\n  }\n\n  function onTextTracksAdded(e) {\n    var _this = this;\n\n    var tracks = e.tracks;\n    var index = e.index;\n\n    if (defaultSettings) {\n      tracks.some(function (item, idx) {\n        // matchSettings is compatible with setTextDefaultLanguage and setInitialSettings\n        if (mediaController.matchSettings(defaultSettings, item)) {\n          _this.setTextTrack(idx);\n\n          index = idx;\n          return true;\n        }\n      });\n    }\n\n    if (textDefaultEnabled === false || textDefaultEnabled === undefined && !defaultSettings || disableTextBeforeTextTracksAdded) {\n      // disable text at startup if explicitely configured with setTextDefaultEnabled(false) or if there is no defaultSettings (configuration or from domStorage)\n      this.setTextTrack(-1);\n    }\n\n    lastEnabledIndex = index;\n    eventBus.trigger(_Events2.default.TEXT_TRACKS_ADDED, {\n      enabled: isTextEnabled(),\n      index: index,\n      tracks: tracks\n    });\n    textTracksAdded = true;\n  }\n\n  function onCurrentTrackChanged(event) {\n    if (!initialSettingsSet && event && event.newMediaInfo) {\n      var mediaInfo = event.newMediaInfo;\n\n      if (mediaInfo.type === _Constants2.default.FRAGMENTED_TEXT) {\n        defaultSettings = {\n          lang: mediaInfo.lang,\n          role: mediaInfo.roles[0],\n          accessibility: mediaInfo.accessibility[0]\n        };\n      }\n    }\n  }\n\n  function setTextDefaultEnabled(enable) {\n    (0, _SupervisorTools.checkParameterType)(enable, 'boolean');\n    textDefaultEnabled = enable;\n\n    if (!textDefaultEnabled) {\n      // disable text at startup\n      this.setTextTrack(-1);\n    } else {\n      allTracksAreDisabled = false;\n    }\n  }\n\n  function getTextDefaultEnabled() {\n    return textDefaultEnabled === undefined ? false : textDefaultEnabled;\n  }\n\n  function enableText(enable) {\n    (0, _SupervisorTools.checkParameterType)(enable, 'boolean');\n\n    if (!textDefaultEnabled && enable) {\n      textDefaultEnabled = true;\n    }\n\n    if (isTextEnabled() !== enable) {\n      // change track selection\n      if (enable) {\n        // apply last enabled track\n        this.setTextTrack(lastEnabledIndex);\n      }\n\n      if (!enable) {\n        // keep last index and disable text track\n        lastEnabledIndex = this.getCurrentTrackIdx();\n\n        if (!textTracksAdded) {\n          disableTextBeforeTextTracksAdded = true;\n        } else {\n          this.setTextTrack(-1);\n        }\n      }\n    }\n  }\n\n  function isTextEnabled() {\n    var enabled = true;\n\n    if (allTracksAreDisabled && !forceTextStreaming) {\n      enabled = false;\n    }\n\n    return enabled;\n  } // when set to true ScheduleController will allow schedule of chunks even if tracks are all disabled. Allowing streaming to hidden track for external players to work with.\n\n\n  function enableForcedTextStreaming(enable) {\n    (0, _SupervisorTools.checkParameterType)(enable, 'boolean');\n    forceTextStreaming = enable;\n  }\n\n  function setTextTrack(idx) {\n    //For external time text file, the only action needed to change a track is marking the track mode to showing.\n    // Fragmented text tracks need the additional step of calling TextController.setTextTrack();\n    var config = textSourceBuffer.getConfig();\n    var fragmentModel = config.fragmentModel;\n    var fragmentedTracks = config.fragmentedTracks;\n    var videoModel = config.videoModel;\n    var mediaInfosArr = void 0,\n        streamProcessor = void 0;\n    allTracksAreDisabled = idx === -1 ? true : false;\n    var oldTrackIdx = textTracks.getCurrentTrackIdx();\n\n    if (oldTrackIdx !== idx) {\n      if (allTracksAreDisabled && mediaController) {\n        mediaController.saveTextSettingsDisabled();\n      }\n\n      textTracks.setModeForTrackIdx(oldTrackIdx, _Constants2.default.TEXT_HIDDEN);\n      textTracks.setCurrentTrackIdx(idx);\n      textTracks.setModeForTrackIdx(idx, _Constants2.default.TEXT_SHOWING);\n      var currentTrackInfo = textTracks.getCurrentTrackInfo();\n\n      if (currentTrackInfo && currentTrackInfo.isFragmented && !currentTrackInfo.isEmbedded) {\n        for (var i = 0; i < fragmentedTracks.length; i++) {\n          var mediaInfo = fragmentedTracks[i];\n\n          if (currentTrackInfo.lang === mediaInfo.lang && currentTrackInfo.index === mediaInfo.index && (mediaInfo.id ? currentTrackInfo.id === mediaInfo.id : currentTrackInfo.id === mediaInfo.index)) {\n            var currentFragTrack = mediaController.getCurrentTrackFor(_Constants2.default.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n\n            if (mediaInfo !== currentFragTrack) {\n              fragmentModel.abortRequests();\n              fragmentModel.removeExecutedRequestsBeforeTime();\n              textSourceBuffer.remove();\n              textTracks.deleteCuesFromTrackIdx(oldTrackIdx);\n              mediaController.setTrack(mediaInfo);\n              textSourceBuffer.setCurrentFragmentedTrackIdx(i);\n            } else if (oldTrackIdx === -1) {\n              //in fragmented use case, if the user selects the older track (the one selected before disabled text track)\n              //no CURRENT_TRACK_CHANGED event will be trigger, so dashHandler current time has to be updated and the scheduleController\n              //has to be restarted.\n              var streamProcessors = streamController.getActiveStreamProcessors();\n\n              for (var _i = 0; _i < streamProcessors.length; _i++) {\n                if (streamProcessors[_i].getType() === _Constants2.default.FRAGMENTED_TEXT) {\n                  streamProcessor = streamProcessors[_i];\n                  break;\n                }\n              }\n\n              streamProcessor.setBufferingTime(videoModel.getTime());\n              streamProcessor.getScheduleController().start();\n            }\n          }\n        }\n      } else if (currentTrackInfo && !currentTrackInfo.isFragmented) {\n        var _streamProcessors = streamController.getActiveStreamProcessors();\n\n        for (var _i2 = 0; _i2 < _streamProcessors.length; _i2++) {\n          if (_streamProcessors[_i2].getType() === _Constants2.default.TEXT) {\n            streamProcessor = _streamProcessors[_i2];\n            mediaInfosArr = streamProcessor.getMediaInfoArr();\n            break;\n          }\n        }\n\n        if (streamProcessor && mediaInfosArr) {\n          for (var _i3 = 0; _i3 < mediaInfosArr.length; _i3++) {\n            if (mediaInfosArr[_i3].index === currentTrackInfo.index && mediaInfosArr[_i3].lang === currentTrackInfo.lang) {\n              streamProcessor.selectMediaInfo(mediaInfosArr[_i3]);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function getCurrentTrackIdx() {\n    return textTracks.getCurrentTrackIdx();\n  }\n\n  function resetInitialSettings() {\n    allTracksAreDisabled = true;\n    textTracksAdded = false;\n    disableTextBeforeTextTracksAdded = false;\n  }\n\n  function reset() {\n    resetInitialSettings();\n    textSourceBuffer.resetEmbedded();\n    textSourceBuffer.reset();\n  }\n\n  instance = {\n    setConfig: setConfig,\n    getTextSourceBuffer: getTextSourceBuffer,\n    getAllTracksAreDisabled: getAllTracksAreDisabled,\n    addEmbeddedTrack: addEmbeddedTrack,\n    getTextDefaultLanguage: getTextDefaultLanguage,\n    setTextDefaultLanguage: setTextDefaultLanguage,\n    setTextDefaultEnabled: setTextDefaultEnabled,\n    getTextDefaultEnabled: getTextDefaultEnabled,\n    setInitialSettings: setInitialSettings,\n    enableText: enableText,\n    isTextEnabled: isTextEnabled,\n    setTextTrack: setTextTrack,\n    getCurrentTrackIdx: getCurrentTrackIdx,\n    enableForcedTextStreaming: enableForcedTextStreaming,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nTextController.__dashjs_factory_name = 'TextController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(TextController);","map":{"version":3,"sources":["../../../../../src/streaming/text/TextController.js"],"names":["context","instance","textSourceBuffer","errHandler","adapter","manifestModel","mediaController","videoModel","streamController","textTracks","vttParser","ttmlParser","eventBus","defaultSettings","initialSettingsSet","lastEnabledIndex","textDefaultEnabled","allTracksAreDisabled","forceTextStreaming","textTracksAdded","disableTextBeforeTextTracksAdded","previousPeriodSelectedTrack","Events","resetInitialSettings","e","config","tracks","index","enabled","isTextEnabled","event","mediaInfo","Constants","lang","role","accessibility","fragmentModel","fragmentedTracks","mediaInfosArr","streamProcessor","idx","oldTrackIdx","currentTrackInfo","i","currentFragTrack","streamProcessors","setConfig","getTextSourceBuffer","getAllTracksAreDisabled","addEmbeddedTrack","getTextDefaultLanguage","setTextDefaultLanguage","setTextDefaultEnabled","getTextDefaultEnabled","setInitialSettings","enableText","setTextTrack","getCurrentTrackIdx","enableForcedTextStreaming","reset","setup","TextController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport TextSourceBuffer from './TextSourceBuffer';\nimport TextTracks from './TextTracks';\nimport VTTParser from '../utils/VTTParser';\nimport TTMLParser from '../utils/TTMLParser';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport { checkParameterType } from '../utils/SupervisorTools';\n\nfunction TextController() {\n\n    let context = this.context;\n\n    let instance,\n        textSourceBuffer,\n        errHandler,\n        adapter,\n        manifestModel,\n        mediaController,\n        videoModel,\n        streamController,\n        textTracks,\n        vttParser,\n        ttmlParser,\n        eventBus,\n        defaultSettings,\n        initialSettingsSet,\n        lastEnabledIndex,\n        textDefaultEnabled, // this is used for default settings (each time a file is loaded, we check value of this settings )\n        allTracksAreDisabled, // this is used for one session (when a file has been loaded, we use this settings to enable/disable text)\n        forceTextStreaming,\n        textTracksAdded,\n        disableTextBeforeTextTracksAdded,\n        previousPeriodSelectedTrack;\n\n    function setup() {\n\n        defaultSettings = null;\n        lastEnabledIndex = -1;\n        forceTextStreaming = false;\n        textTracksAdded = false;\n        initialSettingsSet = false;\n        disableTextBeforeTextTracksAdded = false;\n        textTracks = TextTracks(context).getInstance();\n        vttParser = VTTParser(context).getInstance();\n        ttmlParser = TTMLParser(context).getInstance();\n        textSourceBuffer = TextSourceBuffer(context).getInstance();\n        eventBus = EventBus(context).getInstance();\n\n        textTracks.initialize();\n        eventBus.on(Events.TEXT_TRACKS_QUEUE_INITIALIZED, onTextTracksAdded, instance);\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n\n        /*\n        * register those event callbacks in order to detect switch of periods and set\n        * correctly the selected track index in the new period.\n        * there is different cases :\n        *   - switch occurs after a seek command from the user\n        *   - switch occurs but codecs in streams are different\n        *   - switch occurs and codecs in streams are not different\n        */\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, instance);\n        eventBus.on(Events.PERIOD_SWITCH_COMPLETED, onPeriodSwitchCompleted, instance);\n\n        resetInitialSettings();\n    }\n\n    function onPeriodSwitchStarted(e) {\n        if (previousPeriodSelectedTrack === undefined && e.fromStreamInfo !== null /* test if this is the first period */) {\n            previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n        }\n    }\n\n    function onStreamCompleted() {\n        if (previousPeriodSelectedTrack === undefined) {\n            previousPeriodSelectedTrack = this.getCurrentTrackIdx();\n        }\n    }\n\n    function onPeriodSwitchCompleted() {\n        if (previousPeriodSelectedTrack !== undefined) {\n            this.setTextTrack(previousPeriodSelectedTrack);\n            previousPeriodSelectedTrack = undefined;\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.mediaController) {\n            mediaController = config.mediaController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.textTracks) {\n            textTracks = config.textTracks;\n        }\n        if (config.vttParser) {\n            vttParser = config.vttParser;\n        }\n        if (config.ttmlParser) {\n            ttmlParser = config.ttmlParser;\n        }\n\n        // create config for source buffer\n        textSourceBuffer.setConfig({\n            errHandler: errHandler,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            mediaController: mediaController,\n            videoModel: videoModel,\n            streamController: streamController,\n            textTracks: textTracks,\n            vttParser: vttParser,\n            ttmlParser: ttmlParser\n        });\n    }\n\n    function getTextSourceBuffer() {\n        return textSourceBuffer;\n    }\n\n    function getAllTracksAreDisabled() {\n        return allTracksAreDisabled;\n    }\n\n    function addEmbeddedTrack(mediaInfo) {\n        textSourceBuffer.addEmbeddedTrack(mediaInfo);\n    }\n\n    function setTextDefaultLanguage(lang) {\n        checkParameterType(lang, 'string');\n        if (!defaultSettings) {\n            defaultSettings = {};\n        }\n        defaultSettings.lang = lang;\n        initialSettingsSet = true;\n    }\n\n    function setInitialSettings(settings) {\n        defaultSettings = settings;\n        initialSettingsSet = true;\n    }\n\n    function getTextDefaultLanguage() {\n        return defaultSettings && defaultSettings.lang || '';\n    }\n\n    function onTextTracksAdded(e) {\n        let tracks = e.tracks;\n        let index = e.index;\n\n        if (defaultSettings) {\n            tracks.some((item, idx) => {\n                // matchSettings is compatible with setTextDefaultLanguage and setInitialSettings\n                if (mediaController.matchSettings(defaultSettings, item)) {\n                    this.setTextTrack(idx);\n                    index = idx;\n                    return true;\n                }\n            });\n        }\n\n        if (textDefaultEnabled === false || ( textDefaultEnabled === undefined && !defaultSettings ) || disableTextBeforeTextTracksAdded) {\n            // disable text at startup if explicitely configured with setTextDefaultEnabled(false) or if there is no defaultSettings (configuration or from domStorage)\n            this.setTextTrack(-1);\n        }\n\n        lastEnabledIndex = index;\n        eventBus.trigger(Events.TEXT_TRACKS_ADDED, {\n            enabled: isTextEnabled(),\n            index: index,\n            tracks: tracks\n        });\n        textTracksAdded = true;\n    }\n\n    function onCurrentTrackChanged(event) {\n        if (!initialSettingsSet && event && event.newMediaInfo) {\n            let mediaInfo = event.newMediaInfo;\n            if (mediaInfo.type === Constants.FRAGMENTED_TEXT) {\n                defaultSettings = {\n                    lang: mediaInfo.lang,\n                    role: mediaInfo.roles[0],\n                    accessibility: mediaInfo.accessibility[0]\n                };\n            }\n        }\n    }\n\n    function setTextDefaultEnabled(enable) {\n        checkParameterType(enable,'boolean');\n        textDefaultEnabled = enable;\n\n        if (!textDefaultEnabled) {\n            // disable text at startup\n            this.setTextTrack(-1);\n        } else {\n            allTracksAreDisabled = false;\n        }\n    }\n\n    function getTextDefaultEnabled() {\n        return textDefaultEnabled === undefined ? false : textDefaultEnabled;\n    }\n\n    function enableText(enable) {\n        checkParameterType(enable,'boolean');\n        if (!textDefaultEnabled && enable) {\n            textDefaultEnabled = true;\n        }\n        if (isTextEnabled() !== enable) {\n            // change track selection\n            if (enable) {\n                // apply last enabled track\n                this.setTextTrack(lastEnabledIndex);\n            }\n\n            if (!enable) {\n                // keep last index and disable text track\n                lastEnabledIndex = this.getCurrentTrackIdx();\n                if (!textTracksAdded) {\n                    disableTextBeforeTextTracksAdded = true;\n                } else {\n                    this.setTextTrack(-1);\n                }\n            }\n        }\n    }\n\n    function isTextEnabled() {\n        let enabled = true;\n        if (allTracksAreDisabled && !forceTextStreaming) {\n            enabled = false;\n        }\n        return enabled;\n    }\n\n    // when set to true ScheduleController will allow schedule of chunks even if tracks are all disabled. Allowing streaming to hidden track for external players to work with.\n    function enableForcedTextStreaming(enable) {\n        checkParameterType(enable,'boolean');\n        forceTextStreaming = enable;\n    }\n\n    function setTextTrack(idx) {\n        //For external time text file, the only action needed to change a track is marking the track mode to showing.\n        // Fragmented text tracks need the additional step of calling TextController.setTextTrack();\n        let config = textSourceBuffer.getConfig();\n        let fragmentModel = config.fragmentModel;\n        let fragmentedTracks = config.fragmentedTracks;\n        let videoModel = config.videoModel;\n        let mediaInfosArr,\n            streamProcessor;\n\n        allTracksAreDisabled = idx === -1 ? true : false;\n\n        let oldTrackIdx = textTracks.getCurrentTrackIdx();\n        if (oldTrackIdx !== idx) {\n            if (allTracksAreDisabled && mediaController) {\n                mediaController.saveTextSettingsDisabled();\n            }\n            textTracks.setModeForTrackIdx(oldTrackIdx, Constants.TEXT_HIDDEN);\n            textTracks.setCurrentTrackIdx(idx);\n            textTracks.setModeForTrackIdx(idx, Constants.TEXT_SHOWING);\n\n            let currentTrackInfo = textTracks.getCurrentTrackInfo();\n\n            if (currentTrackInfo && currentTrackInfo.isFragmented && !currentTrackInfo.isEmbedded) {\n                for (let i = 0; i < fragmentedTracks.length; i++) {\n                    let mediaInfo = fragmentedTracks[i];\n                    if (currentTrackInfo.lang === mediaInfo.lang && currentTrackInfo.index === mediaInfo.index &&\n                        (mediaInfo.id ? currentTrackInfo.id === mediaInfo.id : currentTrackInfo.id === mediaInfo.index)) {\n                        let currentFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n                        if (mediaInfo !== currentFragTrack) {\n                            fragmentModel.abortRequests();\n                            fragmentModel.removeExecutedRequestsBeforeTime();\n                            textSourceBuffer.remove();\n                            textTracks.deleteCuesFromTrackIdx(oldTrackIdx);\n                            mediaController.setTrack(mediaInfo);\n                            textSourceBuffer.setCurrentFragmentedTrackIdx(i);\n                        } else if (oldTrackIdx === -1) {\n                            //in fragmented use case, if the user selects the older track (the one selected before disabled text track)\n                            //no CURRENT_TRACK_CHANGED event will be trigger, so dashHandler current time has to be updated and the scheduleController\n                            //has to be restarted.\n                            const streamProcessors = streamController.getActiveStreamProcessors();\n                            for (let i = 0; i < streamProcessors.length; i++) {\n                                if (streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\n                                    streamProcessor = streamProcessors[i];\n                                    break;\n                                }\n                            }\n                            streamProcessor.setBufferingTime(videoModel.getTime());\n                            streamProcessor.getScheduleController().start();\n                        }\n                    }\n                }\n            } else if (currentTrackInfo && !currentTrackInfo.isFragmented) {\n                const streamProcessors = streamController.getActiveStreamProcessors();\n                for (let i = 0; i < streamProcessors.length; i++) {\n                    if (streamProcessors[i].getType() === Constants.TEXT) {\n                        streamProcessor = streamProcessors[i];\n                        mediaInfosArr = streamProcessor.getMediaInfoArr();\n                        break;\n                    }\n                }\n\n                if (streamProcessor && mediaInfosArr) {\n                    for (let i = 0; i < mediaInfosArr.length; i++) {\n                        if (mediaInfosArr[i].index === currentTrackInfo.index && mediaInfosArr[i].lang === currentTrackInfo.lang) {\n                            streamProcessor.selectMediaInfo(mediaInfosArr[i]);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function getCurrentTrackIdx() {\n        return textTracks.getCurrentTrackIdx();\n    }\n\n    function resetInitialSettings() {\n        allTracksAreDisabled = true;\n        textTracksAdded = false;\n        disableTextBeforeTextTracksAdded = false;\n    }\n\n    function reset() {\n        resetInitialSettings();\n        textSourceBuffer.resetEmbedded();\n        textSourceBuffer.reset();\n    }\n\n    instance = {\n        setConfig: setConfig,\n        getTextSourceBuffer: getTextSourceBuffer,\n        getAllTracksAreDisabled: getAllTracksAreDisabled,\n        addEmbeddedTrack: addEmbeddedTrack,\n        getTextDefaultLanguage: getTextDefaultLanguage,\n        setTextDefaultLanguage: setTextDefaultLanguage,\n        setTextDefaultEnabled: setTextDefaultEnabled,\n        getTextDefaultEnabled: getTextDefaultEnabled,\n        setInitialSettings: setInitialSettings,\n        enableText: enableText,\n        isTextEnabled: isTextEnabled,\n        setTextTrack: setTextTrack,\n        getCurrentTrackIdx: getCurrentTrackIdx,\n        enableForcedTextStreaming: enableForcedTextStreaming,\n        reset: reset\n    };\n    setup();\n    return instance;\n}\n\nTextController.__dashjs_factory_name = 'TextController';\nexport default FactoryMaker.getSingletonFactory(TextController);\n"]},"metadata":{},"sourceType":"script"}