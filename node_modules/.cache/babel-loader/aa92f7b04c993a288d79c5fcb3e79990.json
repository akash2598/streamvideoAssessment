{"ast":null,"code":"/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\n\n/**\r\n * @module imscISD\r\n */\n;\n\n(function (imscISD, imscNames, imscStyles, imscUtils) {\n  // wrapper for non-node envs\n\n  /** \r\n   * Creates a canonical representation of an IMSC1 document returned by <pre>imscDoc.fromXML()</pre>\r\n   * at a given absolute offset in seconds. This offset does not have to be one of the values returned\r\n   * by <pre>getMediaTimeEvents()</pre>.\r\n   * \r\n   * @param {Object} tt IMSC1 document\r\n   * @param {number} offset Absolute offset (in seconds)\r\n   * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n   * @returns {Object} Opaque in-memory representation of an ISD\r\n   */\n  imscISD.generateISD = function (tt, offset, errorHandler) {\n    /* TODO check for tt and offset validity */\n\n    /* create the ISD object from the IMSC1 doc */\n    var isd = new ISD(tt);\n    /* context */\n\n    var context = {\n      /*rubyfs: []*/\n\n      /* font size of the nearest textContainer or container */\n    };\n    /* process regions */\n\n    for (var r in tt.head.layout.regions) {\n      /* post-order traversal of the body tree per [construct intermediate document] */\n      var c = isdProcessContentElement(tt, offset, tt.head.layout.regions[r], tt.body, null, '', tt.head.layout.regions[r], errorHandler, context);\n\n      if (c !== null) {\n        /* add the region to the ISD */\n        isd.contents.push(c.element);\n      }\n    }\n\n    return isd;\n  };\n  /* set of styles not applicable to ruby container spans */\n\n\n  var _rcs_na_styles = [imscStyles.byName.color.qname, imscStyles.byName.textCombine.qname, imscStyles.byName.textDecoration.qname, imscStyles.byName.textEmphasis.qname, imscStyles.byName.textOutline.qname, imscStyles.byName.textShadow.qname];\n\n  function isdProcessContentElement(doc, offset, region, body, parent, inherited_region_id, elem, errorHandler, context) {\n    /* prune if temporally inactive */\n    if (offset < elem.begin || offset >= elem.end) {\n      return null;\n    }\n    /* \r\n     * set the associated region as specified by the regionID attribute, or the \r\n     * inherited associated region otherwise\r\n     */\n\n\n    var associated_region_id = 'regionID' in elem && elem.regionID !== '' ? elem.regionID : inherited_region_id;\n    /* prune the element if either:\r\n     * - the element is not terminal and the associated region is neither the default\r\n     *   region nor the parent region (this allows children to be associated with a \r\n     *   region later on)\r\n     * - the element is terminal and the associated region is not the parent region\r\n     */\n\n    /* TODO: improve detection of terminal elements since <region> has no contents */\n\n    if (parent !== null\n    /* are we in the region element */\n    && associated_region_id !== region.id && (!('contents' in elem) || 'contents' in elem && elem.contents.length === 0 || associated_region_id !== '')) return null;\n    /* create an ISD element, including applying specified styles */\n\n    var isd_element = new ISDContentElement(elem);\n    /* apply set (animation) styling */\n\n    for (var i in elem.sets) {\n      if (offset < elem.sets[i].begin || offset >= elem.sets[i].end) continue;\n      isd_element.styleAttrs[elem.sets[i].qname] = elem.sets[i].value;\n    }\n    /* \r\n     * keep track of specified styling attributes so that we\r\n     * can compute them later\r\n     */\n\n\n    var spec_attr = {};\n\n    for (var qname in isd_element.styleAttrs) {\n      spec_attr[qname] = true;\n      /* special rule for tts:writingMode (section 7.29.1 of XSL)\r\n       * direction is set consistently with writingMode only\r\n       * if writingMode sets inline-direction to LTR or RTL  \r\n       */\n\n      if (isd_element.kind === 'region' && qname === imscStyles.byName.writingMode.qname && !(imscStyles.byName.direction.qname in isd_element.styleAttrs)) {\n        var wm = isd_element.styleAttrs[qname];\n\n        if (wm === \"lrtb\" || wm === \"lr\") {\n          isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"ltr\";\n        } else if (wm === \"rltb\" || wm === \"rl\") {\n          isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"rtl\";\n        }\n      }\n    }\n    /* inherited styling */\n\n\n    if (parent !== null) {\n      for (var j in imscStyles.all) {\n        var sa = imscStyles.all[j];\n        /* textDecoration has special inheritance rules */\n\n        if (sa.qname === imscStyles.byName.textDecoration.qname) {\n          /* handle both textDecoration inheritance and specification */\n          var ps = parent.styleAttrs[sa.qname];\n          var es = isd_element.styleAttrs[sa.qname];\n          var outs = [];\n\n          if (es === undefined) {\n            outs = ps;\n          } else if (es.indexOf(\"none\") === -1) {\n            if (es.indexOf(\"noUnderline\") === -1 && ps.indexOf(\"underline\") !== -1 || es.indexOf(\"underline\") !== -1) {\n              outs.push(\"underline\");\n            }\n\n            if (es.indexOf(\"noLineThrough\") === -1 && ps.indexOf(\"lineThrough\") !== -1 || es.indexOf(\"lineThrough\") !== -1) {\n              outs.push(\"lineThrough\");\n            }\n\n            if (es.indexOf(\"noOverline\") === -1 && ps.indexOf(\"overline\") !== -1 || es.indexOf(\"overline\") !== -1) {\n              outs.push(\"overline\");\n            }\n          } else {\n            outs.push(\"none\");\n          }\n\n          isd_element.styleAttrs[sa.qname] = outs;\n        } else if (sa.qname === imscStyles.byName.fontSize.qname && !(sa.qname in isd_element.styleAttrs) && isd_element.kind === 'span' && isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\n          /* special inheritance rule for ruby text container font size */\n          var ruby_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\n          isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(0.5 * ruby_fs.rw, 0.5 * ruby_fs.rh);\n        } else if (sa.qname === imscStyles.byName.fontSize.qname && !(sa.qname in isd_element.styleAttrs) && isd_element.kind === 'span' && isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"text\") {\n          /* special inheritance rule for ruby text font size */\n          var parent_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\n\n          if (parent.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\n            isd_element.styleAttrs[sa.qname] = parent_fs;\n          } else {\n            isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(0.5 * parent_fs.rw, 0.5 * parent_fs.rh);\n          }\n        } else if (sa.inherit && sa.qname in parent.styleAttrs && !(sa.qname in isd_element.styleAttrs)) {\n          isd_element.styleAttrs[sa.qname] = parent.styleAttrs[sa.qname];\n        }\n      }\n    }\n    /* initial value styling */\n\n\n    for (var k in imscStyles.all) {\n      var ivs = imscStyles.all[k];\n      /* skip if value is already specified */\n\n      if (ivs.qname in isd_element.styleAttrs) continue;\n      /* skip tts:position if tts:origin is specified */\n\n      if (ivs.qname === imscStyles.byName.position.qname && imscStyles.byName.origin.qname in isd_element.styleAttrs) continue;\n      /* skip tts:origin if tts:position is specified */\n\n      if (ivs.qname === imscStyles.byName.origin.qname && imscStyles.byName.position.qname in isd_element.styleAttrs) continue;\n      /* determine initial value */\n\n      var iv = doc.head.styling.initials[ivs.qname] || ivs.initial;\n\n      if (iv === null) {\n        /* skip processing if no initial value defined */\n        continue;\n      }\n      /* apply initial value to elements other than region only if non-inherited */\n\n\n      if (isd_element.kind === 'region' || ivs.inherit === false && iv !== null) {\n        var piv = ivs.parse(iv);\n\n        if (piv !== null) {\n          isd_element.styleAttrs[ivs.qname] = piv;\n          /* keep track of the style as specified */\n\n          spec_attr[ivs.qname] = true;\n        } else {\n          reportError(errorHandler, \"Invalid initial value for '\" + ivs.qname + \"' on element '\" + isd_element.kind);\n        }\n      }\n    }\n    /* compute styles (only for non-inherited styles) */\n\n    /* TODO: get rid of spec_attr */\n\n\n    for (var z in imscStyles.all) {\n      var cs = imscStyles.all[z];\n      if (!(cs.qname in spec_attr)) continue;\n\n      if (cs.compute !== null) {\n        var cstyle = cs.compute(\n        /*doc, parent, element, attr, context*/\n        doc, parent, isd_element, isd_element.styleAttrs[cs.qname], context);\n\n        if (cstyle !== null) {\n          isd_element.styleAttrs[cs.qname] = cstyle;\n        } else {\n          /* if the style cannot be computed, replace it by its initial value */\n          isd_element.styleAttrs[cs.qname] = cs.compute(\n          /*doc, parent, element, attr, context*/\n          doc, parent, isd_element, cs.parse(cs.initial), context);\n          reportError(errorHandler, \"Style '\" + cs.qname + \"' on element '\" + isd_element.kind + \"' cannot be computed\");\n        }\n      }\n    }\n    /* prune if tts:display is none */\n\n\n    if (isd_element.styleAttrs[imscStyles.byName.display.qname] === \"none\") return null;\n    /* process contents of the element */\n\n    var contents;\n\n    if (parent === null) {\n      /* we are processing the region */\n      if (body === null) {\n        /* if there is no body, still process the region but with empty content */\n        contents = [];\n      } else {\n        /*use the body element as contents */\n        contents = [body];\n      }\n    } else if ('contents' in elem) {\n      contents = elem.contents;\n    }\n\n    for (var x in contents) {\n      var c = isdProcessContentElement(doc, offset, region, body, isd_element, associated_region_id, contents[x], errorHandler, context);\n      /* \r\n       * keep child element only if they are non-null and their region match \r\n       * the region of this element\r\n       */\n\n      if (c !== null) {\n        isd_element.contents.push(c.element);\n      }\n    }\n    /* remove styles that are not applicable */\n\n\n    for (var qnameb in isd_element.styleAttrs) {\n      /* true if not applicable */\n      var na = false;\n      /* special applicability of certain style properties to ruby container spans */\n\n      /* TODO: in the future ruby elements should be translated to elements instead of kept as spans */\n\n      if (isd_element.kind === 'span') {\n        var rsp = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\n        na = (rsp === 'container' || rsp === 'textContainer' || rsp === 'baseContainer') && _rcs_na_styles.indexOf(qnameb) !== -1;\n\n        if (!na) {\n          na = rsp !== 'container' && qnameb === imscStyles.byName.rubyAlign.qname;\n        }\n\n        if (!na) {\n          na = !(rsp === 'textContainer' || rsp === 'text') && qnameb === imscStyles.byName.rubyPosition.qname;\n        }\n      }\n      /* normal applicability */\n\n\n      if (!na) {\n        var da = imscStyles.byQName[qnameb];\n        na = da.applies.indexOf(isd_element.kind) === -1;\n      }\n\n      if (na) {\n        delete isd_element.styleAttrs[qnameb];\n      }\n    }\n    /* trim whitespace around explicit line breaks */\n\n\n    var ruby = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\n\n    if (isd_element.kind === 'p' || isd_element.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\")) {\n      var elist = [];\n      constructSpanList(isd_element, elist);\n      collapseLWSP(elist);\n      pruneEmptySpans(isd_element);\n    }\n    /* keep element if:\r\n     * * contains a background image\r\n     * * <br/>\r\n     * * if there are children\r\n     * * if it is an image\r\n     * * if <span> and has text\r\n     * * if region and showBackground = always\r\n     */\n\n\n    if (isd_element.kind === 'div' && imscStyles.byName.backgroundImage.qname in isd_element.styleAttrs || isd_element.kind === 'br' || isd_element.kind === 'image' || 'contents' in isd_element && isd_element.contents.length > 0 || isd_element.kind === 'span' && isd_element.text !== null || isd_element.kind === 'region' && isd_element.styleAttrs[imscStyles.byName.showBackground.qname] === 'always') {\n      return {\n        region_id: associated_region_id,\n        element: isd_element\n      };\n    }\n\n    return null;\n  }\n\n  function collapseLWSP(elist) {\n    function isPrevCharLWSP(prev_element) {\n      return prev_element.kind === 'br' || /[\\r\\n\\t ]$/.test(prev_element.text);\n    }\n\n    function isNextCharLWSP(next_element) {\n      return next_element.kind === 'br' || next_element.space === \"preserve\" && /^[\\r\\n]/.test(next_element.text);\n    }\n    /* collapse spaces and remove leading LWSPs */\n\n\n    var element;\n\n    for (var i = 0; i < elist.length;) {\n      element = elist[i];\n\n      if (element.kind === \"br\" || element.space === \"preserve\") {\n        i++;\n        continue;\n      }\n\n      var trimmed_text = element.text.replace(/[\\t\\r\\n ]+/g, ' ');\n\n      if (/^[ ]/.test(trimmed_text)) {\n        if (i === 0 || isPrevCharLWSP(elist[i - 1])) {\n          trimmed_text = trimmed_text.substring(1);\n        }\n      }\n\n      element.text = trimmed_text;\n\n      if (trimmed_text.length === 0) {\n        elist.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n    /* remove trailing LWSPs */\n\n\n    for (i = 0; i < elist.length; i++) {\n      element = elist[i];\n\n      if (element.kind === \"br\" || element.space === \"preserve\") {\n        i++;\n        continue;\n      }\n\n      if (/[ ]$/.test(element.text)) {\n        if (i === elist.length - 1 || isNextCharLWSP(elist[i + 1])) {\n          element.text = element.text.slice(0, -1);\n        }\n      }\n    }\n  }\n\n  function constructSpanList(element, elist) {\n    for (var i in element.contents) {\n      var child = element.contents[i];\n      var ruby = child.styleAttrs[imscStyles.byName.ruby.qname];\n\n      if (child.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\")) {\n        /* skip ruby text and text containers, which are handled on their own */\n        continue;\n      } else if ('contents' in child) {\n        constructSpanList(child, elist);\n      } else if (child.kind === 'span' && child.text.length !== 0 || child.kind === 'br') {\n        /* skip empty spans */\n        elist.push(child);\n      }\n    }\n  }\n\n  function pruneEmptySpans(element) {\n    if (element.kind === 'br') {\n      return false;\n    } else if ('text' in element) {\n      return element.text.length === 0;\n    } else if ('contents' in element) {\n      var i = element.contents.length;\n\n      while (i--) {\n        if (pruneEmptySpans(element.contents[i])) {\n          element.contents.splice(i, 1);\n        }\n      }\n\n      return element.contents.length === 0;\n    }\n  }\n\n  function ISD(tt) {\n    this.contents = [];\n    this.aspectRatio = tt.aspectRatio;\n    this.lang = tt.lang;\n  }\n\n  function ISDContentElement(ttelem) {\n    /* assume the element is a region if it does not have a kind */\n    this.kind = ttelem.kind || 'region';\n    /* copy lang */\n\n    this.lang = ttelem.lang;\n    /* copy id */\n\n    if (ttelem.id) {\n      this.id = ttelem.id;\n    }\n    /* deep copy of style attributes */\n\n\n    this.styleAttrs = {};\n\n    for (var sname in ttelem.styleAttrs) {\n      this.styleAttrs[sname] = ttelem.styleAttrs[sname];\n    }\n    /* copy src and type if image */\n\n\n    if ('src' in ttelem) {\n      this.src = ttelem.src;\n    }\n\n    if ('type' in ttelem) {\n      this.type = ttelem.type;\n    }\n    /* TODO: clean this! \r\n     * TODO: ISDElement and document element should be better tied together */\n\n\n    if ('text' in ttelem) {\n      this.text = ttelem.text;\n    } else if (this.kind === 'region' || 'contents' in ttelem) {\n      this.contents = [];\n    }\n\n    if ('space' in ttelem) {\n      this.space = ttelem.space;\n    }\n  }\n  /*\r\n   * ERROR HANDLING UTILITY FUNCTIONS\r\n   * \r\n   */\n\n\n  function reportInfo(errorHandler, msg) {\n    if (errorHandler && errorHandler.info && errorHandler.info(msg)) throw msg;\n  }\n\n  function reportWarning(errorHandler, msg) {\n    if (errorHandler && errorHandler.warn && errorHandler.warn(msg)) throw msg;\n  }\n\n  function reportError(errorHandler, msg) {\n    if (errorHandler && errorHandler.error && errorHandler.error(msg)) throw msg;\n  }\n\n  function reportFatal(errorHandler, msg) {\n    if (errorHandler && errorHandler.fatal) errorHandler.fatal(msg);\n    throw msg;\n  }\n})(typeof exports === 'undefined' ? this.imscISD = {} : exports, typeof imscNames === 'undefined' ? require(\"./names\") : imscNames, typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles, typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils);","map":{"version":3,"sources":["/Users/webwerks1/Documents/Project/React Js Training/streamvideo/node_modules/imsc/src/main/js/isd.js"],"names":["imscISD","imscNames","imscStyles","imscUtils","generateISD","tt","offset","errorHandler","isd","ISD","context","r","head","layout","regions","c","isdProcessContentElement","body","contents","push","element","_rcs_na_styles","byName","color","qname","textCombine","textDecoration","textEmphasis","textOutline","textShadow","doc","region","parent","inherited_region_id","elem","begin","end","associated_region_id","regionID","id","length","isd_element","ISDContentElement","i","sets","styleAttrs","value","spec_attr","kind","writingMode","direction","wm","j","all","sa","ps","es","outs","undefined","indexOf","fontSize","ruby","ruby_fs","ComputedLength","rw","rh","parent_fs","inherit","k","ivs","position","origin","iv","styling","initials","initial","piv","parse","reportError","z","cs","compute","cstyle","display","x","qnameb","na","rsp","rubyAlign","rubyPosition","da","byQName","applies","elist","constructSpanList","collapseLWSP","pruneEmptySpans","backgroundImage","text","showBackground","region_id","isPrevCharLWSP","prev_element","test","isNextCharLWSP","next_element","space","trimmed_text","replace","substring","splice","slice","child","aspectRatio","lang","ttelem","sname","src","type","reportInfo","msg","info","reportWarning","warn","error","reportFatal","fatal","exports","require"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;;AACA,CAAC,UAAUA,OAAV,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0CC,SAA1C,EAAqD;AAAE;;AAEpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEIH,EAAAA,OAAO,CAACI,WAAR,GAAsB,UAAUC,EAAV,EAAcC,MAAd,EAAsBC,YAAtB,EAAoC;AAEtD;;AAEA;AAEA,QAAIC,GAAG,GAAG,IAAIC,GAAJ,CAAQJ,EAAR,CAAV;AAEA;;AAEA,QAAIK,OAAO,GAAG;AAEV;;AAAe;AAFL,KAAd;AAMA;;AAEA,SAAK,IAAIC,CAAT,IAAcN,EAAE,CAACO,IAAH,CAAQC,MAAR,CAAeC,OAA7B,EAAsC;AAElC;AAEA,UAAIC,CAAC,GAAGC,wBAAwB,CAACX,EAAD,EAAKC,MAAL,EAAaD,EAAE,CAACO,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBH,CAAvB,CAAb,EAAwCN,EAAE,CAACY,IAA3C,EAAiD,IAAjD,EAAuD,EAAvD,EAA2DZ,EAAE,CAACO,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBH,CAAvB,CAA3D,EAAsFJ,YAAtF,EAAoGG,OAApG,CAAhC;;AAEA,UAAIK,CAAC,KAAK,IAAV,EAAgB;AAEZ;AAEAP,QAAAA,GAAG,CAACU,QAAJ,CAAaC,IAAb,CAAkBJ,CAAC,CAACK,OAApB;AACH;AAGJ;;AAED,WAAOZ,GAAP;AACH,GAnCD;AAqCA;;;AAEA,MAAIa,cAAc,GAAG,CACjBnB,UAAU,CAACoB,MAAX,CAAkBC,KAAlB,CAAwBC,KADP,EAEjBtB,UAAU,CAACoB,MAAX,CAAkBG,WAAlB,CAA8BD,KAFb,EAGjBtB,UAAU,CAACoB,MAAX,CAAkBI,cAAlB,CAAiCF,KAHhB,EAIjBtB,UAAU,CAACoB,MAAX,CAAkBK,YAAlB,CAA+BH,KAJd,EAKjBtB,UAAU,CAACoB,MAAX,CAAkBM,WAAlB,CAA8BJ,KALb,EAMjBtB,UAAU,CAACoB,MAAX,CAAkBO,UAAlB,CAA6BL,KANZ,CAArB;;AASA,WAASR,wBAAT,CAAkCc,GAAlC,EAAuCxB,MAAvC,EAA+CyB,MAA/C,EAAuDd,IAAvD,EAA6De,MAA7D,EAAqEC,mBAArE,EAA0FC,IAA1F,EAAgG3B,YAAhG,EAA8GG,OAA9G,EAAuH;AAEnH;AAEA,QAAIJ,MAAM,GAAG4B,IAAI,CAACC,KAAd,IAAuB7B,MAAM,IAAI4B,IAAI,CAACE,GAA1C,EAA+C;AAC3C,aAAO,IAAP;AACH;AAED;AACR;AACA;AACA;;;AAEQ,QAAIC,oBAAoB,GAAG,cAAcH,IAAd,IAAsBA,IAAI,CAACI,QAAL,KAAkB,EAAxC,GAA6CJ,IAAI,CAACI,QAAlD,GAA6DL,mBAAxF;AAEA;AACR;AACA;AACA;AACA;AACA;;AAEQ;;AAEA,QAAID,MAAM,KAAK;AAAK;AAAhB,OACAK,oBAAoB,KAAKN,MAAM,CAACQ,EADhC,KAGK,EAAE,cAAcL,IAAhB,CAAD,IACC,cAAcA,IAAd,IAAsBA,IAAI,CAAChB,QAAL,CAAcsB,MAAd,KAAyB,CADhD,IAEAH,oBAAoB,KAAK,EAL7B,CAAJ,EAQI,OAAO,IAAP;AAEJ;;AAEA,QAAII,WAAW,GAAG,IAAIC,iBAAJ,CAAsBR,IAAtB,CAAlB;AAEA;;AAEA,SAAK,IAAIS,CAAT,IAAcT,IAAI,CAACU,IAAnB,EAAyB;AAErB,UAAItC,MAAM,GAAG4B,IAAI,CAACU,IAAL,CAAUD,CAAV,EAAaR,KAAtB,IAA+B7B,MAAM,IAAI4B,IAAI,CAACU,IAAL,CAAUD,CAAV,EAAaP,GAA1D,EACI;AAEJK,MAAAA,WAAW,CAACI,UAAZ,CAAuBX,IAAI,CAACU,IAAL,CAAUD,CAAV,EAAanB,KAApC,IAA6CU,IAAI,CAACU,IAAL,CAAUD,CAAV,EAAaG,KAA1D;AAEH;AAED;AACR;AACA;AACA;;;AAEQ,QAAIC,SAAS,GAAG,EAAhB;;AAEA,SAAK,IAAIvB,KAAT,IAAkBiB,WAAW,CAACI,UAA9B,EAA0C;AAEtCE,MAAAA,SAAS,CAACvB,KAAD,CAAT,GAAmB,IAAnB;AAEA;AACZ;AACA;AACA;;AAEY,UAAIiB,WAAW,CAACO,IAAZ,KAAqB,QAArB,IACAxB,KAAK,KAAKtB,UAAU,CAACoB,MAAX,CAAkB2B,WAAlB,CAA8BzB,KADxC,IAEA,EAAEtB,UAAU,CAACoB,MAAX,CAAkB4B,SAAlB,CAA4B1B,KAA5B,IAAqCiB,WAAW,CAACI,UAAnD,CAFJ,EAEoE;AAEhE,YAAIM,EAAE,GAAGV,WAAW,CAACI,UAAZ,CAAuBrB,KAAvB,CAAT;;AAEA,YAAI2B,EAAE,KAAK,MAAP,IAAiBA,EAAE,KAAK,IAA5B,EAAkC;AAE9BV,UAAAA,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkB4B,SAAlB,CAA4B1B,KAAnD,IAA4D,KAA5D;AAEH,SAJD,MAIO,IAAI2B,EAAE,KAAK,MAAP,IAAiBA,EAAE,KAAK,IAA5B,EAAkC;AAErCV,UAAAA,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkB4B,SAAlB,CAA4B1B,KAAnD,IAA4D,KAA5D;AAEH;AAEJ;AACJ;AAED;;;AAEA,QAAIQ,MAAM,KAAK,IAAf,EAAqB;AAEjB,WAAK,IAAIoB,CAAT,IAAclD,UAAU,CAACmD,GAAzB,EAA8B;AAE1B,YAAIC,EAAE,GAAGpD,UAAU,CAACmD,GAAX,CAAeD,CAAf,CAAT;AAEA;;AAEA,YAAIE,EAAE,CAAC9B,KAAH,KAAatB,UAAU,CAACoB,MAAX,CAAkBI,cAAlB,CAAiCF,KAAlD,EAAyD;AAErD;AAEA,cAAI+B,EAAE,GAAGvB,MAAM,CAACa,UAAP,CAAkBS,EAAE,CAAC9B,KAArB,CAAT;AACA,cAAIgC,EAAE,GAAGf,WAAW,CAACI,UAAZ,CAAuBS,EAAE,CAAC9B,KAA1B,CAAT;AACA,cAAIiC,IAAI,GAAG,EAAX;;AAEA,cAAID,EAAE,KAAKE,SAAX,EAAsB;AAElBD,YAAAA,IAAI,GAAGF,EAAP;AAEH,WAJD,MAIO,IAAIC,EAAE,CAACG,OAAH,CAAW,MAAX,MAAuB,CAAC,CAA5B,EAA+B;AAElC,gBAAKH,EAAE,CAACG,OAAH,CAAW,aAAX,MAA8B,CAAC,CAA/B,IACDJ,EAAE,CAACI,OAAH,CAAW,WAAX,MAA4B,CAAC,CAD7B,IAEAH,EAAE,CAACG,OAAH,CAAW,WAAX,MAA4B,CAAC,CAFjC,EAEoC;AAEhCF,cAAAA,IAAI,CAACtC,IAAL,CAAU,WAAV;AAEH;;AAED,gBAAKqC,EAAE,CAACG,OAAH,CAAW,eAAX,MAAgC,CAAC,CAAjC,IACDJ,EAAE,CAACI,OAAH,CAAW,aAAX,MAA8B,CAAC,CAD/B,IAEAH,EAAE,CAACG,OAAH,CAAW,aAAX,MAA8B,CAAC,CAFnC,EAEsC;AAElCF,cAAAA,IAAI,CAACtC,IAAL,CAAU,aAAV;AAEH;;AAED,gBAAKqC,EAAE,CAACG,OAAH,CAAW,YAAX,MAA6B,CAAC,CAA9B,IACDJ,EAAE,CAACI,OAAH,CAAW,UAAX,MAA2B,CAAC,CAD5B,IAEAH,EAAE,CAACG,OAAH,CAAW,UAAX,MAA2B,CAAC,CAFhC,EAEmC;AAE/BF,cAAAA,IAAI,CAACtC,IAAL,CAAU,UAAV;AAEH;AAEJ,WA1BM,MA0BA;AAEHsC,YAAAA,IAAI,CAACtC,IAAL,CAAU,MAAV;AAEH;;AAEDsB,UAAAA,WAAW,CAACI,UAAZ,CAAuBS,EAAE,CAAC9B,KAA1B,IAAmCiC,IAAnC;AAEH,SA9CD,MA8CO,IAAIH,EAAE,CAAC9B,KAAH,KAAatB,UAAU,CAACoB,MAAX,CAAkBsC,QAAlB,CAA2BpC,KAAxC,IACP,EAAE8B,EAAE,CAAC9B,KAAH,IAAYiB,WAAW,CAACI,UAA1B,CADO,IAEPJ,WAAW,CAACO,IAAZ,KAAqB,MAFd,IAGPP,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkBuC,IAAlB,CAAuBrC,KAA9C,MAAyD,eAHtD,EAGuE;AAE1E;AAEA,cAAIsC,OAAO,GAAG9B,MAAM,CAACa,UAAP,CAAkB3C,UAAU,CAACoB,MAAX,CAAkBsC,QAAlB,CAA2BpC,KAA7C,CAAd;AAEAiB,UAAAA,WAAW,CAACI,UAAZ,CAAuBS,EAAE,CAAC9B,KAA1B,IAAmC,IAAIrB,SAAS,CAAC4D,cAAd,CAC/B,MAAMD,OAAO,CAACE,EADiB,EAE/B,MAAMF,OAAO,CAACG,EAFiB,CAAnC;AAIH,SAbM,MAaA,IAAIX,EAAE,CAAC9B,KAAH,KAAatB,UAAU,CAACoB,MAAX,CAAkBsC,QAAlB,CAA2BpC,KAAxC,IACP,EAAE8B,EAAE,CAAC9B,KAAH,IAAYiB,WAAW,CAACI,UAA1B,CADO,IAEPJ,WAAW,CAACO,IAAZ,KAAqB,MAFd,IAGPP,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkBuC,IAAlB,CAAuBrC,KAA9C,MAAyD,MAHtD,EAG8D;AAEjE;AAEA,cAAI0C,SAAS,GAAGlC,MAAM,CAACa,UAAP,CAAkB3C,UAAU,CAACoB,MAAX,CAAkBsC,QAAlB,CAA2BpC,KAA7C,CAAhB;;AAEA,cAAIQ,MAAM,CAACa,UAAP,CAAkB3C,UAAU,CAACoB,MAAX,CAAkBuC,IAAlB,CAAuBrC,KAAzC,MAAoD,eAAxD,EAAyE;AAErEiB,YAAAA,WAAW,CAACI,UAAZ,CAAuBS,EAAE,CAAC9B,KAA1B,IAAmC0C,SAAnC;AAEH,WAJD,MAIO;AAEHzB,YAAAA,WAAW,CAACI,UAAZ,CAAuBS,EAAE,CAAC9B,KAA1B,IAAmC,IAAIrB,SAAS,CAAC4D,cAAd,CAC/B,MAAMG,SAAS,CAACF,EADe,EAE/B,MAAME,SAAS,CAACD,EAFe,CAAnC;AAGH;AAEJ,SApBM,MAoBA,IAAIX,EAAE,CAACa,OAAH,IACNb,EAAE,CAAC9B,KAAH,IAAYQ,MAAM,CAACa,UADb,IAEP,EAAES,EAAE,CAAC9B,KAAH,IAAYiB,WAAW,CAACI,UAA1B,CAFG,EAEoC;AAEvCJ,UAAAA,WAAW,CAACI,UAAZ,CAAuBS,EAAE,CAAC9B,KAA1B,IAAmCQ,MAAM,CAACa,UAAP,CAAkBS,EAAE,CAAC9B,KAArB,CAAnC;AAEH;AAEJ;AAEJ;AAED;;;AAEA,SAAK,IAAI4C,CAAT,IAAclE,UAAU,CAACmD,GAAzB,EAA8B;AAE1B,UAAIgB,GAAG,GAAGnE,UAAU,CAACmD,GAAX,CAAee,CAAf,CAAV;AAEA;;AAEA,UAAIC,GAAG,CAAC7C,KAAJ,IAAaiB,WAAW,CAACI,UAA7B,EAAyC;AAEzC;;AAEA,UAAIwB,GAAG,CAAC7C,KAAJ,KAActB,UAAU,CAACoB,MAAX,CAAkBgD,QAAlB,CAA2B9C,KAAzC,IACAtB,UAAU,CAACoB,MAAX,CAAkBiD,MAAlB,CAAyB/C,KAAzB,IAAkCiB,WAAW,CAACI,UADlD,EAEI;AAEJ;;AAEA,UAAIwB,GAAG,CAAC7C,KAAJ,KAActB,UAAU,CAACoB,MAAX,CAAkBiD,MAAlB,CAAyB/C,KAAvC,IACAtB,UAAU,CAACoB,MAAX,CAAkBgD,QAAlB,CAA2B9C,KAA3B,IAAoCiB,WAAW,CAACI,UADpD,EAEI;AAEJ;;AAEA,UAAI2B,EAAE,GAAG1C,GAAG,CAAClB,IAAJ,CAAS6D,OAAT,CAAiBC,QAAjB,CAA0BL,GAAG,CAAC7C,KAA9B,KAAwC6C,GAAG,CAACM,OAArD;;AAEA,UAAIH,EAAE,KAAK,IAAX,EAAiB;AACb;AAEA;AACH;AAED;;;AAEA,UAAI/B,WAAW,CAACO,IAAZ,KAAqB,QAArB,IAAkCqB,GAAG,CAACF,OAAJ,KAAgB,KAAhB,IAAyBK,EAAE,KAAK,IAAtE,EAA6E;AAEzE,YAAII,GAAG,GAAGP,GAAG,CAACQ,KAAJ,CAAUL,EAAV,CAAV;;AAEA,YAAII,GAAG,KAAK,IAAZ,EAAkB;AAEdnC,UAAAA,WAAW,CAACI,UAAZ,CAAuBwB,GAAG,CAAC7C,KAA3B,IAAoCoD,GAApC;AAEA;;AAEA7B,UAAAA,SAAS,CAACsB,GAAG,CAAC7C,KAAL,CAAT,GAAuB,IAAvB;AAEH,SARD,MAQO;AAEHsD,UAAAA,WAAW,CAACvE,YAAD,EAAe,gCAAgC8D,GAAG,CAAC7C,KAApC,GAA4C,gBAA5C,GAA+DiB,WAAW,CAACO,IAA1F,CAAX;AAEH;AAEJ;AAEJ;AAED;;AACA;;;AAEA,SAAK,IAAI+B,CAAT,IAAc7E,UAAU,CAACmD,GAAzB,EAA8B;AAE1B,UAAI2B,EAAE,GAAG9E,UAAU,CAACmD,GAAX,CAAe0B,CAAf,CAAT;AAEA,UAAI,EAAEC,EAAE,CAACxD,KAAH,IAAYuB,SAAd,CAAJ,EAA8B;;AAE9B,UAAIiC,EAAE,CAACC,OAAH,KAAe,IAAnB,EAAyB;AAErB,YAAIC,MAAM,GAAGF,EAAE,CAACC,OAAH;AACT;AACAnD,QAAAA,GAFS,EAGTE,MAHS,EAITS,WAJS,EAKTA,WAAW,CAACI,UAAZ,CAAuBmC,EAAE,CAACxD,KAA1B,CALS,EAMTd,OANS,CAAb;;AASA,YAAIwE,MAAM,KAAK,IAAf,EAAqB;AAEjBzC,UAAAA,WAAW,CAACI,UAAZ,CAAuBmC,EAAE,CAACxD,KAA1B,IAAmC0D,MAAnC;AAEH,SAJD,MAIO;AACH;AAEAzC,UAAAA,WAAW,CAACI,UAAZ,CAAuBmC,EAAE,CAACxD,KAA1B,IAAmCwD,EAAE,CAACC,OAAH;AAC/B;AACAnD,UAAAA,GAF+B,EAG/BE,MAH+B,EAI/BS,WAJ+B,EAK/BuC,EAAE,CAACH,KAAH,CAASG,EAAE,CAACL,OAAZ,CAL+B,EAM/BjE,OAN+B,CAAnC;AASAoE,UAAAA,WAAW,CAACvE,YAAD,EAAe,YAAYyE,EAAE,CAACxD,KAAf,GAAuB,gBAAvB,GAA0CiB,WAAW,CAACO,IAAtD,GAA6D,sBAA5E,CAAX;AACH;AACJ;AAEJ;AAED;;;AAEA,QAAIP,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkB6D,OAAlB,CAA0B3D,KAAjD,MAA4D,MAAhE,EACI,OAAO,IAAP;AAEJ;;AAEA,QAAIN,QAAJ;;AAEA,QAAIc,MAAM,KAAK,IAAf,EAAqB;AAEjB;AAEA,UAAIf,IAAI,KAAK,IAAb,EAAmB;AAEf;AAEAC,QAAAA,QAAQ,GAAG,EAAX;AAEH,OAND,MAMO;AAEH;AAEAA,QAAAA,QAAQ,GAAG,CAACD,IAAD,CAAX;AAEH;AAEJ,KAlBD,MAkBO,IAAI,cAAciB,IAAlB,EAAwB;AAE3BhB,MAAAA,QAAQ,GAAGgB,IAAI,CAAChB,QAAhB;AAEH;;AAED,SAAK,IAAIkE,CAAT,IAAclE,QAAd,EAAwB;AAEpB,UAAIH,CAAC,GAAGC,wBAAwB,CAACc,GAAD,EAAMxB,MAAN,EAAcyB,MAAd,EAAsBd,IAAtB,EAA4BwB,WAA5B,EAAyCJ,oBAAzC,EAA+DnB,QAAQ,CAACkE,CAAD,CAAvE,EAA4E7E,YAA5E,EAA0FG,OAA1F,CAAhC;AAEA;AACZ;AACA;AACA;;AAEY,UAAIK,CAAC,KAAK,IAAV,EAAgB;AAEZ0B,QAAAA,WAAW,CAACvB,QAAZ,CAAqBC,IAArB,CAA0BJ,CAAC,CAACK,OAA5B;AAEH;AAEJ;AAED;;;AAEA,SAAK,IAAIiE,MAAT,IAAmB5C,WAAW,CAACI,UAA/B,EAA2C;AAEvC;AAEA,UAAIyC,EAAE,GAAG,KAAT;AAEA;;AACA;;AAEA,UAAI7C,WAAW,CAACO,IAAZ,KAAqB,MAAzB,EAAiC;AAE7B,YAAIuC,GAAG,GAAG9C,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkBuC,IAAlB,CAAuBrC,KAA9C,CAAV;AAEA8D,QAAAA,EAAE,GAAG,CAAEC,GAAG,KAAK,WAAR,IAAuBA,GAAG,KAAK,eAA/B,IAAkDA,GAAG,KAAK,eAA5D,KACDlE,cAAc,CAACsC,OAAf,CAAuB0B,MAAvB,MAAmC,CAAC,CADxC;;AAGA,YAAI,CAAEC,EAAN,EAAU;AAENA,UAAAA,EAAE,GAAGC,GAAG,KAAK,WAAR,IACDF,MAAM,KAAKnF,UAAU,CAACoB,MAAX,CAAkBkE,SAAlB,CAA4BhE,KAD3C;AAGH;;AAED,YAAI,CAAE8D,EAAN,EAAU;AAENA,UAAAA,EAAE,GAAK,EAAGC,GAAG,KAAK,eAAR,IAA2BA,GAAG,KAAK,MAAtC,CAAD,IACFF,MAAM,KAAKnF,UAAU,CAACoB,MAAX,CAAkBmE,YAAlB,CAA+BjE,KAD9C;AAGH;AAEJ;AAED;;;AAEA,UAAI,CAAE8D,EAAN,EAAU;AAEN,YAAII,EAAE,GAAGxF,UAAU,CAACyF,OAAX,CAAmBN,MAAnB,CAAT;AACAC,QAAAA,EAAE,GAAGI,EAAE,CAACE,OAAH,CAAWjC,OAAX,CAAmBlB,WAAW,CAACO,IAA/B,MAAyC,CAAC,CAA/C;AAEH;;AAGD,UAAIsC,EAAJ,EAAQ;AACJ,eAAO7C,WAAW,CAACI,UAAZ,CAAuBwC,MAAvB,CAAP;AACH;AAEJ;AAED;;;AAEA,QAAIxB,IAAI,GAAGpB,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkBuC,IAAlB,CAAuBrC,KAA9C,CAAX;;AAEA,QAAIiB,WAAW,CAACO,IAAZ,KAAqB,GAArB,IACCP,WAAW,CAACO,IAAZ,KAAqB,MAArB,KAAgCa,IAAI,KAAK,eAAT,IAA4BA,IAAI,KAAK,MAArE,CADL,EAEM;AAEF,UAAIgC,KAAK,GAAG,EAAZ;AAEAC,MAAAA,iBAAiB,CAACrD,WAAD,EAAcoD,KAAd,CAAjB;AAEAE,MAAAA,YAAY,CAACF,KAAD,CAAZ;AAEAG,MAAAA,eAAe,CAACvD,WAAD,CAAf;AAEH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEQ,QAAKA,WAAW,CAACO,IAAZ,KAAqB,KAArB,IAA8B9C,UAAU,CAACoB,MAAX,CAAkB2E,eAAlB,CAAkCzE,KAAlC,IAA2CiB,WAAW,CAACI,UAAtF,IACAJ,WAAW,CAACO,IAAZ,KAAqB,IADrB,IAEAP,WAAW,CAACO,IAAZ,KAAqB,OAFrB,IAGC,cAAcP,WAAd,IAA6BA,WAAW,CAACvB,QAAZ,CAAqBsB,MAArB,GAA8B,CAH5D,IAICC,WAAW,CAACO,IAAZ,KAAqB,MAArB,IAA+BP,WAAW,CAACyD,IAAZ,KAAqB,IAJrD,IAKCzD,WAAW,CAACO,IAAZ,KAAqB,QAArB,IACGP,WAAW,CAACI,UAAZ,CAAuB3C,UAAU,CAACoB,MAAX,CAAkB6E,cAAlB,CAAiC3E,KAAxD,MAAmE,QAN3E,EAMsF;AAElF,aAAO;AACH4E,QAAAA,SAAS,EAAE/D,oBADR;AAEHjB,QAAAA,OAAO,EAAEqB;AAFN,OAAP;AAIH;;AAED,WAAO,IAAP;AACH;;AAED,WAASsD,YAAT,CAAsBF,KAAtB,EAA6B;AAEzB,aAASQ,cAAT,CAAwBC,YAAxB,EAAsC;AAClC,aAAOA,YAAY,CAACtD,IAAb,KAAsB,IAAtB,IAA8B,aAAauD,IAAb,CAAkBD,YAAY,CAACJ,IAA/B,CAArC;AACH;;AAED,aAASM,cAAT,CAAwBC,YAAxB,EAAsC;AAClC,aAAOA,YAAY,CAACzD,IAAb,KAAsB,IAAtB,IAA+ByD,YAAY,CAACC,KAAb,KAAuB,UAAvB,IAAqC,UAAUH,IAAV,CAAeE,YAAY,CAACP,IAA5B,CAA3E;AACH;AAED;;;AAEA,QAAI9E,OAAJ;;AAEA,SAAI,IAAIuB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGkD,KAAK,CAACrD,MAAzB,GAAkC;AAE9BpB,MAAAA,OAAO,GAAGyE,KAAK,CAAClD,CAAD,CAAf;;AAEA,UAAIvB,OAAO,CAAC4B,IAAR,KAAiB,IAAjB,IAAyB5B,OAAO,CAACsF,KAAR,KAAkB,UAA/C,EAA2D;AACvD/D,QAAAA,CAAC;AACD;AACH;;AAED,UAAIgE,YAAY,GAAGvF,OAAO,CAAC8E,IAAR,CAAaU,OAAb,CAAqB,aAArB,EAAoC,GAApC,CAAnB;;AAEA,UAAI,OAAOL,IAAP,CAAYI,YAAZ,CAAJ,EAA+B;AAE3B,YAAIhE,CAAC,KAAK,CAAN,IAAW0D,cAAc,CAACR,KAAK,CAAClD,CAAC,GAAG,CAAL,CAAN,CAA7B,EAA6C;AACzCgE,UAAAA,YAAY,GAAGA,YAAY,CAACE,SAAb,CAAuB,CAAvB,CAAf;AACH;AAEJ;;AAEDzF,MAAAA,OAAO,CAAC8E,IAAR,GAAeS,YAAf;;AAEA,UAAIA,YAAY,CAACnE,MAAb,KAAwB,CAA5B,EAA+B;AAC3BqD,QAAAA,KAAK,CAACiB,MAAN,CAAanE,CAAb,EAAgB,CAAhB;AACH,OAFD,MAEO;AACHA,QAAAA,CAAC;AACJ;AAEJ;AAED;;;AAEA,SAAIA,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGkD,KAAK,CAACrD,MAArB,EAA6BG,CAAC,EAA9B,EAAkC;AAE9BvB,MAAAA,OAAO,GAAGyE,KAAK,CAAClD,CAAD,CAAf;;AAEA,UAAIvB,OAAO,CAAC4B,IAAR,KAAiB,IAAjB,IAAyB5B,OAAO,CAACsF,KAAR,KAAkB,UAA/C,EAA2D;AACvD/D,QAAAA,CAAC;AACD;AACH;;AAED,UAAI,OAAO4D,IAAP,CAAYnF,OAAO,CAAC8E,IAApB,CAAJ,EAA+B;AAE3B,YAAIvD,CAAC,KAAMkD,KAAK,CAACrD,MAAN,GAAe,CAAtB,IAA4BgE,cAAc,CAACX,KAAK,CAAClD,CAAC,GAAG,CAAL,CAAN,CAA9C,EAA8D;AAC1DvB,UAAAA,OAAO,CAAC8E,IAAR,GAAe9E,OAAO,CAAC8E,IAAR,CAAaa,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,CAAf;AACH;AAEJ;AAEJ;AAEJ;;AAED,WAASjB,iBAAT,CAA2B1E,OAA3B,EAAoCyE,KAApC,EAA2C;AAEvC,SAAK,IAAIlD,CAAT,IAAcvB,OAAO,CAACF,QAAtB,EAAgC;AAE5B,UAAI8F,KAAK,GAAG5F,OAAO,CAACF,QAAR,CAAiByB,CAAjB,CAAZ;AACA,UAAIkB,IAAI,GAAGmD,KAAK,CAACnE,UAAN,CAAiB3C,UAAU,CAACoB,MAAX,CAAkBuC,IAAlB,CAAuBrC,KAAxC,CAAX;;AAEA,UAAIwF,KAAK,CAAChE,IAAN,KAAe,MAAf,KAA0Ba,IAAI,KAAK,eAAT,IAA4BA,IAAI,KAAK,MAA/D,CAAJ,EAA4E;AAExE;AAEA;AAEH,OAND,MAMO,IAAI,cAAcmD,KAAlB,EAAyB;AAE5BlB,QAAAA,iBAAiB,CAACkB,KAAD,EAAQnB,KAAR,CAAjB;AAEH,OAJM,MAIA,IAAKmB,KAAK,CAAChE,IAAN,KAAe,MAAf,IAAyBgE,KAAK,CAACd,IAAN,CAAW1D,MAAX,KAAsB,CAAhD,IAAsDwE,KAAK,CAAChE,IAAN,KAAe,IAAzE,EAA+E;AAElF;AAEA6C,QAAAA,KAAK,CAAC1E,IAAN,CAAW6F,KAAX;AAEH;AAEJ;AAEJ;;AAED,WAAShB,eAAT,CAAyB5E,OAAzB,EAAkC;AAE9B,QAAIA,OAAO,CAAC4B,IAAR,KAAiB,IAArB,EAA2B;AAEvB,aAAO,KAAP;AAEH,KAJD,MAIO,IAAI,UAAU5B,OAAd,EAAuB;AAE1B,aAAQA,OAAO,CAAC8E,IAAR,CAAa1D,MAAb,KAAwB,CAAhC;AAEH,KAJM,MAIA,IAAI,cAAcpB,OAAlB,EAA2B;AAE9B,UAAIuB,CAAC,GAAGvB,OAAO,CAACF,QAAR,CAAiBsB,MAAzB;;AAEA,aAAOG,CAAC,EAAR,EAAY;AAER,YAAIqD,eAAe,CAAC5E,OAAO,CAACF,QAAR,CAAiByB,CAAjB,CAAD,CAAnB,EAA0C;AACtCvB,UAAAA,OAAO,CAACF,QAAR,CAAiB4F,MAAjB,CAAwBnE,CAAxB,EAA2B,CAA3B;AACH;AAEJ;;AAED,aAAOvB,OAAO,CAACF,QAAR,CAAiBsB,MAAjB,KAA4B,CAAnC;AAEH;AACJ;;AAED,WAAS/B,GAAT,CAAaJ,EAAb,EAAiB;AACb,SAAKa,QAAL,GAAgB,EAAhB;AACA,SAAK+F,WAAL,GAAmB5G,EAAE,CAAC4G,WAAtB;AACA,SAAKC,IAAL,GAAY7G,EAAE,CAAC6G,IAAf;AACH;;AAED,WAASxE,iBAAT,CAA2ByE,MAA3B,EAAmC;AAE/B;AAEA,SAAKnE,IAAL,GAAYmE,MAAM,CAACnE,IAAP,IAAe,QAA3B;AAEA;;AAEA,SAAKkE,IAAL,GAAYC,MAAM,CAACD,IAAnB;AAEA;;AAEA,QAAIC,MAAM,CAAC5E,EAAX,EAAe;AACX,WAAKA,EAAL,GAAU4E,MAAM,CAAC5E,EAAjB;AACH;AAED;;;AACA,SAAKM,UAAL,GAAkB,EAAlB;;AAEA,SAAK,IAAIuE,KAAT,IAAkBD,MAAM,CAACtE,UAAzB,EAAqC;AAEjC,WAAKA,UAAL,CAAgBuE,KAAhB,IACID,MAAM,CAACtE,UAAP,CAAkBuE,KAAlB,CADJ;AAEH;AAED;;;AAEA,QAAI,SAASD,MAAb,EAAqB;AAEjB,WAAKE,GAAL,GAAWF,MAAM,CAACE,GAAlB;AAEH;;AAEA,QAAI,UAAUF,MAAd,EAAsB;AAEnB,WAAKG,IAAL,GAAYH,MAAM,CAACG,IAAnB;AAEH;AAED;AACR;;;AAEQ,QAAI,UAAUH,MAAd,EAAsB;AAElB,WAAKjB,IAAL,GAAYiB,MAAM,CAACjB,IAAnB;AAEH,KAJD,MAIO,IAAI,KAAKlD,IAAL,KAAc,QAAd,IAA0B,cAAcmE,MAA5C,EAAoD;AAEvD,WAAKjG,QAAL,GAAgB,EAAhB;AACH;;AAED,QAAI,WAAWiG,MAAf,EAAuB;AAEnB,WAAKT,KAAL,GAAaS,MAAM,CAACT,KAApB;AACH;AACJ;AAGD;AACJ;AACA;AACA;;;AAEI,WAASa,UAAT,CAAoBhH,YAApB,EAAkCiH,GAAlC,EAAuC;AAEnC,QAAIjH,YAAY,IAAIA,YAAY,CAACkH,IAA7B,IAAqClH,YAAY,CAACkH,IAAb,CAAkBD,GAAlB,CAAzC,EACI,MAAMA,GAAN;AAEP;;AAED,WAASE,aAAT,CAAuBnH,YAAvB,EAAqCiH,GAArC,EAA0C;AAEtC,QAAIjH,YAAY,IAAIA,YAAY,CAACoH,IAA7B,IAAqCpH,YAAY,CAACoH,IAAb,CAAkBH,GAAlB,CAAzC,EACI,MAAMA,GAAN;AAEP;;AAED,WAAS1C,WAAT,CAAqBvE,YAArB,EAAmCiH,GAAnC,EAAwC;AAEpC,QAAIjH,YAAY,IAAIA,YAAY,CAACqH,KAA7B,IAAsCrH,YAAY,CAACqH,KAAb,CAAmBJ,GAAnB,CAA1C,EACI,MAAMA,GAAN;AAEP;;AAED,WAASK,WAAT,CAAqBtH,YAArB,EAAmCiH,GAAnC,EAAwC;AAEpC,QAAIjH,YAAY,IAAIA,YAAY,CAACuH,KAAjC,EACIvH,YAAY,CAACuH,KAAb,CAAmBN,GAAnB;AAEJ,UAAMA,GAAN;AAEH;AAGJ,CAtsBD,EAssBG,OAAOO,OAAP,KAAmB,WAAnB,GAAiC,KAAK/H,OAAL,GAAe,EAAhD,GAAqD+H,OAtsBxD,EAusBI,OAAO9H,SAAP,KAAqB,WAArB,GAAmC+H,OAAO,CAAC,SAAD,CAA1C,GAAwD/H,SAvsB5D,EAwsBI,OAAOC,UAAP,KAAsB,WAAtB,GAAoC8H,OAAO,CAAC,UAAD,CAA3C,GAA0D9H,UAxsB9D,EAysBI,OAAOC,SAAP,KAAqB,WAArB,GAAmC6H,OAAO,CAAC,SAAD,CAA1C,GAAwD7H,SAzsB5D","sourcesContent":["/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * @module imscISD\r\n */\r\n\r\n\r\n;\r\n(function (imscISD, imscNames, imscStyles, imscUtils) { // wrapper for non-node envs\r\n\r\n    /** \r\n     * Creates a canonical representation of an IMSC1 document returned by <pre>imscDoc.fromXML()</pre>\r\n     * at a given absolute offset in seconds. This offset does not have to be one of the values returned\r\n     * by <pre>getMediaTimeEvents()</pre>.\r\n     * \r\n     * @param {Object} tt IMSC1 document\r\n     * @param {number} offset Absolute offset (in seconds)\r\n     * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n     * @returns {Object} Opaque in-memory representation of an ISD\r\n     */\r\n\r\n    imscISD.generateISD = function (tt, offset, errorHandler) {\r\n\r\n        /* TODO check for tt and offset validity */\r\n\r\n        /* create the ISD object from the IMSC1 doc */\r\n\r\n        var isd = new ISD(tt);\r\n\r\n        /* context */\r\n\r\n        var context = {\r\n\r\n            /*rubyfs: []*/ /* font size of the nearest textContainer or container */\r\n\r\n        };\r\n\r\n        /* process regions */\r\n\r\n        for (var r in tt.head.layout.regions) {\r\n\r\n            /* post-order traversal of the body tree per [construct intermediate document] */\r\n\r\n            var c = isdProcessContentElement(tt, offset, tt.head.layout.regions[r], tt.body, null, '', tt.head.layout.regions[r], errorHandler, context);\r\n\r\n            if (c !== null) {\r\n\r\n                /* add the region to the ISD */\r\n\r\n                isd.contents.push(c.element);\r\n            }\r\n\r\n\r\n        }\r\n\r\n        return isd;\r\n    };\r\n\r\n    /* set of styles not applicable to ruby container spans */\r\n\r\n    var _rcs_na_styles = [\r\n        imscStyles.byName.color.qname,\r\n        imscStyles.byName.textCombine.qname,\r\n        imscStyles.byName.textDecoration.qname,\r\n        imscStyles.byName.textEmphasis.qname,\r\n        imscStyles.byName.textOutline.qname,\r\n        imscStyles.byName.textShadow.qname\r\n    ];\r\n\r\n    function isdProcessContentElement(doc, offset, region, body, parent, inherited_region_id, elem, errorHandler, context) {\r\n\r\n        /* prune if temporally inactive */\r\n\r\n        if (offset < elem.begin || offset >= elem.end) {\r\n            return null;\r\n        }\r\n\r\n        /* \r\n         * set the associated region as specified by the regionID attribute, or the \r\n         * inherited associated region otherwise\r\n         */\r\n\r\n        var associated_region_id = 'regionID' in elem && elem.regionID !== '' ? elem.regionID : inherited_region_id;\r\n\r\n        /* prune the element if either:\r\n         * - the element is not terminal and the associated region is neither the default\r\n         *   region nor the parent region (this allows children to be associated with a \r\n         *   region later on)\r\n         * - the element is terminal and the associated region is not the parent region\r\n         */\r\n\r\n        /* TODO: improve detection of terminal elements since <region> has no contents */\r\n\r\n        if (parent !== null /* are we in the region element */ &&\r\n            associated_region_id !== region.id &&\r\n            (\r\n                (!('contents' in elem)) ||\r\n                ('contents' in elem && elem.contents.length === 0) ||\r\n                associated_region_id !== ''\r\n                )\r\n            )\r\n            return null;\r\n\r\n        /* create an ISD element, including applying specified styles */\r\n\r\n        var isd_element = new ISDContentElement(elem);\r\n\r\n        /* apply set (animation) styling */\r\n\r\n        for (var i in elem.sets) {\r\n\r\n            if (offset < elem.sets[i].begin || offset >= elem.sets[i].end)\r\n                continue;\r\n\r\n            isd_element.styleAttrs[elem.sets[i].qname] = elem.sets[i].value;\r\n\r\n        }\r\n\r\n        /* \r\n         * keep track of specified styling attributes so that we\r\n         * can compute them later\r\n         */\r\n\r\n        var spec_attr = {};\r\n\r\n        for (var qname in isd_element.styleAttrs) {\r\n\r\n            spec_attr[qname] = true;\r\n\r\n            /* special rule for tts:writingMode (section 7.29.1 of XSL)\r\n             * direction is set consistently with writingMode only\r\n             * if writingMode sets inline-direction to LTR or RTL  \r\n             */\r\n\r\n            if (isd_element.kind === 'region' &&\r\n                qname === imscStyles.byName.writingMode.qname &&\r\n                !(imscStyles.byName.direction.qname in isd_element.styleAttrs)) {\r\n\r\n                var wm = isd_element.styleAttrs[qname];\r\n\r\n                if (wm === \"lrtb\" || wm === \"lr\") {\r\n\r\n                    isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"ltr\";\r\n\r\n                } else if (wm === \"rltb\" || wm === \"rl\") {\r\n\r\n                    isd_element.styleAttrs[imscStyles.byName.direction.qname] = \"rtl\";\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /* inherited styling */\r\n\r\n        if (parent !== null) {\r\n\r\n            for (var j in imscStyles.all) {\r\n\r\n                var sa = imscStyles.all[j];\r\n\r\n                /* textDecoration has special inheritance rules */\r\n\r\n                if (sa.qname === imscStyles.byName.textDecoration.qname) {\r\n\r\n                    /* handle both textDecoration inheritance and specification */\r\n\r\n                    var ps = parent.styleAttrs[sa.qname];\r\n                    var es = isd_element.styleAttrs[sa.qname];\r\n                    var outs = [];\r\n\r\n                    if (es === undefined) {\r\n\r\n                        outs = ps;\r\n\r\n                    } else if (es.indexOf(\"none\") === -1) {\r\n\r\n                        if ((es.indexOf(\"noUnderline\") === -1 &&\r\n                            ps.indexOf(\"underline\") !== -1) ||\r\n                            es.indexOf(\"underline\") !== -1) {\r\n\r\n                            outs.push(\"underline\");\r\n\r\n                        }\r\n\r\n                        if ((es.indexOf(\"noLineThrough\") === -1 &&\r\n                            ps.indexOf(\"lineThrough\") !== -1) ||\r\n                            es.indexOf(\"lineThrough\") !== -1) {\r\n\r\n                            outs.push(\"lineThrough\");\r\n\r\n                        }\r\n\r\n                        if ((es.indexOf(\"noOverline\") === -1 &&\r\n                            ps.indexOf(\"overline\") !== -1) ||\r\n                            es.indexOf(\"overline\") !== -1) {\r\n\r\n                            outs.push(\"overline\");\r\n\r\n                        }\r\n\r\n                    } else {\r\n\r\n                        outs.push(\"none\");\r\n\r\n                    }\r\n\r\n                    isd_element.styleAttrs[sa.qname] = outs;\r\n\r\n                } else if (sa.qname === imscStyles.byName.fontSize.qname &&\r\n                    !(sa.qname in isd_element.styleAttrs) &&\r\n                    isd_element.kind === 'span' &&\r\n                    isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\r\n                    \r\n                    /* special inheritance rule for ruby text container font size */\r\n                    \r\n                    var ruby_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\r\n\r\n                    isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(\r\n                        0.5 * ruby_fs.rw,\r\n                        0.5 * ruby_fs.rh);\r\n\r\n                } else if (sa.qname === imscStyles.byName.fontSize.qname &&\r\n                    !(sa.qname in isd_element.styleAttrs) &&\r\n                    isd_element.kind === 'span' &&\r\n                    isd_element.styleAttrs[imscStyles.byName.ruby.qname] === \"text\") {\r\n                    \r\n                    /* special inheritance rule for ruby text font size */\r\n                    \r\n                    var parent_fs = parent.styleAttrs[imscStyles.byName.fontSize.qname];\r\n                    \r\n                    if (parent.styleAttrs[imscStyles.byName.ruby.qname] === \"textContainer\") {\r\n                        \r\n                        isd_element.styleAttrs[sa.qname] = parent_fs;\r\n                        \r\n                    } else {\r\n                        \r\n                        isd_element.styleAttrs[sa.qname] = new imscUtils.ComputedLength(\r\n                            0.5 * parent_fs.rw,\r\n                            0.5 * parent_fs.rh);\r\n                    }\r\n                    \r\n                } else if (sa.inherit &&\r\n                    (sa.qname in parent.styleAttrs) &&\r\n                    !(sa.qname in isd_element.styleAttrs)) {\r\n\r\n                    isd_element.styleAttrs[sa.qname] = parent.styleAttrs[sa.qname];\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* initial value styling */\r\n\r\n        for (var k in imscStyles.all) {\r\n\r\n            var ivs = imscStyles.all[k];\r\n\r\n            /* skip if value is already specified */\r\n\r\n            if (ivs.qname in isd_element.styleAttrs) continue;\r\n\r\n            /* skip tts:position if tts:origin is specified */\r\n\r\n            if (ivs.qname === imscStyles.byName.position.qname &&\r\n                imscStyles.byName.origin.qname in isd_element.styleAttrs)\r\n                continue;\r\n\r\n            /* skip tts:origin if tts:position is specified */\r\n\r\n            if (ivs.qname === imscStyles.byName.origin.qname &&\r\n                imscStyles.byName.position.qname in isd_element.styleAttrs)\r\n                continue;\r\n            \r\n            /* determine initial value */\r\n            \r\n            var iv = doc.head.styling.initials[ivs.qname] || ivs.initial;\r\n\r\n            if (iv === null) {\r\n                /* skip processing if no initial value defined */\r\n\r\n                continue;\r\n            }\r\n\r\n            /* apply initial value to elements other than region only if non-inherited */\r\n\r\n            if (isd_element.kind === 'region' || (ivs.inherit === false && iv !== null)) {\r\n\r\n                var piv = ivs.parse(iv);\r\n\r\n                if (piv !== null) {\r\n\r\n                    isd_element.styleAttrs[ivs.qname] = piv;\r\n\r\n                    /* keep track of the style as specified */\r\n\r\n                    spec_attr[ivs.qname] = true;\r\n\r\n                } else {\r\n\r\n                    reportError(errorHandler, \"Invalid initial value for '\" + ivs.qname + \"' on element '\" + isd_element.kind);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* compute styles (only for non-inherited styles) */\r\n        /* TODO: get rid of spec_attr */\r\n\r\n        for (var z in imscStyles.all) {\r\n\r\n            var cs = imscStyles.all[z];\r\n\r\n            if (!(cs.qname in spec_attr)) continue;\r\n\r\n            if (cs.compute !== null) {\r\n\r\n                var cstyle = cs.compute(\r\n                    /*doc, parent, element, attr, context*/\r\n                    doc,\r\n                    parent,\r\n                    isd_element,\r\n                    isd_element.styleAttrs[cs.qname],\r\n                    context\r\n                    );\r\n\r\n                if (cstyle !== null) {\r\n\r\n                    isd_element.styleAttrs[cs.qname] = cstyle;\r\n                    \r\n                } else {\r\n                    /* if the style cannot be computed, replace it by its initial value */\r\n\r\n                    isd_element.styleAttrs[cs.qname] = cs.compute(\r\n                        /*doc, parent, element, attr, context*/\r\n                        doc,\r\n                        parent,\r\n                        isd_element,\r\n                        cs.parse(cs.initial),\r\n                        context\r\n                    );\r\n\r\n                    reportError(errorHandler, \"Style '\" + cs.qname + \"' on element '\" + isd_element.kind + \"' cannot be computed\");\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /* prune if tts:display is none */\r\n\r\n        if (isd_element.styleAttrs[imscStyles.byName.display.qname] === \"none\")\r\n            return null;\r\n\r\n        /* process contents of the element */\r\n\r\n        var contents;\r\n\r\n        if (parent === null) {\r\n\r\n            /* we are processing the region */\r\n\r\n            if (body === null) {\r\n\r\n                /* if there is no body, still process the region but with empty content */\r\n\r\n                contents = [];\r\n\r\n            } else {\r\n\r\n                /*use the body element as contents */\r\n\r\n                contents = [body];\r\n\r\n            }\r\n\r\n        } else if ('contents' in elem) {\r\n\r\n            contents = elem.contents;\r\n\r\n        }\r\n\r\n        for (var x in contents) {\r\n\r\n            var c = isdProcessContentElement(doc, offset, region, body, isd_element, associated_region_id, contents[x], errorHandler, context);\r\n\r\n            /* \r\n             * keep child element only if they are non-null and their region match \r\n             * the region of this element\r\n             */\r\n\r\n            if (c !== null) {\r\n\r\n                isd_element.contents.push(c.element);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* remove styles that are not applicable */\r\n\r\n        for (var qnameb in isd_element.styleAttrs) {\r\n\r\n            /* true if not applicable */\r\n\r\n            var na = false;\r\n\r\n            /* special applicability of certain style properties to ruby container spans */\r\n            /* TODO: in the future ruby elements should be translated to elements instead of kept as spans */\r\n\r\n            if (isd_element.kind === 'span') {\r\n\r\n                var rsp = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n                na = ( rsp === 'container' || rsp === 'textContainer' || rsp === 'baseContainer' ) && \r\n                    _rcs_na_styles.indexOf(qnameb) !== -1;\r\n\r\n                if (! na) {\r\n\r\n                    na = rsp !== 'container' &&\r\n                        qnameb === imscStyles.byName.rubyAlign.qname;\r\n\r\n                }\r\n\r\n                if (! na) {\r\n\r\n                    na =  (! (rsp === 'textContainer' || rsp === 'text')) &&\r\n                        qnameb === imscStyles.byName.rubyPosition.qname;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            /* normal applicability */\r\n            \r\n            if (! na) {\r\n\r\n                var da = imscStyles.byQName[qnameb];\r\n                na = da.applies.indexOf(isd_element.kind) === -1;\r\n\r\n            }\r\n\r\n\r\n            if (na) {\r\n                delete isd_element.styleAttrs[qnameb];\r\n            }\r\n\r\n        }\r\n\r\n        /* trim whitespace around explicit line breaks */\r\n\r\n        var ruby = isd_element.styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n        if (isd_element.kind === 'p' ||\r\n            (isd_element.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\"))\r\n            ) {\r\n\r\n            var elist = [];\r\n\r\n            constructSpanList(isd_element, elist);\r\n\r\n            collapseLWSP(elist);\r\n\r\n            pruneEmptySpans(isd_element);\r\n\r\n        }\r\n\r\n        /* keep element if:\r\n         * * contains a background image\r\n         * * <br/>\r\n         * * if there are children\r\n         * * if it is an image\r\n         * * if <span> and has text\r\n         * * if region and showBackground = always\r\n         */\r\n\r\n        if ((isd_element.kind === 'div' && imscStyles.byName.backgroundImage.qname in isd_element.styleAttrs) ||\r\n            isd_element.kind === 'br' ||\r\n            isd_element.kind === 'image' ||\r\n            ('contents' in isd_element && isd_element.contents.length > 0) ||\r\n            (isd_element.kind === 'span' && isd_element.text !== null) ||\r\n            (isd_element.kind === 'region' &&\r\n                isd_element.styleAttrs[imscStyles.byName.showBackground.qname] === 'always')) {\r\n\r\n            return {\r\n                region_id: associated_region_id,\r\n                element: isd_element\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function collapseLWSP(elist) {\r\n\r\n        function isPrevCharLWSP(prev_element) {\r\n            return prev_element.kind === 'br' || /[\\r\\n\\t ]$/.test(prev_element.text);\r\n        }\r\n\r\n        function isNextCharLWSP(next_element) {\r\n            return next_element.kind === 'br' || (next_element.space === \"preserve\" && /^[\\r\\n]/.test(next_element.text));\r\n        }\r\n\r\n        /* collapse spaces and remove leading LWSPs */\r\n\r\n        var element;\r\n\r\n        for(var i = 0; i < elist.length;) {\r\n\r\n            element = elist[i];\r\n\r\n            if (element.kind === \"br\" || element.space === \"preserve\") {\r\n                i++;\r\n                continue;\r\n            }\r\n\r\n            var trimmed_text = element.text.replace(/[\\t\\r\\n ]+/g, ' ');\r\n\r\n            if (/^[ ]/.test(trimmed_text)) {\r\n\r\n                if (i === 0 || isPrevCharLWSP(elist[i - 1])) {\r\n                    trimmed_text = trimmed_text.substring(1);\r\n                }\r\n\r\n            }\r\n\r\n            element.text = trimmed_text;\r\n\r\n            if (trimmed_text.length === 0) {\r\n                elist.splice(i, 1);\r\n            } else {\r\n                i++;\r\n            }\r\n\r\n        }\r\n\r\n        /* remove trailing LWSPs */\r\n\r\n        for(i = 0; i < elist.length; i++) {\r\n\r\n            element = elist[i];\r\n\r\n            if (element.kind === \"br\" || element.space === \"preserve\") {\r\n                i++;\r\n                continue;\r\n            }\r\n\r\n            if (/[ ]$/.test(element.text)) {\r\n\r\n                if (i === (elist.length - 1) || isNextCharLWSP(elist[i + 1])) {\r\n                    element.text = element.text.slice(0, -1);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function constructSpanList(element, elist) {\r\n\r\n        for (var i in element.contents) {\r\n\r\n            var child = element.contents[i];\r\n            var ruby = child.styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n            if (child.kind === 'span' && (ruby === \"textContainer\" || ruby === \"text\")) {\r\n\r\n                /* skip ruby text and text containers, which are handled on their own */\r\n            \r\n                continue;\r\n\r\n            } else if ('contents' in child) {\r\n    \r\n                constructSpanList(child, elist);\r\n    \r\n            } else if ((child.kind === 'span' && child.text.length !== 0) || child.kind === 'br') {\r\n\r\n                /* skip empty spans */\r\n\r\n                elist.push(child);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function pruneEmptySpans(element) {\r\n\r\n        if (element.kind === 'br') {\r\n\r\n            return false;\r\n\r\n        } else if ('text' in element) {\r\n\r\n            return  element.text.length === 0;\r\n\r\n        } else if ('contents' in element) {\r\n\r\n            var i = element.contents.length;\r\n\r\n            while (i--) {\r\n\r\n                if (pruneEmptySpans(element.contents[i])) {\r\n                    element.contents.splice(i, 1);\r\n                }\r\n\r\n            }\r\n\r\n            return element.contents.length === 0;\r\n\r\n        }\r\n    }\r\n\r\n    function ISD(tt) {\r\n        this.contents = [];\r\n        this.aspectRatio = tt.aspectRatio;\r\n        this.lang = tt.lang;\r\n    }\r\n\r\n    function ISDContentElement(ttelem) {\r\n\r\n        /* assume the element is a region if it does not have a kind */\r\n\r\n        this.kind = ttelem.kind || 'region';\r\n\r\n        /* copy lang */\r\n\r\n        this.lang = ttelem.lang;\r\n\r\n        /* copy id */\r\n\r\n        if (ttelem.id) {\r\n            this.id = ttelem.id;\r\n        }\r\n\r\n        /* deep copy of style attributes */\r\n        this.styleAttrs = {};\r\n\r\n        for (var sname in ttelem.styleAttrs) {\r\n\r\n            this.styleAttrs[sname] =\r\n                ttelem.styleAttrs[sname];\r\n        }\r\n        \r\n        /* copy src and type if image */\r\n        \r\n        if ('src' in ttelem) {\r\n            \r\n            this.src = ttelem.src;\r\n            \r\n        }\r\n        \r\n         if ('type' in ttelem) {\r\n            \r\n            this.type = ttelem.type;\r\n            \r\n        }\r\n\r\n        /* TODO: clean this! \r\n         * TODO: ISDElement and document element should be better tied together */\r\n\r\n        if ('text' in ttelem) {\r\n\r\n            this.text = ttelem.text;\r\n\r\n        } else if (this.kind === 'region' || 'contents' in ttelem) {\r\n\r\n            this.contents = [];\r\n        }\r\n\r\n        if ('space' in ttelem) {\r\n\r\n            this.space = ttelem.space;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * ERROR HANDLING UTILITY FUNCTIONS\r\n     * \r\n     */\r\n\r\n    function reportInfo(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.info && errorHandler.info(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportWarning(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.warn && errorHandler.warn(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportError(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.error && errorHandler.error(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportFatal(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.fatal)\r\n            errorHandler.fatal(msg);\r\n\r\n        throw msg;\r\n\r\n    }\r\n\r\n\r\n})(typeof exports === 'undefined' ? this.imscISD = {} : exports,\r\n    typeof imscNames === 'undefined' ? require(\"./names\") : imscNames,\r\n    typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles,\r\n    typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils\r\n    );\r\n"]},"metadata":{},"sourceType":"script"}