{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ProtectionKeyController = require('../controllers/ProtectionKeyController');\n\nvar _ProtectionKeyController2 = _interopRequireDefault(_ProtectionKeyController);\n\nvar _NeedKey = require('../vo/NeedKey');\n\nvar _NeedKey2 = _interopRequireDefault(_NeedKey);\n\nvar _DashJSError = require('../../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _ProtectionErrors = require('../errors/ProtectionErrors');\n\nvar _ProtectionErrors2 = _interopRequireDefault(_ProtectionErrors);\n\nvar _KeyMessage = require('../vo/KeyMessage');\n\nvar _KeyMessage2 = _interopRequireDefault(_KeyMessage);\n\nvar _KeySystemConfiguration = require('../vo/KeySystemConfiguration');\n\nvar _KeySystemConfiguration2 = _interopRequireDefault(_KeySystemConfiguration);\n\nvar _KeySystemAccess = require('../vo/KeySystemAccess');\n\nvar _KeySystemAccess2 = _interopRequireDefault(_KeySystemAccess);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ProtectionModel_3Feb2014(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = config.eventBus; //Need to pass in here so we can use same instance since this is optional module\n\n  var events = config.events;\n  var debug = config.debug;\n  var api = config.api;\n  var instance = void 0,\n      logger = void 0,\n      videoElement = void 0,\n      keySystem = void 0,\n      mediaKeys = void 0,\n      keySystemAccess = void 0,\n      sessions = void 0,\n      eventHandler = void 0,\n      protectionKeyController = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    videoElement = null;\n    keySystem = null;\n    mediaKeys = null;\n    keySystemAccess = null;\n    sessions = [];\n    protectionKeyController = (0, _ProtectionKeyController2.default)(context).getInstance();\n    eventHandler = createEventHandler();\n  }\n\n  function reset() {\n    try {\n      for (var i = 0; i < sessions.length; i++) {\n        closeKeySession(sessions[i]);\n      }\n\n      if (videoElement) {\n        videoElement.removeEventListener(api.needkey, eventHandler);\n      }\n\n      eventBus.trigger(events.TEARDOWN_COMPLETE);\n    } catch (error) {\n      eventBus.trigger(events.TEARDOWN_COMPLETE, {\n        error: 'Error tearing down key sessions and MediaKeys! -- ' + error.message\n      });\n    }\n  }\n\n  function getKeySystem() {\n    return keySystem;\n  }\n\n  function getAllInitData() {\n    var retVal = [];\n\n    for (var i = 0; i < sessions.length; i++) {\n      retVal.push(sessions[i].initData);\n    }\n\n    return retVal;\n  }\n\n  function requestKeySystemAccess(ksConfigurations) {\n    // Try key systems in order, first one with supported key system configuration\n    // is used\n    var found = false;\n\n    for (var ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\n      var systemString = ksConfigurations[ksIdx].ks.systemString;\n      var configs = ksConfigurations[ksIdx].configs;\n      var supportedAudio = null;\n      var supportedVideo = null; // Try key system configs in order, first one with supported audio/video\n      // is used\n\n      for (var configIdx = 0; configIdx < configs.length; configIdx++) {\n        var audios = configs[configIdx].audioCapabilities;\n        var videos = configs[configIdx].videoCapabilities; // Look for supported audio container/codecs\n\n        if (audios && audios.length !== 0) {\n          supportedAudio = []; // Indicates that we have a requested audio config\n\n          for (var audioIdx = 0; audioIdx < audios.length; audioIdx++) {\n            if (window[api.MediaKeys].isTypeSupported(systemString, audios[audioIdx].contentType)) {\n              supportedAudio.push(audios[audioIdx]);\n            }\n          }\n        } // Look for supported video container/codecs\n\n\n        if (videos && videos.length !== 0) {\n          supportedVideo = []; // Indicates that we have a requested video config\n\n          for (var videoIdx = 0; videoIdx < videos.length; videoIdx++) {\n            if (window[api.MediaKeys].isTypeSupported(systemString, videos[videoIdx].contentType)) {\n              supportedVideo.push(videos[videoIdx]);\n            }\n          }\n        } // No supported audio or video in this configuration OR we have\n        // requested audio or video configuration that is not supported\n\n\n        if (!supportedAudio && !supportedVideo || supportedAudio && supportedAudio.length === 0 || supportedVideo && supportedVideo.length === 0) {\n          continue;\n        } // This configuration is supported\n\n\n        found = true;\n        var ksConfig = new _KeySystemConfiguration2.default(supportedAudio, supportedVideo);\n        var ks = protectionKeyController.getKeySystemBySystemString(systemString);\n        eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n          data: new _KeySystemAccess2.default(ks, ksConfig)\n        });\n        break;\n      }\n    }\n\n    if (!found) {\n      eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n        error: 'Key system access denied! -- No valid audio/video content configurations detected!'\n      });\n    }\n  }\n\n  function selectKeySystem(ksAccess) {\n    try {\n      mediaKeys = ksAccess.mediaKeys = new window[api.MediaKeys](ksAccess.keySystem.systemString);\n      keySystem = ksAccess.keySystem;\n      keySystemAccess = ksAccess;\n\n      if (videoElement) {\n        setMediaKeys();\n      }\n\n      eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n    } catch (error) {\n      eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, {\n        error: 'Error selecting keys system (' + keySystem.systemString + ')! Could not create MediaKeys -- TODO'\n      });\n    }\n  }\n\n  function setMediaElement(mediaElement) {\n    if (videoElement === mediaElement) return; // Replacing the previous element\n\n    if (videoElement) {\n      videoElement.removeEventListener(api.needkey, eventHandler);\n    }\n\n    videoElement = mediaElement; // Only if we are not detaching from the existing element\n\n    if (videoElement) {\n      videoElement.addEventListener(api.needkey, eventHandler);\n\n      if (mediaKeys) {\n        setMediaKeys();\n      }\n    }\n  }\n\n  function createKeySession(initData, protData, sessionType, cdmData) {\n    if (!keySystem || !mediaKeys || !keySystemAccess) {\n      throw new Error('Can not create sessions until you have selected a key system');\n    } // Use the first video capability for the contentType.\n    // TODO:  Not sure if there is a way to concatenate all capability data into a RFC6386-compatible format\n    // If player is trying to playback Audio only stream - don't error out.\n\n\n    var capabilities = null;\n\n    if (keySystemAccess.ksConfiguration.videoCapabilities && keySystemAccess.ksConfiguration.videoCapabilities.length > 0) {\n      capabilities = keySystemAccess.ksConfiguration.videoCapabilities[0];\n    }\n\n    if (capabilities === null && keySystemAccess.ksConfiguration.audioCapabilities && keySystemAccess.ksConfiguration.audioCapabilities.length > 0) {\n      capabilities = keySystemAccess.ksConfiguration.audioCapabilities[0];\n    }\n\n    if (capabilities === null) {\n      throw new Error('Can not create sessions for unknown content types.');\n    }\n\n    var contentType = capabilities.contentType;\n    var session = mediaKeys.createSession(contentType, new Uint8Array(initData), cdmData ? new Uint8Array(cdmData) : null);\n    var sessionToken = createSessionToken(session, initData); // Add all event listeners\n\n    session.addEventListener(api.error, sessionToken);\n    session.addEventListener(api.message, sessionToken);\n    session.addEventListener(api.ready, sessionToken);\n    session.addEventListener(api.close, sessionToken); // Add to our session list\n\n    sessions.push(sessionToken);\n    logger.debug('DRM: Session created.  SessionID = ' + sessionToken.getSessionID());\n    eventBus.trigger(events.KEY_SESSION_CREATED, {\n      data: sessionToken\n    });\n  }\n\n  function updateKeySession(sessionToken, message) {\n    var session = sessionToken.session;\n\n    if (!protectionKeyController.isClearKey(keySystem)) {\n      // Send our request to the key session\n      session.update(new Uint8Array(message));\n    } else {\n      // For clearkey, message is a ClearKeyKeySet\n      session.update(new Uint8Array(message.toJWK()));\n    }\n  }\n  /**\n  * Close the given session and release all associated keys.  Following\n  * this call, the sessionToken becomes invalid\n  *\n  * @param {Object} sessionToken - the session token\n  */\n\n\n  function closeKeySession(sessionToken) {\n    var session = sessionToken.session; // Remove event listeners\n\n    session.removeEventListener(api.error, sessionToken);\n    session.removeEventListener(api.message, sessionToken);\n    session.removeEventListener(api.ready, sessionToken);\n    session.removeEventListener(api.close, sessionToken); // Remove from our session list\n\n    for (var i = 0; i < sessions.length; i++) {\n      if (sessions[i] === sessionToken) {\n        sessions.splice(i, 1);\n        break;\n      }\n    } // Send our request to the key session\n\n\n    session[api.release]();\n  }\n\n  function setServerCertificate()\n  /*serverCertificate*/\n  {\n    /* Not supported */\n  }\n\n  function loadKeySession()\n  /*sessionID*/\n  {\n    /* Not supported */\n  }\n\n  function removeKeySession()\n  /*sessionToken*/\n  {\n    /* Not supported */\n  }\n\n  function createEventHandler() {\n    return {\n      handleEvent: function handleEvent(event) {\n        switch (event.type) {\n          case api.needkey:\n            if (event.initData) {\n              var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n              eventBus.trigger(events.NEED_KEY, {\n                key: new _NeedKey2.default(initData, 'cenc')\n              });\n            }\n\n            break;\n        }\n      }\n    };\n  } // IE11 does not let you set MediaKeys until it has entered a certain\n  // readyState, so we need this logic to ensure we don't set the keys\n  // too early\n\n\n  function setMediaKeys() {\n    var boundDoSetKeys = null;\n\n    var doSetKeys = function doSetKeys() {\n      videoElement.removeEventListener('loadedmetadata', boundDoSetKeys);\n      videoElement[api.setMediaKeys](mediaKeys);\n      eventBus.trigger(events.VIDEO_ELEMENT_SELECTED);\n    };\n\n    if (videoElement.readyState >= 1) {\n      doSetKeys();\n    } else {\n      boundDoSetKeys = doSetKeys.bind(this);\n      videoElement.addEventListener('loadedmetadata', boundDoSetKeys);\n    }\n  } // Function to create our session token objects which manage the EME\n  // MediaKeySession and session-specific event handler\n\n\n  function createSessionToken(keySession, initData) {\n    return {\n      // Implements SessionToken\n      session: keySession,\n      initData: initData,\n      getSessionID: function getSessionID() {\n        return this.session.sessionId;\n      },\n      getExpirationTime: function getExpirationTime() {\n        return NaN;\n      },\n      getSessionType: function getSessionType() {\n        return 'temporary';\n      },\n      // This is our main event handler for all desired MediaKeySession events\n      // These events are translated into our API-independent versions of the\n      // same events\n      handleEvent: function handleEvent(event) {\n        switch (event.type) {\n          case api.error:\n            var errorStr = 'KeyError'; // TODO: Make better string from event\n\n            eventBus.trigger(events.KEY_ERROR, {\n              data: new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEYERR_CODE, errorStr, this)\n            });\n            break;\n\n          case api.message:\n            var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n            eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {\n              data: new _KeyMessage2.default(this, message, event.destinationURL)\n            });\n            break;\n\n          case api.ready:\n            logger.debug('DRM: Key added.');\n            eventBus.trigger(events.KEY_ADDED);\n            break;\n\n          case api.close:\n            logger.debug('DRM: Session closed.  SessionID = ' + this.getSessionID());\n            eventBus.trigger(events.KEY_SESSION_CLOSED, {\n              data: this.getSessionID()\n            });\n            break;\n        }\n      }\n    };\n  }\n\n  instance = {\n    getAllInitData: getAllInitData,\n    requestKeySystemAccess: requestKeySystemAccess,\n    getKeySystem: getKeySystem,\n    selectKeySystem: selectKeySystem,\n    setMediaElement: setMediaElement,\n    createKeySession: createKeySession,\n    updateKeySession: updateKeySession,\n    closeKeySession: closeKeySession,\n    setServerCertificate: setServerCertificate,\n    loadKeySession: loadKeySession,\n    removeKeySession: removeKeySession,\n    stop: reset,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Implementation of the EME APIs as of the 3 Feb 2014 state of the specification.\n*\n* Implemented by Internet Explorer 11 (Windows 8.1)\n*\n* @implements ProtectionModel\n* @class\n*/\n\n\nProtectionModel_3Feb2014.__dashjs_factory_name = 'ProtectionModel_3Feb2014';\nexports.default = dashjs.FactoryMaker.getClassFactory(ProtectionModel_3Feb2014);\n/* jshint ignore:line */","map":{"version":3,"sources":["../../../../../../src/streaming/protection/models/ProtectionModel_3Feb2014.js"],"names":["config","context","eventBus","events","debug","api","instance","logger","videoElement","keySystem","mediaKeys","keySystemAccess","sessions","eventHandler","protectionKeyController","createEventHandler","i","closeKeySession","error","retVal","found","ksIdx","ksConfigurations","systemString","configs","supportedAudio","supportedVideo","configIdx","audios","videos","audioIdx","window","videoIdx","ksConfig","KeySystemConfiguration","ks","data","KeySystemAccess","ksAccess","setMediaKeys","capabilities","contentType","session","cdmData","sessionToken","createSessionToken","message","handleEvent","event","initData","ArrayBuffer","key","NeedKey","boundDoSetKeys","doSetKeys","getSessionID","getExpirationTime","getSessionType","errorStr","DashJSError","ProtectionErrors","KeyMessage","getAllInitData","requestKeySystemAccess","getKeySystem","selectKeySystem","setMediaElement","createKeySession","updateKeySession","setServerCertificate","loadKeySession","removeKeySession","stop","reset","setup","ProtectionModel_3Feb2014","dashjs"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Implementation of the EME APIs as of the 3 Feb 2014 state of the specification.\n *\n * Implemented by Internet Explorer 11 (Windows 8.1)\n *\n * @implements ProtectionModel\n * @class\n */\n\nimport ProtectionKeyController from '../controllers/ProtectionKeyController';\nimport NeedKey from '../vo/NeedKey';\nimport DashJSError from '../../vo/DashJSError';\nimport ProtectionErrors from '../errors/ProtectionErrors';\nimport KeyMessage from '../vo/KeyMessage';\nimport KeySystemConfiguration from '../vo/KeySystemConfiguration';\nimport KeySystemAccess from '../vo/KeySystemAccess';\n\nfunction ProtectionModel_3Feb2014(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module\n    const events = config.events;\n    const debug = config.debug;\n    const api = config.api;\n\n    let instance,\n        logger,\n        videoElement,\n        keySystem,\n        mediaKeys,\n        keySystemAccess,\n        sessions,\n        eventHandler,\n        protectionKeyController;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        videoElement = null;\n        keySystem = null;\n        mediaKeys = null;\n        keySystemAccess = null;\n        sessions = [];\n        protectionKeyController = ProtectionKeyController(context).getInstance();\n        eventHandler = createEventHandler();\n    }\n\n    function reset() {\n        try {\n            for (let i = 0; i < sessions.length; i++) {\n                closeKeySession(sessions[i]);\n            }\n            if (videoElement) {\n                videoElement.removeEventListener(api.needkey, eventHandler);\n            }\n            eventBus.trigger(events.TEARDOWN_COMPLETE);\n        } catch (error) {\n            eventBus.trigger(events.TEARDOWN_COMPLETE, { error: 'Error tearing down key sessions and MediaKeys! -- ' + error.message });\n        }\n    }\n\n    function getKeySystem() {\n        return keySystem;\n    }\n\n    function getAllInitData() {\n        const retVal = [];\n        for (let i = 0; i < sessions.length; i++) {\n            retVal.push(sessions[i].initData);\n        }\n        return retVal;\n    }\n\n    function requestKeySystemAccess(ksConfigurations) {\n\n        // Try key systems in order, first one with supported key system configuration\n        // is used\n        let found = false;\n        for (let ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\n            const systemString = ksConfigurations[ksIdx].ks.systemString;\n            const configs = ksConfigurations[ksIdx].configs;\n            let supportedAudio = null;\n            let supportedVideo = null;\n\n            // Try key system configs in order, first one with supported audio/video\n            // is used\n            for (let configIdx = 0; configIdx < configs.length; configIdx++) {\n                const audios = configs[configIdx].audioCapabilities;\n                const videos = configs[configIdx].videoCapabilities;\n\n                // Look for supported audio container/codecs\n                if (audios && audios.length !== 0) {\n                    supportedAudio = []; // Indicates that we have a requested audio config\n                    for (let audioIdx = 0; audioIdx < audios.length; audioIdx++) {\n                        if (window[api.MediaKeys].isTypeSupported(systemString, audios[audioIdx].contentType)) {\n                            supportedAudio.push(audios[audioIdx]);\n                        }\n                    }\n                }\n\n                // Look for supported video container/codecs\n                if (videos && videos.length !== 0) {\n                    supportedVideo = []; // Indicates that we have a requested video config\n                    for (let videoIdx = 0; videoIdx < videos.length; videoIdx++) {\n                        if (window[api.MediaKeys].isTypeSupported(systemString, videos[videoIdx].contentType)) {\n                            supportedVideo.push(videos[videoIdx]);\n                        }\n                    }\n                }\n\n                // No supported audio or video in this configuration OR we have\n                // requested audio or video configuration that is not supported\n                if ((!supportedAudio && !supportedVideo) ||\n                    (supportedAudio && supportedAudio.length === 0) ||\n                    (supportedVideo && supportedVideo.length === 0)) {\n                    continue;\n                }\n\n                // This configuration is supported\n                found = true;\n                const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo);\n                const ks = protectionKeyController.getKeySystemBySystemString(systemString);\n                eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) });\n                break;\n            }\n        }\n        if (!found) {\n            eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Key system access denied! -- No valid audio/video content configurations detected!' });\n        }\n    }\n\n    function selectKeySystem(ksAccess) {\n        try {\n            mediaKeys = ksAccess.mediaKeys = new window[api.MediaKeys](ksAccess.keySystem.systemString);\n            keySystem = ksAccess.keySystem;\n            keySystemAccess = ksAccess;\n            if (videoElement) {\n                setMediaKeys();\n            }\n            eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n        } catch (error) {\n            eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, { error: 'Error selecting keys system (' + keySystem.systemString + ')! Could not create MediaKeys -- TODO' });\n        }\n    }\n\n    function setMediaElement(mediaElement) {\n        if (videoElement === mediaElement)\n            return;\n\n        // Replacing the previous element\n        if (videoElement) {\n            videoElement.removeEventListener(api.needkey, eventHandler);\n        }\n\n        videoElement = mediaElement;\n\n        // Only if we are not detaching from the existing element\n        if (videoElement) {\n            videoElement.addEventListener(api.needkey, eventHandler);\n            if (mediaKeys) {\n                setMediaKeys();\n            }\n        }\n    }\n\n    function createKeySession(initData, protData, sessionType, cdmData) {\n        if (!keySystem || !mediaKeys || !keySystemAccess) {\n            throw new Error('Can not create sessions until you have selected a key system');\n        }\n\n        // Use the first video capability for the contentType.\n        // TODO:  Not sure if there is a way to concatenate all capability data into a RFC6386-compatible format\n\n        // If player is trying to playback Audio only stream - don't error out.\n        let capabilities = null;\n\n        if (keySystemAccess.ksConfiguration.videoCapabilities && keySystemAccess.ksConfiguration.videoCapabilities.length > 0) {\n            capabilities = keySystemAccess.ksConfiguration.videoCapabilities[0];\n        }\n\n        if (capabilities === null && keySystemAccess.ksConfiguration.audioCapabilities && keySystemAccess.ksConfiguration.audioCapabilities.length > 0) {\n            capabilities = keySystemAccess.ksConfiguration.audioCapabilities[0];\n        }\n\n        if (capabilities === null) {\n            throw new Error('Can not create sessions for unknown content types.');\n        }\n\n        const contentType = capabilities.contentType;\n        const session = mediaKeys.createSession(contentType, new Uint8Array(initData), cdmData ? new Uint8Array(cdmData) : null);\n        const sessionToken = createSessionToken(session, initData);\n\n        // Add all event listeners\n        session.addEventListener(api.error, sessionToken);\n        session.addEventListener(api.message, sessionToken);\n        session.addEventListener(api.ready, sessionToken);\n        session.addEventListener(api.close, sessionToken);\n\n        // Add to our session list\n        sessions.push(sessionToken);\n        logger.debug('DRM: Session created.  SessionID = ' + sessionToken.getSessionID());\n        eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken });\n    }\n\n    function updateKeySession(sessionToken, message) {\n        const session = sessionToken.session;\n\n        if (!protectionKeyController.isClearKey(keySystem)) {\n            // Send our request to the key session\n            session.update(new Uint8Array(message));\n        } else {\n            // For clearkey, message is a ClearKeyKeySet\n            session.update(new Uint8Array(message.toJWK()));\n        }\n    }\n\n    /**\n     * Close the given session and release all associated keys.  Following\n     * this call, the sessionToken becomes invalid\n     *\n     * @param {Object} sessionToken - the session token\n     */\n    function closeKeySession(sessionToken) {\n        const session = sessionToken.session;\n\n        // Remove event listeners\n        session.removeEventListener(api.error, sessionToken);\n        session.removeEventListener(api.message, sessionToken);\n        session.removeEventListener(api.ready, sessionToken);\n        session.removeEventListener(api.close, sessionToken);\n\n        // Remove from our session list\n        for (let i = 0; i < sessions.length; i++) {\n            if (sessions[i] === sessionToken) {\n                sessions.splice(i, 1);\n                break;\n            }\n        }\n\n        // Send our request to the key session\n        session[api.release]();\n    }\n\n    function setServerCertificate(/*serverCertificate*/) { /* Not supported */ }\n    function loadKeySession(/*sessionID*/) { /* Not supported */ }\n    function removeKeySession(/*sessionToken*/) { /* Not supported */ }\n\n\n    function createEventHandler() {\n        return {\n            handleEvent: function (event) {\n                switch (event.type) {\n\n                    case api.needkey:\n                        if (event.initData) {\n                            const initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                            eventBus.trigger(events.NEED_KEY, { key: new NeedKey(initData, 'cenc') });\n                        }\n                        break;\n                }\n            }\n        };\n    }\n\n\n    // IE11 does not let you set MediaKeys until it has entered a certain\n    // readyState, so we need this logic to ensure we don't set the keys\n    // too early\n    function setMediaKeys() {\n        let boundDoSetKeys = null;\n        const doSetKeys = function () {\n            videoElement.removeEventListener('loadedmetadata', boundDoSetKeys);\n            videoElement[api.setMediaKeys](mediaKeys);\n            eventBus.trigger(events.VIDEO_ELEMENT_SELECTED);\n        };\n        if (videoElement.readyState >= 1) {\n            doSetKeys();\n        } else {\n            boundDoSetKeys = doSetKeys.bind(this);\n            videoElement.addEventListener('loadedmetadata', boundDoSetKeys);\n        }\n\n    }\n\n    // Function to create our session token objects which manage the EME\n    // MediaKeySession and session-specific event handler\n    function createSessionToken(keySession, initData) {\n        return {\n            // Implements SessionToken\n            session: keySession,\n            initData: initData,\n\n            getSessionID: function () {\n                return this.session.sessionId;\n            },\n\n            getExpirationTime: function () {\n                return NaN;\n            },\n\n            getSessionType: function () {\n                return 'temporary';\n            },\n            // This is our main event handler for all desired MediaKeySession events\n            // These events are translated into our API-independent versions of the\n            // same events\n            handleEvent: function (event) {\n                switch (event.type) {\n                    case api.error:\n                        let errorStr = 'KeyError'; // TODO: Make better string from event\n                        eventBus.trigger(events.KEY_ERROR, { data: new DashJSError(ProtectionErrors.MEDIA_KEYERR_CODE, errorStr, this) });\n                        break;\n                    case api.message:\n                        let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n                        eventBus.trigger(events.INTERNAL_KEY_MESSAGE, { data: new KeyMessage(this, message, event.destinationURL) });\n                        break;\n                    case api.ready:\n                        logger.debug('DRM: Key added.');\n                        eventBus.trigger(events.KEY_ADDED);\n                        break;\n\n                    case api.close:\n                        logger.debug('DRM: Session closed.  SessionID = ' + this.getSessionID());\n                        eventBus.trigger(events.KEY_SESSION_CLOSED, { data: this.getSessionID() });\n                        break;\n                }\n            }\n        };\n    }\n\n    instance = {\n        getAllInitData: getAllInitData,\n        requestKeySystemAccess: requestKeySystemAccess,\n        getKeySystem: getKeySystem,\n        selectKeySystem: selectKeySystem,\n        setMediaElement: setMediaElement,\n        createKeySession: createKeySession,\n        updateKeySession: updateKeySession,\n        closeKeySession: closeKeySession,\n        setServerCertificate: setServerCertificate,\n        loadKeySession: loadKeySession,\n        removeKeySession: removeKeySession,\n        stop: reset,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nProtectionModel_3Feb2014.__dashjs_factory_name = 'ProtectionModel_3Feb2014';\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionModel_3Feb2014); /* jshint ignore:line */\n"]},"metadata":{},"sourceType":"script"}