{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MetricSerialiser = require('../../utils/MetricSerialiser');\n\nvar _MetricSerialiser2 = _interopRequireDefault(_MetricSerialiser);\n\nvar _RNG = require('../../utils/RNG');\n\nvar _RNG2 = _interopRequireDefault(_RNG);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction DVBReporting(config) {\n  config = config || {};\n  var instance = void 0;\n  var context = this.context;\n  var metricSerialiser = void 0,\n      randomNumberGenerator = void 0,\n      reportingPlayerStatusDecided = void 0,\n      isReportingPlayer = void 0,\n      reportingUrl = void 0,\n      rangeController = void 0;\n  var USE_DRAFT_DVB_SPEC = true;\n  var allowPendingRequestsToCompleteOnReset = true;\n  var pendingRequests = [];\n  var metricsConstants = config.metricsConstants;\n\n  function setup() {\n    metricSerialiser = (0, _MetricSerialiser2.default)(context).getInstance();\n    randomNumberGenerator = (0, _RNG2.default)(context).getInstance();\n    resetInitialSettings();\n  }\n\n  function doGetRequest(url, successCB, failureCB) {\n    var req = new XMLHttpRequest();\n\n    var oncomplete = function oncomplete() {\n      var reqIndex = pendingRequests.indexOf(req);\n\n      if (reqIndex === -1) {\n        return;\n      } else {\n        pendingRequests.splice(reqIndex, 1);\n      }\n\n      if (req.status >= 200 && req.status < 300) {\n        if (successCB) {\n          successCB();\n        }\n      } else {\n        if (failureCB) {\n          failureCB();\n        }\n      }\n    };\n\n    pendingRequests.push(req);\n\n    try {\n      req.open('GET', url);\n      req.onloadend = oncomplete;\n      req.onerror = oncomplete;\n      req.send();\n    } catch (e) {\n      req.onerror();\n    }\n  }\n\n  function report(type, vos) {\n    if (!Array.isArray(vos)) {\n      vos = [vos];\n    } // If the Player is not a reporting Player, then the Player shall\n    // not report any errors.\n    // ... In addition to any time restrictions specified by a Range\n    // element within the Metrics element.\n\n\n    if (isReportingPlayer && rangeController.isEnabled()) {\n      // This reporting mechanism operates by creating one HTTP GET\n      // request for every entry in the top level list of the metric.\n      vos.forEach(function (vo) {\n        var url = metricSerialiser.serialise(vo); // this has been proposed for errata\n\n        if (USE_DRAFT_DVB_SPEC && type !== metricsConstants.DVB_ERRORS) {\n          url = 'metricname=' + type + '&' + url;\n        } // Take the value of the @reportingUrl attribute, append a\n        // question mark ('?') character and then append the string\n        // created in the previous step.\n\n\n        url = reportingUrl + '?' + url; // Make an HTTP GET request to the URL contained within the\n        // string created in the previous step.\n\n        doGetRequest(url, null, function () {\n          // If the Player is unable to make the report, for\n          // example because the @reportingUrl is invalid, the\n          // host cannot be reached, or an HTTP status code other\n          // than one in the 200 series is received, the Player\n          // shall cease being a reporting Player for the\n          // duration of the MPD.\n          isReportingPlayer = false;\n        });\n      });\n    }\n  }\n\n  function initialize(entry, rc) {\n    var probability = void 0;\n    rangeController = rc;\n    reportingUrl = entry.dvb_reportingUrl; // If a required attribute is missing, the Reporting descriptor may\n    // be ignored by the Player\n\n    if (!reportingUrl) {\n      throw new Error('required parameter missing (dvb:reportingUrl)');\n    } // A Player's status, as a reporting Player or not, shall remain\n    // static for the duration of the MPD, regardless of MPD updates.\n    // (i.e. only calling reset (or failure) changes this state)\n\n\n    if (!reportingPlayerStatusDecided) {\n      probability = entry.dvb_probability; // TS 103 285 Clause 10.12.3.4\n      // If the @probability attribute is set to 1000, it shall be a reporting Player.\n      // If the @probability attribute is absent it will take the default value of 1000.\n      // For any other value of the @probability attribute, it shall decide at random whether to be a\n      // reporting Player, such that the probability of being one is @probability/1000.\n\n      if (probability && (probability === 1000 || probability / 1000 >= randomNumberGenerator.random())) {\n        isReportingPlayer = true;\n      }\n\n      reportingPlayerStatusDecided = true;\n    }\n  }\n\n  function resetInitialSettings() {\n    reportingPlayerStatusDecided = false;\n    isReportingPlayer = false;\n    reportingUrl = null;\n    rangeController = null;\n  }\n\n  function reset() {\n    if (!allowPendingRequestsToCompleteOnReset) {\n      pendingRequests.forEach(function (req) {\n        return req.abort();\n      });\n      pendingRequests = [];\n    }\n\n    resetInitialSettings();\n  }\n\n  instance = {\n    report: report,\n    initialize: initialize,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nDVBReporting.__dashjs_factory_name = 'DVBReporting';\nexports.default = dashjs.FactoryMaker.getClassFactory(DVBReporting);\n/* jshint ignore:line */","map":{"version":3,"sources":["../../../../../../../src/streaming/metrics/reporting/reporters/DVBReporting.js"],"names":["config","instance","context","metricSerialiser","randomNumberGenerator","reportingPlayerStatusDecided","isReportingPlayer","reportingUrl","rangeController","USE_DRAFT_DVB_SPEC","allowPendingRequestsToCompleteOnReset","pendingRequests","metricsConstants","resetInitialSettings","req","oncomplete","reqIndex","successCB","failureCB","Array","vos","url","type","doGetRequest","probability","entry","report","initialize","reset","setup","DVBReporting","dashjs"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport MetricSerialiser from '../../utils/MetricSerialiser';\nimport RNG from '../../utils/RNG';\n\nfunction DVBReporting(config) {\n    config = config || {};\n    let instance;\n\n    let context = this.context;\n    let metricSerialiser,\n        randomNumberGenerator,\n        reportingPlayerStatusDecided,\n        isReportingPlayer,\n        reportingUrl,\n        rangeController;\n\n    let USE_DRAFT_DVB_SPEC = true;\n    let allowPendingRequestsToCompleteOnReset = true;\n    let pendingRequests = [];\n\n    const metricsConstants = config.metricsConstants;\n\n    function setup() {\n        metricSerialiser = MetricSerialiser(context).getInstance();\n        randomNumberGenerator = RNG(context).getInstance();\n\n        resetInitialSettings();\n    }\n\n    function doGetRequest(url, successCB, failureCB) {\n        let req = new XMLHttpRequest();\n        const oncomplete = function () {\n            let reqIndex = pendingRequests.indexOf(req);\n\n            if (reqIndex === -1) {\n                return;\n            } else {\n                pendingRequests.splice(reqIndex, 1);\n            }\n\n            if ((req.status >= 200) && (req.status < 300)) {\n                if (successCB) {\n                    successCB();\n                }\n            } else {\n                if (failureCB) {\n                    failureCB();\n                }\n            }\n        };\n\n        pendingRequests.push(req);\n\n        try {\n            req.open('GET', url);\n            req.onloadend = oncomplete;\n            req.onerror = oncomplete;\n            req.send();\n        } catch (e) {\n            req.onerror();\n        }\n    }\n\n    function report(type, vos) {\n        if (!Array.isArray(vos)) {\n            vos = [vos];\n        }\n\n        // If the Player is not a reporting Player, then the Player shall\n        // not report any errors.\n        // ... In addition to any time restrictions specified by a Range\n        // element within the Metrics element.\n        if (isReportingPlayer && rangeController.isEnabled()) {\n\n            // This reporting mechanism operates by creating one HTTP GET\n            // request for every entry in the top level list of the metric.\n            vos.forEach(function (vo) {\n                let url = metricSerialiser.serialise(vo);\n\n                // this has been proposed for errata\n                if (USE_DRAFT_DVB_SPEC && (type !== metricsConstants.DVB_ERRORS)) {\n                    url = `metricname=${type}&${url}`;\n                }\n\n                // Take the value of the @reportingUrl attribute, append a\n                // question mark ('?') character and then append the string\n                // created in the previous step.\n                url = `${reportingUrl}?${url}`;\n\n                // Make an HTTP GET request to the URL contained within the\n                // string created in the previous step.\n                doGetRequest(url, null, function () {\n                    // If the Player is unable to make the report, for\n                    // example because the @reportingUrl is invalid, the\n                    // host cannot be reached, or an HTTP status code other\n                    // than one in the 200 series is received, the Player\n                    // shall cease being a reporting Player for the\n                    // duration of the MPD.\n                    isReportingPlayer = false;\n                });\n            });\n        }\n    }\n\n    function initialize(entry, rc) {\n        let probability;\n\n        rangeController = rc;\n\n        reportingUrl = entry.dvb_reportingUrl;\n\n        // If a required attribute is missing, the Reporting descriptor may\n        // be ignored by the Player\n        if (!reportingUrl) {\n            throw new Error(\n                'required parameter missing (dvb:reportingUrl)'\n            );\n        }\n\n        // A Player's status, as a reporting Player or not, shall remain\n        // static for the duration of the MPD, regardless of MPD updates.\n        // (i.e. only calling reset (or failure) changes this state)\n        if (!reportingPlayerStatusDecided) {\n            probability = entry.dvb_probability;\n            // TS 103 285 Clause 10.12.3.4\n            // If the @probability attribute is set to 1000, it shall be a reporting Player.\n            // If the @probability attribute is absent it will take the default value of 1000.\n            // For any other value of the @probability attribute, it shall decide at random whether to be a\n            // reporting Player, such that the probability of being one is @probability/1000.\n            if (probability && (probability === 1000 || ((probability / 1000) >= randomNumberGenerator.random()))) {\n                isReportingPlayer = true;\n            }\n\n            reportingPlayerStatusDecided = true;\n        }\n    }\n\n    function resetInitialSettings() {\n        reportingPlayerStatusDecided = false;\n        isReportingPlayer = false;\n        reportingUrl = null;\n        rangeController = null;\n    }\n\n    function reset() {\n        if (!allowPendingRequestsToCompleteOnReset) {\n            pendingRequests.forEach(req => req.abort());\n            pendingRequests = [];\n        }\n\n        resetInitialSettings();\n    }\n\n    instance = {\n        report:     report,\n        initialize: initialize,\n        reset:      reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nDVBReporting.__dashjs_factory_name = 'DVBReporting';\nexport default dashjs.FactoryMaker.getClassFactory(DVBReporting); /* jshint ignore:line */\n"]},"metadata":{},"sourceType":"script"}