{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DashConstants = require('./constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _RepresentationInfo = require('./vo/RepresentationInfo');\n\nvar _RepresentationInfo2 = _interopRequireDefault(_RepresentationInfo);\n\nvar _MediaInfo = require('./vo/MediaInfo');\n\nvar _MediaInfo2 = _interopRequireDefault(_MediaInfo);\n\nvar _StreamInfo = require('./vo/StreamInfo');\n\nvar _StreamInfo2 = _interopRequireDefault(_StreamInfo);\n\nvar _ManifestInfo = require('./vo/ManifestInfo');\n\nvar _ManifestInfo2 = _interopRequireDefault(_ManifestInfo);\n\nvar _Event = require('./vo/Event');\n\nvar _Event2 = _interopRequireDefault(_Event);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashManifestModel = require('./models/DashManifestModel');\n\nvar _DashManifestModel2 = _interopRequireDefault(_DashManifestModel);\n\nvar _PatchManifestModel = require('./models/PatchManifestModel');\n\nvar _PatchManifestModel2 = _interopRequireDefault(_PatchManifestModel);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* @module DashAdapter\n*/\n\n\nfunction DashAdapter() {\n  var instance = void 0,\n      dashManifestModel = void 0,\n      patchManifestModel = void 0,\n      voPeriods = void 0,\n      voAdaptations = void 0,\n      currentMediaInfo = void 0,\n      constants = void 0,\n      cea608parser = void 0;\n  var context = this.context;\n  var PROFILE_DVB = 'urn:dvb:dash:profile:dvb-dash:2014';\n\n  function setup() {\n    dashManifestModel = (0, _DashManifestModel2.default)(context).getInstance();\n    patchManifestModel = (0, _PatchManifestModel2.default)(context).getInstance();\n    reset();\n  } // #region PUBLIC FUNCTIONS\n  // --------------------------------------------------\n\n\n  function getVoAdaptations() {\n    return voAdaptations;\n  }\n\n  function getVoPeriods() {\n    return voPeriods;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.constants) {\n      constants = config.constants;\n    }\n\n    if (config.cea608parser) {\n      cea608parser = config.cea608parser;\n    }\n\n    if (config.errHandler) {\n      dashManifestModel.setConfig({\n        errHandler: config.errHandler\n      });\n    }\n\n    if (config.BASE64) {\n      dashManifestModel.setConfig({\n        BASE64: config.BASE64\n      });\n    }\n  }\n  /**\n  * Creates an instance of RepresentationInfo based on a representation value object\n  * @param {object} voRepresentation\n  * @returns {RepresentationInfo|null} representationInfo\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function convertRepresentationToRepresentationInfo(voRepresentation) {\n    if (voRepresentation) {\n      var representationInfo = new _RepresentationInfo2.default();\n      var realAdaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n      var realRepresentation = dashManifestModel.getRepresentationFor(voRepresentation.index, realAdaptation);\n      representationInfo.id = voRepresentation.id;\n      representationInfo.quality = voRepresentation.index;\n      representationInfo.bandwidth = dashManifestModel.getBandwidth(realRepresentation);\n      representationInfo.DVRWindow = voRepresentation.segmentAvailabilityRange;\n      representationInfo.fragmentDuration = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length > 0 ? voRepresentation.segments[0].duration : NaN);\n      representationInfo.MSETimeOffset = voRepresentation.MSETimeOffset;\n      representationInfo.mediaInfo = convertAdaptationToMediaInfo(voRepresentation.adaptation);\n      return representationInfo;\n    } else {\n      return null;\n    }\n  }\n  /**\n  * Returns a MediaInfo object for a given media type.\n  * @param {object} streamInfo\n  * @param {MediaType }type\n  * @returns {null|MediaInfo} mediaInfo\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getMediaInfoForType(streamInfo, type) {\n    if (voPeriods.length === 0 || !streamInfo) {\n      return null;\n    }\n\n    var selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n    if (!selectedVoPeriod) return null;\n    var periodId = selectedVoPeriod.id;\n    voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n    var realAdaptation = getAdaptationForType(streamInfo.index, type, streamInfo);\n    if (!realAdaptation) return null;\n    var idx = dashManifestModel.getIndexForAdaptation(realAdaptation, voPeriods[0].mpd.manifest, streamInfo.index);\n    return convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n  }\n  /**\n  * Checks if the role of the specified AdaptationSet is set to main\n  * @param {object} adaptation\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getIsMain(adaptation) {\n    return dashManifestModel.getRolesForAdaptation(adaptation).filter(function (role) {\n      return role.value === _DashConstants2.default.MAIN;\n    })[0];\n  }\n  /**\n  * Returns the AdaptationSet for a given period and a given mediaType.\n  * @param {number} periodIndex\n  * @param {MediaType} type\n  * @param {object} streamInfo\n  * @returns {null|object} adaptation\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getAdaptationForType(periodIndex, type, streamInfo) {\n    var adaptations = dashManifestModel.getAdaptationsForType(voPeriods[0].mpd.manifest, periodIndex, type);\n    if (!adaptations || adaptations.length === 0) return null;\n\n    if (adaptations.length > 1 && streamInfo) {\n      var allMediaInfoForType = getAllMediaInfoForType(streamInfo, type);\n\n      if (currentMediaInfo[streamInfo.id] && currentMediaInfo[streamInfo.id][type]) {\n        for (var i = 0, ln = adaptations.length; i < ln; i++) {\n          if (areMediaInfosEqual(currentMediaInfo[streamInfo.id][type], allMediaInfoForType[i])) {\n            return adaptations[i];\n          }\n        }\n      }\n\n      for (var _i = 0, _ln = adaptations.length; _i < _ln; _i++) {\n        if (getIsMain(adaptations[_i])) {\n          return adaptations[_i];\n        }\n      }\n    }\n\n    return adaptations[0];\n  }\n  /**\n  * Compares two mediaInfo objects\n  * @param {MediaInfo} mInfoOne\n  * @param {MediaInfo} mInfoTwo\n  * @returns {boolean}\n  */\n\n\n  function areMediaInfosEqual(mInfoOne, mInfoTwo) {\n    if (!mInfoOne || !mInfoTwo) {\n      return false;\n    }\n\n    var sameId = mInfoOne.id === mInfoTwo.id;\n    var sameViewpoint = mInfoOne.viewpoint === mInfoTwo.viewpoint;\n    var sameLang = mInfoOne.lang === mInfoTwo.lang;\n    var sameRoles = mInfoOne.roles.toString() === mInfoTwo.roles.toString();\n    var sameAccessibility = mInfoOne.accessibility.toString() === mInfoTwo.accessibility.toString();\n    var sameAudioChannelConfiguration = mInfoOne.audioChannelConfiguration.toString() === mInfoTwo.audioChannelConfiguration.toString();\n    return sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration;\n  }\n  /**\n  * Returns the mediaInfo for a given mediaType\n  * @param {object} streamInfo\n  * @param {MediaType} type\n  * @param {object} externalManifest Set to null or undefined if no external manifest is to be used\n  * @returns {Array} mediaArr\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getAllMediaInfoForType(streamInfo, type, externalManifest) {\n    var voLocalPeriods = voPeriods;\n    var manifest = externalManifest;\n    var mediaArr = [];\n    var data = void 0,\n        media = void 0,\n        idx = void 0,\n        i = void 0,\n        j = void 0,\n        ln = void 0,\n        periodId = void 0;\n\n    if (manifest) {\n      checkConfig();\n      voLocalPeriods = getRegularPeriods(manifest);\n    } else {\n      if (voPeriods.length > 0) {\n        manifest = voPeriods[0].mpd.manifest;\n      } else {\n        return mediaArr;\n      }\n    }\n\n    var selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voLocalPeriods);\n\n    if (selectedVoPeriod) {\n      periodId = selectedVoPeriod.id;\n    }\n\n    var adaptationsForType = dashManifestModel.getAdaptationsForType(manifest, streamInfo ? streamInfo.index : null, type !== constants.EMBEDDED_TEXT ? type : constants.VIDEO);\n    if (!adaptationsForType || adaptationsForType.length === 0) return mediaArr;\n    voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n\n    for (i = 0, ln = adaptationsForType.length; i < ln; i++) {\n      data = adaptationsForType[i];\n      idx = dashManifestModel.getIndexForAdaptation(data, manifest, streamInfo.index);\n      media = convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n\n      if (type === constants.EMBEDDED_TEXT) {\n        var accessibilityLength = media.accessibility.length;\n\n        for (j = 0; j < accessibilityLength; j++) {\n          if (!media) {\n            continue;\n          }\n\n          var accessibility = media.accessibility[j];\n\n          if (accessibility.indexOf('cea-608:') === 0) {\n            var value = accessibility.substring(8);\n            var parts = value.split(';');\n\n            if (parts[0].substring(0, 2) === 'CC') {\n              for (j = 0; j < parts.length; j++) {\n                if (!media) {\n                  media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                }\n\n                convertVideoInfoToEmbeddedTextInfo(media, parts[j].substring(0, 3), parts[j].substring(4));\n                mediaArr.push(media);\n                media = null;\n              }\n            } else {\n              for (j = 0; j < parts.length; j++) {\n                // Only languages for CC1, CC2, ...\n                if (!media) {\n                  media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                }\n\n                convertVideoInfoToEmbeddedTextInfo(media, 'CC' + (j + 1), parts[j]);\n                mediaArr.push(media);\n                media = null;\n              }\n            }\n          } else if (accessibility.indexOf('cea-608') === 0) {\n            // Nothing known. We interpret it as CC1=eng\n            convertVideoInfoToEmbeddedTextInfo(media, constants.CC1, 'eng');\n            mediaArr.push(media);\n            media = null;\n          }\n        }\n      } else if (type === constants.IMAGE) {\n        convertVideoInfoToThumbnailInfo(media);\n        mediaArr.push(media);\n        media = null;\n      } else if (media) {\n        mediaArr.push(media);\n      }\n    }\n\n    return mediaArr;\n  }\n  /**\n  * @param {object} newManifest\n  * @returns {*}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function updatePeriods(newManifest) {\n    if (!newManifest) return null;\n    checkConfig();\n    voPeriods = getRegularPeriods(newManifest);\n    voAdaptations = {};\n  }\n  /**\n  * @param {object} externalManifest\n  * @param {number} maxStreamsInfo\n  * @returns {Array} streams\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getStreamsInfo(externalManifest, maxStreamsInfo) {\n    var streams = [];\n    var voLocalPeriods = voPeriods; //if manifest is defined, getStreamsInfo is for an outside manifest, not the current one\n\n    if (externalManifest) {\n      checkConfig();\n      voLocalPeriods = getRegularPeriods(externalManifest);\n    }\n\n    if (voLocalPeriods.length > 0) {\n      if (!maxStreamsInfo || maxStreamsInfo > voLocalPeriods.length) {\n        maxStreamsInfo = voLocalPeriods.length;\n      }\n\n      for (var i = 0; i < maxStreamsInfo; i++) {\n        streams.push(convertPeriodToStreamInfo(voLocalPeriods[i]));\n      }\n    }\n\n    return streams;\n  }\n  /**\n  *\n  * @param {object} streamInfo\n  * @param {object} mediaInfo\n  * @returns {object} realAdaptation\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getRealAdaptation(streamInfo, mediaInfo) {\n    var id = void 0,\n        realAdaptation = void 0;\n    var selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n    id = mediaInfo ? mediaInfo.id : null;\n\n    if (voPeriods.length > 0 && selectedVoPeriod) {\n      realAdaptation = id ? dashManifestModel.getAdaptationForId(id, voPeriods[0].mpd.manifest, selectedVoPeriod.index) : dashManifestModel.getAdaptationForIndex(mediaInfo ? mediaInfo.index : null, voPeriods[0].mpd.manifest, selectedVoPeriod.index);\n    }\n\n    return realAdaptation;\n  }\n  /**\n  * Return all EssentialProperties of a Representation\n  * @param {object} representation\n  * @return {array}\n  */\n\n\n  function getEssentialPropertiesForRepresentation(representation) {\n    try {\n      return dashManifestModel.getEssentialPropertiesForRepresentation(representation);\n    } catch (e) {\n      return [];\n    }\n  }\n  /**\n  * Returns the period by index\n  * @param {number} index\n  * @return {object}\n  */\n\n\n  function getRealPeriodByIndex(index) {\n    return dashManifestModel.getRealPeriodForIndex(index, voPeriods[0].mpd.manifest);\n  }\n  /**\n  * Returns all voRepresentations for a given mediaInfo\n  * @param {object} mediaInfo\n  * @returns {Array} voReps\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getVoRepresentations(mediaInfo) {\n    var voReps = void 0;\n    var voAdaptation = getAdaptationForMediaInfo(mediaInfo);\n    voReps = dashManifestModel.getRepresentationsForAdaptation(voAdaptation);\n    return voReps;\n  }\n  /**\n  *\n  * @param {object} eventBox\n  * @param {object} eventStreams\n  * @param {number} mediaStartTime\n  * @param {object} voRepresentation\n  * @returns {null|Event}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getEvent(eventBox, eventStreams, mediaStartTime, voRepresentation) {\n    try {\n      if (!eventBox || !eventStreams || isNaN(mediaStartTime) || !voRepresentation) {\n        return null;\n      }\n\n      var schemeIdUri = eventBox.scheme_id_uri;\n      var value = eventBox.value;\n\n      if (!eventStreams[schemeIdUri + '/' + value]) {\n        return null;\n      }\n\n      var event = new _Event2.default();\n      var timescale = eventBox.timescale || 1;\n      var periodStart = voRepresentation.adaptation.period.start;\n      var eventStream = eventStreams[schemeIdUri + '/' + value];\n      var presentationTimeOffset = !isNaN(voRepresentation.presentationTimeOffset) ? voRepresentation.presentationTimeOffset : !isNaN(eventStream.presentationTimeOffset) ? eventStream.presentationTimeOffset : 0;\n      var presentationTimeDelta = eventBox.presentation_time_delta / timescale; // In case of version 1 events the presentation_time is parsed as presentation_time_delta\n\n      var calculatedPresentationTime = void 0;\n\n      if (eventBox.version === 0) {\n        calculatedPresentationTime = periodStart + mediaStartTime - presentationTimeOffset + presentationTimeDelta;\n      } else {\n        calculatedPresentationTime = periodStart - presentationTimeOffset + presentationTimeDelta;\n      }\n\n      var duration = eventBox.event_duration;\n      var id = eventBox.id;\n      var messageData = eventBox.message_data;\n      event.eventStream = eventStream;\n      event.eventStream.value = value;\n      event.eventStream.timescale = timescale;\n      event.duration = duration;\n      event.id = id;\n      event.calculatedPresentationTime = calculatedPresentationTime;\n      event.messageData = messageData;\n      event.presentationTimeDelta = presentationTimeDelta;\n      return event;\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n  *\n  * @param {object} info\n  * @param {object} voRepresentation\n  * @returns {Array}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getEventsFor(info, voRepresentation) {\n    var events = [];\n\n    if (voPeriods.length > 0) {\n      var manifest = voPeriods[0].mpd.manifest;\n\n      if (info instanceof _StreamInfo2.default) {\n        events = dashManifestModel.getEventsForPeriod(getPeriodForStreamInfo(info, voPeriods));\n      } else if (info instanceof _MediaInfo2.default) {\n        events = dashManifestModel.getEventStreamForAdaptationSet(manifest, getAdaptationForMediaInfo(info));\n      } else if (info instanceof _RepresentationInfo2.default) {\n        events = dashManifestModel.getEventStreamForRepresentation(manifest, voRepresentation);\n      }\n    }\n\n    return events;\n  }\n  /**\n  *\n  * @param {number} streamId\n  * @param {MediaType} type\n  * @param {object} mediaInfo\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function setCurrentMediaInfo(streamId, type, mediaInfo) {\n    currentMediaInfo[streamId] = currentMediaInfo[streamId] || {};\n    currentMediaInfo[streamId][type] = currentMediaInfo[streamId][type] || {};\n    currentMediaInfo[streamId][type] = mediaInfo;\n  }\n  /**\n  *\n  * @param {String} type\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getIsTextTrack(type) {\n    return dashManifestModel.getIsTextTrack(type);\n  }\n  /**\n  * Returns the UTC Timing Sources specified in the manifest\n  * @returns {Array} utcTimingSources\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getUTCTimingSources() {\n    var manifest = getManifest();\n    return dashManifestModel.getUTCTimingSources(manifest);\n  }\n  /**\n  * Returns the suggestedPresentationDelay as specified in the manifest\n  * @returns {String} suggestedPresentationDelay\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getSuggestedPresentationDelay() {\n    var mpd = voPeriods.length > 0 ? voPeriods[0].mpd : null;\n    return dashManifestModel.getSuggestedPresentationDelay(mpd);\n  }\n  /**\n  * Returns the availabilityStartTime as specified in the manifest\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {string} availabilityStartTime\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getAvailabilityStartTime(externalManifest) {\n    var mpd = getMpd(externalManifest);\n    return dashManifestModel.getAvailabilityStartTime(mpd);\n  }\n  /**\n  * Returns a boolean indicating if the manifest is dynamic or not\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getIsDynamic(externalManifest) {\n    var manifest = getManifest(externalManifest);\n    return dashManifestModel.getIsDynamic(manifest);\n  }\n  /**\n  * Returns the duration of the MPD\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {number} duration\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getDuration(externalManifest) {\n    var manifest = getManifest(externalManifest);\n    return dashManifestModel.getDuration(manifest);\n  }\n  /**\n  * Returns all periods of the MPD\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {Array} periods\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getRegularPeriods(externalManifest) {\n    var mpd = getMpd(externalManifest);\n    return dashManifestModel.getRegularPeriods(mpd);\n  }\n  /**\n  * Returns an MPD object\n  * @param {object} externalManifest Omit this value if no external manifest should be used\n  * @returns {object} MPD\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getMpd(externalManifest) {\n    var manifest = getManifest(externalManifest);\n    return dashManifestModel.getMpd(manifest);\n  }\n  /**\n  * Returns the location element of the MPD\n  * @param {object} manifest\n  * @returns {String} location\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getLocation(manifest) {\n    return dashManifestModel.getLocation(manifest);\n  }\n  /**\n  * Returns the manifest update period used for dynamic manifests\n  * @param {object} manifest\n  * @param {number} latencyOfLastUpdate\n  * @returns {NaN|number} manifestUpdatePeriod\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getManifestUpdatePeriod(manifest) {\n    var latencyOfLastUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return dashManifestModel.getManifestUpdatePeriod(manifest, latencyOfLastUpdate);\n  }\n  /**\n  * Returns the publish time from the manifest\n  * @param {object} manifest\n  * @returns {Date|null} publishTime\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getPublishTime(manifest) {\n    return dashManifestModel.getPublishTime(manifest);\n  }\n  /**\n  * Returns the patch location of the MPD if one exists and it is still valid\n  * @param {object} manifest\n  * @returns {(String|null)} patch location\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getPatchLocation(manifest) {\n    var patchLocation = dashManifestModel.getPatchLocation(manifest);\n    var publishTime = dashManifestModel.getPublishTime(manifest); // short-circuit when no patch location or publish time exists\n\n    if (!patchLocation || !publishTime) {\n      return null;\n    } // if a ttl is provided, ensure patch location has not expired\n\n\n    if (patchLocation.hasOwnProperty('ttl') && publishTime) {\n      // attribute describes number of seconds as a double\n      var ttl = parseFloat(patchLocation.ttl) * 1000; // check if the patch location has expired, if so do not consider it\n\n      if (publishTime.getTime() + ttl <= new Date().getTime()) {\n        return null;\n      }\n    } // the patch location exists and, if a ttl applies, has not expired\n\n\n    return patchLocation.__text;\n  }\n  /**\n  * Checks if the manifest has a DVB profile\n  * @param {object} manifest\n  * @returns {boolean}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getIsDVB(manifest) {\n    return dashManifestModel.hasProfile(manifest, PROFILE_DVB);\n  }\n  /**\n  * Checks if the manifest is actually just a patch manifest\n  * @param  {object} manifest\n  * @return {boolean}\n  */\n\n\n  function getIsPatch(manifest) {\n    return patchManifestModel.getIsPatch(manifest);\n  }\n  /**\n  *\n  * @param {object} node\n  * @returns {Array}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getBaseURLsFromElement(node) {\n    return dashManifestModel.getBaseURLsFromElement(node);\n  }\n  /**\n  *\n  * @returns {*}\n  * @memberOf module:DashAdapter\n  * @instance\n  * @ignore\n  */\n\n\n  function getRepresentationSortFunction() {\n    return dashManifestModel.getRepresentationSortFunction();\n  }\n  /**\n  * Returns the codec for a given adaptation set and a given representation id.\n  * @param {object} adaptation\n  * @param {number} representationId\n  * @param {boolean} addResolutionInfo Defines whether to include resolution information in the output\n  * @returns {String} codec\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getCodec(adaptation, representationId, addResolutionInfo) {\n    return dashManifestModel.getCodec(adaptation, representationId, addResolutionInfo);\n  }\n  /**\n  * Returns the bandwidth for a given representation id\n  * @param {number} representationId\n  * @param {number} periodIdx\n  * @returns {number} bandwidth\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getBandwidthForRepresentation(representationId, periodIdx) {\n    var representation = void 0;\n    var period = getPeriod(periodIdx);\n    representation = findRepresentation(period, representationId);\n    return representation ? representation.bandwidth : null;\n  }\n  /**\n  * Returns the index for a given representation id\n  * @param {string} representationId\n  * @param {number} periodIdx\n  * @returns {number} index\n  * @memberOf module:DashAdapter\n  * @instance\n  */\n\n\n  function getIndexForRepresentation(representationId, periodIdx) {\n    var period = getPeriod(periodIdx);\n    return findRepresentationIndex(period, representationId);\n  }\n  /**\n  * This method returns the current max index based on what is defined in the MPD.\n  *\n  * @param {string} bufferType - String 'audio' or 'video',\n  * @param {number} periodIdx - Make sure this is the period index not id\n  * @return {number}\n  * @memberof module:DashAdapter\n  * @instance\n  */\n\n\n  function getMaxIndexForBufferType(bufferType, periodIdx) {\n    var period = getPeriod(periodIdx);\n    return findMaxBufferIndex(period, bufferType);\n  }\n  /**\n  * Returns the voPeriod object for a given id\n  * @param {String} id\n  * @returns {object|null}\n  */\n\n\n  function getPeriodById(id) {\n    if (!id || voPeriods.length === 0) {\n      return null;\n    }\n\n    var periods = voPeriods.filter(function (p) {\n      return p.id === id;\n    });\n\n    if (periods && periods.length > 0) {\n      return periods[0];\n    }\n\n    return null;\n  }\n\n  function getIsTypeOf(adaptation, type) {\n    return dashManifestModel.getIsTypeOf(adaptation, type);\n  }\n\n  function reset() {\n    voPeriods = [];\n    voAdaptations = {};\n    currentMediaInfo = {};\n  }\n  /**\n  * Checks if the supplied manifest is compatible for application of the supplied patch\n  * @param  {object}  manifest\n  * @param  {object}  patch\n  * @return {boolean}\n  */\n\n\n  function isPatchValid(manifest, patch) {\n    var manifestId = dashManifestModel.getId(manifest);\n    var patchManifestId = patchManifestModel.getMpdId(patch);\n    var manifestPublishTime = dashManifestModel.getPublishTime(manifest);\n    var patchPublishTime = patchManifestModel.getPublishTime(patch);\n    var originalManifestPublishTime = patchManifestModel.getOriginalPublishTime(patch); // Patches are considered compatible if the following are true\n    // - MPD@id == Patch@mpdId\n    // - MPD@publishTime == Patch@originalPublishTime\n    // - MPD@publishTime < Patch@publishTime\n    // - All values in comparison exist\n\n    return !!(manifestId && patchManifestId && manifestId == patchManifestId && manifestPublishTime && originalManifestPublishTime && manifestPublishTime.getTime() == originalManifestPublishTime.getTime() && patchPublishTime && manifestPublishTime.getTime() < patchPublishTime.getTime());\n  }\n  /**\n  * Takes a given patch and applies it to the provided manifest, assumes patch is valid for manifest\n  * @param  {object} manifest\n  * @param  {object} patch\n  */\n\n\n  function applyPatchToManifest(manifest, patch) {\n    // get all operations from the patch and apply them in document order\n    patchManifestModel.getPatchOperations(patch).forEach(function (operation) {\n      var result = operation.getMpdTarget(manifest); // operation supplies a path that doesn't match mpd, skip\n\n      if (result === null) {\n        return;\n      }\n\n      var name = result.name,\n          target = result.target,\n          leaf = result.leaf; // short circuit for attribute selectors\n\n      if (operation.xpath.findsAttribute()) {\n        switch (operation.action) {\n          case 'add':\n          case 'replace':\n            // add and replace are just setting the value\n            target[name] = operation.value;\n            break;\n\n          case 'remove':\n            // remove is deleting the value\n            delete target[name];\n            break;\n        }\n\n        return;\n      } // determine the relative insert position prior to possible removal\n\n\n      var relativePosition = (target[name + '_asArray'] || []).indexOf(leaf);\n      var insertBefore = operation.position === 'prepend' || operation.position === 'before'; // perform removal operation first, we have already capture the appropriate relative position\n\n      if (operation.action === 'remove' || operation.action === 'replace') {\n        // note that we ignore the 'ws' attribute of patch operations as it does not effect parsed mpd operations\n        // purge the directly named entity\n        delete target[name]; // if we did have a positional reference we need to purge from array set and restore X2JS proper semantics\n\n        if (relativePosition != -1) {\n          var targetArray = target[name + '_asArray'];\n          targetArray.splice(relativePosition, 1);\n\n          if (targetArray.length > 1) {\n            target[name] = targetArray;\n          } else if (targetArray.length == 1) {\n            // xml parsing semantics, singular asArray must be non-array in the unsuffixed key\n            target[name] = targetArray[0];\n          } else {\n            // all nodes of this type deleted, remove entry\n            delete target[name + '_asArray'];\n          }\n        }\n      } // Perform any add/replace operations now, technically RFC5261 only allows a single element to take the\n      // place of a replaced element while the add case allows an arbitrary number of children.\n      // Due to the both operations requiring the same insertion logic they have been combined here and we will\n      // not enforce single child operations for replace, assertions should be made at patch parse time if necessary\n\n\n      if (operation.action === 'add' || operation.action === 'replace') {\n        // value will be an object with element name keys pointing to arrays of objects\n        Object.keys(operation.value).forEach(function (insert) {\n          var insertNodes = operation.value[insert];\n          var updatedNodes = target[insert + '_asArray'] || [];\n\n          if (updatedNodes.length === 0 && target[insert]) {\n            updatedNodes.push(target[insert]);\n          }\n\n          if (updatedNodes.length === 0) {\n            // no original nodes for this element type\n            updatedNodes = insertNodes;\n          } else {\n            // compute the position we need to insert at, default to end of set\n            var position = updatedNodes.length;\n\n            if (insert == name && relativePosition != -1) {\n              // if the inserted element matches the operation target (not leaf) and there is a relative position we\n              // want the inserted position to be set such that our insertion is relative to original position\n              // since replace has modified the array length we reduce the insert point by 1\n              position = relativePosition + (insertBefore ? 0 : 1) + (operation.action == 'replace' ? -1 : 0);\n            } else {\n              // otherwise we are in an add append/prepend case or replace case that removed the target name completely\n              position = insertBefore ? 0 : updatedNodes.length;\n            } // we dont have to perform element removal for the replace case as that was done above\n\n\n            updatedNodes.splice.apply(updatedNodes, [position, 0].concat(insertNodes));\n          } // now we properly reset the element keys on the target to match parsing semantics\n\n\n          target[insert + '_asArray'] = updatedNodes;\n          target[insert] = updatedNodes.length == 1 ? updatedNodes[0] : updatedNodes;\n        });\n      }\n    });\n  } // #endregion PUBLIC FUNCTIONS\n  // #region PRIVATE FUNCTIONS\n  // --------------------------------------------------\n\n\n  function getManifest(externalManifest) {\n    return externalManifest ? externalManifest : voPeriods.length > 0 ? voPeriods[0].mpd.manifest : null;\n  }\n\n  function getAdaptationForMediaInfo(mediaInfo) {\n    if (!mediaInfo || !mediaInfo.streamInfo || mediaInfo.streamInfo.id === undefined || !voAdaptations[mediaInfo.streamInfo.id]) return null;\n    return voAdaptations[mediaInfo.streamInfo.id][mediaInfo.index];\n  }\n\n  function getPeriodForStreamInfo(streamInfo, voPeriodsArray) {\n    var ln = voPeriodsArray.length;\n\n    for (var i = 0; i < ln; i++) {\n      var voPeriod = voPeriodsArray[i];\n      if (streamInfo && streamInfo.id === voPeriod.id) return voPeriod;\n    }\n\n    return null;\n  }\n\n  function convertAdaptationToMediaInfo(adaptation) {\n    if (!adaptation) {\n      return null;\n    }\n\n    var mediaInfo = new _MediaInfo2.default();\n    var realAdaptation = adaptation.period.mpd.manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index];\n    var viewpoint = void 0;\n    mediaInfo.id = adaptation.id;\n    mediaInfo.index = adaptation.index;\n    mediaInfo.type = adaptation.type;\n    mediaInfo.streamInfo = convertPeriodToStreamInfo(adaptation.period);\n    mediaInfo.representationCount = dashManifestModel.getRepresentationCount(realAdaptation);\n    mediaInfo.labels = dashManifestModel.getLabelsForAdaptation(realAdaptation);\n    mediaInfo.lang = dashManifestModel.getLanguageForAdaptation(realAdaptation);\n    viewpoint = dashManifestModel.getViewpointForAdaptation(realAdaptation);\n    mediaInfo.viewpoint = viewpoint ? viewpoint.value : undefined;\n    mediaInfo.accessibility = dashManifestModel.getAccessibilityForAdaptation(realAdaptation).map(function (accessibility) {\n      var accessibilityValue = accessibility.value;\n      var accessibilityData = accessibilityValue;\n\n      if (accessibility.schemeIdUri && accessibility.schemeIdUri.search('cea-608') >= 0 && typeof cea608parser !== 'undefined') {\n        if (accessibilityValue) {\n          accessibilityData = 'cea-608:' + accessibilityValue;\n        } else {\n          accessibilityData = 'cea-608';\n        }\n\n        mediaInfo.embeddedCaptions = true;\n      }\n\n      return accessibilityData;\n    });\n    mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForAdaptation(realAdaptation).map(function (audioChannelConfiguration) {\n      return audioChannelConfiguration.value;\n    });\n\n    if (mediaInfo.audioChannelConfiguration.length === 0 && Array.isArray(realAdaptation.Representation_asArray) && realAdaptation.Representation_asArray.length > 0) {\n      mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForRepresentation(realAdaptation.Representation_asArray[0]).map(function (audioChannelConfiguration) {\n        return audioChannelConfiguration.value;\n      });\n    }\n\n    mediaInfo.roles = dashManifestModel.getRolesForAdaptation(realAdaptation).map(function (role) {\n      return role.value;\n    });\n    mediaInfo.codec = dashManifestModel.getCodec(realAdaptation);\n    mediaInfo.mimeType = dashManifestModel.getMimeType(realAdaptation);\n    mediaInfo.contentProtection = dashManifestModel.getContentProtectionData(realAdaptation);\n    mediaInfo.bitrateList = dashManifestModel.getBitrateListForAdaptation(realAdaptation);\n\n    if (mediaInfo.contentProtection) {\n      mediaInfo.contentProtection.forEach(function (item) {\n        item.KID = dashManifestModel.getKID(item);\n      });\n    }\n\n    mediaInfo.isText = dashManifestModel.getIsTextTrack(mediaInfo.mimeType);\n    mediaInfo.supplementalProperties = dashManifestModel.getSupplementalPropperties(realAdaptation);\n    return mediaInfo;\n  }\n\n  function convertVideoInfoToEmbeddedTextInfo(mediaInfo, channel, lang) {\n    mediaInfo.id = channel; // CC1, CC2, CC3, or CC4\n\n    mediaInfo.index = 100 + parseInt(channel.substring(2, 3));\n    mediaInfo.type = constants.EMBEDDED_TEXT;\n    mediaInfo.codec = 'cea-608-in-SEI';\n    mediaInfo.isText = true;\n    mediaInfo.isEmbedded = true;\n    mediaInfo.lang = lang;\n    mediaInfo.roles = ['caption'];\n  }\n\n  function convertVideoInfoToThumbnailInfo(mediaInfo) {\n    mediaInfo.type = constants.IMAGE;\n  }\n\n  function convertPeriodToStreamInfo(period) {\n    var streamInfo = new _StreamInfo2.default();\n    var THRESHOLD = 1;\n    streamInfo.id = period.id;\n    streamInfo.index = period.index;\n    streamInfo.start = period.start;\n    streamInfo.duration = period.duration;\n    streamInfo.manifestInfo = convertMpdToManifestInfo(period.mpd);\n    streamInfo.isLast = period.mpd.manifest.Period_asArray.length === 1 || Math.abs(streamInfo.start + streamInfo.duration - streamInfo.manifestInfo.duration) < THRESHOLD;\n    return streamInfo;\n  }\n\n  function convertMpdToManifestInfo(mpd) {\n    var manifestInfo = new _ManifestInfo2.default();\n    manifestInfo.DVRWindowSize = mpd.timeShiftBufferDepth;\n    manifestInfo.loadedTime = mpd.manifest.loadedTime;\n    manifestInfo.availableFrom = mpd.availabilityStartTime;\n    manifestInfo.minBufferTime = mpd.manifest.minBufferTime;\n    manifestInfo.maxFragmentDuration = mpd.maxSegmentDuration;\n    manifestInfo.duration = dashManifestModel.getDuration(mpd.manifest);\n    manifestInfo.isDynamic = dashManifestModel.getIsDynamic(mpd.manifest);\n    manifestInfo.serviceDescriptions = dashManifestModel.getServiceDescriptions(mpd.manifest);\n    manifestInfo.protocol = mpd.manifest.protocol;\n    return manifestInfo;\n  }\n\n  function checkConfig() {\n    if (!constants) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n\n  function getPeriod(periodIdx) {\n    return voPeriods.length > 0 ? voPeriods[0].mpd.manifest.Period_asArray[periodIdx] : null;\n  }\n\n  function findRepresentationIndex(period, representationId) {\n    var index = findRepresentation(period, representationId, true);\n    return index !== null ? index : -1;\n  }\n\n  function findRepresentation(period, representationId, returnIndex) {\n    var adaptationSet = void 0,\n        adaptationSetArray = void 0,\n        representation = void 0,\n        representationArray = void 0,\n        adaptationSetArrayIndex = void 0,\n        representationArrayIndex = void 0;\n\n    if (period) {\n      adaptationSetArray = period.AdaptationSet_asArray;\n\n      for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n        adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n        representationArray = adaptationSet.Representation_asArray;\n\n        for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n          representation = representationArray[representationArrayIndex];\n\n          if (representationId === representation.id) {\n            if (returnIndex) {\n              return representationArrayIndex;\n            } else {\n              return representation;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function findMaxBufferIndex(period, bufferType) {\n    var adaptationSet = void 0,\n        adaptationSetArray = void 0,\n        representationArray = void 0,\n        adaptationSetArrayIndex = void 0;\n    if (!period || !bufferType) return -1;\n    adaptationSetArray = period.AdaptationSet_asArray;\n\n    for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n      adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n      representationArray = adaptationSet.Representation_asArray;\n\n      if (dashManifestModel.getIsTypeOf(adaptationSet, bufferType)) {\n        return representationArray.length;\n      }\n    }\n\n    return -1;\n  } // #endregion PRIVATE FUNCTIONS\n\n\n  instance = {\n    getBandwidthForRepresentation: getBandwidthForRepresentation,\n    getIndexForRepresentation: getIndexForRepresentation,\n    getMaxIndexForBufferType: getMaxIndexForBufferType,\n    convertDataToRepresentationInfo: convertRepresentationToRepresentationInfo,\n    getDataForMedia: getAdaptationForMediaInfo,\n    getStreamsInfo: getStreamsInfo,\n    getMediaInfoForType: getMediaInfoForType,\n    getAllMediaInfoForType: getAllMediaInfoForType,\n    getAdaptationForType: getAdaptationForType,\n    getRealAdaptation: getRealAdaptation,\n    getRealPeriodByIndex: getRealPeriodByIndex,\n    getEssentialPropertiesForRepresentation: getEssentialPropertiesForRepresentation,\n    getVoRepresentations: getVoRepresentations,\n    getEventsFor: getEventsFor,\n    getEvent: getEvent,\n    getMpd: getMpd,\n    setConfig: setConfig,\n    updatePeriods: updatePeriods,\n    getIsTextTrack: getIsTextTrack,\n    getUTCTimingSources: getUTCTimingSources,\n    getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n    getAvailabilityStartTime: getAvailabilityStartTime,\n    getIsTypeOf: getIsTypeOf,\n    getIsDynamic: getIsDynamic,\n    getDuration: getDuration,\n    getRegularPeriods: getRegularPeriods,\n    getLocation: getLocation,\n    getPatchLocation: getPatchLocation,\n    getManifestUpdatePeriod: getManifestUpdatePeriod,\n    getPublishTime: getPublishTime,\n    getIsDVB: getIsDVB,\n    getIsPatch: getIsPatch,\n    getBaseURLsFromElement: getBaseURLsFromElement,\n    getRepresentationSortFunction: getRepresentationSortFunction,\n    getCodec: getCodec,\n    getVoAdaptations: getVoAdaptations,\n    getVoPeriods: getVoPeriods,\n    getPeriodById: getPeriodById,\n    setCurrentMediaInfo: setCurrentMediaInfo,\n    isPatchValid: isPatchValid,\n    applyPatchToManifest: applyPatchToManifest,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nDashAdapter.__dashjs_factory_name = 'DashAdapter';\nexports.default = _FactoryMaker2.default.getSingletonFactory(DashAdapter);","map":{"version":3,"sources":["../../../../src/dash/DashAdapter.js"],"names":["instance","dashManifestModel","patchManifestModel","voPeriods","voAdaptations","currentMediaInfo","constants","cea608parser","context","PROFILE_DVB","reset","config","errHandler","BASE64","representationInfo","RepresentationInfo","realAdaptation","voRepresentation","realRepresentation","convertAdaptationToMediaInfo","selectedVoPeriod","getPeriodForStreamInfo","periodId","getAdaptationForType","streamInfo","idx","role","DashConstants","adaptations","allMediaInfoForType","getAllMediaInfoForType","i","ln","areMediaInfosEqual","getIsMain","sameId","mInfoOne","mInfoTwo","sameViewpoint","sameLang","sameRoles","sameAccessibility","sameAudioChannelConfiguration","voLocalPeriods","manifest","mediaArr","data","media","j","checkConfig","getRegularPeriods","adaptationsForType","type","accessibilityLength","accessibility","value","parts","convertVideoInfoToEmbeddedTextInfo","convertVideoInfoToThumbnailInfo","streams","maxStreamsInfo","convertPeriodToStreamInfo","id","mediaInfo","voReps","voAdaptation","getAdaptationForMediaInfo","isNaN","schemeIdUri","eventBox","eventStreams","event","Event","timescale","periodStart","eventStream","presentationTimeOffset","presentationTimeDelta","calculatedPresentationTime","duration","messageData","events","info","StreamInfo","MediaInfo","getManifest","mpd","getMpd","latencyOfLastUpdate","patchLocation","publishTime","ttl","parseFloat","representation","period","getPeriod","findRepresentation","findRepresentationIndex","findMaxBufferIndex","periods","p","manifestId","patchManifestId","manifestPublishTime","patchPublishTime","originalManifestPublishTime","result","operation","name","target","leaf","relativePosition","insertBefore","targetArray","Object","insertNodes","updatedNodes","insert","position","externalManifest","voPeriodsArray","voPeriod","adaptation","viewpoint","accessibilityValue","accessibilityData","audioChannelConfiguration","Array","item","parseInt","channel","THRESHOLD","convertMpdToManifestInfo","Math","manifestInfo","ManifestInfo","index","adaptationSet","adaptationSetArray","representationArray","adaptationSetArrayIndex","representationArrayIndex","representationId","getBandwidthForRepresentation","getIndexForRepresentation","getMaxIndexForBufferType","convertDataToRepresentationInfo","getDataForMedia","getStreamsInfo","getMediaInfoForType","getRealAdaptation","getRealPeriodByIndex","getEssentialPropertiesForRepresentation","getVoRepresentations","getEventsFor","getEvent","setConfig","updatePeriods","getIsTextTrack","getUTCTimingSources","getSuggestedPresentationDelay","getAvailabilityStartTime","getIsTypeOf","getIsDynamic","getDuration","getLocation","getPatchLocation","getManifestUpdatePeriod","getPublishTime","getIsDVB","getIsPatch","getBaseURLsFromElement","getRepresentationSortFunction","getCodec","getVoAdaptations","getVoPeriods","getPeriodById","setCurrentMediaInfo","isPatchValid","applyPatchToManifest","setup","DashAdapter","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport DashConstants from './constants/DashConstants';\nimport RepresentationInfo from './vo/RepresentationInfo';\nimport MediaInfo from './vo/MediaInfo';\nimport StreamInfo from './vo/StreamInfo';\nimport ManifestInfo from './vo/ManifestInfo';\nimport Event from './vo/Event';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashManifestModel from './models/DashManifestModel';\nimport PatchManifestModel from './models/PatchManifestModel';\n\n/**\n * @module DashAdapter\n */\n\nfunction DashAdapter() {\n    let instance,\n        dashManifestModel,\n        patchManifestModel,\n        voPeriods,\n        voAdaptations,\n        currentMediaInfo,\n        constants,\n        cea608parser;\n\n    const context = this.context;\n\n    const PROFILE_DVB = 'urn:dvb:dash:profile:dvb-dash:2014';\n\n    function setup() {\n        dashManifestModel = DashManifestModel(context).getInstance();\n        patchManifestModel = PatchManifestModel(context).getInstance();\n        reset();\n    }\n\n    // #region PUBLIC FUNCTIONS\n    // --------------------------------------------------\n    function getVoAdaptations() {\n        return voAdaptations;\n    }\n\n    function getVoPeriods() {\n        return voPeriods;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.constants) {\n            constants = config.constants;\n        }\n\n        if (config.cea608parser) {\n            cea608parser = config.cea608parser;\n        }\n\n        if (config.errHandler) {\n            dashManifestModel.setConfig({ errHandler: config.errHandler });\n        }\n\n        if (config.BASE64) {\n            dashManifestModel.setConfig({ BASE64: config.BASE64 });\n        }\n    }\n\n    /**\n     * Creates an instance of RepresentationInfo based on a representation value object\n     * @param {object} voRepresentation\n     * @returns {RepresentationInfo|null} representationInfo\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function convertRepresentationToRepresentationInfo(voRepresentation) {\n        if (voRepresentation) {\n            let representationInfo = new RepresentationInfo();\n            const realAdaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n            const realRepresentation = dashManifestModel.getRepresentationFor(voRepresentation.index, realAdaptation);\n\n            representationInfo.id = voRepresentation.id;\n            representationInfo.quality = voRepresentation.index;\n            representationInfo.bandwidth = dashManifestModel.getBandwidth(realRepresentation);\n            representationInfo.DVRWindow = voRepresentation.segmentAvailabilityRange;\n            representationInfo.fragmentDuration = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length > 0 ? voRepresentation.segments[0].duration : NaN);\n            representationInfo.MSETimeOffset = voRepresentation.MSETimeOffset;\n            representationInfo.mediaInfo = convertAdaptationToMediaInfo(voRepresentation.adaptation);\n\n            return representationInfo;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns a MediaInfo object for a given media type.\n     * @param {object} streamInfo\n     * @param {MediaType }type\n     * @returns {null|MediaInfo} mediaInfo\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getMediaInfoForType(streamInfo, type) {\n        if (voPeriods.length === 0 || !streamInfo) {\n            return null;\n        }\n\n        let selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n        if (!selectedVoPeriod) return null;\n\n        let periodId = selectedVoPeriod.id;\n        voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n\n        let realAdaptation = getAdaptationForType(streamInfo.index, type, streamInfo);\n        if (!realAdaptation) return null;\n        let idx = dashManifestModel.getIndexForAdaptation(realAdaptation, voPeriods[0].mpd.manifest, streamInfo.index);\n\n        return convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n    }\n\n    /**\n     * Checks if the role of the specified AdaptationSet is set to main\n     * @param {object} adaptation\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getIsMain(adaptation) {\n        return dashManifestModel.getRolesForAdaptation(adaptation).filter(function (role) {\n            return role.value === DashConstants.MAIN;\n        })[0];\n    }\n\n    /**\n     * Returns the AdaptationSet for a given period and a given mediaType.\n     * @param {number} periodIndex\n     * @param {MediaType} type\n     * @param {object} streamInfo\n     * @returns {null|object} adaptation\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getAdaptationForType(periodIndex, type, streamInfo) {\n        const adaptations = dashManifestModel.getAdaptationsForType(voPeriods[0].mpd.manifest, periodIndex, type);\n\n        if (!adaptations || adaptations.length === 0) return null;\n\n        if (adaptations.length > 1 && streamInfo) {\n            const allMediaInfoForType = getAllMediaInfoForType(streamInfo, type);\n\n            if (currentMediaInfo[streamInfo.id] && currentMediaInfo[streamInfo.id][type]) {\n                for (let i = 0, ln = adaptations.length; i < ln; i++) {\n                    if (areMediaInfosEqual(currentMediaInfo[streamInfo.id][type], allMediaInfoForType[i])) {\n                        return adaptations[i];\n                    }\n                }\n            }\n\n            for (let i = 0, ln = adaptations.length; i < ln; i++) {\n                if (getIsMain(adaptations[i])) {\n                    return adaptations[i];\n                }\n            }\n        }\n\n        return adaptations[0];\n    }\n\n    /**\n     * Compares two mediaInfo objects\n     * @param {MediaInfo} mInfoOne\n     * @param {MediaInfo} mInfoTwo\n     * @returns {boolean}\n     */\n    function areMediaInfosEqual(mInfoOne, mInfoTwo) {\n        if (!mInfoOne || !mInfoTwo) {\n            return false;\n        }\n\n        const sameId = mInfoOne.id === mInfoTwo.id;\n        const sameViewpoint = mInfoOne.viewpoint === mInfoTwo.viewpoint;\n        const sameLang = mInfoOne.lang === mInfoTwo.lang;\n        const sameRoles = mInfoOne.roles.toString() === mInfoTwo.roles.toString();\n        const sameAccessibility = mInfoOne.accessibility.toString() === mInfoTwo.accessibility.toString();\n        const sameAudioChannelConfiguration = mInfoOne.audioChannelConfiguration.toString() === mInfoTwo.audioChannelConfiguration.toString();\n\n        return (sameId && sameViewpoint && sameLang && sameRoles && sameAccessibility && sameAudioChannelConfiguration);\n    }\n\n    /**\n     * Returns the mediaInfo for a given mediaType\n     * @param {object} streamInfo\n     * @param {MediaType} type\n     * @param {object} externalManifest Set to null or undefined if no external manifest is to be used\n     * @returns {Array} mediaArr\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getAllMediaInfoForType(streamInfo, type, externalManifest) {\n        let voLocalPeriods = voPeriods;\n        let manifest = externalManifest;\n        let mediaArr = [];\n        let data,\n            media,\n            idx,\n            i,\n            j,\n            ln,\n            periodId;\n\n        if (manifest) {\n            checkConfig();\n\n            voLocalPeriods = getRegularPeriods(manifest);\n        } else {\n            if (voPeriods.length > 0) {\n                manifest = voPeriods[0].mpd.manifest;\n            } else {\n                return mediaArr;\n            }\n        }\n\n        const selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voLocalPeriods);\n        if (selectedVoPeriod) {\n            periodId = selectedVoPeriod.id;\n        }\n        const adaptationsForType = dashManifestModel.getAdaptationsForType(manifest, streamInfo ? streamInfo.index : null, type !== constants.EMBEDDED_TEXT ? type : constants.VIDEO);\n\n        if (!adaptationsForType || adaptationsForType.length === 0) return mediaArr;\n\n        voAdaptations[periodId] = voAdaptations[periodId] || dashManifestModel.getAdaptationsForPeriod(selectedVoPeriod);\n\n        for (i = 0, ln = adaptationsForType.length; i < ln; i++) {\n            data = adaptationsForType[i];\n            idx = dashManifestModel.getIndexForAdaptation(data, manifest, streamInfo.index);\n            media = convertAdaptationToMediaInfo(voAdaptations[periodId][idx]);\n\n            if (type === constants.EMBEDDED_TEXT) {\n                let accessibilityLength = media.accessibility.length;\n                for (j = 0; j < accessibilityLength; j++) {\n                    if (!media) {\n                        continue;\n                    }\n                    let accessibility = media.accessibility[j];\n                    if (accessibility.indexOf('cea-608:') === 0) {\n                        let value = accessibility.substring(8);\n                        let parts = value.split(';');\n                        if (parts[0].substring(0, 2) === 'CC') {\n                            for (j = 0; j < parts.length; j++) {\n                                if (!media) {\n                                    media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                                }\n                                convertVideoInfoToEmbeddedTextInfo(media, parts[j].substring(0, 3), parts[j].substring(4));\n                                mediaArr.push(media);\n                                media = null;\n                            }\n                        } else {\n                            for (j = 0; j < parts.length; j++) { // Only languages for CC1, CC2, ...\n                                if (!media) {\n                                    media = convertAdaptationToMediaInfo.call(this, voAdaptations[periodId][idx]);\n                                }\n                                convertVideoInfoToEmbeddedTextInfo(media, 'CC' + (j + 1), parts[j]);\n                                mediaArr.push(media);\n                                media = null;\n                            }\n                        }\n                    } else if (accessibility.indexOf('cea-608') === 0) { // Nothing known. We interpret it as CC1=eng\n                        convertVideoInfoToEmbeddedTextInfo(media, constants.CC1, 'eng');\n                        mediaArr.push(media);\n                        media = null;\n                    }\n                }\n            } else if (type === constants.IMAGE) {\n                convertVideoInfoToThumbnailInfo(media);\n                mediaArr.push(media);\n                media = null;\n            } else if (media) {\n                mediaArr.push(media);\n            }\n        }\n\n        return mediaArr;\n    }\n\n    /**\n     * @param {object} newManifest\n     * @returns {*}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function updatePeriods(newManifest) {\n        if (!newManifest) return null;\n\n        checkConfig();\n\n        voPeriods = getRegularPeriods(newManifest);\n\n        voAdaptations = {};\n    }\n\n    /**\n     * @param {object} externalManifest\n     * @param {number} maxStreamsInfo\n     * @returns {Array} streams\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getStreamsInfo(externalManifest, maxStreamsInfo) {\n        const streams = [];\n        let voLocalPeriods = voPeriods;\n\n        //if manifest is defined, getStreamsInfo is for an outside manifest, not the current one\n        if (externalManifest) {\n            checkConfig();\n            voLocalPeriods = getRegularPeriods(externalManifest);\n        }\n\n        if (voLocalPeriods.length > 0) {\n            if (!maxStreamsInfo || maxStreamsInfo > voLocalPeriods.length) {\n                maxStreamsInfo = voLocalPeriods.length;\n            }\n            for (let i = 0; i < maxStreamsInfo; i++) {\n                streams.push(convertPeriodToStreamInfo(voLocalPeriods[i]));\n            }\n        }\n\n        return streams;\n    }\n\n    /**\n     *\n     * @param {object} streamInfo\n     * @param {object} mediaInfo\n     * @returns {object} realAdaptation\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getRealAdaptation(streamInfo, mediaInfo) {\n        let id,\n            realAdaptation;\n\n        const selectedVoPeriod = getPeriodForStreamInfo(streamInfo, voPeriods);\n\n        id = mediaInfo ? mediaInfo.id : null;\n\n        if (voPeriods.length > 0 && selectedVoPeriod) {\n            realAdaptation = id ? dashManifestModel.getAdaptationForId(id, voPeriods[0].mpd.manifest, selectedVoPeriod.index) : dashManifestModel.getAdaptationForIndex(mediaInfo ? mediaInfo.index : null, voPeriods[0].mpd.manifest, selectedVoPeriod.index);\n        }\n\n        return realAdaptation;\n    }\n\n    /**\n     * Return all EssentialProperties of a Representation\n     * @param {object} representation\n     * @return {array}\n     */\n    function getEssentialPropertiesForRepresentation(representation) {\n        try {\n            return dashManifestModel.getEssentialPropertiesForRepresentation(representation);\n        } catch (e) {\n            return [];\n        }\n    }\n\n    /**\n     * Returns the period by index\n     * @param {number} index\n     * @return {object}\n     */\n    function getRealPeriodByIndex(index) {\n        return dashManifestModel.getRealPeriodForIndex(index, voPeriods[0].mpd.manifest);\n    }\n\n    /**\n     * Returns all voRepresentations for a given mediaInfo\n     * @param {object} mediaInfo\n     * @returns {Array} voReps\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getVoRepresentations(mediaInfo) {\n        let voReps;\n\n        const voAdaptation = getAdaptationForMediaInfo(mediaInfo);\n        voReps = dashManifestModel.getRepresentationsForAdaptation(voAdaptation);\n\n        return voReps;\n    }\n\n    /**\n     *\n     * @param {object} eventBox\n     * @param {object} eventStreams\n     * @param {number} mediaStartTime\n     * @param {object} voRepresentation\n     * @returns {null|Event}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getEvent(eventBox, eventStreams, mediaStartTime, voRepresentation) {\n        try {\n            if (!eventBox || !eventStreams || isNaN(mediaStartTime) || !voRepresentation) {\n                return null;\n            }\n\n            const schemeIdUri = eventBox.scheme_id_uri;\n            const value = eventBox.value;\n\n            if (!eventStreams[schemeIdUri + '/' + value]) {\n                return null;\n            }\n\n            const event = new Event();\n            const timescale = eventBox.timescale || 1;\n            const periodStart = voRepresentation.adaptation.period.start;\n            const eventStream = eventStreams[schemeIdUri + '/' + value];\n            const presentationTimeOffset = !isNaN(voRepresentation.presentationTimeOffset) ? voRepresentation.presentationTimeOffset : !isNaN(eventStream.presentationTimeOffset) ? eventStream.presentationTimeOffset : 0;\n            let presentationTimeDelta = eventBox.presentation_time_delta / timescale; // In case of version 1 events the presentation_time is parsed as presentation_time_delta\n            let calculatedPresentationTime;\n\n            if (eventBox.version === 0) {\n                calculatedPresentationTime = periodStart + mediaStartTime - presentationTimeOffset + presentationTimeDelta;\n            } else {\n                calculatedPresentationTime = periodStart - presentationTimeOffset + presentationTimeDelta;\n            }\n\n            const duration = eventBox.event_duration;\n            const id = eventBox.id;\n            const messageData = eventBox.message_data;\n\n            event.eventStream = eventStream;\n            event.eventStream.value = value;\n            event.eventStream.timescale = timescale;\n            event.duration = duration;\n            event.id = id;\n            event.calculatedPresentationTime = calculatedPresentationTime;\n            event.messageData = messageData;\n            event.presentationTimeDelta = presentationTimeDelta;\n\n            return event;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     *\n     * @param {object} info\n     * @param {object} voRepresentation\n     * @returns {Array}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getEventsFor(info, voRepresentation) {\n        let events = [];\n\n        if (voPeriods.length > 0) {\n            const manifest = voPeriods[0].mpd.manifest;\n\n            if (info instanceof StreamInfo) {\n                events = dashManifestModel.getEventsForPeriod(getPeriodForStreamInfo(info, voPeriods));\n            } else if (info instanceof MediaInfo) {\n                events = dashManifestModel.getEventStreamForAdaptationSet(manifest, getAdaptationForMediaInfo(info));\n            } else if (info instanceof RepresentationInfo) {\n                events = dashManifestModel.getEventStreamForRepresentation(manifest, voRepresentation);\n            }\n        }\n\n        return events;\n    }\n\n    /**\n     *\n     * @param {number} streamId\n     * @param {MediaType} type\n     * @param {object} mediaInfo\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function setCurrentMediaInfo(streamId, type, mediaInfo) {\n        currentMediaInfo[streamId] = currentMediaInfo[streamId] || {};\n        currentMediaInfo[streamId][type] = currentMediaInfo[streamId][type] || {};\n        currentMediaInfo[streamId][type] = mediaInfo;\n    }\n\n    /**\n     *\n     * @param {String} type\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getIsTextTrack(type) {\n        return dashManifestModel.getIsTextTrack(type);\n    }\n\n    /**\n     * Returns the UTC Timing Sources specified in the manifest\n     * @returns {Array} utcTimingSources\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getUTCTimingSources() {\n        const manifest = getManifest();\n        return dashManifestModel.getUTCTimingSources(manifest);\n    }\n\n    /**\n     * Returns the suggestedPresentationDelay as specified in the manifest\n     * @returns {String} suggestedPresentationDelay\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getSuggestedPresentationDelay() {\n        const mpd = voPeriods.length > 0 ? voPeriods[0].mpd : null;\n        return dashManifestModel.getSuggestedPresentationDelay(mpd);\n    }\n\n    /**\n     * Returns the availabilityStartTime as specified in the manifest\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {string} availabilityStartTime\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getAvailabilityStartTime(externalManifest) {\n        const mpd = getMpd(externalManifest);\n        return dashManifestModel.getAvailabilityStartTime(mpd);\n    }\n\n    /**\n     * Returns a boolean indicating if the manifest is dynamic or not\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getIsDynamic(externalManifest) {\n        const manifest = getManifest(externalManifest);\n        return dashManifestModel.getIsDynamic(manifest);\n    }\n\n    /**\n     * Returns the duration of the MPD\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {number} duration\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getDuration(externalManifest) {\n        const manifest = getManifest(externalManifest);\n        return dashManifestModel.getDuration(manifest);\n    }\n\n    /**\n     * Returns all periods of the MPD\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {Array} periods\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getRegularPeriods(externalManifest) {\n        const mpd = getMpd(externalManifest);\n        return dashManifestModel.getRegularPeriods(mpd);\n    }\n\n    /**\n     * Returns an MPD object\n     * @param {object} externalManifest Omit this value if no external manifest should be used\n     * @returns {object} MPD\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getMpd(externalManifest) {\n        const manifest = getManifest(externalManifest);\n        return dashManifestModel.getMpd(manifest);\n    }\n\n    /**\n     * Returns the location element of the MPD\n     * @param {object} manifest\n     * @returns {String} location\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getLocation(manifest) {\n        return dashManifestModel.getLocation(manifest);\n    }\n\n    /**\n     * Returns the manifest update period used for dynamic manifests\n     * @param {object} manifest\n     * @param {number} latencyOfLastUpdate\n     * @returns {NaN|number} manifestUpdatePeriod\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getManifestUpdatePeriod(manifest, latencyOfLastUpdate = 0) {\n        return dashManifestModel.getManifestUpdatePeriod(manifest, latencyOfLastUpdate);\n    }\n\n    /**\n     * Returns the publish time from the manifest\n     * @param {object} manifest\n     * @returns {Date|null} publishTime\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getPublishTime(manifest) {\n        return dashManifestModel.getPublishTime(manifest);\n    }\n\n    /**\n     * Returns the patch location of the MPD if one exists and it is still valid\n     * @param {object} manifest\n     * @returns {(String|null)} patch location\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getPatchLocation(manifest) {\n        const patchLocation = dashManifestModel.getPatchLocation(manifest);\n        const publishTime = dashManifestModel.getPublishTime(manifest);\n\n        // short-circuit when no patch location or publish time exists\n        if (!patchLocation || !publishTime) {\n            return null;\n        }\n\n        // if a ttl is provided, ensure patch location has not expired\n        if (patchLocation.hasOwnProperty('ttl') && publishTime) {\n            // attribute describes number of seconds as a double\n            const ttl = parseFloat(patchLocation.ttl) * 1000;\n\n            // check if the patch location has expired, if so do not consider it\n            if (publishTime.getTime() + ttl <= new Date().getTime()) {\n                return null;\n            }\n        }\n\n        // the patch location exists and, if a ttl applies, has not expired\n        return patchLocation.__text;\n    }\n\n    /**\n     * Checks if the manifest has a DVB profile\n     * @param {object} manifest\n     * @returns {boolean}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getIsDVB(manifest) {\n        return dashManifestModel.hasProfile(manifest, PROFILE_DVB);\n    }\n\n    /**\n     * Checks if the manifest is actually just a patch manifest\n     * @param  {object} manifest\n     * @return {boolean}\n     */\n    function getIsPatch(manifest) {\n        return patchManifestModel.getIsPatch(manifest);\n    }\n\n    /**\n     *\n     * @param {object} node\n     * @returns {Array}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getBaseURLsFromElement(node) {\n        return dashManifestModel.getBaseURLsFromElement(node);\n    }\n\n    /**\n     *\n     * @returns {*}\n     * @memberOf module:DashAdapter\n     * @instance\n     * @ignore\n     */\n    function getRepresentationSortFunction() {\n        return dashManifestModel.getRepresentationSortFunction();\n    }\n\n    /**\n     * Returns the codec for a given adaptation set and a given representation id.\n     * @param {object} adaptation\n     * @param {number} representationId\n     * @param {boolean} addResolutionInfo Defines whether to include resolution information in the output\n     * @returns {String} codec\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getCodec(adaptation, representationId, addResolutionInfo) {\n        return dashManifestModel.getCodec(adaptation, representationId, addResolutionInfo);\n    }\n\n    /**\n     * Returns the bandwidth for a given representation id\n     * @param {number} representationId\n     * @param {number} periodIdx\n     * @returns {number} bandwidth\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getBandwidthForRepresentation(representationId, periodIdx) {\n        let representation;\n        let period = getPeriod(periodIdx);\n\n        representation = findRepresentation(period, representationId);\n\n        return representation ? representation.bandwidth : null;\n    }\n\n    /**\n     * Returns the index for a given representation id\n     * @param {string} representationId\n     * @param {number} periodIdx\n     * @returns {number} index\n     * @memberOf module:DashAdapter\n     * @instance\n     */\n    function getIndexForRepresentation(representationId, periodIdx) {\n        let period = getPeriod(periodIdx);\n\n        return findRepresentationIndex(period, representationId);\n    }\n\n    /**\n     * This method returns the current max index based on what is defined in the MPD.\n     *\n     * @param {string} bufferType - String 'audio' or 'video',\n     * @param {number} periodIdx - Make sure this is the period index not id\n     * @return {number}\n     * @memberof module:DashAdapter\n     * @instance\n     */\n    function getMaxIndexForBufferType(bufferType, periodIdx) {\n        let period = getPeriod(periodIdx);\n\n        return findMaxBufferIndex(period, bufferType);\n    }\n\n    /**\n     * Returns the voPeriod object for a given id\n     * @param {String} id\n     * @returns {object|null}\n     */\n    function getPeriodById(id) {\n        if (!id || voPeriods.length === 0) {\n            return null;\n        }\n        const periods = voPeriods.filter((p) => {\n            return p.id === id;\n        });\n\n        if (periods && periods.length > 0) {\n            return periods[0];\n        }\n\n        return null;\n    }\n\n    function getIsTypeOf(adaptation, type) {\n        return dashManifestModel.getIsTypeOf(adaptation, type);\n    }\n\n    function reset() {\n        voPeriods = [];\n        voAdaptations = {};\n        currentMediaInfo = {};\n    }\n\n    /**\n     * Checks if the supplied manifest is compatible for application of the supplied patch\n     * @param  {object}  manifest\n     * @param  {object}  patch\n     * @return {boolean}\n     */\n    function isPatchValid(manifest, patch) {\n        let manifestId = dashManifestModel.getId(manifest);\n        let patchManifestId = patchManifestModel.getMpdId(patch);\n        let manifestPublishTime = dashManifestModel.getPublishTime(manifest);\n        let patchPublishTime = patchManifestModel.getPublishTime(patch);\n        let originalManifestPublishTime = patchManifestModel.getOriginalPublishTime(patch);\n\n        // Patches are considered compatible if the following are true\n        // - MPD@id == Patch@mpdId\n        // - MPD@publishTime == Patch@originalPublishTime\n        // - MPD@publishTime < Patch@publishTime\n        // - All values in comparison exist\n        return !!(manifestId && patchManifestId && (manifestId == patchManifestId) &&\n            manifestPublishTime && originalManifestPublishTime && (manifestPublishTime.getTime() == originalManifestPublishTime.getTime()) &&\n            patchPublishTime && (manifestPublishTime.getTime() < patchPublishTime.getTime()));\n    }\n\n    /**\n     * Takes a given patch and applies it to the provided manifest, assumes patch is valid for manifest\n     * @param  {object} manifest\n     * @param  {object} patch\n     */\n    function applyPatchToManifest(manifest, patch) {\n        // get all operations from the patch and apply them in document order\n        patchManifestModel.getPatchOperations(patch)\n            .forEach((operation) => {\n                let result = operation.getMpdTarget(manifest);\n\n                // operation supplies a path that doesn't match mpd, skip\n                if (result === null) {\n                    return;\n                }\n\n                let {name, target, leaf} = result;\n\n                // short circuit for attribute selectors\n                if (operation.xpath.findsAttribute()) {\n                    switch (operation.action) {\n                        case 'add':\n                        case 'replace':\n                            // add and replace are just setting the value\n                            target[name] = operation.value;\n                            break;\n                        case 'remove':\n                            // remove is deleting the value\n                            delete target[name];\n                            break;\n                    }\n                    return;\n                }\n\n                // determine the relative insert position prior to possible removal\n                let relativePosition = (target[name + '_asArray'] || []).indexOf(leaf);\n                let insertBefore = (operation.position === 'prepend' || operation.position === 'before');\n\n                // perform removal operation first, we have already capture the appropriate relative position\n                if (operation.action === 'remove' || operation.action === 'replace') {\n                    // note that we ignore the 'ws' attribute of patch operations as it does not effect parsed mpd operations\n\n                    // purge the directly named entity\n                    delete target[name];\n\n                    // if we did have a positional reference we need to purge from array set and restore X2JS proper semantics\n                    if (relativePosition != -1) {\n                        let targetArray = target[name + '_asArray'];\n                        targetArray.splice(relativePosition, 1);\n                        if (targetArray.length > 1) {\n                            target[name] = targetArray;\n                        } else if (targetArray.length == 1) {\n                            // xml parsing semantics, singular asArray must be non-array in the unsuffixed key\n                            target[name] = targetArray[0];\n                        } else {\n                            // all nodes of this type deleted, remove entry\n                            delete target[name + '_asArray'];\n                        }\n                    }\n                }\n\n                // Perform any add/replace operations now, technically RFC5261 only allows a single element to take the\n                // place of a replaced element while the add case allows an arbitrary number of children.\n                // Due to the both operations requiring the same insertion logic they have been combined here and we will\n                // not enforce single child operations for replace, assertions should be made at patch parse time if necessary\n                if (operation.action === 'add' || operation.action === 'replace') {\n                    // value will be an object with element name keys pointing to arrays of objects\n                    Object.keys(operation.value).forEach((insert) => {\n                        let insertNodes = operation.value[insert];\n\n                        let updatedNodes = target[insert + '_asArray'] || [];\n                        if (updatedNodes.length === 0 && target[insert]) {\n                            updatedNodes.push(target[insert]);\n                        }\n\n                        if (updatedNodes.length === 0) {\n                            // no original nodes for this element type\n                            updatedNodes = insertNodes;\n                        } else {\n                            // compute the position we need to insert at, default to end of set\n                            let position = updatedNodes.length;\n                            if (insert == name && relativePosition != -1) {\n                                // if the inserted element matches the operation target (not leaf) and there is a relative position we\n                                // want the inserted position to be set such that our insertion is relative to original position\n                                // since replace has modified the array length we reduce the insert point by 1\n                                position = relativePosition + (insertBefore ? 0 : 1) + (operation.action == 'replace' ? -1 : 0);\n                            } else {\n                                // otherwise we are in an add append/prepend case or replace case that removed the target name completely\n                                position = insertBefore ? 0 : updatedNodes.length;\n                            }\n\n                            // we dont have to perform element removal for the replace case as that was done above\n                            updatedNodes.splice.apply(updatedNodes, [position, 0].concat(insertNodes));\n                        }\n\n                        // now we properly reset the element keys on the target to match parsing semantics\n                        target[insert + '_asArray'] = updatedNodes;\n                        target[insert] = updatedNodes.length == 1 ? updatedNodes[0] : updatedNodes;\n                    });\n                }\n            });\n    }\n\n    // #endregion PUBLIC FUNCTIONS\n\n    // #region PRIVATE FUNCTIONS\n    // --------------------------------------------------\n    function getManifest(externalManifest) {\n        return externalManifest ? externalManifest : voPeriods.length > 0 ? voPeriods[0].mpd.manifest : null;\n    }\n\n    function getAdaptationForMediaInfo(mediaInfo) {\n        if (!mediaInfo || !mediaInfo.streamInfo || mediaInfo.streamInfo.id === undefined || !voAdaptations[mediaInfo.streamInfo.id]) return null;\n        return voAdaptations[mediaInfo.streamInfo.id][mediaInfo.index];\n    }\n\n    function getPeriodForStreamInfo(streamInfo, voPeriodsArray) {\n        const ln = voPeriodsArray.length;\n\n        for (let i = 0; i < ln; i++) {\n            let voPeriod = voPeriodsArray[i];\n\n            if (streamInfo && streamInfo.id === voPeriod.id) return voPeriod;\n        }\n\n        return null;\n    }\n\n    function convertAdaptationToMediaInfo(adaptation) {\n        if (!adaptation) {\n            return null;\n        }\n\n        let mediaInfo = new MediaInfo();\n        const realAdaptation = adaptation.period.mpd.manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index];\n        let viewpoint;\n\n        mediaInfo.id = adaptation.id;\n        mediaInfo.index = adaptation.index;\n        mediaInfo.type = adaptation.type;\n        mediaInfo.streamInfo = convertPeriodToStreamInfo(adaptation.period);\n        mediaInfo.representationCount = dashManifestModel.getRepresentationCount(realAdaptation);\n        mediaInfo.labels = dashManifestModel.getLabelsForAdaptation(realAdaptation);\n        mediaInfo.lang = dashManifestModel.getLanguageForAdaptation(realAdaptation);\n        viewpoint = dashManifestModel.getViewpointForAdaptation(realAdaptation);\n        mediaInfo.viewpoint = viewpoint ? viewpoint.value : undefined;\n        mediaInfo.accessibility = dashManifestModel.getAccessibilityForAdaptation(realAdaptation).map(function (accessibility) {\n            let accessibilityValue = accessibility.value;\n            let accessibilityData = accessibilityValue;\n            if (accessibility.schemeIdUri && (accessibility.schemeIdUri.search('cea-608') >= 0) && typeof (cea608parser) !== 'undefined') {\n                if (accessibilityValue) {\n                    accessibilityData = 'cea-608:' + accessibilityValue;\n                } else {\n                    accessibilityData = 'cea-608';\n                }\n                mediaInfo.embeddedCaptions = true;\n            }\n            return accessibilityData;\n        });\n\n        mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForAdaptation(realAdaptation).map(function (audioChannelConfiguration) {\n            return audioChannelConfiguration.value;\n        });\n\n        if (mediaInfo.audioChannelConfiguration.length === 0 && Array.isArray(realAdaptation.Representation_asArray) && realAdaptation.Representation_asArray.length > 0) {\n            mediaInfo.audioChannelConfiguration = dashManifestModel.getAudioChannelConfigurationForRepresentation(realAdaptation.Representation_asArray[0]).map(function (audioChannelConfiguration) {\n                return audioChannelConfiguration.value;\n            });\n        }\n        mediaInfo.roles = dashManifestModel.getRolesForAdaptation(realAdaptation).map(function (role) {\n            return role.value;\n        });\n        mediaInfo.codec = dashManifestModel.getCodec(realAdaptation);\n        mediaInfo.mimeType = dashManifestModel.getMimeType(realAdaptation);\n        mediaInfo.contentProtection = dashManifestModel.getContentProtectionData(realAdaptation);\n        mediaInfo.bitrateList = dashManifestModel.getBitrateListForAdaptation(realAdaptation);\n\n        if (mediaInfo.contentProtection) {\n            mediaInfo.contentProtection.forEach(function (item) {\n                item.KID = dashManifestModel.getKID(item);\n            });\n        }\n\n        mediaInfo.isText = dashManifestModel.getIsTextTrack(mediaInfo.mimeType);\n        mediaInfo.supplementalProperties = dashManifestModel.getSupplementalPropperties(realAdaptation);\n\n        return mediaInfo;\n    }\n\n    function convertVideoInfoToEmbeddedTextInfo(mediaInfo, channel, lang) {\n        mediaInfo.id = channel; // CC1, CC2, CC3, or CC4\n        mediaInfo.index = 100 + parseInt(channel.substring(2, 3));\n        mediaInfo.type = constants.EMBEDDED_TEXT;\n        mediaInfo.codec = 'cea-608-in-SEI';\n        mediaInfo.isText = true;\n        mediaInfo.isEmbedded = true;\n        mediaInfo.lang = lang;\n        mediaInfo.roles = ['caption'];\n    }\n\n    function convertVideoInfoToThumbnailInfo(mediaInfo) {\n        mediaInfo.type = constants.IMAGE;\n    }\n\n    function convertPeriodToStreamInfo(period) {\n        let streamInfo = new StreamInfo();\n        const THRESHOLD = 1;\n\n        streamInfo.id = period.id;\n        streamInfo.index = period.index;\n        streamInfo.start = period.start;\n        streamInfo.duration = period.duration;\n        streamInfo.manifestInfo = convertMpdToManifestInfo(period.mpd);\n        streamInfo.isLast = period.mpd.manifest.Period_asArray.length === 1 || Math.abs((streamInfo.start + streamInfo.duration) - streamInfo.manifestInfo.duration) < THRESHOLD;\n\n        return streamInfo;\n    }\n\n    function convertMpdToManifestInfo(mpd) {\n        let manifestInfo = new ManifestInfo();\n\n        manifestInfo.DVRWindowSize = mpd.timeShiftBufferDepth;\n        manifestInfo.loadedTime = mpd.manifest.loadedTime;\n        manifestInfo.availableFrom = mpd.availabilityStartTime;\n        manifestInfo.minBufferTime = mpd.manifest.minBufferTime;\n        manifestInfo.maxFragmentDuration = mpd.maxSegmentDuration;\n        manifestInfo.duration = dashManifestModel.getDuration(mpd.manifest);\n        manifestInfo.isDynamic = dashManifestModel.getIsDynamic(mpd.manifest);\n        manifestInfo.serviceDescriptions = dashManifestModel.getServiceDescriptions(mpd.manifest);\n        manifestInfo.protocol = mpd.manifest.protocol;\n\n        return manifestInfo;\n    }\n\n    function checkConfig() {\n        if (!constants) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function getPeriod(periodIdx) {\n        return voPeriods.length > 0 ? voPeriods[0].mpd.manifest.Period_asArray[periodIdx] : null;\n    }\n\n    function findRepresentationIndex(period, representationId) {\n        const index = findRepresentation(period, representationId, true);\n\n        return index !== null ? index : -1;\n    }\n\n    function findRepresentation(period, representationId, returnIndex) {\n        let adaptationSet,\n            adaptationSetArray,\n            representation,\n            representationArray,\n            adaptationSetArrayIndex,\n            representationArrayIndex;\n\n        if (period) {\n            adaptationSetArray = period.AdaptationSet_asArray;\n            for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                representationArray = adaptationSet.Representation_asArray;\n                for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n                    representation = representationArray[representationArrayIndex];\n                    if (representationId === representation.id) {\n                        if (returnIndex) {\n                            return representationArrayIndex;\n                        } else {\n                            return representation;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    function findMaxBufferIndex(period, bufferType) {\n        let adaptationSet,\n            adaptationSetArray,\n            representationArray,\n            adaptationSetArrayIndex;\n\n        if (!period || !bufferType) return -1;\n\n        adaptationSetArray = period.AdaptationSet_asArray;\n        for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n            adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n            representationArray = adaptationSet.Representation_asArray;\n            if (dashManifestModel.getIsTypeOf(adaptationSet, bufferType)) {\n                return representationArray.length;\n            }\n        }\n\n        return -1;\n    }\n\n    // #endregion PRIVATE FUNCTIONS\n\n    instance = {\n        getBandwidthForRepresentation: getBandwidthForRepresentation,\n        getIndexForRepresentation: getIndexForRepresentation,\n        getMaxIndexForBufferType: getMaxIndexForBufferType,\n        convertDataToRepresentationInfo: convertRepresentationToRepresentationInfo,\n        getDataForMedia: getAdaptationForMediaInfo,\n        getStreamsInfo: getStreamsInfo,\n        getMediaInfoForType: getMediaInfoForType,\n        getAllMediaInfoForType: getAllMediaInfoForType,\n        getAdaptationForType: getAdaptationForType,\n        getRealAdaptation: getRealAdaptation,\n        getRealPeriodByIndex,\n        getEssentialPropertiesForRepresentation,\n        getVoRepresentations: getVoRepresentations,\n        getEventsFor: getEventsFor,\n        getEvent: getEvent,\n        getMpd,\n        setConfig: setConfig,\n        updatePeriods: updatePeriods,\n        getIsTextTrack: getIsTextTrack,\n        getUTCTimingSources: getUTCTimingSources,\n        getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n        getAvailabilityStartTime: getAvailabilityStartTime,\n        getIsTypeOf,\n        getIsDynamic: getIsDynamic,\n        getDuration: getDuration,\n        getRegularPeriods: getRegularPeriods,\n        getLocation: getLocation,\n        getPatchLocation: getPatchLocation,\n        getManifestUpdatePeriod: getManifestUpdatePeriod,\n        getPublishTime,\n        getIsDVB: getIsDVB,\n        getIsPatch: getIsPatch,\n        getBaseURLsFromElement: getBaseURLsFromElement,\n        getRepresentationSortFunction: getRepresentationSortFunction,\n        getCodec: getCodec,\n        getVoAdaptations: getVoAdaptations,\n        getVoPeriods: getVoPeriods,\n        getPeriodById,\n        setCurrentMediaInfo: setCurrentMediaInfo,\n        isPatchValid: isPatchValid,\n        applyPatchToManifest: applyPatchToManifest,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nDashAdapter.__dashjs_factory_name = 'DashAdapter';\nexport default FactoryMaker.getSingletonFactory(DashAdapter);\n"]},"metadata":{},"sourceType":"script"}