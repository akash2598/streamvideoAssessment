{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Segment = require('./vo/Segment');\n\nvar _Segment2 = _interopRequireDefault(_Segment);\n\nvar _DashJSError = require('../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _FragmentRequest = require('../streaming/vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _URLLoader = require('../streaming/net/URLLoader');\n\nvar _URLLoader2 = _interopRequireDefault(_URLLoader);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction SegmentBaseLoader() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      errHandler = void 0,\n      boxParser = void 0,\n      requestModifier = void 0,\n      dashMetrics = void 0,\n      settings = void 0,\n      mediaPlayerModel = void 0,\n      urlLoader = void 0,\n      events = void 0,\n      eventBus = void 0,\n      errors = void 0,\n      constants = void 0,\n      dashConstants = void 0,\n      urlUtils = void 0,\n      baseURLController = void 0;\n\n  function setup() {}\n\n  function initialize() {\n    urlLoader = (0, _URLLoader2.default)(context).create({\n      errHandler: errHandler,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      requestModifier: requestModifier,\n      useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n      boxParser: boxParser,\n      errors: errors,\n      urlUtils: urlUtils,\n      constants: constants,\n      dashConstants: dashConstants\n    });\n  }\n\n  function setConfig(config) {\n    if (config.baseURLController) {\n      baseURLController = config.baseURLController;\n    }\n\n    if (config.dashMetrics) {\n      dashMetrics = config.dashMetrics;\n    }\n\n    if (config.mediaPlayerModel) {\n      mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n\n    if (config.boxParser) {\n      boxParser = config.boxParser;\n    }\n\n    if (config.events) {\n      events = config.events;\n    }\n\n    if (config.eventBus) {\n      eventBus = config.eventBus;\n    }\n\n    if (config.debug) {\n      logger = config.debug.getLogger(instance);\n    }\n\n    if (config.requestModifier) {\n      requestModifier = config.requestModifier;\n    }\n\n    if (config.errors) {\n      errors = config.errors;\n    }\n\n    if (config.urlUtils) {\n      urlUtils = config.urlUtils;\n    }\n\n    if (config.constants) {\n      constants = config.constants;\n    }\n\n    if (config.dashConstants) {\n      dashConstants = config.dashConstants;\n    }\n  }\n\n  function checkConfig() {\n    if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n\n  function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n    checkConfig();\n    var initRange = null;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var info = loadingInfo || {\n      init: true,\n      url: baseUrl ? baseUrl.url : undefined,\n      range: {\n        start: 0,\n        end: 1500\n      },\n      searching: false,\n      bytesLoaded: 0,\n      bytesToLoad: 1500,\n      mediaType: mediaType\n    };\n    logger.debug('Start searching for initialization.');\n    var request = getFragmentRequest(info);\n\n    var onload = function onload(response) {\n      info.bytesLoaded = info.range.end;\n      initRange = boxParser.findInitRange(response);\n\n      if (initRange) {\n        representation.range = initRange; // note that we don't explicitly set rep.initialization as this\n        // will be computed when all BaseURLs are resolved later\n\n        eventBus.trigger(events.INITIALIZATION_LOADED, {\n          representation: representation\n        }, {\n          streamId: streamId,\n          mediaType: mediaType\n        });\n      } else {\n        info.range.end = info.bytesLoaded + info.bytesToLoad;\n        loadInitialization(streamId, mediaType, representation, info);\n      }\n    };\n\n    var onerror = function onerror() {\n      eventBus.trigger(events.INITIALIZATION_LOADED, {\n        representation: representation\n      }, {\n        streamId: streamId,\n        mediaType: mediaType\n      });\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onerror\n    });\n    logger.debug('Perform init search: ' + info.url);\n  }\n\n  function loadSegments(streamId, mediaType, representation, range, callback, loadingInfo) {\n    checkConfig();\n\n    if (range && (range.start === undefined || range.end === undefined)) {\n      var parts = range ? range.toString().split('-') : null;\n      range = parts ? {\n        start: parseFloat(parts[0]),\n        end: parseFloat(parts[1])\n      } : null;\n    }\n\n    callback = !callback ? onLoaded : callback;\n    var isoFile = null;\n    var sidx = null;\n    var hasRange = !!range;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var info = {\n      init: false,\n      url: baseUrl ? baseUrl.url : undefined,\n      range: hasRange ? range : {\n        start: 0,\n        end: 1500\n      },\n      searching: !hasRange,\n      bytesLoaded: loadingInfo ? loadingInfo.bytesLoaded : 0,\n      bytesToLoad: 1500,\n      mediaType: mediaType\n    };\n    var request = getFragmentRequest(info);\n\n    var onload = function onload(response) {\n      var extraBytes = info.bytesToLoad;\n      var loadedLength = response.byteLength;\n      info.bytesLoaded = info.range.end - info.range.start;\n      isoFile = boxParser.parse(response);\n      sidx = isoFile.getBox('sidx');\n\n      if (!sidx || !sidx.isComplete) {\n        if (sidx) {\n          info.range.start = sidx.offset || info.range.start;\n          info.range.end = info.range.start + (sidx.size || extraBytes);\n        } else if (loadedLength < info.bytesLoaded) {\n          // if we have reached a search limit or if we have reached the end of the file we have to stop trying to find sidx\n          callback(streamId, mediaType, null, representation);\n          return;\n        } else {\n          var lastBox = isoFile.getLastBox();\n\n          if (lastBox && lastBox.size) {\n            info.range.start = lastBox.offset + lastBox.size;\n            info.range.end = info.range.start + extraBytes;\n          } else {\n            info.range.end += extraBytes;\n          }\n        }\n\n        loadSegments(streamId, mediaType, representation, info.range, callback, info);\n      } else {\n        var ref = sidx.references;\n        var loadMultiSidx = void 0,\n            segments = void 0;\n\n        if (ref !== null && ref !== undefined && ref.length > 0) {\n          loadMultiSidx = ref[0].reference_type === 1;\n        }\n\n        if (loadMultiSidx) {\n          logger.debug('Initiate multiple SIDX load.');\n          info.range.end = info.range.start + sidx.size;\n          var j = void 0,\n              len = void 0,\n              ss = void 0,\n              se = void 0,\n              r = void 0;\n          var segs = [];\n          var count = 0;\n          var offset = (sidx.offset || info.range.start) + sidx.size;\n\n          var tmpCallback = function tmpCallback(streamId, mediaType, result) {\n            if (result) {\n              segs = segs.concat(result);\n              count++;\n\n              if (count >= len) {\n                // http requests can be processed in a wrong order, so, we have to reorder segments with an ascending start Time order\n                segs.sort(function (a, b) {\n                  return a.startTime - b.startTime < 0 ? -1 : 0;\n                });\n                callback(streamId, mediaType, segs, representation);\n              }\n            } else {\n              callback(streamId, mediaType, null, representation);\n            }\n          };\n\n          for (j = 0, len = ref.length; j < len; j++) {\n            ss = offset;\n            se = offset + ref[j].referenced_size - 1;\n            offset = offset + ref[j].referenced_size;\n            r = {\n              start: ss,\n              end: se\n            };\n            loadSegments(streamId, mediaType, representation, r, tmpCallback, info);\n          }\n        } else {\n          logger.debug('Parsing segments from SIDX. representation ' + mediaType + ' - id: ' + representation.id + ' for range : ' + info.range.start + ' - ' + info.range.end);\n          segments = getSegmentsForSidx(sidx, info);\n          callback(streamId, mediaType, segments, representation);\n        }\n      }\n    };\n\n    var onerror = function onerror() {\n      callback(streamId, mediaType, null, representation);\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onerror\n    });\n    logger.debug('Perform SIDX load: ' + info.url + ' with range : ' + info.range.start + ' - ' + info.range.end);\n  }\n\n  function reset() {\n    urlLoader.abort();\n    urlLoader = null;\n    errHandler = null;\n    boxParser = null;\n    requestModifier = null;\n  }\n\n  function getSegmentsForSidx(sidx, info) {\n    var refs = sidx.references;\n    var len = refs.length;\n    var timescale = sidx.timescale;\n    var time = sidx.earliest_presentation_time;\n    var start = info.range.start + sidx.offset + sidx.first_offset + sidx.size;\n    var segments = [];\n    var segment = void 0,\n        end = void 0,\n        duration = void 0,\n        size = void 0;\n\n    for (var i = 0; i < len; i++) {\n      duration = refs[i].subsegment_duration;\n      size = refs[i].referenced_size;\n      segment = new _Segment2.default(); // note that we don't explicitly set segment.media as this will be\n      // computed when all BaseURLs are resolved later\n\n      segment.duration = duration;\n      segment.startTime = time;\n      segment.timescale = timescale;\n      end = start + size - 1;\n      segment.mediaRange = start + '-' + end;\n      segments.push(segment);\n      time += duration;\n      start += size;\n    }\n\n    return segments;\n  }\n\n  function getFragmentRequest(info) {\n    if (!info.url) {\n      return;\n    }\n\n    var request = new _FragmentRequest2.default();\n    request.setInfo(info);\n    return request;\n  }\n\n  function onLoaded(streamId, mediaType, segments, representation) {\n    eventBus.trigger(events.SEGMENTS_LOADED, {\n      segments: segments,\n      representation: representation,\n      error: segments ? undefined : new _DashJSError2.default(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n    }, {\n      streamId: streamId,\n      mediaType: mediaType\n    });\n  }\n\n  instance = {\n    setConfig: setConfig,\n    initialize: initialize,\n    loadInitialization: loadInitialization,\n    loadSegments: loadSegments,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nSegmentBaseLoader.__dashjs_factory_name = 'SegmentBaseLoader';\nexports.default = _FactoryMaker2.default.getSingletonFactory(SegmentBaseLoader);","map":{"version":3,"sources":["../../../../src/dash/SegmentBaseLoader.js"],"names":["context","instance","logger","errHandler","boxParser","requestModifier","dashMetrics","settings","mediaPlayerModel","urlLoader","events","eventBus","errors","constants","dashConstants","urlUtils","baseURLController","useFetch","config","checkConfig","initRange","baseUrl","representation","info","loadingInfo","init","url","range","start","end","searching","bytesLoaded","bytesToLoad","mediaType","request","getFragmentRequest","onload","streamId","loadInitialization","onerror","success","error","parts","parseFloat","callback","isoFile","sidx","hasRange","extraBytes","loadedLength","response","lastBox","loadSegments","ref","loadMultiSidx","segments","j","len","ss","se","r","segs","count","offset","tmpCallback","a","b","getSegmentsForSidx","refs","timescale","time","segment","duration","size","i","Segment","FragmentRequest","DashJSError","setConfig","initialize","reset","setup","SegmentBaseLoader","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Segment from './vo/Segment';\nimport DashJSError from '../streaming/vo/DashJSError';\nimport FactoryMaker from '../core/FactoryMaker';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport URLLoader from '../streaming/net/URLLoader';\n\nfunction SegmentBaseLoader() {\n\n    const context = this.context;\n\n    let instance,\n        logger,\n        errHandler,\n        boxParser,\n        requestModifier,\n        dashMetrics,\n        settings,\n        mediaPlayerModel,\n        urlLoader,\n        events,\n        eventBus,\n        errors,\n        constants,\n        dashConstants,\n        urlUtils,\n        baseURLController;\n\n    function setup() {\n    }\n\n    function initialize() {\n        urlLoader = URLLoader(context).create({\n            errHandler: errHandler,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            requestModifier: requestModifier,\n            useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n            boxParser: boxParser,\n            errors: errors,\n            urlUtils: urlUtils,\n            constants: constants,\n            dashConstants: dashConstants\n        });\n    }\n\n    function setConfig(config) {\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n\n        if (config.settings) {\n            settings = config.settings;\n        }\n\n        if (config.boxParser) {\n            boxParser = config.boxParser;\n        }\n\n        if (config.events) {\n            events = config.events;\n        }\n\n        if (config.eventBus) {\n            eventBus = config.eventBus;\n        }\n\n        if (config.debug) {\n            logger = config.debug.getLogger(instance);\n        }\n\n        if (config.requestModifier) {\n            requestModifier = config.requestModifier;\n        }\n\n        if (config.errors) {\n            errors = config.errors;\n        }\n\n        if (config.urlUtils) {\n            urlUtils = config.urlUtils;\n        }\n\n        if (config.constants) {\n            constants = config.constants;\n        }\n\n        if (config.dashConstants) {\n            dashConstants = config.dashConstants;\n        }\n    }\n\n    function checkConfig() {\n        if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n        checkConfig();\n        let initRange = null;\n        const baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        const info = loadingInfo || {\n            init: true,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: {\n                start: 0,\n                end: 1500\n            },\n            searching: false,\n            bytesLoaded: 0,\n            bytesToLoad: 1500,\n            mediaType: mediaType\n        };\n\n        logger.debug('Start searching for initialization.');\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            info.bytesLoaded = info.range.end;\n            initRange = boxParser.findInitRange(response);\n\n            if (initRange) {\n                representation.range = initRange;\n                // note that we don't explicitly set rep.initialization as this\n                // will be computed when all BaseURLs are resolved later\n                eventBus.trigger(events.INITIALIZATION_LOADED,\n                    { representation: representation },\n                    { streamId: streamId, mediaType: mediaType }\n                );\n            } else {\n                info.range.end = info.bytesLoaded + info.bytesToLoad;\n                loadInitialization(streamId, mediaType, representation, info);\n            }\n        };\n\n        const onerror = function () {\n            eventBus.trigger(events.INITIALIZATION_LOADED,\n                { representation: representation },\n                { streamId: streamId, mediaType: mediaType }\n            );\n        };\n\n        urlLoader.load({request: request, success: onload, error: onerror});\n\n        logger.debug('Perform init search: ' + info.url);\n    }\n\n    function loadSegments(streamId, mediaType, representation, range, callback, loadingInfo) {\n        checkConfig();\n        if (range && (range.start === undefined || range.end === undefined)) {\n            const parts = range ? range.toString().split('-') : null;\n            range = parts ? {start: parseFloat(parts[0]), end: parseFloat(parts[1])} : null;\n        }\n\n        callback = !callback ? onLoaded : callback;\n        let isoFile = null;\n        let sidx = null;\n        const hasRange = !!range;\n        const baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        const info = {\n            init: false,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: hasRange ? range : { start: 0, end: 1500 },\n            searching: !hasRange,\n            bytesLoaded: loadingInfo ? loadingInfo.bytesLoaded : 0,\n            bytesToLoad: 1500,\n            mediaType: mediaType\n        };\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            const extraBytes = info.bytesToLoad;\n            const loadedLength = response.byteLength;\n\n            info.bytesLoaded = info.range.end - info.range.start;\n            isoFile = boxParser.parse(response);\n            sidx = isoFile.getBox('sidx');\n\n            if (!sidx || !sidx.isComplete) {\n                if (sidx) {\n                    info.range.start = sidx.offset || info.range.start;\n                    info.range.end = info.range.start + (sidx.size || extraBytes);\n                } else if (loadedLength < info.bytesLoaded) {\n                    // if we have reached a search limit or if we have reached the end of the file we have to stop trying to find sidx\n                    callback(streamId, mediaType, null, representation);\n                    return;\n                } else {\n                    const lastBox = isoFile.getLastBox();\n\n                    if (lastBox && lastBox.size) {\n                        info.range.start = lastBox.offset + lastBox.size;\n                        info.range.end = info.range.start + extraBytes;\n                    } else {\n                        info.range.end += extraBytes;\n                    }\n                }\n                loadSegments(streamId, mediaType, representation, info.range, callback, info);\n            } else {\n                const ref = sidx.references;\n                let loadMultiSidx,\n                    segments;\n\n                if (ref !== null && ref !== undefined && ref.length > 0) {\n                    loadMultiSidx = (ref[0].reference_type === 1);\n                }\n\n                if (loadMultiSidx) {\n                    logger.debug('Initiate multiple SIDX load.');\n                    info.range.end = info.range.start + sidx.size;\n\n                    let j, len, ss, se, r;\n                    let segs = [];\n                    let count = 0;\n                    let offset = (sidx.offset || info.range.start) + sidx.size;\n                    const tmpCallback = function (streamId, mediaType, result) {\n                        if (result) {\n                            segs = segs.concat(result);\n                            count++;\n\n                            if (count >= len) {\n                                // http requests can be processed in a wrong order, so, we have to reorder segments with an ascending start Time order\n                                segs.sort(function (a, b) {\n                                    return a.startTime - b.startTime < 0 ? -1 : 0;\n                                });\n                                callback(streamId, mediaType, segs, representation);\n                            }\n                        } else {\n                            callback(streamId, mediaType, null, representation);\n                        }\n                    };\n\n                    for (j = 0, len = ref.length; j < len; j++) {\n                        ss = offset;\n                        se = offset + ref[j].referenced_size - 1;\n                        offset = offset + ref[j].referenced_size;\n                        r = {start: ss, end: se};\n                        loadSegments(streamId, mediaType, representation, r, tmpCallback, info);\n                    }\n\n                } else {\n                    logger.debug('Parsing segments from SIDX. representation ' + mediaType + ' - id: ' + representation.id + ' for range : ' + info.range.start + ' - ' + info.range.end);\n                    segments = getSegmentsForSidx(sidx, info);\n                    callback(streamId, mediaType, segments, representation);\n                }\n            }\n        };\n\n        const onerror = function () {\n            callback(streamId, mediaType, null, representation);\n        };\n\n        urlLoader.load({request: request, success: onload, error: onerror});\n        logger.debug('Perform SIDX load: ' + info.url + ' with range : ' + info.range.start + ' - ' + info.range.end);\n    }\n\n    function reset() {\n        urlLoader.abort();\n        urlLoader = null;\n        errHandler = null;\n        boxParser = null;\n        requestModifier = null;\n    }\n\n    function getSegmentsForSidx(sidx, info) {\n        const refs = sidx.references;\n        const len = refs.length;\n        const timescale = sidx.timescale;\n        let time = sidx.earliest_presentation_time;\n        let start = info.range.start + sidx.offset + sidx.first_offset + sidx.size;\n        const segments = [];\n        let segment,\n            end,\n            duration,\n            size;\n\n        for (let i = 0; i < len; i++) {\n            duration = refs[i].subsegment_duration;\n            size = refs[i].referenced_size;\n\n            segment = new Segment();\n            // note that we don't explicitly set segment.media as this will be\n            // computed when all BaseURLs are resolved later\n            segment.duration = duration;\n            segment.startTime = time;\n            segment.timescale = timescale;\n            end = start + size - 1;\n            segment.mediaRange = start + '-' + end;\n            segments.push(segment);\n            time += duration;\n            start += size;\n        }\n\n        return segments;\n    }\n\n    function getFragmentRequest(info) {\n        if (!info.url) {\n            return;\n        }\n        const request = new FragmentRequest();\n        request.setInfo(info);\n        return request;\n    }\n\n    function onLoaded(streamId, mediaType, segments, representation) {\n        eventBus.trigger(events.SEGMENTS_LOADED,\n            {\n                segments: segments,\n                representation: representation,\n                error: segments ? undefined : new DashJSError(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n            },\n            { streamId: streamId, mediaType: mediaType }\n        );\n    }\n\n    instance = {\n        setConfig: setConfig,\n        initialize: initialize,\n        loadInitialization: loadInitialization,\n        loadSegments: loadSegments,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nSegmentBaseLoader.__dashjs_factory_name = 'SegmentBaseLoader';\nexport default FactoryMaker.getSingletonFactory(SegmentBaseLoader);\n"]},"metadata":{},"sourceType":"script"}