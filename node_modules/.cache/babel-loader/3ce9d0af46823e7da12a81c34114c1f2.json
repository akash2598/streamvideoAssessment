{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _IsoFile = require('./IsoFile');\n\nvar _IsoFile2 = _interopRequireDefault(_IsoFile);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _codemIsoboxer = require('codem-isoboxer');\n\nvar _codemIsoboxer2 = _interopRequireDefault(_codemIsoboxer);\n\nvar _IsoBoxSearchInfo = require('../vo/IsoBoxSearchInfo');\n\nvar _IsoBoxSearchInfo2 = _interopRequireDefault(_IsoBoxSearchInfo);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction BoxParser()\n/*config*/\n{\n  var logger = void 0,\n      instance = void 0;\n  var context = this.context;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n  /**\n  * @param {ArrayBuffer} data\n  * @returns {IsoFile|null}\n  * @memberof BoxParser#\n  */\n\n\n  function parse(data) {\n    if (!data) return null;\n\n    if (data.fileStart === undefined) {\n      data.fileStart = 0;\n    }\n\n    var parsedFile = _codemIsoboxer2.default.parseBuffer(data);\n\n    var dashIsoFile = (0, _IsoFile2.default)(context).create();\n    dashIsoFile.setData(parsedFile);\n    return dashIsoFile;\n  }\n  /**\n  * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\n  * method only looks into the list of top boxes and doesn't analyze nested boxes.\n  * @param {string[]} types\n  * @param {ArrayBuffer|uint8Array} buffer\n  * @param {number} offset\n  * @returns {IsoBoxSearchInfo}\n  * @memberof BoxParser#\n  */\n\n\n  function findLastTopIsoBoxCompleted(types, buffer, offset) {\n    if (offset === undefined) {\n      offset = 0;\n    } // 8 = size (uint32) + type (4 characters)\n\n\n    if (!buffer || offset + 8 >= buffer.byteLength) {\n      return new _IsoBoxSearchInfo2.default(0, false);\n    }\n\n    var data = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;\n    var boxInfo = void 0;\n    var lastCompletedOffset = 0;\n\n    while (offset < data.byteLength) {\n      var boxSize = parseUint32(data, offset);\n      var boxType = parseIsoBoxType(data, offset + 4);\n\n      if (boxSize === 0) {\n        break;\n      }\n\n      if (offset + boxSize <= data.byteLength) {\n        if (types.indexOf(boxType) >= 0) {\n          boxInfo = new _IsoBoxSearchInfo2.default(offset, true, boxSize);\n        } else {\n          lastCompletedOffset = offset + boxSize;\n        }\n      }\n\n      offset += boxSize;\n    }\n\n    if (!boxInfo) {\n      return new _IsoBoxSearchInfo2.default(lastCompletedOffset, false);\n    }\n\n    return boxInfo;\n  }\n\n  function getSamplesInfo(ab) {\n    if (!ab || ab.byteLength === 0) {\n      return {\n        sampleList: [],\n        lastSequenceNumber: NaN,\n        totalDuration: NaN,\n        numSequences: NaN\n      };\n    }\n\n    var isoFile = parse(ab); // zero or more moofs\n\n    var moofBoxes = isoFile.getBoxes('moof'); // exactly one mfhd per moof\n\n    var mfhdBoxes = isoFile.getBoxes('mfhd');\n    var sampleDuration = void 0,\n        sampleCompositionTimeOffset = void 0,\n        sampleCount = void 0,\n        sampleSize = void 0,\n        sampleDts = void 0,\n        sampleList = void 0,\n        sample = void 0,\n        i = void 0,\n        j = void 0,\n        k = void 0,\n        l = void 0,\n        m = void 0,\n        n = void 0,\n        dataOffset = void 0,\n        lastSequenceNumber = void 0,\n        numSequences = void 0,\n        totalDuration = void 0;\n    numSequences = isoFile.getBoxes('moof').length;\n    lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\n    sampleCount = 0;\n    sampleList = [];\n    var subsIndex = -1;\n    var nextSubsSample = -1;\n\n    for (l = 0; l < moofBoxes.length; l++) {\n      var moofBox = moofBoxes[l]; // zero or more trafs per moof\n\n      var trafBoxes = moofBox.getChildBoxes('traf');\n\n      for (j = 0; j < trafBoxes.length; j++) {\n        var trafBox = trafBoxes[j]; // exactly one tfhd per traf\n\n        var tfhdBox = trafBox.getChildBox('tfhd'); // zero or one tfdt per traf\n\n        var tfdtBox = trafBox.getChildBox('tfdt');\n        sampleDts = tfdtBox.baseMediaDecodeTime; // zero or more truns per traf\n\n        var trunBoxes = trafBox.getChildBoxes('trun'); // zero or more subs per traf\n\n        var subsBoxes = trafBox.getChildBoxes('subs');\n\n        for (k = 0; k < trunBoxes.length; k++) {\n          var trunBox = trunBoxes[k];\n          sampleCount = trunBox.sample_count;\n          dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\n\n          for (i = 0; i < sampleCount; i++) {\n            sample = trunBox.samples[i];\n            sampleDuration = sample.sample_duration !== undefined ? sample.sample_duration : tfhdBox.default_sample_duration;\n            sampleSize = sample.sample_size !== undefined ? sample.sample_size : tfhdBox.default_sample_size;\n            sampleCompositionTimeOffset = sample.sample_composition_time_offset !== undefined ? sample.sample_composition_time_offset : 0;\n            var sampleData = {\n              'dts': sampleDts,\n              'cts': sampleDts + sampleCompositionTimeOffset,\n              'duration': sampleDuration,\n              'offset': moofBox.offset + dataOffset,\n              'size': sampleSize,\n              'subSizes': [sampleSize]\n            };\n\n            if (subsBoxes) {\n              for (m = 0; m < subsBoxes.length; m++) {\n                var subsBox = subsBoxes[m];\n\n                if (subsIndex < subsBox.entry_count - 1 && i > nextSubsSample) {\n                  subsIndex++;\n                  nextSubsSample += subsBox.entries[subsIndex].sample_delta;\n                }\n\n                if (i == nextSubsSample) {\n                  sampleData.subSizes = [];\n                  var entry = subsBox.entries[subsIndex];\n\n                  for (n = 0; n < entry.subsample_count; n++) {\n                    sampleData.subSizes.push(entry.subsamples[n].subsample_size);\n                  }\n                }\n              }\n            }\n\n            sampleList.push(sampleData);\n            dataOffset += sampleSize;\n            sampleDts += sampleDuration;\n          }\n        }\n\n        totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\n      }\n    }\n\n    return {\n      sampleList: sampleList,\n      lastSequenceNumber: lastSequenceNumber,\n      totalDuration: totalDuration,\n      numSequences: numSequences\n    };\n  }\n\n  function getMediaTimescaleFromMoov(ab) {\n    var isoFile = parse(ab);\n    var mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\n    return mdhdBox ? mdhdBox.timescale : NaN;\n  }\n\n  function parseUint32(data, offset) {\n    return data[offset + 3] >>> 0 | data[offset + 2] << 8 >>> 0 | data[offset + 1] << 16 >>> 0 | data[offset] << 24 >>> 0;\n  }\n\n  function parseIsoBoxType(data, offset) {\n    return String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset++]) + String.fromCharCode(data[offset]);\n  }\n\n  function findInitRange(data) {\n    var initRange = null;\n    var start = void 0,\n        end = void 0;\n    var isoFile = parse(data);\n\n    if (!isoFile) {\n      return initRange;\n    }\n\n    var ftyp = isoFile.getBox('ftyp');\n    var moov = isoFile.getBox('moov');\n    logger.debug('Searching for initialization.');\n\n    if (moov && moov.isComplete) {\n      start = ftyp ? ftyp.offset : moov.offset;\n      end = moov.offset + moov.size - 1;\n      initRange = start + '-' + end;\n      logger.debug('Found the initialization.  Range: ' + initRange);\n    }\n\n    return initRange;\n  }\n  /**\n  * Real-time parsing (whenever data is loaded in the buffer payload) of the payload to capture the moof of a chunk\n  * @param {array} types\n  * @param {ArrayBuffer} buffer\n  * @param {number} offset\n  * @return {IsoBoxSearchInfo}\n  */\n\n\n  function parsePayload(types, buffer, offset) {\n    if (offset === undefined) {\n      offset = 0;\n    }\n\n    if (!buffer || offset + 8 >= buffer.byteLength) {\n      return new _IsoBoxSearchInfo2.default(0, false);\n    }\n\n    var data = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;\n    var boxInfo = void 0;\n    var lastCompletedOffset = 0;\n\n    while (offset < data.byteLength) {\n      var boxSize = parseUint32(data, offset);\n      var boxType = parseIsoBoxType(data, offset + 4);\n\n      if (boxSize === 0) {\n        break;\n      }\n\n      if (offset + boxSize <= data.byteLength) {\n        if (types.indexOf(boxType) >= 0) {\n          boxInfo = new _IsoBoxSearchInfo2.default(offset, true, boxSize, boxType);\n        } else {\n          lastCompletedOffset = offset + boxSize;\n        }\n      }\n\n      offset += boxSize;\n    }\n\n    if (!boxInfo) {\n      return new _IsoBoxSearchInfo2.default(lastCompletedOffset, false);\n    }\n\n    return boxInfo;\n  }\n\n  instance = {\n    parse: parse,\n    findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\n    getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\n    getSamplesInfo: getSamplesInfo,\n    findInitRange: findInitRange,\n    parsePayload: parsePayload\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nBoxParser.__dashjs_factory_name = 'BoxParser';\nexports.default = _FactoryMaker2.default.getSingletonFactory(BoxParser);","map":{"version":3,"sources":["../../../../../src/streaming/utils/BoxParser.js"],"names":["logger","instance","context","data","parsedFile","ISOBoxer","dashIsoFile","offset","buffer","IsoBoxSearchInfo","boxInfo","lastCompletedOffset","boxSize","parseUint32","boxType","parseIsoBoxType","types","ab","sampleList","lastSequenceNumber","totalDuration","numSequences","isoFile","parse","moofBoxes","mfhdBoxes","sampleDuration","sampleCompositionTimeOffset","sampleCount","sampleSize","sampleDts","sample","i","j","k","l","m","n","dataOffset","subsIndex","nextSubsSample","moofBox","trafBoxes","trafBox","tfhdBox","tfdtBox","trunBoxes","subsBoxes","trunBox","sampleData","subsBox","entry","mdhdBox","String","initRange","start","end","ftyp","moov","findLastTopIsoBoxCompleted","getMediaTimescaleFromMoov","getSamplesInfo","findInitRange","parsePayload","setup","BoxParser","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Debug from '../../core/Debug';\nimport IsoFile from './IsoFile';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport ISOBoxer from 'codem-isoboxer';\n\nimport IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo';\n\nfunction BoxParser(/*config*/) {\n\n    let logger,\n        instance;\n    let context = this.context;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     * @returns {IsoFile|null}\n     * @memberof BoxParser#\n     */\n    function parse(data) {\n        if (!data) return null;\n\n        if (data.fileStart === undefined) {\n            data.fileStart = 0;\n        }\n\n        let parsedFile = ISOBoxer.parseBuffer(data);\n        let dashIsoFile = IsoFile(context).create();\n\n        dashIsoFile.setData(parsedFile);\n\n        return dashIsoFile;\n    }\n\n    /**\n     * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\n     * method only looks into the list of top boxes and doesn't analyze nested boxes.\n     * @param {string[]} types\n     * @param {ArrayBuffer|uint8Array} buffer\n     * @param {number} offset\n     * @returns {IsoBoxSearchInfo}\n     * @memberof BoxParser#\n     */\n    function findLastTopIsoBoxCompleted(types, buffer, offset) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n\n        // 8 = size (uint32) + type (4 characters)\n        if (!buffer || offset + 8 >= buffer.byteLength) {\n            return new IsoBoxSearchInfo(0, false);\n        }\n\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\n        let boxInfo;\n        let lastCompletedOffset = 0;\n        while (offset < data.byteLength) {\n            const boxSize = parseUint32(data, offset);\n            const boxType = parseIsoBoxType(data, offset + 4);\n\n            if (boxSize === 0) {\n                break;\n            }\n\n            if (offset + boxSize <= data.byteLength) {\n                if (types.indexOf(boxType) >= 0) {\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize);\n                } else {\n                    lastCompletedOffset = offset + boxSize;\n                }\n            }\n\n            offset += boxSize;\n        }\n\n        if (!boxInfo) {\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\n        }\n\n        return boxInfo;\n    }\n\n    function getSamplesInfo(ab) {\n        if (!ab || ab.byteLength === 0) {\n            return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN};\n        }\n        let isoFile = parse(ab);\n        // zero or more moofs\n        let moofBoxes = isoFile.getBoxes('moof');\n        // exactly one mfhd per moof\n        let mfhdBoxes = isoFile.getBoxes('mfhd');\n\n        let sampleDuration,\n            sampleCompositionTimeOffset,\n            sampleCount,\n            sampleSize,\n            sampleDts,\n            sampleList,\n            sample,\n            i, j, k, l, m, n,\n            dataOffset,\n            lastSequenceNumber,\n            numSequences,\n            totalDuration;\n\n        numSequences = isoFile.getBoxes('moof').length;\n        lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\n        sampleCount = 0;\n\n        sampleList = [];\n        let subsIndex = -1;\n        let nextSubsSample = -1;\n        for (l = 0; l < moofBoxes.length; l++) {\n            let moofBox = moofBoxes[l];\n            // zero or more trafs per moof\n            let trafBoxes = moofBox.getChildBoxes('traf');\n            for (j = 0; j < trafBoxes.length; j++) {\n                let trafBox = trafBoxes[j];\n                // exactly one tfhd per traf\n                let tfhdBox = trafBox.getChildBox('tfhd');\n                // zero or one tfdt per traf\n                let tfdtBox = trafBox.getChildBox('tfdt');\n                sampleDts = tfdtBox.baseMediaDecodeTime;\n                // zero or more truns per traf\n                let trunBoxes = trafBox.getChildBoxes('trun');\n                // zero or more subs per traf\n                let subsBoxes = trafBox.getChildBoxes('subs');\n                for (k = 0; k < trunBoxes.length; k++) {\n                    let trunBox = trunBoxes[k];\n                    sampleCount = trunBox.sample_count;\n                    dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\n\n                    for (i = 0; i < sampleCount; i++) {\n                        sample = trunBox.samples[i];\n                        sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration;\n                        sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size;\n                        sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0;\n                        let sampleData = {\n                            'dts': sampleDts,\n                            'cts': (sampleDts + sampleCompositionTimeOffset),\n                            'duration': sampleDuration,\n                            'offset': moofBox.offset + dataOffset,\n                            'size': sampleSize,\n                            'subSizes': [sampleSize]\n                        };\n                        if (subsBoxes) {\n                            for (m = 0; m < subsBoxes.length; m++) {\n                                let subsBox = subsBoxes[m];\n                                if (subsIndex < (subsBox.entry_count - 1) && i > nextSubsSample) {\n                                    subsIndex++;\n                                    nextSubsSample += subsBox.entries[subsIndex].sample_delta;\n                                }\n                                if (i == nextSubsSample) {\n                                    sampleData.subSizes = [];\n                                    let entry = subsBox.entries[subsIndex];\n                                    for (n = 0; n < entry.subsample_count; n++) {\n                                        sampleData.subSizes.push(entry.subsamples[n].subsample_size);\n                                    }\n                                }\n                            }\n                        }\n                        sampleList.push(sampleData);\n                        dataOffset += sampleSize;\n                        sampleDts += sampleDuration;\n                    }\n                }\n                totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\n            }\n        }\n        return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences};\n    }\n\n    function getMediaTimescaleFromMoov(ab) {\n        let isoFile = parse(ab);\n        let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\n\n        return mdhdBox ? mdhdBox.timescale : NaN;\n    }\n\n    function parseUint32(data, offset) {\n        return data[offset + 3] >>> 0 |\n            (data[offset + 2] << 8) >>> 0 |\n            (data[offset + 1] << 16) >>> 0 |\n            (data[offset] << 24) >>> 0;\n    }\n\n    function parseIsoBoxType(data, offset) {\n        return String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset]);\n    }\n\n    function findInitRange(data) {\n        let initRange = null;\n        let start,\n            end;\n\n        const isoFile = parse(data);\n\n        if (!isoFile) {\n            return initRange;\n        }\n\n        const ftyp = isoFile.getBox('ftyp');\n        const moov = isoFile.getBox('moov');\n\n        logger.debug('Searching for initialization.');\n\n        if (moov && moov.isComplete) {\n            start = ftyp ? ftyp.offset : moov.offset;\n            end = moov.offset + moov.size - 1;\n            initRange = start + '-' + end;\n\n            logger.debug('Found the initialization.  Range: ' + initRange);\n        }\n\n        return initRange;\n    }\n\n    /**\n     * Real-time parsing (whenever data is loaded in the buffer payload) of the payload to capture the moof of a chunk\n     * @param {array} types\n     * @param {ArrayBuffer} buffer\n     * @param {number} offset\n     * @return {IsoBoxSearchInfo}\n     */\n    function parsePayload(types, buffer, offset) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n\n        if (!buffer || offset + 8 >= buffer.byteLength) {\n            return new IsoBoxSearchInfo(0, false);\n        }\n\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\n        let boxInfo;\n        let lastCompletedOffset = 0;\n        while (offset < data.byteLength) {\n            const boxSize = parseUint32(data, offset);\n            const boxType = parseIsoBoxType(data, offset + 4);\n\n            if (boxSize === 0) {\n                break;\n            }\n\n            if (offset + boxSize <= data.byteLength) {\n                if (types.indexOf(boxType) >= 0) {\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize, boxType);\n                } else {\n                    lastCompletedOffset = offset + boxSize;\n                }\n            }\n\n            offset += boxSize;\n        }\n\n        if (!boxInfo) {\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\n        }\n\n        return boxInfo;\n    }\n\n    instance = {\n        parse: parse,\n        findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\n        getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\n        getSamplesInfo: getSamplesInfo,\n        findInitRange: findInitRange,\n        parsePayload: parsePayload\n    };\n\n    setup();\n\n    return instance;\n}\nBoxParser.__dashjs_factory_name = 'BoxParser';\nexport default FactoryMaker.getSingletonFactory(BoxParser);\n"]},"metadata":{},"sourceType":"script"}