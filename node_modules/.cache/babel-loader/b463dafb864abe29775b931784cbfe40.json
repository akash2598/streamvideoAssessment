{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MetricsConstants = require('../../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _SwitchRequest = require('../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _FactoryMaker = require('../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _HTTPRequest = require('../../vo/metrics/HTTPRequest');\n\nvar _EventBus = require('../../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\n\n\nvar BOLA_STATE_ONE_BITRATE = 0;\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2016, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nvar BOLA_STATE_STARTUP = 1;\nvar BOLA_STATE_STEADY = 2;\nvar MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\n\nvar MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2; // E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nvar PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n  config = config || {};\n  var context = this.context;\n  var dashMetrics = config.dashMetrics;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      bolaStateDict = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n    eventBus.on(_Events2.default.BUFFER_EMPTY, onBufferEmpty, instance);\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.on(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.on(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n    eventBus.on(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n  }\n\n  function utilitiesFromBitrates(bitrates) {\n    return bitrates.map(function (b) {\n      return Math.log(b);\n    }); // no need to worry about offset, utilities will be offset (uniformly) anyway later\n  } // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n\n\n  function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n    var highestUtilityIndex = utilities.reduce(function (highestIndex, u, uIndex) {\n      return u > utilities[highestIndex] ? uIndex : highestIndex;\n    }, 0);\n\n    if (highestUtilityIndex === 0) {\n      // if highestUtilityIndex === 0, then always use lowest bitrate\n      return null;\n    }\n\n    var bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length); // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n    // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n    // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n    // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n    // giving:\n\n    var gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n    var Vp = MINIMUM_BUFFER_S / gp; // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n    return {\n      gp: gp,\n      Vp: Vp\n    };\n  }\n\n  function getInitialBolaState(rulesContext) {\n    var initialState = {};\n    var mediaInfo = rulesContext.getMediaInfo();\n    var bitrates = mediaInfo.bitrateList.map(function (b) {\n      return b.bandwidth;\n    });\n    var utilities = utilitiesFromBitrates(bitrates);\n    utilities = utilities.map(function (u) {\n      return u - utilities[0] + 1;\n    }); // normalize\n\n    var stableBufferTime = mediaPlayerModel.getStableBufferTime();\n    var params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n    if (!params) {\n      // only happens when there is only one bitrate level\n      initialState.state = BOLA_STATE_ONE_BITRATE;\n    } else {\n      initialState.state = BOLA_STATE_STARTUP;\n      initialState.bitrates = bitrates;\n      initialState.utilities = utilities;\n      initialState.stableBufferTime = stableBufferTime;\n      initialState.Vp = params.Vp;\n      initialState.gp = params.gp;\n      initialState.lastQuality = 0;\n      clearBolaStateOnSeek(initialState);\n    }\n\n    return initialState;\n  }\n\n  function clearBolaStateOnSeek(bolaState) {\n    bolaState.placeholderBuffer = 0;\n    bolaState.mostAdvancedSegmentStart = NaN;\n    bolaState.lastSegmentWasReplacement = false;\n    bolaState.lastSegmentStart = NaN;\n    bolaState.lastSegmentDurationS = NaN;\n    bolaState.lastSegmentRequestTimeMs = NaN;\n    bolaState.lastSegmentFinishTimeMs = NaN;\n  } // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n\n\n  function checkBolaStateStableBufferTime(bolaState, mediaType) {\n    var stableBufferTime = mediaPlayerModel.getStableBufferTime();\n\n    if (bolaState.stableBufferTime !== stableBufferTime) {\n      var params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n\n      if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n        // correct placeholder buffer using two criteria:\n        // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n        // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n        var effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n        effectiveBufferLevel -= MINIMUM_BUFFER_S;\n        effectiveBufferLevel *= params.Vp / bolaState.Vp;\n        effectiveBufferLevel += MINIMUM_BUFFER_S;\n        bolaState.stableBufferTime = stableBufferTime;\n        bolaState.Vp = params.Vp;\n        bolaState.gp = params.gp;\n        bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n      }\n    }\n  }\n\n  function getBolaState(rulesContext) {\n    var mediaType = rulesContext.getMediaType();\n    var bolaState = bolaStateDict[mediaType];\n\n    if (!bolaState) {\n      bolaState = getInitialBolaState(rulesContext);\n      bolaStateDict[mediaType] = bolaState;\n    } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n      checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    return bolaState;\n  } // The core idea of BOLA.\n\n\n  function getQualityFromBufferLevel(bolaState, bufferLevel) {\n    var bitrateCount = bolaState.bitrates.length;\n    var quality = NaN;\n    var score = NaN;\n\n    for (var i = 0; i < bitrateCount; ++i) {\n      var s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n\n      if (isNaN(score) || s >= score) {\n        score = s;\n        quality = i;\n      }\n    }\n\n    return quality;\n  } // maximum buffer level which prefers to download at quality rather than wait\n\n\n  function maxBufferLevelForQuality(bolaState, quality) {\n    return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n  } // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n\n\n  function minBufferLevelForQuality(bolaState, quality) {\n    var qBitrate = bolaState.bitrates[quality];\n    var qUtility = bolaState.utilities[quality];\n    var min = 0;\n\n    for (var i = quality - 1; i >= 0; --i) {\n      // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n      if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n        var iBitrate = bolaState.bitrates[i];\n        var iUtility = bolaState.utilities[i];\n        var level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n        min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n      }\n    }\n\n    return min;\n  }\n  /*\n  * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n  * There are two main reasons we might want to increase the placeholder buffer:\n  *\n  * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n  *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n  *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n  *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n  *\n  * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n  *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n  *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n  *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n  */\n\n\n  function updatePlaceholderBuffer(bolaState, mediaType) {\n    var nowMs = Date.now();\n\n    if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n      // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n      var delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n      bolaState.placeholderBuffer += Math.max(0, delay);\n    } else if (!isNaN(bolaState.lastCallTimeMs)) {\n      // no download after last call, compensate for delay between calls\n      var _delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n\n      bolaState.placeholderBuffer += Math.max(0, _delay);\n    }\n\n    bolaState.lastCallTimeMs = nowMs;\n    bolaState.lastSegmentStart = NaN;\n    bolaState.lastSegmentRequestTimeMs = NaN;\n    bolaState.lastSegmentFinishTimeMs = NaN;\n    checkBolaStateStableBufferTime(bolaState, mediaType);\n  }\n\n  function onBufferEmpty() {\n    // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n    for (var mediaType in bolaStateDict) {\n      if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n        bolaStateDict[mediaType].placeholderBuffer = 0;\n      }\n    }\n  }\n\n  function onPlaybackSeeking() {\n    // TODO: 1. Verify what happens if we seek mid-fragment.\n    // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n    for (var mediaType in bolaStateDict) {\n      if (bolaStateDict.hasOwnProperty(mediaType)) {\n        var bolaState = bolaStateDict[mediaType];\n\n        if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n          bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n\n          clearBolaStateOnSeek(bolaState);\n        }\n      }\n    }\n  }\n\n  function onMediaFragmentLoaded(e) {\n    if (e && e.chunk && e.chunk.mediaInfo) {\n      var bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        var start = e.chunk.start;\n\n        if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n          bolaState.mostAdvancedSegmentStart = start;\n          bolaState.lastSegmentWasReplacement = false;\n        } else {\n          bolaState.lastSegmentWasReplacement = true;\n        }\n\n        bolaState.lastSegmentStart = start;\n        bolaState.lastSegmentDurationS = e.chunk.duration;\n        bolaState.lastQuality = e.chunk.quality;\n        checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n      }\n    }\n  }\n\n  function onMetricAdded(e) {\n    if (e && e.metric === _MetricsConstants2.default.HTTP_REQUEST && e.value && e.value.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n      var bolaState = bolaStateDict[e.mediaType];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n        bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n        checkNewSegment(bolaState, e.mediaType);\n      }\n    }\n  }\n  /*\n  * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n  * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n  * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n  * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n  * decides not to increase the quality to avoid oscillations.\n  *\n  * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n  * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n  * We avoid this by growing the placeholder buffer.\n  */\n\n\n  function checkNewSegment(bolaState, mediaType) {\n    if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n      bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY; // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n\n      if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n        var bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n\n        var maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n        var maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n        bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n      } // then see if we should grow placeholder buffer\n\n\n      if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n        // compensate for segments that were downloaded but did not grow the buffer\n        bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n      }\n\n      bolaState.lastSegmentStart = NaN;\n      bolaState.lastSegmentRequestTimeMs = NaN;\n    }\n  }\n\n  function onQualityChangeRequested(e) {\n    // Useful to store change requests when abandoning a download.\n    if (e) {\n      var bolaState = bolaStateDict[e.mediaType];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        bolaState.abrQuality = e.newQuality;\n      }\n    }\n  }\n\n  function onFragmentLoadingAbandoned(e) {\n    if (e) {\n      var bolaState = bolaStateDict[e.mediaType];\n\n      if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n        // deflate placeholderBuffer - note that we want to be conservative when abandoning\n        var bufferLevel = dashMetrics.getCurrentBufferLevel(e.mediaType);\n        var wantEffectiveBufferLevel = void 0;\n\n        if (bolaState.abrQuality > 0) {\n          // deflate to point where BOLA just chooses newQuality over newQuality-1\n          wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\n        } else {\n          wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n        }\n\n        var maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n        bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\n      }\n    }\n  }\n\n  function getMaxIndex(rulesContext) {\n    var switchRequest = (0, _SwitchRequest2.default)(context).create();\n\n    if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') || !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') || !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useBufferOccupancyABR')) {\n      return switchRequest;\n    }\n\n    var mediaInfo = rulesContext.getMediaInfo();\n    var mediaType = rulesContext.getMediaType();\n    var scheduleController = rulesContext.getScheduleController();\n    var streamInfo = rulesContext.getStreamInfo();\n    var abrController = rulesContext.getAbrController();\n    var throughputHistory = abrController.getThroughputHistory();\n    var streamId = streamInfo ? streamInfo.id : null;\n    var isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n    var useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n    switchRequest.reason = switchRequest.reason || {};\n\n    if (!useBufferOccupancyABR) {\n      return switchRequest;\n    }\n\n    scheduleController.setTimeToLoadDelay(0);\n    var bolaState = getBolaState(rulesContext);\n\n    if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n      // shouldn't even have been called\n      return switchRequest;\n    }\n\n    var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n    var throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n    var safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n    var latency = throughputHistory.getAverageLatency(mediaType);\n    var quality = void 0;\n    switchRequest.reason.state = bolaState.state;\n    switchRequest.reason.throughput = throughput;\n    switchRequest.reason.latency = latency;\n\n    if (isNaN(throughput)) {\n      // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n      // still starting up - not enough information\n      return switchRequest;\n    }\n\n    switch (bolaState.state) {\n      case BOLA_STATE_STARTUP:\n        quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = safeThroughput;\n        bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n        bolaState.lastQuality = quality;\n\n        if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n          bolaState.state = BOLA_STATE_STEADY;\n        }\n\n        break;\n      // BOLA_STATE_STARTUP\n\n      case BOLA_STATE_STEADY:\n        // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n        //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n        //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n        //     However, the InsufficientBufferRule takes care of this scenario.\n        updatePlaceholderBuffer(bolaState, mediaType);\n        quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer); // we want to avoid oscillations\n        // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n\n        var qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n        if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n          // only intervene if we are trying to *increase* quality to an *unsustainable* level\n          // we are only avoid oscillations - do not drop below last quality\n          quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n        } // We do not want to overfill buffer with low quality chunks.\n        // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n\n\n        var delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality)); // First reduce placeholder buffer, then tell schedule controller to pause.\n\n        if (delayS <= bolaState.placeholderBuffer) {\n          bolaState.placeholderBuffer -= delayS;\n          delayS = 0;\n        } else {\n          delayS -= bolaState.placeholderBuffer;\n          bolaState.placeholderBuffer = 0;\n\n          if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n            // At top quality, allow schedule controller to decide how far to fill buffer.\n            scheduleController.setTimeToLoadDelay(1000 * delayS);\n          } else {\n            delayS = 0;\n          }\n        }\n\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n        switchRequest.reason.bufferLevel = bufferLevel;\n        switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n        switchRequest.reason.delay = delayS;\n        bolaState.lastQuality = quality; // keep bolaState.state === BOLA_STATE_STEADY\n\n        break;\n      // BOLA_STATE_STEADY\n\n      default:\n        logger.debug('BOLA ABR rule invoked in bad state.'); // should not arrive here, try to recover\n\n        switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = safeThroughput;\n        switchRequest.reason.latency = latency;\n        bolaState.state = BOLA_STATE_STARTUP;\n        clearBolaStateOnSeek(bolaState);\n    }\n\n    return switchRequest;\n  }\n\n  function resetInitialSettings() {\n    bolaStateDict = {};\n  }\n\n  function reset() {\n    resetInitialSettings();\n    eventBus.off(_Events2.default.BUFFER_EMPTY, onBufferEmpty, instance);\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    eventBus.off(_Events2.default.METRIC_ADDED, onMetricAdded, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n    eventBus.off(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n  }\n\n  instance = {\n    getMaxIndex: getMaxIndex,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexports.default = _FactoryMaker2.default.getClassFactory(BolaRule);","map":{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":["BOLA_STATE_ONE_BITRATE","BOLA_STATE_STARTUP","BOLA_STATE_STEADY","MINIMUM_BUFFER_S","MINIMUM_BUFFER_PER_BITRATE_LEVEL_S","PLACEHOLDER_BUFFER_DECAY","config","context","dashMetrics","mediaPlayerModel","eventBus","instance","logger","bolaStateDict","resetInitialSettings","Events","bitrates","Math","highestUtilityIndex","utilities","u","bufferTime","gp","Vp","initialState","mediaInfo","rulesContext","b","utilitiesFromBitrates","stableBufferTime","params","calculateBolaParameters","clearBolaStateOnSeek","bolaState","bufferLevel","effectiveBufferLevel","mediaType","getInitialBolaState","checkBolaStateStableBufferTime","bitrateCount","quality","score","i","s","isNaN","qBitrate","qUtility","min","iBitrate","iUtility","level","nowMs","Date","delay","e","start","checkNewSegment","MetricsConstants","HTTPRequest","bufferAtLastSegmentRequest","maxEffectiveBufferForLastSegment","maxBufferLevelForQuality","maxPlaceholderBuffer","wantEffectiveBufferLevel","minBufferLevelForQuality","switchRequest","scheduleController","streamInfo","abrController","throughputHistory","streamId","isDynamic","useBufferOccupancyABR","getBolaState","throughput","safeThroughput","latency","updatePlaceholderBuffer","getQualityFromBufferLevel","qualityForThroughput","delayS","getMaxIndex","reset","setup","BolaRule","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport { HTTPRequest } from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\nconst BOLA_STATE_ONE_BITRATE    = 0;\nconst BOLA_STATE_STARTUP        = 1;\nconst BOLA_STATE_STEADY         = 2;\n\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        bolaStateDict;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    function utilitiesFromBitrates(bitrates) {\n        return bitrates.map(b => Math.log(b));\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\n    }\n\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n        const highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\n\n        if (highestUtilityIndex === 0) {\n            // if highestUtilityIndex === 0, then always use lowest bitrate\n            return null;\n        }\n\n        const bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\n\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n        // giving:\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n        const Vp = MINIMUM_BUFFER_S / gp;\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n        return {gp: gp, Vp: Vp};\n    }\n\n    function getInitialBolaState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        let utilities = utilitiesFromBitrates(bitrates);\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n        if (!params) {\n            // only happens when there is only one bitrate level\n            initialState.state = BOLA_STATE_ONE_BITRATE;\n        } else {\n            initialState.state = BOLA_STATE_STARTUP;\n\n            initialState.bitrates = bitrates;\n            initialState.utilities = utilities;\n            initialState.stableBufferTime = stableBufferTime;\n            initialState.Vp = params.Vp;\n            initialState.gp = params.gp;\n\n            initialState.lastQuality = 0;\n            clearBolaStateOnSeek(initialState);\n        }\n\n        return initialState;\n    }\n\n    function clearBolaStateOnSeek(bolaState) {\n        bolaState.placeholderBuffer = 0;\n        bolaState.mostAdvancedSegmentStart = NaN;\n        bolaState.lastSegmentWasReplacement = false;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentDurationS = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n    }\n\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        if (bolaState.stableBufferTime !== stableBufferTime) {\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n                // correct placeholder buffer using two criteria:\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\n\n                bolaState.stableBufferTime = stableBufferTime;\n                bolaState.Vp = params.Vp;\n                bolaState.gp = params.gp;\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n            }\n        }\n    }\n\n    function getBolaState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let bolaState = bolaStateDict[mediaType];\n        if (!bolaState) {\n            bolaState = getInitialBolaState(rulesContext);\n            bolaStateDict[mediaType] = bolaState;\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n            checkBolaStateStableBufferTime(bolaState, mediaType);\n        }\n        return bolaState;\n    }\n\n    // The core idea of BOLA.\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\n        const bitrateCount = bolaState.bitrates.length;\n        let quality = NaN;\n        let score = NaN;\n        for (let i = 0; i < bitrateCount; ++i) {\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n            if (isNaN(score) || s >= score) {\n                score = s;\n                quality = i;\n            }\n        }\n        return quality;\n    }\n\n    // maximum buffer level which prefers to download at quality rather than wait\n    function maxBufferLevelForQuality(bolaState, quality) {\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n    }\n\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n    function minBufferLevelForQuality(bolaState, quality) {\n        const qBitrate = bolaState.bitrates[quality];\n        const qUtility = bolaState.utilities[quality];\n\n        let min = 0;\n        for (let i = quality - 1; i >= 0; --i) {\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n                const iBitrate = bolaState.bitrates[i];\n                const iUtility = bolaState.utilities[i];\n\n                const level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n            }\n        }\n        return min;\n    }\n\n    /*\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n     * There are two main reasons we might want to increase the placeholder buffer:\n     *\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n     *\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n     */\n    function updatePlaceholderBuffer(bolaState, mediaType) {\n        const nowMs = Date.now();\n\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n            const delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\n            // no download after last call, compensate for delay between calls\n            const delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        }\n\n        bolaState.lastCallTimeMs = nowMs;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n\n        checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    function onBufferEmpty() {\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n                bolaStateDict[mediaType].placeholderBuffer = 0;\n            }\n        }\n    }\n\n    function onPlaybackSeeking() {\n        // TODO: 1. Verify what happens if we seek mid-fragment.\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\n                const bolaState = bolaStateDict[mediaType];\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n                    clearBolaStateOnSeek(bolaState);\n                }\n            }\n        }\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n                    bolaState.mostAdvancedSegmentStart = start;\n                    bolaState.lastSegmentWasReplacement = false;\n                } else {\n                    bolaState.lastSegmentWasReplacement = true;\n                }\n\n                bolaState.lastSegmentStart = start;\n                bolaState.lastSegmentDurationS = e.chunk.duration;\n                bolaState.lastQuality = e.chunk.quality;\n\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n            }\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n                checkNewSegment(bolaState, e.mediaType);\n            }\n        }\n    }\n\n    /*\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n     * decides not to increase the quality to avoid oscillations.\n     *\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n     * We avoid this by growing the placeholder buffer.\n     */\n    function checkNewSegment(bolaState, mediaType) {\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\n\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n                const bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n                const maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n                const maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n            }\n\n            // then see if we should grow placeholder buffer\n\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n                // compensate for segments that were downloaded but did not grow the buffer\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n            }\n\n            bolaState.lastSegmentStart = NaN;\n            bolaState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    function onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(e.mediaType);\n                let wantEffectiveBufferLevel;\n                if (bolaState.abrQuality > 0) {\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\n                } else {\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n                }\n                const maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n                bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\n            }\n        }\n    }\n\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useBufferOccupancyABR')) {\n            return switchRequest;\n        }\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const streamId = streamInfo ? streamInfo.id : null;\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n        switchRequest.reason = switchRequest.reason || {};\n\n        if (!useBufferOccupancyABR) {\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const bolaState = getBolaState(rulesContext);\n\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        let quality;\n\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (bolaState.state) {\n            case BOLA_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n                bolaState.lastQuality = quality;\n\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n                    bolaState.state = BOLA_STATE_STEADY;\n                }\n\n                break; // BOLA_STATE_STARTUP\n\n            case BOLA_STATE_STEADY:\n\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n                //     However, the InsufficientBufferRule takes care of this scenario.\n\n                updatePlaceholderBuffer(bolaState, mediaType);\n\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\n\n                // we want to avoid oscillations\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n                const qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\n                    // we are only avoid oscillations - do not drop below last quality\n\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n                }\n\n                // We do not want to overfill buffer with low quality chunks.\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\n\n                // First reduce placeholder buffer, then tell schedule controller to pause.\n                if (delayS <= bolaState.placeholderBuffer) {\n                    bolaState.placeholderBuffer -= delayS;\n                    delayS = 0;\n                } else {\n                    delayS -= bolaState.placeholderBuffer;\n                    bolaState.placeholderBuffer = 0;\n\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\n                        scheduleController.setTimeToLoadDelay(1000 * delayS);\n                    } else {\n                        delayS = 0;\n                    }\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n                switchRequest.reason.delay = delayS;\n\n                bolaState.lastQuality = quality;\n                // keep bolaState.state === BOLA_STATE_STEADY\n\n                break; // BOLA_STATE_STEADY\n\n            default:\n                logger.debug('BOLA ABR rule invoked in bad state.');\n                // should not arrive here, try to recover\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = bolaState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                bolaState.state = BOLA_STATE_STARTUP;\n                clearBolaStateOnSeek(bolaState);\n        }\n\n        return switchRequest;\n    }\n\n    function resetInitialSettings() {\n        bolaStateDict = {};\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexport default FactoryMaker.getClassFactory(BolaRule);\n"]},"metadata":{},"sourceType":"script"}