{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvar WEBVTT = 'WEBVTT';\n\nfunction VTTParser() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      regExNewLine = void 0,\n      regExToken = void 0,\n      regExWhiteSpace = void 0,\n      regExWhiteSpaceWordBoundary = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    regExNewLine = /(?:\\r\\n|\\r|\\n)/gm;\n    regExToken = /-->/;\n    regExWhiteSpace = /(^[\\s]+|[\\s]+$)/g;\n    regExWhiteSpaceWordBoundary = /\\s\\b/g;\n  }\n\n  function parse(data) {\n    var captionArray = [];\n    var len = void 0,\n        lastStartTime = void 0;\n\n    if (!data) {\n      return captionArray;\n    }\n\n    data = data.split(regExNewLine);\n    len = data.length;\n    lastStartTime = -1;\n\n    for (var i = 0; i < len; i++) {\n      var item = data[i];\n\n      if (item.length > 0 && item !== WEBVTT) {\n        if (item.match(regExToken)) {\n          var attributes = parseItemAttributes(item);\n          var cuePoints = attributes.cuePoints;\n          var styles = attributes.styles;\n          var text = getSublines(data, i + 1);\n          var startTime = convertCuePointTimes(cuePoints[0].replace(regExWhiteSpace, ''));\n          var endTime = convertCuePointTimes(cuePoints[1].replace(regExWhiteSpace, ''));\n\n          if (!isNaN(startTime) && !isNaN(endTime) && startTime >= lastStartTime && endTime > startTime) {\n            if (text !== '') {\n              lastStartTime = startTime; //TODO Make VO external so other parsers can use.\n\n              captionArray.push({\n                start: startTime,\n                end: endTime,\n                data: text,\n                styles: styles\n              });\n            } else {\n              logger.error('Skipping cue due to empty/malformed cue text');\n            }\n          } else {\n            logger.error('Skipping cue due to incorrect cue timing');\n          }\n        }\n      }\n    }\n\n    return captionArray;\n  }\n\n  function convertCuePointTimes(time) {\n    var timeArray = time.split(':');\n    var len = timeArray.length - 1;\n    time = parseInt(timeArray[len - 1], 10) * 60 + parseFloat(timeArray[len]);\n\n    if (len === 2) {\n      time += parseInt(timeArray[0], 10) * 3600;\n    }\n\n    return time;\n  }\n\n  function parseItemAttributes(data) {\n    var vttCuePoints = data.split(regExToken);\n    var arr = vttCuePoints[1].split(regExWhiteSpaceWordBoundary);\n    arr.shift(); //remove first array index it is empty...\n\n    vttCuePoints[1] = arr[0];\n    arr.shift();\n    return {\n      cuePoints: vttCuePoints,\n      styles: getCaptionStyles(arr)\n    };\n  }\n\n  function getCaptionStyles(arr) {\n    var styleObject = {};\n    arr.forEach(function (element) {\n      if (element.split(/:/).length > 1) {\n        var val = element.split(/:/)[1];\n\n        if (val && val.search(/%/) != -1) {\n          val = parseInt(val.replace(/%/, ''), 10);\n        }\n\n        if (element.match(/align/) || element.match(/A/)) {\n          styleObject.align = val;\n        }\n\n        if (element.match(/line/) || element.match(/L/)) {\n          styleObject.line = val;\n        }\n\n        if (element.match(/position/) || element.match(/P/)) {\n          styleObject.position = val;\n        }\n\n        if (element.match(/size/) || element.match(/S/)) {\n          styleObject.size = val;\n        }\n      }\n    });\n    return styleObject;\n  }\n  /*\n  * VTT can have multiple lines to display per cuepoint.\n  */\n\n\n  function getSublines(data, idx) {\n    var i = idx;\n    var subline = '';\n    var lineData = '';\n    var lineCount = void 0;\n\n    while (data[i] !== '' && i < data.length) {\n      i++;\n    }\n\n    lineCount = i - idx;\n\n    if (lineCount > 1) {\n      for (var j = 0; j < lineCount; j++) {\n        lineData = data[idx + j];\n\n        if (!lineData.match(regExToken)) {\n          subline += lineData;\n\n          if (j !== lineCount - 1) {\n            subline += '\\n';\n          }\n        } else {\n          // caption text should not have '-->' in it\n          subline = '';\n          break;\n        }\n      }\n    } else {\n      lineData = data[idx];\n      if (!lineData.match(regExToken)) subline = lineData;\n    }\n\n    return subline;\n  }\n\n  instance = {\n    parse: parse\n  };\n  setup();\n  return instance;\n}\n\nVTTParser.__dashjs_factory_name = 'VTTParser';\nexports.default = _FactoryMaker2.default.getSingletonFactory(VTTParser);","map":{"version":3,"sources":["../../../../../src/streaming/utils/VTTParser.js"],"names":["WEBVTT","context","instance","logger","regExNewLine","regExToken","regExWhiteSpace","regExWhiteSpaceWordBoundary","captionArray","len","lastStartTime","data","i","item","attributes","parseItemAttributes","cuePoints","styles","text","getSublines","startTime","convertCuePointTimes","endTime","isNaN","start","end","timeArray","time","parseInt","parseFloat","vttCuePoints","arr","getCaptionStyles","styleObject","element","val","subline","lineData","lineCount","j","idx","parse","setup","VTTParser","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst WEBVTT = 'WEBVTT';\n\nfunction VTTParser() {\n    const context = this.context;\n\n    let instance,\n        logger,\n        regExNewLine,\n        regExToken,\n        regExWhiteSpace,\n        regExWhiteSpaceWordBoundary;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        regExNewLine = /(?:\\r\\n|\\r|\\n)/gm;\n        regExToken = /-->/;\n        regExWhiteSpace = /(^[\\s]+|[\\s]+$)/g;\n        regExWhiteSpaceWordBoundary = /\\s\\b/g;\n    }\n\n    function parse(data) {\n        const captionArray = [];\n        let len,\n            lastStartTime;\n\n        if (!data) {\n            return captionArray;\n        }\n\n        data = data.split( regExNewLine );\n        len = data.length;\n        lastStartTime = -1;\n\n        for (let i = 0 ; i < len; i++) {\n            let item = data[i];\n\n            if (item.length > 0 && item !== WEBVTT) {\n                if (item.match(regExToken)) {\n                    const attributes = parseItemAttributes(item);\n                    const cuePoints = attributes.cuePoints;\n                    const styles = attributes.styles;\n                    const text = getSublines(data, i + 1);\n                    const startTime = convertCuePointTimes(cuePoints[0].replace(regExWhiteSpace, ''));\n                    const endTime = convertCuePointTimes(cuePoints[1].replace(regExWhiteSpace, ''));\n\n                    if ((!isNaN(startTime) && !isNaN(endTime)) && startTime >= lastStartTime && endTime > startTime) {\n                        if (text !== '') {\n                            lastStartTime = startTime;\n                            //TODO Make VO external so other parsers can use.\n                            captionArray.push({\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: styles\n                            });\n                        }\n                        else {\n                            logger.error('Skipping cue due to empty/malformed cue text');\n                        }\n                    }\n                    else {\n                        logger.error('Skipping cue due to incorrect cue timing');\n                    }\n                }\n            }\n        }\n\n        return captionArray;\n    }\n\n    function convertCuePointTimes(time) {\n        const timeArray = time.split(':');\n        const len = timeArray.length - 1;\n\n        time = parseInt( timeArray[len - 1], 10 ) * 60 + parseFloat( timeArray[len]);\n\n        if ( len === 2 ) {\n            time += parseInt( timeArray[0], 10 ) * 3600;\n        }\n\n        return time;\n    }\n\n    function parseItemAttributes(data) {\n        const vttCuePoints = data.split(regExToken);\n        const arr = vttCuePoints[1].split(regExWhiteSpaceWordBoundary);\n        arr.shift(); //remove first array index it is empty...\n        vttCuePoints[1] = arr[0];\n        arr.shift();\n        return {cuePoints: vttCuePoints, styles: getCaptionStyles(arr)};\n    }\n\n    function getCaptionStyles(arr) {\n        const styleObject = {};\n        arr.forEach(function (element) {\n            if (element.split(/:/).length > 1) {\n                let val = element.split(/:/)[1];\n                if (val && val.search(/%/) != -1) {\n                    val = parseInt(val.replace(/%/, ''), 10);\n                }\n                if (element.match(/align/) || element.match(/A/)) {\n                    styleObject.align = val;\n                }\n                if (element.match(/line/) || element.match(/L/) ) {\n                    styleObject.line = val;\n                }\n                if (element.match(/position/) || element.match(/P/) ) {\n                    styleObject.position = val;\n                }\n                if (element.match(/size/) || element.match(/S/)) {\n                    styleObject.size = val;\n                }\n            }\n        });\n\n        return styleObject;\n    }\n\n    /*\n    * VTT can have multiple lines to display per cuepoint.\n    */\n    function getSublines(data, idx) {\n        let i = idx;\n\n        let subline = '';\n        let lineData = '';\n        let lineCount;\n\n        while (data[i] !== '' && i < data.length) {\n            i++;\n        }\n\n        lineCount = i - idx;\n        if (lineCount > 1) {\n            for (let j = 0; j < lineCount; j++) {\n                lineData = data[(idx + j)];\n                if (!lineData.match(regExToken)) {\n                    subline += lineData;\n                    if (j !== lineCount - 1) {\n                        subline += '\\n';\n                    }\n                }\n                else {\n                    // caption text should not have '-->' in it\n                    subline = '';\n                    break;\n                }\n            }\n        } else {\n            lineData = data[idx];\n            if (!lineData.match(regExToken))\n                subline = lineData;\n        }\n        return subline;\n    }\n\n    instance = {\n        parse: parse\n    };\n\n    setup();\n    return instance;\n}\nVTTParser.__dashjs_factory_name = 'VTTParser';\nexport default FactoryMaker.getSingletonFactory(VTTParser);\n"]},"metadata":{},"sourceType":"script"}