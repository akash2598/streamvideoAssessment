{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EBMLParser = require('../streaming/utils/EBMLParser');\n\nvar _EBMLParser2 = _interopRequireDefault(_EBMLParser);\n\nvar _Constants = require('../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Segment = require('./vo/Segment');\n\nvar _Segment2 = _interopRequireDefault(_Segment);\n\nvar _FragmentRequest = require('../streaming/vo/FragmentRequest');\n\nvar _FragmentRequest2 = _interopRequireDefault(_FragmentRequest);\n\nvar _URLLoader = require('../streaming/net/URLLoader');\n\nvar _URLLoader2 = _interopRequireDefault(_URLLoader);\n\nvar _DashJSError = require('../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction WebmSegmentBaseLoader() {\n  var context = this.context;\n  var instance = void 0,\n      logger = void 0,\n      WebM = void 0,\n      errHandler = void 0,\n      requestModifier = void 0,\n      dashMetrics = void 0,\n      mediaPlayerModel = void 0,\n      urlLoader = void 0,\n      settings = void 0,\n      eventBus = void 0,\n      events = void 0,\n      errors = void 0,\n      baseURLController = void 0;\n\n  function setup() {\n    WebM = {\n      EBML: {\n        tag: 0x1A45DFA3,\n        required: true\n      },\n      Segment: {\n        tag: 0x18538067,\n        required: true,\n        SeekHead: {\n          tag: 0x114D9B74,\n          required: true\n        },\n        Info: {\n          tag: 0x1549A966,\n          required: true,\n          TimecodeScale: {\n            tag: 0x2AD7B1,\n            required: true,\n            parse: 'getMatroskaUint'\n          },\n          Duration: {\n            tag: 0x4489,\n            required: true,\n            parse: 'getMatroskaFloat'\n          }\n        },\n        Tracks: {\n          tag: 0x1654AE6B,\n          required: true\n        },\n        Cues: {\n          tag: 0x1C53BB6B,\n          required: true,\n          CuePoint: {\n            tag: 0xBB,\n            required: true,\n            CueTime: {\n              tag: 0xB3,\n              required: true,\n              parse: 'getMatroskaUint'\n            },\n            CueTrackPositions: {\n              tag: 0xB7,\n              required: true,\n              CueTrack: {\n                tag: 0xF7,\n                required: true,\n                parse: 'getMatroskaUint'\n              },\n              CueClusterPosition: {\n                tag: 0xF1,\n                required: true,\n                parse: 'getMatroskaUint'\n              }\n            }\n          }\n        }\n      },\n      Void: {\n        tag: 0xEC,\n        required: true\n      }\n    };\n  }\n\n  function initialize() {\n    urlLoader = (0, _URLLoader2.default)(context).create({\n      errHandler: errHandler,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      requestModifier: requestModifier,\n      useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n      errors: errors\n    });\n  }\n\n  function setConfig(config) {\n    if (!config.baseURLController || !config.dashMetrics || !config.mediaPlayerModel || !config.errHandler) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n\n    baseURLController = config.baseURLController;\n    dashMetrics = config.dashMetrics;\n    mediaPlayerModel = config.mediaPlayerModel;\n    errHandler = config.errHandler;\n    settings = config.settings;\n    events = config.events;\n    eventBus = config.eventBus;\n    errors = config.errors;\n    logger = config.debug.getLogger(instance);\n    requestModifier = config.requestModifier;\n  }\n\n  function parseCues(ab) {\n    var cues = [];\n    var ebmlParser = (0, _EBMLParser2.default)(context).create({\n      data: ab\n    });\n    var cue = void 0,\n        cueTrack = void 0;\n    ebmlParser.consumeTagAndSize(WebM.Segment.Cues);\n\n    while (ebmlParser.moreData() && ebmlParser.consumeTagAndSize(WebM.Segment.Cues.CuePoint, true)) {\n      cue = {};\n      cue.CueTime = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTime);\n      cue.CueTracks = [];\n\n      while (ebmlParser.moreData() && ebmlParser.consumeTag(WebM.Segment.Cues.CuePoint.CueTrackPositions, true)) {\n        var cueTrackPositionSize = ebmlParser.getMatroskaCodedNum();\n        var startPos = ebmlParser.getPos();\n        cueTrack = {};\n        cueTrack.Track = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueTrack);\n\n        if (cueTrack.Track === 0) {\n          throw new Error('Cue track cannot be 0');\n        }\n\n        cueTrack.ClusterPosition = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueClusterPosition);\n        cue.CueTracks.push(cueTrack); // we're not interested any other elements - skip remaining bytes\n\n        ebmlParser.setPos(startPos + cueTrackPositionSize);\n      }\n\n      if (cue.CueTracks.length === 0) {\n        throw new Error('Mandatory cuetrack not found');\n      }\n\n      cues.push(cue);\n    }\n\n    if (cues.length === 0) {\n      throw new Error('mandatory cuepoint not found');\n    }\n\n    return cues;\n  }\n\n  function parseSegments(data, segmentStart, segmentEnd, segmentDuration) {\n    var duration = void 0,\n        parsed = void 0,\n        segments = void 0,\n        segment = void 0,\n        i = void 0,\n        len = void 0,\n        start = void 0,\n        end = void 0;\n    parsed = parseCues(data);\n    segments = []; // we are assuming one cue track per cue point\n    // both duration and media range require the i + 1 segment\n    // the final segment has to use global segment parameters\n\n    for (i = 0, len = parsed.length; i < len; i += 1) {\n      segment = new _Segment2.default();\n      duration = 0;\n\n      if (i < parsed.length - 1) {\n        duration = parsed[i + 1].CueTime - parsed[i].CueTime;\n      } else {\n        duration = segmentDuration - parsed[i].CueTime;\n      } // note that we don't explicitly set segment.media as this will be\n      // computed when all BaseURLs are resolved later\n\n\n      segment.duration = duration;\n      segment.startTime = parsed[i].CueTime;\n      segment.timescale = 1000; // hardcoded for ms\n\n      start = parsed[i].CueTracks[0].ClusterPosition + segmentStart;\n\n      if (i < parsed.length - 1) {\n        end = parsed[i + 1].CueTracks[0].ClusterPosition + segmentStart - 1;\n      } else {\n        end = segmentEnd - 1;\n      }\n\n      segment.mediaRange = start + '-' + end;\n      segments.push(segment);\n    }\n\n    logger.debug('Parsed cues: ' + segments.length + ' cues.');\n    return segments;\n  }\n\n  function parseEbmlHeader(data, media, theRange, callback) {\n    if (!data || data.byteLength === 0) {\n      callback(null);\n      return;\n    }\n\n    var ebmlParser = (0, _EBMLParser2.default)(context).create({\n      data: data\n    });\n    var duration = void 0,\n        segments = void 0,\n        segmentEnd = void 0,\n        segmentStart = void 0;\n    var parts = theRange ? theRange.split('-') : null;\n    var request = null;\n    var info = {\n      url: media,\n      range: {\n        start: parts ? parseFloat(parts[0]) : null,\n        end: parts ? parseFloat(parts[1]) : null\n      },\n      request: request\n    };\n    logger.debug('Parse EBML header: ' + info.url); // skip over the header itself\n\n    ebmlParser.skipOverElement(WebM.EBML);\n    ebmlParser.consumeTag(WebM.Segment); // segments start here\n\n    segmentEnd = ebmlParser.getMatroskaCodedNum();\n    segmentEnd += ebmlParser.getPos();\n    segmentStart = ebmlParser.getPos(); // skip over any top level elements to get to the segment info\n\n    while (ebmlParser.moreData() && !ebmlParser.consumeTagAndSize(WebM.Segment.Info, true)) {\n      if (!(ebmlParser.skipOverElement(WebM.Segment.SeekHead, true) || ebmlParser.skipOverElement(WebM.Segment.Tracks, true) || ebmlParser.skipOverElement(WebM.Segment.Cues, true) || ebmlParser.skipOverElement(WebM.Void, true))) {\n        throw new Error('no valid top level element found');\n      }\n    } // we only need one thing in segment info, duration\n\n\n    while (duration === undefined) {\n      var infoTag = ebmlParser.getMatroskaCodedNum(true);\n      var infoElementSize = ebmlParser.getMatroskaCodedNum();\n\n      switch (infoTag) {\n        case WebM.Segment.Info.Duration.tag:\n          duration = ebmlParser[WebM.Segment.Info.Duration.parse](infoElementSize);\n          break;\n\n        default:\n          ebmlParser.setPos(ebmlParser.getPos() + infoElementSize);\n          break;\n      }\n    } // once we have what we need from segment info, we jump right to the\n    // cues\n\n\n    request = getFragmentRequest(info);\n\n    var onload = function onload(response) {\n      segments = parseSegments(response, segmentStart, segmentEnd, duration);\n      callback(segments);\n    };\n\n    var onloadend = function onloadend() {\n      logger.error('Download Error: Cues ' + info.url);\n      callback(null);\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onloadend\n    });\n    logger.debug('Perform cues load: ' + info.url + ' bytes=' + info.range.start + '-' + info.range.end);\n  }\n\n  function checkConfig() {\n    if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n\n  function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n    checkConfig();\n    var request = null;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var initRange = representation ? representation.range.split('-') : null;\n    var info = loadingInfo || {\n      range: {\n        start: initRange ? parseFloat(initRange[0]) : null,\n        end: initRange ? parseFloat(initRange[1]) : null\n      },\n      request: request,\n      url: baseUrl ? baseUrl.url : undefined,\n      init: true,\n      mediaType: mediaType\n    };\n    logger.info('Start loading initialization.');\n    request = getFragmentRequest(info);\n\n    var onload = function onload() {\n      // note that we don't explicitly set rep.initialization as this\n      // will be computed when all BaseURLs are resolved later\n      eventBus.trigger(events.INITIALIZATION_LOADED, {\n        representation: representation\n      }, {\n        streamId: streamId,\n        mediaType: mediaType\n      });\n    };\n\n    var onloadend = function onloadend() {\n      eventBus.trigger(events.INITIALIZATION_LOADED, {\n        representation: representation\n      }, {\n        streamId: streamId,\n        mediaType: mediaType\n      });\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onloadend\n    });\n    logger.debug('Perform init load: ' + info.url);\n  }\n\n  function loadSegments(streamId, mediaType, representation, theRange, callback) {\n    checkConfig();\n    var request = null;\n    var baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n    var media = baseUrl ? baseUrl.url : undefined;\n    var bytesToLoad = 8192;\n    var info = {\n      bytesLoaded: 0,\n      bytesToLoad: bytesToLoad,\n      range: {\n        start: 0,\n        end: bytesToLoad\n      },\n      request: request,\n      url: media,\n      init: false,\n      mediaType: mediaType\n    };\n    callback = !callback ? onLoaded : callback;\n    request = getFragmentRequest(info); // first load the header, but preserve the manifest range so we can\n    // load the cues after parsing the header\n    // NOTE: we expect segment info to appear in the first 8192 bytes\n\n    logger.debug('Parsing ebml header');\n\n    var onload = function onload(response) {\n      parseEbmlHeader(response, media, theRange, function (segments) {\n        callback(streamId, mediaType, segments, representation);\n      });\n    };\n\n    var onloadend = function onloadend() {\n      callback(streamId, mediaType, null, representation);\n    };\n\n    urlLoader.load({\n      request: request,\n      success: onload,\n      error: onloadend\n    });\n  }\n\n  function onLoaded(streamId, mediaType, segments, representation) {\n    eventBus.trigger(events.SEGMENTS_LOADED, {\n      segments: segments,\n      representation: representation,\n      error: segments ? undefined : new _DashJSError2.default(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n    }, {\n      streamId: streamId,\n      mediaType: mediaType\n    });\n  }\n\n  function getFragmentRequest(info) {\n    var request = new _FragmentRequest2.default();\n    request.setInfo(info);\n    return request;\n  }\n\n  function reset() {\n    errHandler = null;\n    requestModifier = null;\n  }\n\n  instance = {\n    setConfig: setConfig,\n    initialize: initialize,\n    loadInitialization: loadInitialization,\n    loadSegments: loadSegments,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nWebmSegmentBaseLoader.__dashjs_factory_name = 'WebmSegmentBaseLoader';\nexports.default = _FactoryMaker2.default.getSingletonFactory(WebmSegmentBaseLoader);","map":{"version":3,"sources":["../../../../src/dash/WebmSegmentBaseLoader.js"],"names":["context","instance","logger","WebM","errHandler","requestModifier","dashMetrics","mediaPlayerModel","urlLoader","settings","eventBus","events","errors","baseURLController","EBML","tag","required","Segment","SeekHead","Info","TimecodeScale","parse","Duration","Tracks","Cues","CuePoint","CueTime","CueTrackPositions","CueTrack","CueClusterPosition","Void","useFetch","config","Constants","cues","ebmlParser","data","cue","cueTrack","cueTrackPositionSize","startPos","duration","parsed","segments","segment","i","len","start","end","parseCues","segmentDuration","segmentEnd","callback","segmentStart","parts","theRange","request","info","url","range","parseFloat","infoTag","infoElementSize","getFragmentRequest","onload","parseSegments","onloadend","success","error","checkConfig","baseUrl","representation","initRange","loadingInfo","init","mediaType","streamId","media","bytesToLoad","bytesLoaded","parseEbmlHeader","DashJSError","FragmentRequest","setConfig","initialize","loadInitialization","loadSegments","reset","setup","WebmSegmentBaseLoader","FactoryMaker"],"mappings":"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","sourcesContent":["import EBMLParser from '../streaming/utils/EBMLParser';\nimport Constants from '../streaming/constants/Constants';\nimport FactoryMaker from '../core/FactoryMaker';\nimport Segment from './vo/Segment';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport URLLoader from '../streaming/net/URLLoader';\nimport DashJSError from '../streaming/vo/DashJSError';\n\nfunction WebmSegmentBaseLoader() {\n\n    const context = this.context;\n\n    let instance,\n        logger,\n        WebM,\n        errHandler,\n        requestModifier,\n        dashMetrics,\n        mediaPlayerModel,\n        urlLoader,\n        settings,\n        eventBus,\n        events,\n        errors,\n        baseURLController;\n\n    function setup() {\n        WebM = {\n            EBML: {\n                tag: 0x1A45DFA3,\n                required: true\n            },\n            Segment: {\n                tag: 0x18538067,\n                required: true,\n                SeekHead: {\n                    tag: 0x114D9B74,\n                    required: true\n                },\n                Info: {\n                    tag: 0x1549A966,\n                    required: true,\n                    TimecodeScale: {\n                        tag: 0x2AD7B1,\n                        required: true,\n                        parse: 'getMatroskaUint'\n                    },\n                    Duration: {\n                        tag: 0x4489,\n                        required: true,\n                        parse: 'getMatroskaFloat'\n                    }\n                },\n                Tracks: {\n                    tag: 0x1654AE6B,\n                    required: true\n                },\n                Cues: {\n                    tag: 0x1C53BB6B,\n                    required: true,\n                    CuePoint: {\n                        tag: 0xBB,\n                        required: true,\n                        CueTime: {\n                            tag: 0xB3,\n                            required: true,\n                            parse: 'getMatroskaUint'\n                        },\n                        CueTrackPositions: {\n                            tag: 0xB7,\n                            required: true,\n                            CueTrack: {\n                                tag: 0xF7,\n                                required: true,\n                                parse: 'getMatroskaUint'\n                            },\n                            CueClusterPosition: {\n                                tag: 0xF1,\n                                required: true,\n                                parse: 'getMatroskaUint'\n                            }\n                        }\n                    }\n                }\n            },\n            Void: {\n                tag: 0xEC,\n                required: true\n            }\n        };\n    }\n\n    function initialize() {\n        urlLoader = URLLoader(context).create({\n            errHandler: errHandler,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            requestModifier: requestModifier,\n            useFetch: settings ? settings.get().streaming.lowLatencyEnabled : null,\n            errors: errors\n        });\n    }\n\n    function setConfig(config) {\n        if (!config.baseURLController || !config.dashMetrics || !config.mediaPlayerModel || !config.errHandler) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n        baseURLController = config.baseURLController;\n        dashMetrics = config.dashMetrics;\n        mediaPlayerModel = config.mediaPlayerModel;\n        errHandler = config.errHandler;\n        settings = config.settings;\n        events = config.events;\n        eventBus = config.eventBus;\n        errors = config.errors;\n        logger = config.debug.getLogger(instance);\n        requestModifier = config.requestModifier;\n    }\n\n    function parseCues(ab) {\n        let cues = [];\n        let ebmlParser = EBMLParser(context).create({\n            data: ab\n        });\n        let cue,\n            cueTrack;\n\n        ebmlParser.consumeTagAndSize(WebM.Segment.Cues);\n\n        while (ebmlParser.moreData() &&\n            ebmlParser.consumeTagAndSize(WebM.Segment.Cues.CuePoint, true)) {\n            cue = {};\n\n            cue.CueTime = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTime);\n\n            cue.CueTracks = [];\n            while (ebmlParser.moreData() &&\n                ebmlParser.consumeTag(WebM.Segment.Cues.CuePoint.CueTrackPositions, true)) {\n                const cueTrackPositionSize = ebmlParser.getMatroskaCodedNum();\n                const startPos = ebmlParser.getPos();\n                cueTrack = {};\n\n                cueTrack.Track = ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueTrack);\n                if (cueTrack.Track === 0) {\n                    throw new Error('Cue track cannot be 0');\n                }\n\n                cueTrack.ClusterPosition =\n                    ebmlParser.parseTag(WebM.Segment.Cues.CuePoint.CueTrackPositions.CueClusterPosition);\n\n                cue.CueTracks.push(cueTrack);\n\n                // we're not interested any other elements - skip remaining bytes\n                ebmlParser.setPos(startPos + cueTrackPositionSize);\n            }\n\n            if (cue.CueTracks.length === 0) {\n                throw new Error('Mandatory cuetrack not found');\n            }\n            cues.push(cue);\n        }\n\n        if (cues.length === 0) {\n            throw new Error('mandatory cuepoint not found');\n        }\n        return cues;\n    }\n\n    function parseSegments(data, segmentStart, segmentEnd, segmentDuration) {\n        let duration,\n            parsed,\n            segments,\n            segment,\n            i,\n            len,\n            start,\n            end;\n\n        parsed = parseCues(data);\n        segments = [];\n\n        // we are assuming one cue track per cue point\n        // both duration and media range require the i + 1 segment\n        // the final segment has to use global segment parameters\n        for (i = 0, len = parsed.length; i < len; i += 1) {\n            segment = new Segment();\n            duration = 0;\n\n            if (i < parsed.length - 1) {\n                duration = parsed[i + 1].CueTime - parsed[i].CueTime;\n            } else {\n                duration = segmentDuration - parsed[i].CueTime;\n            }\n\n            // note that we don't explicitly set segment.media as this will be\n            // computed when all BaseURLs are resolved later\n            segment.duration = duration;\n            segment.startTime = parsed[i].CueTime;\n            segment.timescale = 1000; // hardcoded for ms\n            start = parsed[i].CueTracks[0].ClusterPosition + segmentStart;\n\n            if (i < parsed.length - 1) {\n                end = parsed[i + 1].CueTracks[0].ClusterPosition + segmentStart - 1;\n            } else {\n                end = segmentEnd - 1;\n            }\n\n            segment.mediaRange = start + '-' + end;\n            segments.push(segment);\n        }\n\n        logger.debug('Parsed cues: ' + segments.length + ' cues.');\n\n        return segments;\n    }\n\n    function parseEbmlHeader(data, media, theRange, callback) {\n        if (!data || data.byteLength === 0) {\n            callback(null);\n            return;\n        }\n        let ebmlParser = EBMLParser(context).create({\n            data: data\n        });\n        let duration,\n            segments,\n            segmentEnd,\n            segmentStart;\n        let parts = theRange ? theRange.split('-') : null;\n        let request = null;\n        let info = {\n            url: media,\n            range: {\n                start: parts ? parseFloat(parts[0]) : null,\n                end: parts ? parseFloat(parts[1]) : null\n            },\n            request: request\n        };\n\n        logger.debug('Parse EBML header: ' + info.url);\n\n        // skip over the header itself\n        ebmlParser.skipOverElement(WebM.EBML);\n        ebmlParser.consumeTag(WebM.Segment);\n\n        // segments start here\n        segmentEnd = ebmlParser.getMatroskaCodedNum();\n        segmentEnd += ebmlParser.getPos();\n        segmentStart = ebmlParser.getPos();\n\n        // skip over any top level elements to get to the segment info\n        while (ebmlParser.moreData() &&\n            !ebmlParser.consumeTagAndSize(WebM.Segment.Info, true)) {\n            if (!(ebmlParser.skipOverElement(WebM.Segment.SeekHead, true) ||\n                    ebmlParser.skipOverElement(WebM.Segment.Tracks, true) ||\n                    ebmlParser.skipOverElement(WebM.Segment.Cues, true) ||\n                    ebmlParser.skipOverElement(WebM.Void, true))) {\n                throw new Error('no valid top level element found');\n            }\n        }\n\n        // we only need one thing in segment info, duration\n        while (duration === undefined) {\n            let infoTag = ebmlParser.getMatroskaCodedNum(true);\n            let infoElementSize = ebmlParser.getMatroskaCodedNum();\n\n            switch (infoTag) {\n                case WebM.Segment.Info.Duration.tag:\n                    duration = ebmlParser[WebM.Segment.Info.Duration.parse](infoElementSize);\n                    break;\n                default:\n                    ebmlParser.setPos(ebmlParser.getPos() + infoElementSize);\n                    break;\n            }\n        }\n\n        // once we have what we need from segment info, we jump right to the\n        // cues\n\n        request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            segments = parseSegments(response, segmentStart, segmentEnd, duration);\n            callback(segments);\n        };\n\n        const onloadend = function () {\n            logger.error('Download Error: Cues ' + info.url);\n            callback(null);\n        };\n\n        urlLoader.load({\n            request: request,\n            success: onload,\n            error: onloadend\n        });\n\n        logger.debug('Perform cues load: ' + info.url + ' bytes=' + info.range.start + '-' + info.range.end);\n    }\n\n    function checkConfig() {\n        if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function loadInitialization(streamId, mediaType, representation, loadingInfo) {\n        checkConfig();\n        let request = null;\n        let baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        let initRange = representation ? representation.range.split('-') : null;\n        let info = loadingInfo || {\n            range: {\n                start: initRange ? parseFloat(initRange[0]) : null,\n                end: initRange ? parseFloat(initRange[1]) : null\n            },\n            request: request,\n            url: baseUrl ? baseUrl.url : undefined,\n            init: true,\n            mediaType: mediaType\n        };\n\n        logger.info('Start loading initialization.');\n\n        request = getFragmentRequest(info);\n\n        const onload = function () {\n            // note that we don't explicitly set rep.initialization as this\n            // will be computed when all BaseURLs are resolved later\n            eventBus.trigger(events.INITIALIZATION_LOADED,\n                { representation: representation },\n                { streamId: streamId, mediaType: mediaType }\n            );\n        };\n\n        const onloadend = function () {\n            eventBus.trigger(events.INITIALIZATION_LOADED,\n                { representation: representation },\n                { streamId: streamId, mediaType: mediaType }\n            );\n        };\n\n        urlLoader.load({\n            request: request,\n            success: onload,\n            error: onloadend\n        });\n\n        logger.debug('Perform init load: ' + info.url);\n    }\n\n    function loadSegments(streamId, mediaType, representation, theRange, callback) {\n        checkConfig();\n        let request = null;\n        let baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        let media = baseUrl ? baseUrl.url : undefined;\n        let bytesToLoad = 8192;\n        let info = {\n            bytesLoaded: 0,\n            bytesToLoad: bytesToLoad,\n            range: {\n                start: 0,\n                end: bytesToLoad\n            },\n            request: request,\n            url: media,\n            init: false,\n            mediaType: mediaType\n        };\n\n        callback = !callback ? onLoaded : callback;\n        request = getFragmentRequest(info);\n\n        // first load the header, but preserve the manifest range so we can\n        // load the cues after parsing the header\n        // NOTE: we expect segment info to appear in the first 8192 bytes\n        logger.debug('Parsing ebml header');\n\n        const onload = function (response) {\n            parseEbmlHeader(response, media, theRange, function (segments) {\n                callback(streamId, mediaType, segments, representation);\n            });\n        };\n\n        const onloadend = function () {\n            callback(streamId, mediaType, null, representation);\n        };\n\n        urlLoader.load({\n            request: request,\n            success: onload,\n            error: onloadend\n        });\n    }\n\n    function onLoaded(streamId, mediaType, segments, representation) {\n        eventBus.trigger(events.SEGMENTS_LOADED,\n            {\n                segments: segments,\n                representation: representation,\n                error: segments ? undefined : new DashJSError(errors.SEGMENT_BASE_LOADER_ERROR_CODE, errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)\n            },\n            { streamId: streamId, mediaType: mediaType }\n        );\n    }\n\n    function getFragmentRequest(info) {\n        const request = new FragmentRequest();\n        request.setInfo(info);\n        return request;\n    }\n\n    function reset() {\n        errHandler = null;\n        requestModifier = null;\n    }\n\n    instance = {\n        setConfig: setConfig,\n        initialize: initialize,\n        loadInitialization: loadInitialization,\n        loadSegments: loadSegments,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nWebmSegmentBaseLoader.__dashjs_factory_name = 'WebmSegmentBaseLoader';\nexport default FactoryMaker.getSingletonFactory(WebmSegmentBaseLoader);\n"]},"metadata":{},"sourceType":"script"}