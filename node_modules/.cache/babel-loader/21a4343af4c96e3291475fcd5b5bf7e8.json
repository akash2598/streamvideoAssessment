{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MetricsConstants = require('../../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _SwitchRequest = require('../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _FactoryMaker = require('../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _HTTPRequest = require('../../vo/metrics/HTTPRequest');\n\nvar _EventBus = require('../../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Debug = require('../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Constants = require('../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2020, Unified Streaming.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n// For a description of the Learn2Adapt-LowLatency (L2A-LL) bitrate adaptation algorithm, see https://github.com/unifiedstreaming/Learn2Adapt-LowLatency/blob/master/Online_learning_for_bitrate_adaptation_in_low_latency_live_streaming_CR.pdf\n\n\nvar L2A_STATE_ONE_BITRATE = 0; // If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n\nvar L2A_STATE_STARTUP = 1; // Set placeholder buffer such that we download fragments at most recently measured throughput.\n\nvar L2A_STATE_STEADY = 2; // Buffer primed, we switch to steady operation.\n\nfunction L2ARule(config) {\n  config = config || {};\n  var context = this.context;\n  var dashMetrics = config.dashMetrics;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      l2AStateDict = void 0,\n      l2AParameterDict = void 0,\n      logger = void 0;\n  /**\n  * Setup function to initialize L2ARule\n  */\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n\n    _resetInitialSettings();\n\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n    eventBus.on(_Events2.default.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n    eventBus.on(_Events2.default.METRIC_ADDED, _onMetricAdded, instance);\n    eventBus.on(_Events2.default.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n  }\n  /**\n  * Sets the initial state of the algorithm. Calls the initialize function for the paramteters.\n  * @param {object} rulesContext\n  * @return {object} initialState\n  * @private\n  */\n\n\n  function _getInitialL2AState(rulesContext) {\n    var initialState = {};\n    var mediaInfo = rulesContext.getMediaInfo();\n    var bitrates = mediaInfo.bitrateList.map(function (b) {\n      return b.bandwidth / 1000;\n    });\n    initialState.state = L2A_STATE_STARTUP;\n    initialState.bitrates = bitrates;\n    initialState.lastQuality = 0;\n\n    _initializeL2AParameters(mediaInfo);\n\n    _clearL2AStateOnSeek(initialState);\n\n    return initialState;\n  }\n  /**\n  * Initializes the parameters of the algorithm. This will be done once for each media type.\n  * @param {object} mediaInfo\n  * @private\n  */\n\n\n  function _initializeL2AParameters(mediaInfo) {\n    if (!mediaInfo || !mediaInfo.type) {\n      return;\n    }\n\n    l2AParameterDict[mediaInfo.type] = {};\n    l2AParameterDict[mediaInfo.type].w = []; //Vector of probabilities associated with bitrate decisions\n\n    l2AParameterDict[mediaInfo.type].prev_w = []; //Vector of probabilities associated with bitrate decisions calculated in the previous step\n\n    l2AParameterDict[mediaInfo.type].Q = 0; //Initialization of Lagrangian multiplier (This keeps track of the buffer displacement)\n\n    l2AParameterDict[mediaInfo.type].segment_request_start_s = 0;\n    l2AParameterDict[mediaInfo.type].segment_download_finish_s = 0;\n    l2AParameterDict[mediaInfo.type].B_target = 1.5; //Target buffer level\n  }\n  /**\n      * Clears the state object\n      * @param {object} l2AState\n      * @private\n      */\n\n\n  function _clearL2AStateOnSeek(l2AState) {\n    l2AState.placeholderBuffer = 0;\n    l2AState.mostAdvancedSegmentStart = NaN;\n    l2AState.lastSegmentWasReplacement = false;\n    l2AState.lastSegmentStart = NaN;\n    l2AState.lastSegmentDurationS = NaN;\n    l2AState.lastSegmentRequestTimeMs = NaN;\n    l2AState.lastSegmentFinishTimeMs = NaN;\n  }\n  /**\n  * Returns the state object for a fiven media type. If the state object is not yet defined _getInitialL2AState is called\n  * @param {object} rulesContext\n  * @return {object} l2AState\n  * @private\n  */\n\n\n  function _getL2AState(rulesContext) {\n    var mediaType = rulesContext.getMediaType();\n    var l2AState = l2AStateDict[mediaType];\n\n    if (!l2AState) {\n      l2AState = _getInitialL2AState(rulesContext);\n      l2AStateDict[mediaType] = l2AState;\n    }\n\n    return l2AState;\n  }\n  /**\n  * Event handler for the seeking event.\n  * @private\n  */\n\n\n  function _onPlaybackSeeking() {\n    for (var mediaType in l2AStateDict) {\n      if (l2AStateDict.hasOwnProperty(mediaType)) {\n        var l2aState = l2AStateDict[mediaType];\n\n        if (l2aState.state !== L2A_STATE_ONE_BITRATE) {\n          l2aState.state = L2A_STATE_STARTUP;\n\n          _clearL2AStateOnSeek(l2aState);\n        }\n      }\n    }\n  }\n  /**\n  * Event handler for the mediaFragmentLoaded event\n  * @param {object} e\n  * @private\n  */\n\n\n  function _onMediaFragmentLoaded(e) {\n    if (e && e.chunk && e.chunk.mediaInfo) {\n      var l2AState = l2AStateDict[e.chunk.mediaInfo.type];\n      var l2AParameters = l2AParameterDict[e.chunk.mediaInfo.type];\n\n      if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n        var start = e.chunk.start;\n\n        if (isNaN(l2AState.mostAdvancedSegmentStart) || start > l2AState.mostAdvancedSegmentStart) {\n          l2AState.mostAdvancedSegmentStart = start;\n          l2AState.lastSegmentWasReplacement = false;\n        } else {\n          l2AState.lastSegmentWasReplacement = true;\n        }\n\n        l2AState.lastSegmentStart = start;\n        l2AState.lastSegmentDurationS = e.chunk.duration;\n        l2AState.lastQuality = e.chunk.quality;\n\n        _checkNewSegment(l2AState, l2AParameters);\n      }\n    }\n  }\n  /**\n  * Event handler for the metricAdded event\n  * @param {object} e\n  * @private\n  */\n\n\n  function _onMetricAdded(e) {\n    if (e && e.metric === _MetricsConstants2.default.HTTP_REQUEST && e.value && e.value.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n      var l2AState = l2AStateDict[e.mediaType];\n      var l2AParameters = l2AParameterDict[e.mediaType];\n\n      if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n        l2AState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n        l2AState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n        _checkNewSegment(l2AState, l2AParameters);\n      }\n    }\n  }\n  /**\n  * When a new metric has been added or a media fragment has been loaded the state is adjusted accordingly\n  * @param {object} L2AState\n  * @param {object} l2AParameters\n  * @private\n  */\n\n\n  function _checkNewSegment(L2AState, l2AParameters) {\n    if (!isNaN(L2AState.lastSegmentStart) && !isNaN(L2AState.lastSegmentRequestTimeMs)) {\n      l2AParameters.segment_request_start_s = 0.001 * L2AState.lastSegmentRequestTimeMs;\n      l2AParameters.segment_download_finish_s = 0.001 * L2AState.lastSegmentFinishTimeMs;\n      L2AState.lastSegmentStart = NaN;\n      L2AState.lastSegmentRequestTimeMs = NaN;\n    }\n  }\n  /**\n  * Event handler for the qualityChangeRequested event\n  * @param {object} e\n  * @private\n  */\n\n\n  function _onQualityChangeRequested(e) {\n    // Useful to store change requests when abandoning a download.\n    if (e && e.mediaType) {\n      var L2AState = l2AStateDict[e.mediaType];\n\n      if (L2AState && L2AState.state !== L2A_STATE_ONE_BITRATE) {\n        L2AState.abrQuality = e.newQuality;\n      }\n    }\n  }\n  /**\n  * Dot multiplication of two arrays\n  * @param {array} arr1\n  * @param {array} arr2\n  * @return {number} sumdot\n  * @private\n  */\n\n\n  function _dotmultiplication(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return -1;\n    }\n\n    var sumdot = 0;\n\n    for (var i = 0; i < arr1.length; i++) {\n      sumdot = sumdot + arr1[i] * arr2[i];\n    }\n\n    return sumdot;\n  }\n  /**\n  * Project an n-dim vector y to the simplex Dn\n  * Dn = { x : x n-dim, 1 >= x >= 0, sum(x) = 1}\n  * Algorithm is explained at http://arxiv.org/abs/1101.6081\n  * @param {array} arr\n  * @return {array}\n  */\n\n\n  function euclideanProjection(arr) {\n    var m = arr.length;\n    var bget = false;\n    var arr2 = [];\n\n    for (var ii = 0; ii < m; ++ii) {\n      arr2[ii] = arr[ii];\n    }\n\n    var s = arr.sort(function (a, b) {\n      return b - a;\n    });\n    var tmpsum = 0;\n    var tmax = 0;\n    var x = [];\n\n    for (var _ii = 0; _ii < m - 1; ++_ii) {\n      tmpsum = tmpsum + s[_ii];\n      tmax = (tmpsum - 1) / (_ii + 1);\n\n      if (tmax >= s[_ii + 1]) {\n        bget = true;\n        break;\n      }\n    }\n\n    if (!bget) {\n      tmax = (tmpsum + s[m - 1] - 1) / m;\n    }\n\n    for (var _ii2 = 0; _ii2 < m; ++_ii2) {\n      x[_ii2] = Math.max(arr2[_ii2] - tmax, 0);\n    }\n\n    return x;\n  }\n  /**\n  * Returns a switch request object indicating which quality is to be played\n  * @param {object} rulesContext\n  * @return {object}\n  */\n\n\n  function getMaxIndex(rulesContext) {\n    var switchRequest = (0, _SwitchRequest2.default)(context).create();\n    var horizon = 4; // Optimization horizon (The amount of steps required to achieve convergence)\n\n    var vl = Math.pow(horizon, 0.99); // Cautiousness parameter, used to control aggressiveness of the bitrate decision process.\n\n    var alpha = Math.max(Math.pow(horizon, 1), vl * Math.sqrt(horizon)); // Step size, used for gradient descent exploration granularity\n\n    var mediaInfo = rulesContext.getMediaInfo();\n    var mediaType = rulesContext.getMediaType();\n    var bitrates = mediaInfo.bitrateList.map(function (b) {\n      return b.bandwidth;\n    });\n    var bitrateCount = bitrates.length;\n    var scheduleController = rulesContext.getScheduleController();\n    var streamInfo = rulesContext.getStreamInfo();\n    var abrController = rulesContext.getAbrController();\n    var throughputHistory = abrController.getThroughputHistory();\n    var isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n    var useL2AABR = rulesContext.useL2AABR();\n    var bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n    var safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n    var throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic); // In kbits/s\n\n    var react = 2; // Reactiveness to volatility (abrupt throughput drops), used to re-calibrate Lagrangian multiplier Q\n\n    var latency = throughputHistory.getAverageLatency(mediaType);\n    var videoModel = rulesContext.getVideoModel();\n    var quality = void 0;\n    var currentPlaybackRate = videoModel.getPlaybackRate();\n\n    if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') || !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') || !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useL2AABR')) {\n      return switchRequest;\n    }\n\n    switchRequest.reason = switchRequest.reason || {};\n\n    if (!useL2AABR || mediaType === _Constants2.default.AUDIO) {\n      // L2A decides bitrate only for video. Audio to be included in decision process in a later stage\n      return switchRequest;\n    }\n\n    scheduleController.setTimeToLoadDelay(0);\n\n    var l2AState = _getL2AState(rulesContext);\n\n    if (l2AState.state === L2A_STATE_ONE_BITRATE) {\n      // shouldn't even have been called\n      return switchRequest;\n    }\n\n    var l2AParameter = l2AParameterDict[mediaType];\n\n    if (!l2AParameter) {\n      return switchRequest;\n    }\n\n    switchRequest.reason.state = l2AState.state;\n    switchRequest.reason.throughput = throughput;\n    switchRequest.reason.latency = latency;\n\n    if (isNaN(throughput)) {\n      // still starting up - not enough information\n      return switchRequest;\n    }\n\n    switch (l2AState.state) {\n      case L2A_STATE_STARTUP:\n        quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency); //During strat-up phase abr.controller is responsible for bitrate decisions.\n\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = safeThroughput;\n        l2AState.lastQuality = quality;\n\n        if (!isNaN(l2AState.lastSegmentDurationS) && bufferLevel >= l2AParameter.B_target) {\n          l2AState.state = L2A_STATE_STEADY;\n          l2AParameter.Q = vl; // Initialization of Q langrangian multiplier\n          // Update of probability vector w, to be used in main adaptation logic of L2A below (steady state)\n\n          for (var i = 0; i < bitrateCount; ++i) {\n            if (i === l2AState.lastQuality) {\n              l2AParameter.prev_w[i] = 1;\n            } else {\n              l2AParameter.prev_w[i] = 0;\n            }\n          }\n        }\n\n        break;\n      // L2A_STATE_STARTUP\n\n      case L2A_STATE_STEADY:\n        var diff1 = []; //Used to calculate the difference between consecutive decisions (w-w_prev)\n        // Manual calculation of latency and throughput during previous request\n\n        var throughputMeasureTime = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce(function (a, b) {\n          return a + b.d;\n        }, 0);\n        var downloadBytes = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce(function (a, b) {\n          return a + b.b[0];\n        }, 0);\n        var lastthroughput = Math.round(8 * downloadBytes / throughputMeasureTime); // bits/ms = kbits/s\n\n        if (lastthroughput < 1) {\n          lastthroughput = 1;\n        } //To avoid division with 0 (avoid infinity) in case of an absolute network outage\n\n\n        var V = l2AState.lastSegmentDurationS;\n        var sign = 1; //Main adaptation logic of L2A-LL\n\n        for (var _i = 0; _i < bitrateCount; ++_i) {\n          bitrates[_i] = bitrates[_i] / 1000; // Originally in bps, now in Kbps\n\n          if (currentPlaybackRate * bitrates[_i] > lastthroughput) {\n            // In this case buffer would deplete, leading to a stall, which increases latency and thus the particular probability of selsection of bitrate[i] should be decreased.\n            sign = -1;\n          } // The objective of L2A is to minimize the overall latency=request-response time + buffer length after download+ potential stalling (if buffer less than chunk downlad time)\n\n\n          l2AParameter.w[_i] = l2AParameter.prev_w[_i] + sign * (V / (2 * alpha)) * ((l2AParameter.Q + vl) * (currentPlaybackRate * bitrates[_i] / lastthroughput)); //Lagrangian descent\n        } // Apply euclidean projection on w to ensure w expresses a probability distribution\n\n\n        l2AParameter.w = euclideanProjection(l2AParameter.w);\n\n        for (var _i2 = 0; _i2 < bitrateCount; ++_i2) {\n          diff1[_i2] = l2AParameter.w[_i2] - l2AParameter.prev_w[_i2];\n          l2AParameter.prev_w[_i2] = l2AParameter.w[_i2];\n        } // Lagrangian multiplier Q calculation:\n\n\n        l2AParameter.Q = Math.max(0, l2AParameter.Q - V + V * currentPlaybackRate * ((_dotmultiplication(bitrates, l2AParameter.prev_w) + _dotmultiplication(bitrates, diff1)) / lastthroughput)); // Quality is calculated as argmin of the absolute difference between available bitrates (bitrates[i]) and bitrate estimation (dotmultiplication(w,bitrates)).\n\n        var temp = [];\n\n        for (var _i3 = 0; _i3 < bitrateCount; ++_i3) {\n          temp[_i3] = Math.abs(bitrates[_i3] - _dotmultiplication(l2AParameter.w, bitrates));\n        } // Quality is calculated based on the probability distribution w (the output of L2A)\n\n\n        quality = temp.indexOf(Math.min.apply(Math, temp)); // We employ a cautious -stepwise- ascent\n\n        if (quality > l2AState.lastQuality) {\n          if (bitrates[l2AState.lastQuality + 1] <= lastthroughput) {\n            quality = l2AState.lastQuality + 1;\n          }\n        } // Provision against bitrate over-estimation, by re-calibrating the Lagrangian multiplier Q, to be taken into account for the next chunk\n\n\n        if (bitrates[quality] >= lastthroughput) {\n          l2AParameter.Q = react * Math.max(vl, l2AParameter.Q);\n        }\n\n        switchRequest.quality = quality;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n        switchRequest.reason.bufferLevel = bufferLevel;\n        l2AState.lastQuality = switchRequest.quality;\n        break;\n\n      default:\n        // should not arrive here, try to recover\n        logger.debug('L2A ABR rule invoked in bad state.');\n        switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n        switchRequest.reason.state = l2AState.state;\n        switchRequest.reason.throughput = safeThroughput;\n        switchRequest.reason.latency = latency;\n        l2AState.state = L2A_STATE_STARTUP;\n\n        _clearL2AStateOnSeek(l2AState);\n\n    }\n\n    return switchRequest;\n  }\n  /**\n  * Reset objects to their initial state\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    l2AStateDict = {};\n    l2AParameterDict = {};\n  }\n  /**\n  * Reset the rule\n  */\n\n\n  function reset() {\n    _resetInitialSettings();\n\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n    eventBus.off(_Events2.default.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n    eventBus.off(_Events2.default.METRIC_ADDED, _onMetricAdded, instance);\n    eventBus.off(_Events2.default.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n  }\n\n  instance = {\n    getMaxIndex: getMaxIndex,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nL2ARule.__dashjs_factory_name = 'L2ARule';\nexports.default = _FactoryMaker2.default.getClassFactory(L2ARule);","map":{"version":3,"sources":["../../../../../../src/streaming/rules/abr/L2ARule.js"],"names":["L2A_STATE_ONE_BITRATE","L2A_STATE_STARTUP","L2A_STATE_STEADY","config","context","dashMetrics","eventBus","instance","l2AStateDict","l2AParameterDict","logger","_resetInitialSettings","Events","initialState","mediaInfo","rulesContext","bitrates","b","_initializeL2AParameters","_clearL2AStateOnSeek","l2AState","mediaType","_getInitialL2AState","l2aState","e","l2AParameters","start","isNaN","_checkNewSegment","MetricsConstants","HTTPRequest","L2AState","arr1","arr2","sumdot","i","m","arr","bget","ii","s","tmpsum","tmax","x","Math","switchRequest","horizon","vl","alpha","bitrateCount","scheduleController","streamInfo","abrController","throughputHistory","isDynamic","useL2AABR","bufferLevel","safeThroughput","throughput","react","latency","videoModel","quality","currentPlaybackRate","Constants","_getL2AState","l2AParameter","diff1","throughputMeasureTime","a","downloadBytes","lastthroughput","V","sign","euclideanProjection","_dotmultiplication","temp","getMaxIndex","reset","setup","L2ARule","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2020, Unified Streaming.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the Learn2Adapt-LowLatency (L2A-LL) bitrate adaptation algorithm, see https://github.com/unifiedstreaming/Learn2Adapt-LowLatency/blob/master/Online_learning_for_bitrate_adaptation_in_low_latency_live_streaming_CR.pdf\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\nimport Constants from '../../constants/Constants';\n\nconst L2A_STATE_ONE_BITRATE = 0; // If there is only one bitrate (or initialization failed), always return NO_CHANGE.\nconst L2A_STATE_STARTUP = 1; // Set placeholder buffer such that we download fragments at most recently measured throughput.\nconst L2A_STATE_STEADY = 2; // Buffer primed, we switch to steady operation.\n\n\nfunction L2ARule(config) {\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        l2AStateDict,\n        l2AParameterDict,\n        logger;\n\n    /**\n     * Setup function to initialize L2ARule\n     */\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    /**\n     * Sets the initial state of the algorithm. Calls the initialize function for the paramteters.\n     * @param {object} rulesContext\n     * @return {object} initialState\n     * @private\n     */\n    function _getInitialL2AState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map((b) => {\n            return b.bandwidth / 1000;\n        });\n\n        initialState.state = L2A_STATE_STARTUP;\n        initialState.bitrates = bitrates;\n        initialState.lastQuality = 0;\n\n        _initializeL2AParameters(mediaInfo);\n        _clearL2AStateOnSeek(initialState);\n\n        return initialState;\n    }\n\n    /**\n     * Initializes the parameters of the algorithm. This will be done once for each media type.\n     * @param {object} mediaInfo\n     * @private\n     */\n    function _initializeL2AParameters(mediaInfo) {\n\n        if (!mediaInfo || !mediaInfo.type) {\n            return;\n        }\n        l2AParameterDict[mediaInfo.type] = {};\n        l2AParameterDict[mediaInfo.type].w = []; //Vector of probabilities associated with bitrate decisions\n        l2AParameterDict[mediaInfo.type].prev_w = []; //Vector of probabilities associated with bitrate decisions calculated in the previous step\n        l2AParameterDict[mediaInfo.type].Q = 0; //Initialization of Lagrangian multiplier (This keeps track of the buffer displacement)\n        l2AParameterDict[mediaInfo.type].segment_request_start_s = 0;\n        l2AParameterDict[mediaInfo.type].segment_download_finish_s = 0;\n        l2AParameterDict[mediaInfo.type].B_target = 1.5; //Target buffer level\n    }\n\n\n    /**\n     * Clears the state object\n     * @param {object} l2AState\n     * @private\n     */\n    function _clearL2AStateOnSeek(l2AState) {\n        l2AState.placeholderBuffer = 0;\n        l2AState.mostAdvancedSegmentStart = NaN;\n        l2AState.lastSegmentWasReplacement = false;\n        l2AState.lastSegmentStart = NaN;\n        l2AState.lastSegmentDurationS = NaN;\n        l2AState.lastSegmentRequestTimeMs = NaN;\n        l2AState.lastSegmentFinishTimeMs = NaN;\n    }\n\n\n    /**\n     * Returns the state object for a fiven media type. If the state object is not yet defined _getInitialL2AState is called\n     * @param {object} rulesContext\n     * @return {object} l2AState\n     * @private\n     */\n    function _getL2AState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let l2AState = l2AStateDict[mediaType];\n\n        if (!l2AState) {\n            l2AState = _getInitialL2AState(rulesContext);\n            l2AStateDict[mediaType] = l2AState;\n        }\n\n        return l2AState;\n    }\n\n    /**\n     * Event handler for the seeking event.\n     * @private\n     */\n    function _onPlaybackSeeking() {\n        for (const mediaType in l2AStateDict) {\n            if (l2AStateDict.hasOwnProperty(mediaType)) {\n                const l2aState = l2AStateDict[mediaType];\n                if (l2aState.state !== L2A_STATE_ONE_BITRATE) {\n                    l2aState.state = L2A_STATE_STARTUP;\n                    _clearL2AStateOnSeek(l2aState);\n                }\n            }\n        }\n    }\n\n    /**\n     * Event handler for the mediaFragmentLoaded event\n     * @param {object} e\n     * @private\n     */\n    function _onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const l2AState = l2AStateDict[e.chunk.mediaInfo.type];\n            const l2AParameters = l2AParameterDict[e.chunk.mediaInfo.type];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(l2AState.mostAdvancedSegmentStart) || start > l2AState.mostAdvancedSegmentStart) {\n                    l2AState.mostAdvancedSegmentStart = start;\n                    l2AState.lastSegmentWasReplacement = false;\n                } else {\n                    l2AState.lastSegmentWasReplacement = true;\n                }\n\n                l2AState.lastSegmentStart = start;\n                l2AState.lastSegmentDurationS = e.chunk.duration;\n                l2AState.lastQuality = e.chunk.quality;\n\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * Event handler for the metricAdded event\n     * @param {object} e\n     * @private\n     */\n    function _onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const l2AState = l2AStateDict[e.mediaType];\n            const l2AParameters = l2AParameterDict[e.mediaType];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                l2AState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                l2AState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * When a new metric has been added or a media fragment has been loaded the state is adjusted accordingly\n     * @param {object} L2AState\n     * @param {object} l2AParameters\n     * @private\n     */\n    function _checkNewSegment(L2AState, l2AParameters) {\n        if (!isNaN(L2AState.lastSegmentStart) && !isNaN(L2AState.lastSegmentRequestTimeMs)) {\n            l2AParameters.segment_request_start_s = 0.001 * L2AState.lastSegmentRequestTimeMs;\n            l2AParameters.segment_download_finish_s = 0.001 * L2AState.lastSegmentFinishTimeMs;\n            L2AState.lastSegmentStart = NaN;\n            L2AState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    /**\n     * Event handler for the qualityChangeRequested event\n     * @param {object} e\n     * @private\n     */\n    function _onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e && e.mediaType) {\n            const L2AState = l2AStateDict[e.mediaType];\n            if (L2AState && L2AState.state !== L2A_STATE_ONE_BITRATE) {\n                L2AState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    /**\n     * Dot multiplication of two arrays\n     * @param {array} arr1\n     * @param {array} arr2\n     * @return {number} sumdot\n     * @private\n     */\n\n    function _dotmultiplication(arr1, arr2) {\n        if (arr1.length !== arr2.length) {\n            return -1;\n        }\n        let sumdot = 0;\n        for (let i = 0; i < arr1.length; i++) {\n            sumdot = sumdot + arr1[i] * arr2[i];\n        }\n        return sumdot;\n    }\n\n    /**\n     * Project an n-dim vector y to the simplex Dn\n     * Dn = { x : x n-dim, 1 >= x >= 0, sum(x) = 1}\n     * Algorithm is explained at http://arxiv.org/abs/1101.6081\n     * @param {array} arr\n     * @return {array}\n     */\n    function euclideanProjection(arr) {\n        const m = arr.length;\n        let bget = false;\n        let arr2 = [];\n        for (let ii = 0; ii < m; ++ii) {\n            arr2[ii] = arr[ii];\n        }\n        let s = arr.sort(function (a, b) {\n            return b - a;\n        });\n        let tmpsum = 0;\n        let tmax = 0;\n        let x = [];\n        for (let ii = 0; ii < m - 1; ++ii) {\n            tmpsum = tmpsum + s[ii];\n            tmax = (tmpsum - 1) / (ii + 1);\n            if (tmax >= s[ii + 1]) {\n                bget = true;\n                break;\n            }\n        }\n        if (!bget) {\n            tmax = (tmpsum + s[m - 1] - 1) / m;\n        }\n        for (let ii = 0; ii < m; ++ii) {\n            x[ii] = Math.max(arr2[ii] - tmax, 0);\n        }\n        return x;\n    }\n\n    /**\n     * Returns a switch request object indicating which quality is to be played\n     * @param {object} rulesContext\n     * @return {object}\n     */\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n        const horizon = 4; // Optimization horizon (The amount of steps required to achieve convergence)\n        const vl = Math.pow(horizon, 0.99);// Cautiousness parameter, used to control aggressiveness of the bitrate decision process.\n        const alpha = Math.max(Math.pow(horizon, 1), vl * Math.sqrt(horizon));// Step size, used for gradient descent exploration granularity\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        const bitrateCount = bitrates.length;\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useL2AABR = rulesContext.useL2AABR();\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic); // In kbits/s\n        const react = 2; // Reactiveness to volatility (abrupt throughput drops), used to re-calibrate Lagrangian multiplier Q\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        const videoModel = rulesContext.getVideoModel();\n        let quality;\n        let currentPlaybackRate = videoModel.getPlaybackRate();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useL2AABR')) {\n            return switchRequest;\n        }\n\n        switchRequest.reason = switchRequest.reason || {};\n\n        if ((!useL2AABR) || (mediaType === Constants.AUDIO)) {// L2A decides bitrate only for video. Audio to be included in decision process in a later stage\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const l2AState = _getL2AState(rulesContext);\n\n        if (l2AState.state === L2A_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const l2AParameter = l2AParameterDict[mediaType];\n\n        if (!l2AParameter) {\n            return switchRequest;\n        }\n\n        switchRequest.reason.state = l2AState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) {\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (l2AState.state) {\n            case L2A_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);//During strat-up phase abr.controller is responsible for bitrate decisions.\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n                l2AState.lastQuality = quality;\n\n                if (!isNaN(l2AState.lastSegmentDurationS) && bufferLevel >= l2AParameter.B_target) {\n                    l2AState.state = L2A_STATE_STEADY;\n                    l2AParameter.Q = vl;// Initialization of Q langrangian multiplier\n                    // Update of probability vector w, to be used in main adaptation logic of L2A below (steady state)\n                    for (let i = 0; i < bitrateCount; ++i) {\n                        if (i === l2AState.lastQuality) {\n                            l2AParameter.prev_w[i] = 1;\n                        } else {\n                            l2AParameter.prev_w[i] = 0;\n                        }\n                    }\n                }\n\n                break; // L2A_STATE_STARTUP\n            case L2A_STATE_STEADY:\n                let diff1 = [];//Used to calculate the difference between consecutive decisions (w-w_prev)\n\n                // Manual calculation of latency and throughput during previous request\n                let throughputMeasureTime = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.d, 0);\n                const downloadBytes = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.b[0], 0);\n                let lastthroughput = Math.round((8 * downloadBytes) / throughputMeasureTime); // bits/ms = kbits/s\n\n                if (lastthroughput < 1) {\n                    lastthroughput = 1;\n                }//To avoid division with 0 (avoid infinity) in case of an absolute network outage\n\n                let V = l2AState.lastSegmentDurationS;\n                let sign = 1;\n\n                //Main adaptation logic of L2A-LL\n                for (let i = 0; i < bitrateCount; ++i) {\n                    bitrates[i] = bitrates[i] / 1000; // Originally in bps, now in Kbps\n                    if (currentPlaybackRate * bitrates[i] > lastthroughput) {// In this case buffer would deplete, leading to a stall, which increases latency and thus the particular probability of selsection of bitrate[i] should be decreased.\n                        sign = -1;\n                    }\n                    // The objective of L2A is to minimize the overall latency=request-response time + buffer length after download+ potential stalling (if buffer less than chunk downlad time)\n                    l2AParameter.w[i] = l2AParameter.prev_w[i] + sign * (V / (2 * alpha)) * ((l2AParameter.Q + vl) * (currentPlaybackRate * bitrates[i] / lastthroughput));//Lagrangian descent\n                }\n\n                // Apply euclidean projection on w to ensure w expresses a probability distribution\n                l2AParameter.w = euclideanProjection(l2AParameter.w);\n\n                for (let i = 0; i < bitrateCount; ++i) {\n                    diff1[i] = l2AParameter.w[i] - l2AParameter.prev_w[i];\n                    l2AParameter.prev_w[i] = l2AParameter.w[i];\n                }\n\n                // Lagrangian multiplier Q calculation:\n                l2AParameter.Q = Math.max(0, l2AParameter.Q - V + V * currentPlaybackRate * ((_dotmultiplication(bitrates, l2AParameter.prev_w) + _dotmultiplication(bitrates, diff1)) / lastthroughput));\n\n                // Quality is calculated as argmin of the absolute difference between available bitrates (bitrates[i]) and bitrate estimation (dotmultiplication(w,bitrates)).\n                let temp = [];\n                for (let i = 0; i < bitrateCount; ++i) {\n                    temp[i] = Math.abs(bitrates[i] - _dotmultiplication(l2AParameter.w, bitrates));\n                }\n\n                // Quality is calculated based on the probability distribution w (the output of L2A)\n                quality = temp.indexOf(Math.min(...temp));\n\n                // We employ a cautious -stepwise- ascent\n                if (quality > l2AState.lastQuality) {\n                    if (bitrates[l2AState.lastQuality + 1] <= lastthroughput) {\n                        quality = l2AState.lastQuality + 1;\n                    }\n                }\n\n                // Provision against bitrate over-estimation, by re-calibrating the Lagrangian multiplier Q, to be taken into account for the next chunk\n                if (bitrates[quality] >= lastthroughput) {\n                    l2AParameter.Q = react * Math.max(vl, l2AParameter.Q);\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                l2AState.lastQuality = switchRequest.quality;\n                break;\n            default:\n                // should not arrive here, try to recover\n                logger.debug('L2A ABR rule invoked in bad state.');\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = l2AState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                l2AState.state = L2A_STATE_STARTUP;\n                _clearL2AStateOnSeek(l2AState);\n        }\n        return switchRequest;\n    }\n\n    /**\n     * Reset objects to their initial state\n     * @private\n     */\n    function _resetInitialSettings() {\n        l2AStateDict = {};\n        l2AParameterDict = {};\n    }\n\n    /**\n     * Reset the rule\n     */\n    function reset() {\n        _resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nL2ARule.__dashjs_factory_name = 'L2ARule';\nexport default FactoryMaker.getClassFactory(L2ARule);\n"]},"metadata":{},"sourceType":"script"}