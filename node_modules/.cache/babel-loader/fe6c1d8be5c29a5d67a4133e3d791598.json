{"ast":null,"code":"/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\n\n/**\r\n * @module imscDoc\r\n */\n;\n\n(function (imscDoc, sax, imscNames, imscStyles, imscUtils) {\n  /**\r\n   * Allows a client to provide callbacks to handle children of the <metadata> element\r\n   * @typedef {Object} MetadataHandler\r\n   * @property {?OpenTagCallBack} onOpenTag\r\n   * @property {?CloseTagCallBack} onCloseTag\r\n   * @property {?TextCallBack} onText\r\n   */\n\n  /**\r\n   * Called when the opening tag of an element node is encountered.\r\n   * @callback OpenTagCallBack\r\n   * @param {string} ns Namespace URI of the element\r\n   * @param {string} name Local name of the element\r\n   * @param {Object[]} attributes List of attributes, each consisting of a\r\n   *                              `uri`, `name` and `value`\r\n   */\n\n  /**\r\n   * Called when the closing tag of an element node is encountered.\r\n   * @callback CloseTagCallBack\r\n   */\n\n  /**\r\n   * Called when a text node is encountered.\r\n   * @callback TextCallBack\r\n   * @param {string} contents Contents of the text node\r\n   */\n\n  /**\r\n   * Parses an IMSC1 document into an opaque in-memory representation that exposes\r\n   * a single method <pre>getMediaTimeEvents()</pre> that returns a list of time\r\n   * offsets (in seconds) of the ISD, i.e. the points in time where the visual\r\n   * representation of the document change. `metadataHandler` allows the caller to\r\n   * be called back when nodes are present in <metadata> elements. \r\n   * \r\n   * @param {string} xmlstring XML document\r\n   * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n   * @param {?MetadataHandler} metadataHandler Callback for <Metadata> elements\r\n   * @returns {Object} Opaque in-memory representation of an IMSC1 document\r\n   */\n  imscDoc.fromXML = function (xmlstring, errorHandler, metadataHandler) {\n    var p = sax.parser(true, {\n      xmlns: true\n    });\n    var estack = [];\n    var xmllangstack = [];\n    var xmlspacestack = [];\n    var metadata_depth = 0;\n    var doc = null;\n\n    p.onclosetag = function (node) {\n      if (estack[0] instanceof Region) {\n        /* merge referenced styles */\n        if (doc.head !== null && doc.head.styling !== null) {\n          mergeReferencedStyles(doc.head.styling, estack[0].styleRefs, estack[0].styleAttrs, errorHandler);\n        }\n\n        delete estack[0].styleRefs;\n      } else if (estack[0] instanceof Styling) {\n        /* flatten chained referential styling */\n        for (var sid in estack[0].styles) {\n          mergeChainedStyles(estack[0], estack[0].styles[sid], errorHandler);\n        }\n      } else if (estack[0] instanceof P || estack[0] instanceof Span) {\n        /* merge anonymous spans */\n        if (estack[0].contents.length > 1) {\n          var cs = [estack[0].contents[0]];\n          var c;\n\n          for (c = 1; c < estack[0].contents.length; c++) {\n            if (estack[0].contents[c] instanceof AnonymousSpan && cs[cs.length - 1] instanceof AnonymousSpan) {\n              cs[cs.length - 1].text += estack[0].contents[c].text;\n            } else {\n              cs.push(estack[0].contents[c]);\n            }\n          }\n\n          estack[0].contents = cs;\n        } // remove redundant nested anonymous spans (9.3.3(1)(c))\n\n\n        if (estack[0] instanceof Span && estack[0].contents.length === 1 && estack[0].contents[0] instanceof AnonymousSpan) {\n          estack[0].text = estack[0].contents[0].text;\n          delete estack[0].contents;\n        }\n      } else if (estack[0] instanceof ForeignElement) {\n        if (estack[0].node.uri === imscNames.ns_tt && estack[0].node.local === 'metadata') {\n          /* leave the metadata element */\n          metadata_depth--;\n        } else if (metadata_depth > 0 && metadataHandler && 'onCloseTag' in metadataHandler) {\n          /* end of child of metadata element */\n          metadataHandler.onCloseTag();\n        }\n      } // TODO: delete stylerefs?\n      // maintain the xml:space stack\n\n\n      xmlspacestack.shift(); // maintain the xml:lang stack\n\n      xmllangstack.shift(); // prepare for the next element\n\n      estack.shift();\n    };\n\n    p.ontext = function (str) {\n      if (estack[0] === undefined) {\n        /* ignoring text outside of elements */\n      } else if (estack[0] instanceof Span || estack[0] instanceof P) {\n        /* ignore children text nodes in ruby container spans */\n        if (estack[0] instanceof Span) {\n          var ruby = estack[0].styleAttrs[imscStyles.byName.ruby.qname];\n\n          if (ruby === 'container' || ruby === 'textContainer' || ruby === 'baseContainer') {\n            return;\n          }\n        }\n        /* create an anonymous span */\n\n\n        var s = new AnonymousSpan();\n        s.initFromText(doc, estack[0], str, xmllangstack[0], xmlspacestack[0], errorHandler);\n        estack[0].contents.push(s);\n      } else if (estack[0] instanceof ForeignElement && metadata_depth > 0 && metadataHandler && 'onText' in metadataHandler) {\n        /* text node within a child of metadata element */\n        metadataHandler.onText(str);\n      }\n    };\n\n    p.onopentag = function (node) {\n      // maintain the xml:space stack\n      var xmlspace = node.attributes[\"xml:space\"];\n\n      if (xmlspace) {\n        xmlspacestack.unshift(xmlspace.value);\n      } else {\n        if (xmlspacestack.length === 0) {\n          xmlspacestack.unshift(\"default\");\n        } else {\n          xmlspacestack.unshift(xmlspacestack[0]);\n        }\n      }\n      /* maintain the xml:lang stack */\n\n\n      var xmllang = node.attributes[\"xml:lang\"];\n\n      if (xmllang) {\n        xmllangstack.unshift(xmllang.value);\n      } else {\n        if (xmllangstack.length === 0) {\n          xmllangstack.unshift(\"\");\n        } else {\n          xmllangstack.unshift(xmllangstack[0]);\n        }\n      }\n      /* process the element */\n\n\n      if (node.uri === imscNames.ns_tt) {\n        if (node.local === 'tt') {\n          if (doc !== null) {\n            reportFatal(errorHandler, \"Two <tt> elements at (\" + this.line + \",\" + this.column + \")\");\n          }\n\n          doc = new TT();\n          doc.initFromNode(node, xmllangstack[0], errorHandler);\n          estack.unshift(doc);\n        } else if (node.local === 'head') {\n          if (!(estack[0] instanceof TT)) {\n            reportFatal(errorHandler, \"Parent of <head> element is not <tt> at (\" + this.line + \",\" + this.column + \")\");\n          }\n\n          estack.unshift(doc.head);\n        } else if (node.local === 'styling') {\n          if (!(estack[0] instanceof Head)) {\n            reportFatal(errorHandler, \"Parent of <styling> element is not <head> at (\" + this.line + \",\" + this.column + \")\");\n          }\n\n          estack.unshift(doc.head.styling);\n        } else if (node.local === 'style') {\n          var s;\n\n          if (estack[0] instanceof Styling) {\n            s = new Style();\n            s.initFromNode(node, errorHandler);\n            /* ignore <style> element missing @id */\n\n            if (!s.id) {\n              reportError(errorHandler, \"<style> element missing @id attribute\");\n            } else {\n              doc.head.styling.styles[s.id] = s;\n            }\n\n            estack.unshift(s);\n          } else if (estack[0] instanceof Region) {\n            /* nested styles can be merged with specified styles\r\n             * immediately, with lower priority\r\n             * (see 8.4.4.2(3) at TTML1 )\r\n             */\n            s = new Style();\n            s.initFromNode(node, errorHandler);\n            mergeStylesIfNotPresent(s.styleAttrs, estack[0].styleAttrs);\n            estack.unshift(s);\n          } else {\n            reportFatal(errorHandler, \"Parent of <style> element is not <styling> or <region> at (\" + this.line + \",\" + this.column + \")\");\n          }\n        } else if (node.local === 'initial') {\n          var ini;\n\n          if (estack[0] instanceof Styling) {\n            ini = new Initial();\n            ini.initFromNode(node, errorHandler);\n\n            for (var qn in ini.styleAttrs) {\n              doc.head.styling.initials[qn] = ini.styleAttrs[qn];\n            }\n\n            estack.unshift(ini);\n          } else {\n            reportFatal(errorHandler, \"Parent of <initial> element is not <styling> at (\" + this.line + \",\" + this.column + \")\");\n          }\n        } else if (node.local === 'layout') {\n          if (!(estack[0] instanceof Head)) {\n            reportFatal(errorHandler, \"Parent of <layout> element is not <head> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          estack.unshift(doc.head.layout);\n        } else if (node.local === 'region') {\n          if (!(estack[0] instanceof Layout)) {\n            reportFatal(errorHandler, \"Parent of <region> element is not <layout> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var r = new Region();\n          r.initFromNode(doc, node, xmllangstack[0], errorHandler);\n\n          if (!r.id || r.id in doc.head.layout.regions) {\n            reportError(errorHandler, \"Ignoring <region> with duplicate or missing @id at \" + this.line + \",\" + this.column + \")\");\n          } else {\n            doc.head.layout.regions[r.id] = r;\n          }\n\n          estack.unshift(r);\n        } else if (node.local === 'body') {\n          if (!(estack[0] instanceof TT)) {\n            reportFatal(errorHandler, \"Parent of <body> element is not <tt> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          if (doc.body !== null) {\n            reportFatal(errorHandler, \"Second <body> element at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var b = new Body();\n          b.initFromNode(doc, node, xmllangstack[0], errorHandler);\n          doc.body = b;\n          estack.unshift(b);\n        } else if (node.local === 'div') {\n          if (!(estack[0] instanceof Div || estack[0] instanceof Body)) {\n            reportFatal(errorHandler, \"Parent of <div> element is not <body> or <div> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var d = new Div();\n          d.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          /* transform smpte:backgroundImage to TTML2 image element */\n\n          var bi = d.styleAttrs[imscStyles.byName.backgroundImage.qname];\n\n          if (bi) {\n            d.contents.push(new Image(bi));\n            delete d.styleAttrs[imscStyles.byName.backgroundImage.qname];\n          }\n\n          estack[0].contents.push(d);\n          estack.unshift(d);\n        } else if (node.local === 'image') {\n          if (!(estack[0] instanceof Div)) {\n            reportFatal(errorHandler, \"Parent of <image> element is not <div> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var img = new Image();\n          img.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          estack[0].contents.push(img);\n          estack.unshift(img);\n        } else if (node.local === 'p') {\n          if (!(estack[0] instanceof Div)) {\n            reportFatal(errorHandler, \"Parent of <p> element is not <div> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var p = new P();\n          p.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          estack[0].contents.push(p);\n          estack.unshift(p);\n        } else if (node.local === 'span') {\n          if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\n            reportFatal(errorHandler, \"Parent of <span> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var ns = new Span();\n          ns.initFromNode(doc, estack[0], node, xmllangstack[0], xmlspacestack[0], errorHandler);\n          estack[0].contents.push(ns);\n          estack.unshift(ns);\n        } else if (node.local === 'br') {\n          if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\n            reportFatal(errorHandler, \"Parent of <br> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var nb = new Br();\n          nb.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\n          estack[0].contents.push(nb);\n          estack.unshift(nb);\n        } else if (node.local === 'set') {\n          if (!(estack[0] instanceof Span || estack[0] instanceof P || estack[0] instanceof Div || estack[0] instanceof Body || estack[0] instanceof Region || estack[0] instanceof Br)) {\n            reportFatal(errorHandler, \"Parent of <set> element is not a content element or a region at \" + this.line + \",\" + this.column + \")\");\n          }\n\n          var st = new Set();\n          st.initFromNode(doc, estack[0], node, errorHandler);\n          estack[0].sets.push(st);\n          estack.unshift(st);\n        } else {\n          /* element in the TT namespace, but not a content element */\n          estack.unshift(new ForeignElement(node));\n        }\n      } else {\n        /* ignore elements not in the TTML namespace unless in metadata element */\n        estack.unshift(new ForeignElement(node));\n      }\n      /* handle metadata callbacks */\n\n\n      if (estack[0] instanceof ForeignElement) {\n        if (node.uri === imscNames.ns_tt && node.local === 'metadata') {\n          /* enter the metadata element */\n          metadata_depth++;\n        } else if (metadata_depth > 0 && metadataHandler && 'onOpenTag' in metadataHandler) {\n          /* start of child of metadata element */\n          var attrs = [];\n\n          for (var a in node.attributes) {\n            attrs[node.attributes[a].uri + \" \" + node.attributes[a].local] = {\n              uri: node.attributes[a].uri,\n              local: node.attributes[a].local,\n              value: node.attributes[a].value\n            };\n          }\n\n          metadataHandler.onOpenTag(node.uri, node.local, attrs);\n        }\n      }\n    }; // parse the document\n\n\n    p.write(xmlstring).close(); // all referential styling has been flatten, so delete styles\n\n    delete doc.head.styling.styles; // create default region if no regions specified\n\n    var hasRegions = false;\n    /* AFAIK the only way to determine whether an object has members */\n\n    for (var i in doc.head.layout.regions) {\n      hasRegions = true;\n      break;\n    }\n\n    if (!hasRegions) {\n      /* create default region */\n      var dr = Region.prototype.createDefaultRegion(doc.lang);\n      doc.head.layout.regions[dr.id] = dr;\n    }\n    /* resolve desired timing for regions */\n\n\n    for (var region_i in doc.head.layout.regions) {\n      resolveTiming(doc, doc.head.layout.regions[region_i], null, null);\n    }\n    /* resolve desired timing for content elements */\n\n\n    if (doc.body) {\n      resolveTiming(doc, doc.body, null, null);\n    }\n    /* remove undefined spans in ruby containers */\n\n\n    if (doc.body) {\n      cleanRubyContainers(doc.body);\n    }\n\n    return doc;\n  };\n\n  function cleanRubyContainers(element) {\n    if (!('contents' in element)) return;\n    var rubyval = 'styleAttrs' in element ? element.styleAttrs[imscStyles.byName.ruby.qname] : null;\n    var isrubycontainer = element.kind === 'span' && (rubyval === \"container\" || rubyval === \"textContainer\" || rubyval === \"baseContainer\");\n\n    for (var i = element.contents.length - 1; i >= 0; i--) {\n      if (isrubycontainer && !('styleAttrs' in element.contents[i] && imscStyles.byName.ruby.qname in element.contents[i].styleAttrs)) {\n        /* prune undefined <span> in ruby containers */\n        delete element.contents[i];\n      } else {\n        cleanRubyContainers(element.contents[i]);\n      }\n    }\n  }\n\n  function resolveTiming(doc, element, prev_sibling, parent) {\n    /* are we in a seq container? */\n    var isinseq = parent && parent.timeContainer === \"seq\";\n    /* determine implicit begin */\n\n    var implicit_begin = 0;\n    /* default */\n\n    if (parent) {\n      if (isinseq && prev_sibling) {\n        /*\r\n         * if seq time container, offset from the previous sibling end\r\n         */\n        implicit_begin = prev_sibling.end;\n      } else {\n        implicit_begin = parent.begin;\n      }\n    }\n    /* compute desired begin */\n\n\n    element.begin = element.explicit_begin ? element.explicit_begin + implicit_begin : implicit_begin;\n    /* determine implicit end */\n\n    var implicit_end = element.begin;\n    var s = null;\n\n    for (var set_i in element.sets) {\n      resolveTiming(doc, element.sets[set_i], s, element);\n\n      if (element.timeContainer === \"seq\") {\n        implicit_end = element.sets[set_i].end;\n      } else {\n        implicit_end = Math.max(implicit_end, element.sets[set_i].end);\n      }\n\n      s = element.sets[set_i];\n    }\n\n    if (!('contents' in element)) {\n      /* anonymous spans and regions and <set> and <br>s and spans with only children text nodes */\n      if (isinseq) {\n        /* in seq container, implicit duration is zero */\n        implicit_end = element.begin;\n      } else {\n        /* in par container, implicit duration is indefinite */\n        implicit_end = Number.POSITIVE_INFINITY;\n      }\n    } else {\n      for (var content_i in element.contents) {\n        resolveTiming(doc, element.contents[content_i], s, element);\n\n        if (element.timeContainer === \"seq\") {\n          implicit_end = element.contents[content_i].end;\n        } else {\n          implicit_end = Math.max(implicit_end, element.contents[content_i].end);\n        }\n\n        s = element.contents[content_i];\n      }\n    }\n    /* determine desired end */\n\n    /* it is never made really clear in SMIL that the explicit end is offset by the implicit begin */\n\n\n    if (element.explicit_end !== null && element.explicit_dur !== null) {\n      element.end = Math.min(element.begin + element.explicit_dur, implicit_begin + element.explicit_end);\n    } else if (element.explicit_end === null && element.explicit_dur !== null) {\n      element.end = element.begin + element.explicit_dur;\n    } else if (element.explicit_end !== null && element.explicit_dur === null) {\n      element.end = implicit_begin + element.explicit_end;\n    } else {\n      element.end = implicit_end;\n    }\n\n    delete element.explicit_begin;\n    delete element.explicit_dur;\n    delete element.explicit_end;\n\n    doc._registerEvent(element);\n  }\n\n  function ForeignElement(node) {\n    this.node = node;\n  }\n\n  function TT() {\n    this.events = [];\n    this.head = new Head();\n    this.body = null;\n  }\n\n  TT.prototype.initFromNode = function (node, xmllang, errorHandler) {\n    /* compute cell resolution */\n    var cr = extractCellResolution(node, errorHandler);\n    this.cellLength = {\n      'h': new imscUtils.ComputedLength(0, 1 / cr.h),\n      'w': new imscUtils.ComputedLength(1 / cr.w, 0)\n    };\n    /* extract frame rate and tick rate */\n\n    var frtr = extractFrameAndTickRate(node, errorHandler);\n    this.effectiveFrameRate = frtr.effectiveFrameRate;\n    this.tickRate = frtr.tickRate;\n    /* extract aspect ratio */\n\n    this.aspectRatio = extractAspectRatio(node, errorHandler);\n    /* check timebase */\n\n    var attr = findAttribute(node, imscNames.ns_ttp, \"timeBase\");\n\n    if (attr !== null && attr !== \"media\") {\n      reportFatal(errorHandler, \"Unsupported time base\");\n    }\n    /* retrieve extent */\n\n\n    var e = extractExtent(node, errorHandler);\n\n    if (e === null) {\n      this.pxLength = {\n        'h': null,\n        'w': null\n      };\n    } else {\n      if (e.h.unit !== \"px\" || e.w.unit !== \"px\") {\n        reportFatal(errorHandler, \"Extent on TT must be in px or absent\");\n      }\n\n      this.pxLength = {\n        'h': new imscUtils.ComputedLength(0, 1 / e.h.value),\n        'w': new imscUtils.ComputedLength(1 / e.w.value, 0)\n      };\n    }\n    /** set root container dimensions to (1, 1) arbitrarily\r\n      * the root container is mapped to actual dimensions at rendering\r\n    **/\n\n\n    this.dimensions = {\n      'h': new imscUtils.ComputedLength(0, 1),\n      'w': new imscUtils.ComputedLength(1, 0)\n    };\n    /* xml:lang */\n\n    this.lang = xmllang;\n  };\n  /* register a temporal events */\n\n\n  TT.prototype._registerEvent = function (elem) {\n    /* skip if begin is not < then end */\n    if (elem.end <= elem.begin) return;\n    /* index the begin time of the event */\n\n    var b_i = indexOf(this.events, elem.begin);\n\n    if (!b_i.found) {\n      this.events.splice(b_i.index, 0, elem.begin);\n    }\n    /* index the end time of the event */\n\n\n    if (elem.end !== Number.POSITIVE_INFINITY) {\n      var e_i = indexOf(this.events, elem.end);\n\n      if (!e_i.found) {\n        this.events.splice(e_i.index, 0, elem.end);\n      }\n    }\n  };\n  /*\r\n   * Retrieves the range of ISD times covered by the document\r\n   * \r\n   * @returns {Array} Array of two elements: min_begin_time and max_begin_time\r\n   * \r\n   */\n\n\n  TT.prototype.getMediaTimeRange = function () {\n    return [this.events[0], this.events[this.events.length - 1]];\n  };\n  /*\r\n   * Returns list of ISD begin times  \r\n   * \r\n   * @returns {Array}\r\n   */\n\n\n  TT.prototype.getMediaTimeEvents = function () {\n    return this.events;\n  };\n  /*\r\n   * Represents a TTML Head element\r\n   */\n\n\n  function Head() {\n    this.styling = new Styling();\n    this.layout = new Layout();\n  }\n  /*\r\n   * Represents a TTML Styling element\r\n   */\n\n\n  function Styling() {\n    this.styles = {};\n    this.initials = {};\n  }\n  /*\r\n   * Represents a TTML Style element\r\n   */\n\n\n  function Style() {\n    this.id = null;\n    this.styleAttrs = null;\n    this.styleRefs = null;\n  }\n\n  Style.prototype.initFromNode = function (node, errorHandler) {\n    this.id = elementGetXMLID(node);\n    this.styleAttrs = elementGetStyles(node, errorHandler);\n    this.styleRefs = elementGetStyleRefs(node);\n  };\n  /*\r\n   * Represents a TTML initial element\r\n   */\n\n\n  function Initial() {\n    this.styleAttrs = null;\n  }\n\n  Initial.prototype.initFromNode = function (node, errorHandler) {\n    this.styleAttrs = {};\n\n    for (var i in node.attributes) {\n      if (node.attributes[i].uri === imscNames.ns_itts || node.attributes[i].uri === imscNames.ns_ebutts || node.attributes[i].uri === imscNames.ns_tts) {\n        var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\n        this.styleAttrs[qname] = node.attributes[i].value;\n      }\n    }\n  };\n  /*\r\n   * Represents a TTML Layout element\r\n   * \r\n   */\n\n\n  function Layout() {\n    this.regions = {};\n  }\n  /*\r\n   * Represents a TTML image element\r\n   */\n\n\n  function Image(src, type) {\n    ContentElement.call(this, 'image');\n    this.src = src;\n    this.type = type;\n  }\n\n  Image.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    this.src = 'src' in node.attributes ? node.attributes.src.value : null;\n\n    if (!this.src) {\n      reportError(errorHandler, \"Invalid image@src attribute\");\n    }\n\n    this.type = 'type' in node.attributes ? node.attributes.type.value : null;\n\n    if (!this.type) {\n      reportError(errorHandler, \"Invalid image@type attribute\");\n    }\n\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * TTML element utility functions\r\n   * \r\n   */\n\n\n  function ContentElement(kind) {\n    this.kind = kind;\n  }\n\n  function IdentifiedElement(id) {\n    this.id = id;\n  }\n\n  IdentifiedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.id = elementGetXMLID(node);\n  };\n\n  function LayoutElement(id) {\n    this.regionID = id;\n  }\n\n  LayoutElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.regionID = elementGetRegionID(node);\n  };\n\n  function StyledElement(styleAttrs) {\n    this.styleAttrs = styleAttrs;\n  }\n\n  StyledElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.styleAttrs = elementGetStyles(node, errorHandler);\n\n    if (doc.head !== null && doc.head.styling !== null) {\n      mergeReferencedStyles(doc.head.styling, elementGetStyleRefs(node), this.styleAttrs, errorHandler);\n    }\n  };\n\n  function AnimatedElement(sets) {\n    this.sets = sets;\n  }\n\n  AnimatedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.sets = [];\n  };\n\n  function ContainerElement(contents) {\n    this.contents = contents;\n  }\n\n  ContainerElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    this.contents = [];\n  };\n\n  function TimedElement(explicit_begin, explicit_end, explicit_dur) {\n    this.explicit_begin = explicit_begin;\n    this.explicit_end = explicit_end;\n    this.explicit_dur = explicit_dur;\n  }\n\n  TimedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    var t = processTiming(doc, parent, node, errorHandler);\n    this.explicit_begin = t.explicit_begin;\n    this.explicit_end = t.explicit_end;\n    this.explicit_dur = t.explicit_dur;\n    this.timeContainer = elementGetTimeContainer(node, errorHandler);\n  };\n  /*\r\n   * Represents a TTML body element\r\n   */\n\n\n  function Body() {\n    ContentElement.call(this, 'body');\n  }\n\n  Body.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML div element\r\n   */\n\n\n  function Div() {\n    ContentElement.call(this, 'div');\n  }\n\n  Div.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML p element\r\n   */\n\n\n  function P() {\n    ContentElement.call(this, 'p');\n  }\n\n  P.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML span element\r\n   */\n\n\n  function Span() {\n    ContentElement.call(this, 'span');\n  }\n\n  Span.prototype.initFromNode = function (doc, parent, node, xmllang, xmlspace, errorHandler) {\n    StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.space = xmlspace;\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML anonymous span element\r\n   */\n\n\n  function AnonymousSpan() {\n    ContentElement.call(this, 'span');\n  }\n\n  AnonymousSpan.prototype.initFromText = function (doc, parent, text, xmllang, xmlspace, errorHandler) {\n    TimedElement.prototype.initFromNode.call(this, doc, parent, null, errorHandler);\n    this.text = text;\n    this.space = xmlspace;\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML br element\r\n   */\n\n\n  function Br() {\n    ContentElement.call(this, 'br');\n  }\n\n  Br.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\n    LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML Region element\r\n   * \r\n   */\n\n\n  function Region() {}\n\n  Region.prototype.createDefaultRegion = function (xmllang) {\n    var r = new Region();\n    IdentifiedElement.call(r, '');\n    StyledElement.call(r, {});\n    AnimatedElement.call(r, []);\n    TimedElement.call(r, 0, Number.POSITIVE_INFINITY, null);\n    this.lang = xmllang;\n    return r;\n  };\n\n  Region.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\n    IdentifiedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\n    /* add specified styles */\n\n    this.styleAttrs = elementGetStyles(node, errorHandler);\n    /* remember referential styles for merging after nested styling is processed*/\n\n    this.styleRefs = elementGetStyleRefs(node);\n    /* xml:lang */\n\n    this.lang = xmllang;\n  };\n  /*\r\n   * Represents a TTML Set element\r\n   * \r\n   */\n\n\n  function Set() {}\n\n  Set.prototype.initFromNode = function (doc, parent, node, errorHandler) {\n    TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\n    var styles = elementGetStyles(node, errorHandler);\n    this.qname = null;\n    this.value = null;\n\n    for (var qname in styles) {\n      if (this.qname) {\n        reportError(errorHandler, \"More than one style specified on set\");\n        break;\n      }\n\n      this.qname = qname;\n      this.value = styles[qname];\n    }\n  };\n  /*\r\n   * Utility functions\r\n   * \r\n   */\n\n\n  function elementGetXMLID(node) {\n    return node && 'xml:id' in node.attributes ? node.attributes['xml:id'].value || null : null;\n  }\n\n  function elementGetRegionID(node) {\n    return node && 'region' in node.attributes ? node.attributes.region.value : '';\n  }\n\n  function elementGetTimeContainer(node, errorHandler) {\n    var tc = node && 'timeContainer' in node.attributes ? node.attributes.timeContainer.value : null;\n\n    if (!tc || tc === \"par\") {\n      return \"par\";\n    } else if (tc === \"seq\") {\n      return \"seq\";\n    } else {\n      reportError(errorHandler, \"Illegal value of timeContainer (assuming 'par')\");\n      return \"par\";\n    }\n  }\n\n  function elementGetStyleRefs(node) {\n    return node && 'style' in node.attributes ? node.attributes.style.value.split(\" \") : [];\n  }\n\n  function elementGetStyles(node, errorHandler) {\n    var s = {};\n\n    if (node !== null) {\n      for (var i in node.attributes) {\n        var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\n        var sa = imscStyles.byQName[qname];\n\n        if (sa !== undefined) {\n          var val = sa.parse(node.attributes[i].value);\n\n          if (val !== null) {\n            s[qname] = val;\n            /* TODO: consider refactoring errorHandler into parse and compute routines */\n\n            if (sa === imscStyles.byName.zIndex) {\n              reportWarning(errorHandler, \"zIndex attribute present but not used by IMSC1 since regions do not overlap\");\n            }\n          } else {\n            reportError(errorHandler, \"Cannot parse styling attribute \" + qname + \" --> \" + node.attributes[i].value);\n          }\n        }\n      }\n    }\n\n    return s;\n  }\n\n  function findAttribute(node, ns, name) {\n    for (var i in node.attributes) {\n      if (node.attributes[i].uri === ns && node.attributes[i].local === name) {\n        return node.attributes[i].value;\n      }\n    }\n\n    return null;\n  }\n\n  function extractAspectRatio(node, errorHandler) {\n    var ar = findAttribute(node, imscNames.ns_ittp, \"aspectRatio\");\n\n    if (ar === null) {\n      ar = findAttribute(node, imscNames.ns_ttp, \"displayAspectRatio\");\n    }\n\n    var rslt = null;\n\n    if (ar !== null) {\n      var ASPECT_RATIO_RE = /(\\d+)\\s+(\\d+)/;\n      var m = ASPECT_RATIO_RE.exec(ar);\n\n      if (m !== null) {\n        var w = parseInt(m[1]);\n        var h = parseInt(m[2]);\n\n        if (w !== 0 && h !== 0) {\n          rslt = w / h;\n        } else {\n          reportError(errorHandler, \"Illegal aspectRatio values (ignoring)\");\n        }\n      } else {\n        reportError(errorHandler, \"Malformed aspectRatio attribute (ignoring)\");\n      }\n    }\n\n    return rslt;\n  }\n  /*\r\n   * Returns the cellResolution attribute from a node\r\n   * \r\n   */\n\n\n  function extractCellResolution(node, errorHandler) {\n    var cr = findAttribute(node, imscNames.ns_ttp, \"cellResolution\"); // initial value\n\n    var h = 15;\n    var w = 32;\n\n    if (cr !== null) {\n      var CELL_RESOLUTION_RE = /(\\d+) (\\d+)/;\n      var m = CELL_RESOLUTION_RE.exec(cr);\n\n      if (m !== null) {\n        w = parseInt(m[1]);\n        h = parseInt(m[2]);\n      } else {\n        reportWarning(errorHandler, \"Malformed cellResolution value (using initial value instead)\");\n      }\n    }\n\n    return {\n      'w': w,\n      'h': h\n    };\n  }\n\n  function extractFrameAndTickRate(node, errorHandler) {\n    // subFrameRate is ignored per IMSC1 specification\n    // extract frame rate\n    var fps_attr = findAttribute(node, imscNames.ns_ttp, \"frameRate\"); // initial value\n\n    var fps = 30; // match variable\n\n    var m;\n\n    if (fps_attr !== null) {\n      var FRAME_RATE_RE = /(\\d+)/;\n      m = FRAME_RATE_RE.exec(fps_attr);\n\n      if (m !== null) {\n        fps = parseInt(m[1]);\n      } else {\n        reportWarning(errorHandler, \"Malformed frame rate attribute (using initial value instead)\");\n      }\n    } // extract frame rate multiplier\n\n\n    var frm_attr = findAttribute(node, imscNames.ns_ttp, \"frameRateMultiplier\"); // initial value\n\n    var frm = 1;\n\n    if (frm_attr !== null) {\n      var FRAME_RATE_MULT_RE = /(\\d+) (\\d+)/;\n      m = FRAME_RATE_MULT_RE.exec(frm_attr);\n\n      if (m !== null) {\n        frm = parseInt(m[1]) / parseInt(m[2]);\n      } else {\n        reportWarning(errorHandler, \"Malformed frame rate multiplier attribute (using initial value instead)\");\n      }\n    }\n\n    var efps = frm * fps; // extract tick rate\n\n    var tr = 1;\n    var trattr = findAttribute(node, imscNames.ns_ttp, \"tickRate\");\n\n    if (trattr === null) {\n      if (fps_attr !== null) tr = efps;\n    } else {\n      var TICK_RATE_RE = /(\\d+)/;\n      m = TICK_RATE_RE.exec(trattr);\n\n      if (m !== null) {\n        tr = parseInt(m[1]);\n      } else {\n        reportWarning(errorHandler, \"Malformed tick rate attribute (using initial value instead)\");\n      }\n    }\n\n    return {\n      effectiveFrameRate: efps,\n      tickRate: tr\n    };\n  }\n\n  function extractExtent(node, errorHandler) {\n    var attr = findAttribute(node, imscNames.ns_tts, \"extent\");\n    if (attr === null) return null;\n    var s = attr.split(\" \");\n\n    if (s.length !== 2) {\n      reportWarning(errorHandler, \"Malformed extent (ignoring)\");\n      return null;\n    }\n\n    var w = imscUtils.parseLength(s[0]);\n    var h = imscUtils.parseLength(s[1]);\n\n    if (!h || !w) {\n      reportWarning(errorHandler, \"Malformed extent values (ignoring)\");\n      return null;\n    }\n\n    return {\n      'h': h,\n      'w': w\n    };\n  }\n\n  function parseTimeExpression(tickRate, effectiveFrameRate, str) {\n    var CLOCK_TIME_FRACTION_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d(?:\\.\\d+)?)$/;\n    var CLOCK_TIME_FRAMES_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d)\\:(\\d{2,})$/;\n    var OFFSET_FRAME_RE = /^(\\d+(?:\\.\\d+)?)f$/;\n    var OFFSET_TICK_RE = /^(\\d+(?:\\.\\d+)?)t$/;\n    var OFFSET_MS_RE = /^(\\d+(?:\\.\\d+)?)ms$/;\n    var OFFSET_S_RE = /^(\\d+(?:\\.\\d+)?)s$/;\n    var OFFSET_H_RE = /^(\\d+(?:\\.\\d+)?)h$/;\n    var OFFSET_M_RE = /^(\\d+(?:\\.\\d+)?)m$/;\n    var m;\n    var r = null;\n\n    if ((m = OFFSET_FRAME_RE.exec(str)) !== null) {\n      if (effectiveFrameRate !== null) {\n        r = parseFloat(m[1]) / effectiveFrameRate;\n      }\n    } else if ((m = OFFSET_TICK_RE.exec(str)) !== null) {\n      if (tickRate !== null) {\n        r = parseFloat(m[1]) / tickRate;\n      }\n    } else if ((m = OFFSET_MS_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]) / 1000.0;\n    } else if ((m = OFFSET_S_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]);\n    } else if ((m = OFFSET_H_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]) * 3600.0;\n    } else if ((m = OFFSET_M_RE.exec(str)) !== null) {\n      r = parseFloat(m[1]) * 60.0;\n    } else if ((m = CLOCK_TIME_FRACTION_RE.exec(str)) !== null) {\n      r = parseInt(m[1]) * 3600 + parseInt(m[2]) * 60 + parseFloat(m[3]);\n    } else if ((m = CLOCK_TIME_FRAMES_RE.exec(str)) !== null) {\n      /* this assumes that HH:MM:SS is a clock-time-with-fraction */\n      if (effectiveFrameRate !== null) {\n        r = parseInt(m[1]) * 3600 + parseInt(m[2]) * 60 + parseInt(m[3]) + (m[4] === null ? 0 : parseInt(m[4]) / effectiveFrameRate);\n      }\n    }\n\n    return r;\n  }\n\n  function processTiming(doc, parent, node, errorHandler) {\n    /* determine explicit begin */\n    var explicit_begin = null;\n\n    if (node && 'begin' in node.attributes) {\n      explicit_begin = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.begin.value);\n\n      if (explicit_begin === null) {\n        reportWarning(errorHandler, \"Malformed begin value \" + node.attributes.begin.value + \" (using 0)\");\n      }\n    }\n    /* determine explicit duration */\n\n\n    var explicit_dur = null;\n\n    if (node && 'dur' in node.attributes) {\n      explicit_dur = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.dur.value);\n\n      if (explicit_dur === null) {\n        reportWarning(errorHandler, \"Malformed dur value \" + node.attributes.dur.value + \" (ignoring)\");\n      }\n    }\n    /* determine explicit end */\n\n\n    var explicit_end = null;\n\n    if (node && 'end' in node.attributes) {\n      explicit_end = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.end.value);\n\n      if (explicit_end === null) {\n        reportWarning(errorHandler, \"Malformed end value (ignoring)\");\n      }\n    }\n\n    return {\n      explicit_begin: explicit_begin,\n      explicit_end: explicit_end,\n      explicit_dur: explicit_dur\n    };\n  }\n\n  function mergeChainedStyles(styling, style, errorHandler) {\n    while (style.styleRefs.length > 0) {\n      var sref = style.styleRefs.pop();\n\n      if (!(sref in styling.styles)) {\n        reportError(errorHandler, \"Non-existant style id referenced\");\n        continue;\n      }\n\n      mergeChainedStyles(styling, styling.styles[sref], errorHandler);\n      mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, style.styleAttrs);\n    }\n  }\n\n  function mergeReferencedStyles(styling, stylerefs, styleattrs, errorHandler) {\n    for (var i = stylerefs.length - 1; i >= 0; i--) {\n      var sref = stylerefs[i];\n\n      if (!(sref in styling.styles)) {\n        reportError(errorHandler, \"Non-existant style id referenced\");\n        continue;\n      }\n\n      mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, styleattrs);\n    }\n  }\n\n  function mergeStylesIfNotPresent(from_styles, into_styles) {\n    for (var sname in from_styles) {\n      if (sname in into_styles) continue;\n      into_styles[sname] = from_styles[sname];\n    }\n  }\n  /* TODO: validate style format at parsing */\n\n  /*\r\n   * ERROR HANDLING UTILITY FUNCTIONS\r\n   * \r\n   */\n\n\n  function reportInfo(errorHandler, msg) {\n    if (errorHandler && errorHandler.info && errorHandler.info(msg)) throw msg;\n  }\n\n  function reportWarning(errorHandler, msg) {\n    if (errorHandler && errorHandler.warn && errorHandler.warn(msg)) throw msg;\n  }\n\n  function reportError(errorHandler, msg) {\n    if (errorHandler && errorHandler.error && errorHandler.error(msg)) throw msg;\n  }\n\n  function reportFatal(errorHandler, msg) {\n    if (errorHandler && errorHandler.fatal) errorHandler.fatal(msg);\n    throw msg;\n  }\n  /*\r\n   * Binary search utility function\r\n   * \r\n   * @typedef {Object} BinarySearchResult\r\n   * @property {boolean} found Was an exact match found?\r\n   * @property {number} index Position of the exact match or insert position\r\n   * \r\n   * @returns {BinarySearchResult}\r\n   */\n\n\n  function indexOf(arr, searchval) {\n    var min = 0;\n    var max = arr.length - 1;\n    var cur;\n\n    while (min <= max) {\n      cur = Math.floor((min + max) / 2);\n      var curval = arr[cur];\n\n      if (curval < searchval) {\n        min = cur + 1;\n      } else if (curval > searchval) {\n        max = cur - 1;\n      } else {\n        return {\n          found: true,\n          index: cur\n        };\n      }\n    }\n\n    return {\n      found: false,\n      index: min\n    };\n  }\n})(typeof exports === 'undefined' ? this.imscDoc = {} : exports, typeof sax === 'undefined' ? require(\"sax\") : sax, typeof imscNames === 'undefined' ? require(\"./names\") : imscNames, typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles, typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils);","map":{"version":3,"sources":["/Users/webwerks1/Documents/Project/React Js Training/streamvideo/node_modules/imsc/src/main/js/doc.js"],"names":["imscDoc","sax","imscNames","imscStyles","imscUtils","fromXML","xmlstring","errorHandler","metadataHandler","p","parser","xmlns","estack","xmllangstack","xmlspacestack","metadata_depth","doc","onclosetag","node","Region","head","styling","mergeReferencedStyles","styleRefs","styleAttrs","Styling","sid","styles","mergeChainedStyles","P","Span","contents","length","cs","c","AnonymousSpan","text","push","ForeignElement","uri","ns_tt","local","onCloseTag","shift","ontext","str","undefined","ruby","byName","qname","s","initFromText","onText","onopentag","xmlspace","attributes","unshift","value","xmllang","reportFatal","line","column","TT","initFromNode","Head","Style","id","reportError","mergeStylesIfNotPresent","ini","Initial","qn","initials","layout","Layout","r","regions","body","b","Body","Div","d","bi","backgroundImage","Image","img","ns","nb","Br","st","Set","sets","attrs","a","onOpenTag","write","close","hasRegions","i","dr","prototype","createDefaultRegion","lang","region_i","resolveTiming","cleanRubyContainers","element","rubyval","isrubycontainer","kind","prev_sibling","parent","isinseq","timeContainer","implicit_begin","end","begin","explicit_begin","implicit_end","set_i","Math","max","Number","POSITIVE_INFINITY","content_i","explicit_end","explicit_dur","min","_registerEvent","events","cr","extractCellResolution","cellLength","ComputedLength","h","w","frtr","extractFrameAndTickRate","effectiveFrameRate","tickRate","aspectRatio","extractAspectRatio","attr","findAttribute","ns_ttp","e","extractExtent","pxLength","unit","dimensions","elem","b_i","indexOf","found","splice","index","e_i","getMediaTimeRange","getMediaTimeEvents","elementGetXMLID","elementGetStyles","elementGetStyleRefs","ns_itts","ns_ebutts","ns_tts","src","type","ContentElement","call","StyledElement","TimedElement","AnimatedElement","LayoutElement","IdentifiedElement","regionID","elementGetRegionID","ContainerElement","t","processTiming","elementGetTimeContainer","space","region","tc","style","split","sa","byQName","val","parse","zIndex","reportWarning","name","ar","ns_ittp","rslt","ASPECT_RATIO_RE","m","exec","parseInt","CELL_RESOLUTION_RE","fps_attr","fps","FRAME_RATE_RE","frm_attr","frm","FRAME_RATE_MULT_RE","efps","tr","trattr","TICK_RATE_RE","parseLength","parseTimeExpression","CLOCK_TIME_FRACTION_RE","CLOCK_TIME_FRAMES_RE","OFFSET_FRAME_RE","OFFSET_TICK_RE","OFFSET_MS_RE","OFFSET_S_RE","OFFSET_H_RE","OFFSET_M_RE","parseFloat","dur","sref","pop","stylerefs","styleattrs","from_styles","into_styles","sname","reportInfo","msg","info","warn","error","fatal","arr","searchval","cur","floor","curval","exports","require"],"mappings":"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","sourcesContent":["/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * @module imscDoc\r\n */\r\n\r\n;\r\n(function (imscDoc, sax, imscNames, imscStyles, imscUtils) {\r\n\r\n\r\n    /**\r\n     * Allows a client to provide callbacks to handle children of the <metadata> element\r\n     * @typedef {Object} MetadataHandler\r\n     * @property {?OpenTagCallBack} onOpenTag\r\n     * @property {?CloseTagCallBack} onCloseTag\r\n     * @property {?TextCallBack} onText\r\n     */\r\n\r\n    /**\r\n     * Called when the opening tag of an element node is encountered.\r\n     * @callback OpenTagCallBack\r\n     * @param {string} ns Namespace URI of the element\r\n     * @param {string} name Local name of the element\r\n     * @param {Object[]} attributes List of attributes, each consisting of a\r\n     *                              `uri`, `name` and `value`\r\n     */\r\n\r\n    /**\r\n     * Called when the closing tag of an element node is encountered.\r\n     * @callback CloseTagCallBack\r\n     */\r\n\r\n    /**\r\n     * Called when a text node is encountered.\r\n     * @callback TextCallBack\r\n     * @param {string} contents Contents of the text node\r\n     */\r\n\r\n    /**\r\n     * Parses an IMSC1 document into an opaque in-memory representation that exposes\r\n     * a single method <pre>getMediaTimeEvents()</pre> that returns a list of time\r\n     * offsets (in seconds) of the ISD, i.e. the points in time where the visual\r\n     * representation of the document change. `metadataHandler` allows the caller to\r\n     * be called back when nodes are present in <metadata> elements. \r\n     * \r\n     * @param {string} xmlstring XML document\r\n     * @param {?module:imscUtils.ErrorHandler} errorHandler Error callback\r\n     * @param {?MetadataHandler} metadataHandler Callback for <Metadata> elements\r\n     * @returns {Object} Opaque in-memory representation of an IMSC1 document\r\n     */\r\n\r\n    imscDoc.fromXML = function (xmlstring, errorHandler, metadataHandler) {\r\n        var p = sax.parser(true, {xmlns: true});\r\n        var estack = [];\r\n        var xmllangstack = [];\r\n        var xmlspacestack = [];\r\n        var metadata_depth = 0;\r\n        var doc = null;\r\n\r\n        p.onclosetag = function (node) {\r\n\r\n            \r\n            if (estack[0] instanceof Region) {\r\n\r\n                /* merge referenced styles */\r\n\r\n                if (doc.head !== null && doc.head.styling !== null) {\r\n                    mergeReferencedStyles(doc.head.styling, estack[0].styleRefs, estack[0].styleAttrs, errorHandler);\r\n                }\r\n\r\n                delete estack[0].styleRefs;\r\n\r\n            } else if (estack[0] instanceof Styling) {\r\n\r\n                /* flatten chained referential styling */\r\n\r\n                for (var sid in estack[0].styles) {\r\n\r\n                    mergeChainedStyles(estack[0], estack[0].styles[sid], errorHandler);\r\n\r\n                }\r\n\r\n            } else if (estack[0] instanceof P || estack[0] instanceof Span) {\r\n\r\n                /* merge anonymous spans */\r\n\r\n                if (estack[0].contents.length > 1) {\r\n\r\n                    var cs = [estack[0].contents[0]];\r\n\r\n                    var c;\r\n\r\n                    for (c = 1; c < estack[0].contents.length; c++) {\r\n\r\n                        if (estack[0].contents[c] instanceof AnonymousSpan &&\r\n                                cs[cs.length - 1] instanceof AnonymousSpan) {\r\n\r\n                            cs[cs.length - 1].text += estack[0].contents[c].text;\r\n\r\n                        } else {\r\n\r\n                            cs.push(estack[0].contents[c]);\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    estack[0].contents = cs;\r\n\r\n                }\r\n\r\n                // remove redundant nested anonymous spans (9.3.3(1)(c))\r\n\r\n                if (estack[0] instanceof Span &&\r\n                        estack[0].contents.length === 1 &&\r\n                        estack[0].contents[0] instanceof AnonymousSpan) {\r\n\r\n                    estack[0].text = estack[0].contents[0].text;\r\n                    delete estack[0].contents;\r\n\r\n                }\r\n\r\n            } else if (estack[0] instanceof ForeignElement) {\r\n\r\n                if (estack[0].node.uri === imscNames.ns_tt &&\r\n                        estack[0].node.local === 'metadata') {\r\n\r\n                    /* leave the metadata element */\r\n\r\n                    metadata_depth--;\r\n\r\n                } else if (metadata_depth > 0 &&\r\n                        metadataHandler &&\r\n                        'onCloseTag' in metadataHandler) {\r\n\r\n                    /* end of child of metadata element */\r\n\r\n                    metadataHandler.onCloseTag();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            // TODO: delete stylerefs?\r\n\r\n            // maintain the xml:space stack\r\n\r\n            xmlspacestack.shift();\r\n\r\n            // maintain the xml:lang stack\r\n\r\n            xmllangstack.shift();\r\n\r\n            // prepare for the next element\r\n\r\n            estack.shift();\r\n        };\r\n\r\n        p.ontext = function (str) {\r\n\r\n            if (estack[0] === undefined) {\r\n\r\n                /* ignoring text outside of elements */\r\n\r\n            } else if (estack[0] instanceof Span || estack[0] instanceof P) {\r\n\r\n                /* ignore children text nodes in ruby container spans */\r\n\r\n                if (estack[0] instanceof Span) {\r\n\r\n                    var ruby = estack[0].styleAttrs[imscStyles.byName.ruby.qname];\r\n\r\n                    if (ruby === 'container' || ruby === 'textContainer' || ruby === 'baseContainer') {\r\n\r\n                        return;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                /* create an anonymous span */\r\n\r\n                var s = new AnonymousSpan();\r\n\r\n                s.initFromText(doc, estack[0], str, xmllangstack[0], xmlspacestack[0], errorHandler);\r\n\r\n                estack[0].contents.push(s);\r\n\r\n            } else if (estack[0] instanceof ForeignElement &&\r\n                    metadata_depth > 0 &&\r\n                    metadataHandler &&\r\n                    'onText' in metadataHandler) {\r\n\r\n                /* text node within a child of metadata element */\r\n\r\n                metadataHandler.onText(str);\r\n\r\n            }\r\n\r\n        };\r\n\r\n\r\n        p.onopentag = function (node) {\r\n\r\n            // maintain the xml:space stack\r\n\r\n            var xmlspace = node.attributes[\"xml:space\"];\r\n\r\n            if (xmlspace) {\r\n\r\n                xmlspacestack.unshift(xmlspace.value);\r\n\r\n            } else {\r\n\r\n                if (xmlspacestack.length === 0) {\r\n\r\n                    xmlspacestack.unshift(\"default\");\r\n\r\n                } else {\r\n\r\n                    xmlspacestack.unshift(xmlspacestack[0]);\r\n\r\n                }\r\n\r\n            }\r\n\r\n            /* maintain the xml:lang stack */\r\n\r\n\r\n            var xmllang = node.attributes[\"xml:lang\"];\r\n\r\n            if (xmllang) {\r\n\r\n                xmllangstack.unshift(xmllang.value);\r\n\r\n            } else {\r\n\r\n                if (xmllangstack.length === 0) {\r\n\r\n                    xmllangstack.unshift(\"\");\r\n\r\n                } else {\r\n\r\n                    xmllangstack.unshift(xmllangstack[0]);\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n            /* process the element */\r\n\r\n            if (node.uri === imscNames.ns_tt) {\r\n\r\n                if (node.local === 'tt') {\r\n\r\n                    if (doc !== null) {\r\n\r\n                        reportFatal(errorHandler, \"Two <tt> elements at (\" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    doc = new TT();\r\n\r\n                    doc.initFromNode(node, xmllangstack[0], errorHandler);\r\n\r\n                    estack.unshift(doc);\r\n\r\n                } else if (node.local === 'head') {\r\n\r\n                    if (!(estack[0] instanceof TT)) {\r\n                        reportFatal(errorHandler, \"Parent of <head> element is not <tt> at (\" + this.line + \",\" + this.column + \")\");\r\n                    }\r\n\r\n                    estack.unshift(doc.head);\r\n\r\n                } else if (node.local === 'styling') {\r\n\r\n                    if (!(estack[0] instanceof Head)) {\r\n                        reportFatal(errorHandler, \"Parent of <styling> element is not <head> at (\" + this.line + \",\" + this.column + \")\");\r\n                    }\r\n\r\n                    estack.unshift(doc.head.styling);\r\n\r\n                } else if (node.local === 'style') {\r\n\r\n                    var s;\r\n\r\n                    if (estack[0] instanceof Styling) {\r\n\r\n                        s = new Style();\r\n\r\n                        s.initFromNode(node, errorHandler);\r\n\r\n                        /* ignore <style> element missing @id */\r\n\r\n                        if (!s.id) {\r\n\r\n                            reportError(errorHandler, \"<style> element missing @id attribute\");\r\n\r\n                        } else {\r\n\r\n                            doc.head.styling.styles[s.id] = s;\r\n\r\n                        }\r\n\r\n                        estack.unshift(s);\r\n\r\n                    } else if (estack[0] instanceof Region) {\r\n\r\n                        /* nested styles can be merged with specified styles\r\n                         * immediately, with lower priority\r\n                         * (see 8.4.4.2(3) at TTML1 )\r\n                         */\r\n\r\n                        s = new Style();\r\n\r\n                        s.initFromNode(node, errorHandler);\r\n\r\n                        mergeStylesIfNotPresent(s.styleAttrs, estack[0].styleAttrs);\r\n\r\n                        estack.unshift(s);\r\n\r\n                    } else {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <style> element is not <styling> or <region> at (\" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                }  else if (node.local === 'initial') {\r\n\r\n                    var ini;\r\n\r\n                    if (estack[0] instanceof Styling) {\r\n\r\n                        ini = new Initial();\r\n\r\n                        ini.initFromNode(node, errorHandler);\r\n                        \r\n                        for (var qn in ini.styleAttrs) {\r\n                            \r\n                            doc.head.styling.initials[qn] = ini.styleAttrs[qn];\r\n                            \r\n                        }\r\n                        \r\n                        estack.unshift(ini);\r\n\r\n                    } else {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <initial> element is not <styling> at (\" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                } else if (node.local === 'layout') {\r\n\r\n                    if (!(estack[0] instanceof Head)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <layout> element is not <head> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    estack.unshift(doc.head.layout);\r\n\r\n                } else if (node.local === 'region') {\r\n\r\n                    if (!(estack[0] instanceof Layout)) {\r\n                        reportFatal(errorHandler, \"Parent of <region> element is not <layout> at \" + this.line + \",\" + this.column + \")\");\r\n                    }\r\n\r\n                    var r = new Region();\r\n\r\n                    r.initFromNode(doc, node, xmllangstack[0], errorHandler);\r\n\r\n                    if (!r.id || r.id in doc.head.layout.regions) {\r\n\r\n                        reportError(errorHandler, \"Ignoring <region> with duplicate or missing @id at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    } else {\r\n\r\n                        doc.head.layout.regions[r.id] = r;\r\n\r\n                    }\r\n\r\n                    estack.unshift(r);\r\n\r\n                } else if (node.local === 'body') {\r\n\r\n                    if (!(estack[0] instanceof TT)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <body> element is not <tt> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    if (doc.body !== null) {\r\n\r\n                        reportFatal(errorHandler, \"Second <body> element at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var b = new Body();\r\n\r\n                    b.initFromNode(doc, node, xmllangstack[0], errorHandler);\r\n\r\n                    doc.body = b;\r\n\r\n                    estack.unshift(b);\r\n\r\n                } else if (node.local === 'div') {\r\n\r\n                    if (!(estack[0] instanceof Div || estack[0] instanceof Body)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <div> element is not <body> or <div> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var d = new Div();\r\n\r\n                    d.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n                    \r\n                    /* transform smpte:backgroundImage to TTML2 image element */\r\n                    \r\n                    var bi = d.styleAttrs[imscStyles.byName.backgroundImage.qname];\r\n                    \r\n                    if (bi) {\r\n                        d.contents.push(new Image(bi));\r\n                        delete d.styleAttrs[imscStyles.byName.backgroundImage.qname];                  \r\n                    }\r\n\r\n                    estack[0].contents.push(d);\r\n\r\n                    estack.unshift(d);\r\n\r\n                } else if (node.local === 'image') {\r\n\r\n                    if (!(estack[0] instanceof Div)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <image> element is not <div> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var img = new Image();\r\n                    \r\n                    img.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n                    \r\n                    estack[0].contents.push(img);\r\n\r\n                    estack.unshift(img);\r\n\r\n                } else if (node.local === 'p') {\r\n\r\n                    if (!(estack[0] instanceof Div)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <p> element is not <div> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var p = new P();\r\n\r\n                    p.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n\r\n                    estack[0].contents.push(p);\r\n\r\n                    estack.unshift(p);\r\n\r\n                } else if (node.local === 'span') {\r\n\r\n                    if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <span> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var ns = new Span();\r\n\r\n                    ns.initFromNode(doc, estack[0], node, xmllangstack[0], xmlspacestack[0], errorHandler);\r\n\r\n                    estack[0].contents.push(ns);\r\n\r\n                    estack.unshift(ns);\r\n\r\n                } else if (node.local === 'br') {\r\n\r\n                    if (!(estack[0] instanceof Span || estack[0] instanceof P)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <br> element is not <span> or <p> at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var nb = new Br();\r\n\r\n                    nb.initFromNode(doc, estack[0], node, xmllangstack[0], errorHandler);\r\n\r\n                    estack[0].contents.push(nb);\r\n\r\n                    estack.unshift(nb);\r\n\r\n                } else if (node.local === 'set') {\r\n\r\n                    if (!(estack[0] instanceof Span ||\r\n                            estack[0] instanceof P ||\r\n                            estack[0] instanceof Div ||\r\n                            estack[0] instanceof Body ||\r\n                            estack[0] instanceof Region ||\r\n                            estack[0] instanceof Br)) {\r\n\r\n                        reportFatal(errorHandler, \"Parent of <set> element is not a content element or a region at \" + this.line + \",\" + this.column + \")\");\r\n\r\n                    }\r\n\r\n                    var st = new Set();\r\n\r\n                    st.initFromNode(doc, estack[0], node, errorHandler);\r\n\r\n                    estack[0].sets.push(st);\r\n\r\n                    estack.unshift(st);\r\n\r\n                } else {\r\n\r\n                    /* element in the TT namespace, but not a content element */\r\n\r\n                    estack.unshift(new ForeignElement(node));\r\n                }\r\n\r\n            } else {\r\n\r\n                /* ignore elements not in the TTML namespace unless in metadata element */\r\n\r\n                estack.unshift(new ForeignElement(node));\r\n\r\n            }\r\n\r\n            /* handle metadata callbacks */\r\n\r\n            if (estack[0] instanceof ForeignElement) {\r\n\r\n                if (node.uri === imscNames.ns_tt &&\r\n                        node.local === 'metadata') {\r\n\r\n                    /* enter the metadata element */\r\n\r\n                    metadata_depth++;\r\n\r\n                } else if (\r\n                        metadata_depth > 0 &&\r\n                        metadataHandler &&\r\n                        'onOpenTag' in metadataHandler\r\n                        ) {\r\n\r\n                    /* start of child of metadata element */\r\n\r\n                    var attrs = [];\r\n\r\n                    for (var a in node.attributes) {\r\n                        attrs[node.attributes[a].uri + \" \" + node.attributes[a].local] =\r\n                                {\r\n                                    uri: node.attributes[a].uri,\r\n                                    local: node.attributes[a].local,\r\n                                    value: node.attributes[a].value\r\n                                };\r\n                    }\r\n\r\n                    metadataHandler.onOpenTag(node.uri, node.local, attrs);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        };\r\n\r\n        // parse the document\r\n\r\n        p.write(xmlstring).close();\r\n\r\n        // all referential styling has been flatten, so delete styles\r\n\r\n        delete doc.head.styling.styles;\r\n       \r\n        // create default region if no regions specified\r\n\r\n        var hasRegions = false;\r\n\r\n        /* AFAIK the only way to determine whether an object has members */\r\n\r\n        for (var i in doc.head.layout.regions) {\r\n\r\n            hasRegions = true;\r\n\r\n            break;\r\n\r\n        }\r\n\r\n        if (!hasRegions) {\r\n\r\n            /* create default region */\r\n\r\n            var dr = Region.prototype.createDefaultRegion(doc.lang);\r\n\r\n            doc.head.layout.regions[dr.id] = dr;\r\n\r\n        }\r\n\r\n        /* resolve desired timing for regions */\r\n\r\n        for (var region_i in doc.head.layout.regions) {\r\n\r\n            resolveTiming(doc, doc.head.layout.regions[region_i], null, null);\r\n\r\n        }\r\n\r\n        /* resolve desired timing for content elements */\r\n\r\n        if (doc.body) {\r\n            resolveTiming(doc, doc.body, null, null);\r\n        }\r\n\r\n        /* remove undefined spans in ruby containers */\r\n\r\n        if (doc.body) {\r\n            cleanRubyContainers(doc.body);\r\n        }\r\n\r\n        return doc;\r\n    };\r\n\r\n    function cleanRubyContainers(element) {\r\n        \r\n        if (! ('contents' in element)) return;\r\n\r\n        var rubyval = 'styleAttrs' in element ? element.styleAttrs[imscStyles.byName.ruby.qname] : null;\r\n\r\n        var isrubycontainer = (element.kind === 'span' && (rubyval === \"container\" || rubyval === \"textContainer\" || rubyval === \"baseContainer\"));\r\n\r\n        for (var i = element.contents.length - 1; i >= 0; i--) {\r\n\r\n            if (isrubycontainer && !('styleAttrs' in element.contents[i] && imscStyles.byName.ruby.qname in element.contents[i].styleAttrs)) {\r\n\r\n                /* prune undefined <span> in ruby containers */\r\n\r\n                delete element.contents[i];\r\n\r\n            } else {\r\n\r\n                cleanRubyContainers(element.contents[i]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function resolveTiming(doc, element, prev_sibling, parent) {\r\n\r\n        /* are we in a seq container? */\r\n\r\n        var isinseq = parent && parent.timeContainer === \"seq\";\r\n\r\n        /* determine implicit begin */\r\n\r\n        var implicit_begin = 0; /* default */\r\n\r\n        if (parent) {\r\n\r\n            if (isinseq && prev_sibling) {\r\n\r\n                /*\r\n                 * if seq time container, offset from the previous sibling end\r\n                 */\r\n\r\n                implicit_begin = prev_sibling.end;\r\n\r\n\r\n            } else {\r\n\r\n                implicit_begin = parent.begin;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* compute desired begin */\r\n\r\n        element.begin = element.explicit_begin ? element.explicit_begin + implicit_begin : implicit_begin;\r\n\r\n\r\n        /* determine implicit end */\r\n\r\n        var implicit_end = element.begin;\r\n\r\n        var s = null;\r\n\r\n        for (var set_i in element.sets) {\r\n\r\n            resolveTiming(doc, element.sets[set_i], s, element);\r\n\r\n            if (element.timeContainer === \"seq\") {\r\n\r\n                implicit_end = element.sets[set_i].end;\r\n\r\n            } else {\r\n\r\n                implicit_end = Math.max(implicit_end, element.sets[set_i].end);\r\n\r\n            }\r\n\r\n            s = element.sets[set_i];\r\n\r\n        }\r\n\r\n        if (!('contents' in element)) {\r\n\r\n            /* anonymous spans and regions and <set> and <br>s and spans with only children text nodes */\r\n\r\n            if (isinseq) {\r\n\r\n                /* in seq container, implicit duration is zero */\r\n\r\n                implicit_end = element.begin;\r\n\r\n            } else {\r\n\r\n                /* in par container, implicit duration is indefinite */\r\n\r\n                implicit_end = Number.POSITIVE_INFINITY;\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n            for (var content_i in element.contents) {\r\n\r\n                resolveTiming(doc, element.contents[content_i], s, element);\r\n\r\n                if (element.timeContainer === \"seq\") {\r\n\r\n                    implicit_end = element.contents[content_i].end;\r\n\r\n                } else {\r\n\r\n                    implicit_end = Math.max(implicit_end, element.contents[content_i].end);\r\n\r\n                }\r\n\r\n                s = element.contents[content_i];\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* determine desired end */\r\n        /* it is never made really clear in SMIL that the explicit end is offset by the implicit begin */\r\n\r\n        if (element.explicit_end !== null && element.explicit_dur !== null) {\r\n\r\n            element.end = Math.min(element.begin + element.explicit_dur, implicit_begin + element.explicit_end);\r\n\r\n        } else if (element.explicit_end === null && element.explicit_dur !== null) {\r\n\r\n            element.end = element.begin + element.explicit_dur;\r\n\r\n        } else if (element.explicit_end !== null && element.explicit_dur === null) {\r\n\r\n            element.end = implicit_begin + element.explicit_end;\r\n\r\n        } else {\r\n\r\n            element.end = implicit_end;\r\n        }\r\n\r\n        delete element.explicit_begin;\r\n        delete element.explicit_dur;\r\n        delete element.explicit_end;\r\n\r\n        doc._registerEvent(element);\r\n\r\n    }\r\n\r\n    function ForeignElement(node) {\r\n        this.node = node;\r\n    }\r\n\r\n    function TT() {\r\n        this.events = [];\r\n        this.head = new Head();\r\n        this.body = null;\r\n    }\r\n\r\n    TT.prototype.initFromNode = function (node, xmllang, errorHandler) {\r\n\r\n        /* compute cell resolution */\r\n\r\n        var cr = extractCellResolution(node, errorHandler);\r\n        \r\n        this.cellLength = {\r\n                'h': new imscUtils.ComputedLength(0, 1/cr.h),\r\n                'w': new imscUtils.ComputedLength(1/cr.w, 0)\r\n            };\r\n\r\n        /* extract frame rate and tick rate */\r\n\r\n        var frtr = extractFrameAndTickRate(node, errorHandler);\r\n\r\n        this.effectiveFrameRate = frtr.effectiveFrameRate;\r\n\r\n        this.tickRate = frtr.tickRate;\r\n\r\n        /* extract aspect ratio */\r\n\r\n        this.aspectRatio = extractAspectRatio(node, errorHandler);\r\n\r\n        /* check timebase */\r\n\r\n        var attr = findAttribute(node, imscNames.ns_ttp, \"timeBase\");\r\n\r\n        if (attr !== null && attr !== \"media\") {\r\n\r\n            reportFatal(errorHandler, \"Unsupported time base\");\r\n\r\n        }\r\n\r\n        /* retrieve extent */\r\n\r\n        var e = extractExtent(node, errorHandler);\r\n\r\n        if (e === null) {\r\n\r\n            this.pxLength = {\r\n                'h': null,\r\n                'w': null\r\n            };\r\n\r\n        } else {\r\n\r\n            if (e.h.unit !== \"px\" || e.w.unit !== \"px\") {\r\n                reportFatal(errorHandler, \"Extent on TT must be in px or absent\");\r\n            }\r\n\r\n            this.pxLength = {\r\n                'h': new imscUtils.ComputedLength(0, 1 / e.h.value),\r\n                'w': new imscUtils.ComputedLength(1 / e.w.value, 0)\r\n            };\r\n        }\r\n        \r\n        /** set root container dimensions to (1, 1) arbitrarily\r\n          * the root container is mapped to actual dimensions at rendering\r\n        **/\r\n        \r\n        this.dimensions = {\r\n                'h': new imscUtils.ComputedLength(0, 1),\r\n                'w': new imscUtils.ComputedLength(1, 0)\r\n\r\n        };\r\n\r\n        /* xml:lang */\r\n\r\n        this.lang = xmllang;\r\n\r\n    };\r\n\r\n    /* register a temporal events */\r\n    TT.prototype._registerEvent = function (elem) {\r\n\r\n        /* skip if begin is not < then end */\r\n\r\n        if (elem.end <= elem.begin)\r\n            return;\r\n\r\n        /* index the begin time of the event */\r\n\r\n        var b_i = indexOf(this.events, elem.begin);\r\n\r\n        if (!b_i.found) {\r\n            this.events.splice(b_i.index, 0, elem.begin);\r\n        }\r\n\r\n        /* index the end time of the event */\r\n\r\n        if (elem.end !== Number.POSITIVE_INFINITY) {\r\n\r\n            var e_i = indexOf(this.events, elem.end);\r\n\r\n            if (!e_i.found) {\r\n                this.events.splice(e_i.index, 0, elem.end);\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Retrieves the range of ISD times covered by the document\r\n     * \r\n     * @returns {Array} Array of two elements: min_begin_time and max_begin_time\r\n     * \r\n     */\r\n    TT.prototype.getMediaTimeRange = function () {\r\n\r\n        return [this.events[0], this.events[this.events.length - 1]];\r\n    };\r\n\r\n    /*\r\n     * Returns list of ISD begin times  \r\n     * \r\n     * @returns {Array}\r\n     */\r\n    TT.prototype.getMediaTimeEvents = function () {\r\n\r\n        return this.events;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Head element\r\n     */\r\n\r\n    function Head() {\r\n        this.styling = new Styling();\r\n        this.layout = new Layout();\r\n    }\r\n\r\n    /*\r\n     * Represents a TTML Styling element\r\n     */\r\n\r\n    function Styling() {\r\n        this.styles = {};\r\n        this.initials = {};\r\n    }\r\n\r\n    /*\r\n     * Represents a TTML Style element\r\n     */\r\n\r\n    function Style() {\r\n        this.id = null;\r\n        this.styleAttrs = null;\r\n        this.styleRefs = null;\r\n    }\r\n\r\n    Style.prototype.initFromNode = function (node, errorHandler) {\r\n        this.id = elementGetXMLID(node);\r\n        this.styleAttrs = elementGetStyles(node, errorHandler);\r\n        this.styleRefs = elementGetStyleRefs(node);\r\n    };\r\n    \r\n    /*\r\n     * Represents a TTML initial element\r\n     */\r\n\r\n    function Initial() {\r\n        this.styleAttrs = null;\r\n    }\r\n\r\n    Initial.prototype.initFromNode = function (node, errorHandler) {\r\n        \r\n        this.styleAttrs = {};\r\n        \r\n        for (var i in node.attributes) {\r\n\r\n            if (node.attributes[i].uri === imscNames.ns_itts ||\r\n                node.attributes[i].uri === imscNames.ns_ebutts ||\r\n                node.attributes[i].uri === imscNames.ns_tts) {\r\n                \r\n                var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\r\n                \r\n                this.styleAttrs[qname] = node.attributes[i].value;\r\n\r\n            }\r\n        }\r\n        \r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Layout element\r\n     * \r\n     */\r\n\r\n    function Layout() {\r\n        this.regions = {};\r\n    }\r\n    \r\n    /*\r\n     * Represents a TTML image element\r\n     */\r\n\r\n    function Image(src, type) {\r\n        ContentElement.call(this, 'image');\r\n        this.src = src;\r\n        this.type = type;\r\n    }\r\n\r\n    Image.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        this.src = 'src' in node.attributes ? node.attributes.src.value : null;\r\n        \r\n        if (! this.src) {\r\n            reportError(errorHandler, \"Invalid image@src attribute\");\r\n        }\r\n        \r\n        this.type = 'type' in node.attributes ? node.attributes.type.value : null;\r\n        \r\n        if (! this.type) {\r\n            reportError(errorHandler, \"Invalid image@type attribute\");\r\n        }\r\n        \r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * TTML element utility functions\r\n     * \r\n     */\r\n\r\n    function ContentElement(kind) {\r\n        this.kind = kind;\r\n    }\r\n\r\n    function IdentifiedElement(id) {\r\n        this.id = id;\r\n    }\r\n\r\n    IdentifiedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.id = elementGetXMLID(node);\r\n    };\r\n\r\n    function LayoutElement(id) {\r\n        this.regionID = id;\r\n    }\r\n\r\n    LayoutElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.regionID = elementGetRegionID(node);\r\n    };\r\n\r\n    function StyledElement(styleAttrs) {\r\n        this.styleAttrs = styleAttrs;\r\n    }\r\n\r\n    StyledElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n\r\n        this.styleAttrs = elementGetStyles(node, errorHandler);\r\n\r\n        if (doc.head !== null && doc.head.styling !== null) {\r\n            mergeReferencedStyles(doc.head.styling, elementGetStyleRefs(node), this.styleAttrs, errorHandler);\r\n        }\r\n\r\n    };\r\n\r\n    function AnimatedElement(sets) {\r\n        this.sets = sets;\r\n    }\r\n\r\n    AnimatedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.sets = [];\r\n    };\r\n\r\n    function ContainerElement(contents) {\r\n        this.contents = contents;\r\n    }\r\n\r\n    ContainerElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        this.contents = [];\r\n    };\r\n\r\n    function TimedElement(explicit_begin, explicit_end, explicit_dur) {\r\n        this.explicit_begin = explicit_begin;\r\n        this.explicit_end = explicit_end;\r\n        this.explicit_dur = explicit_dur;\r\n    }\r\n\r\n    TimedElement.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n        var t = processTiming(doc, parent, node, errorHandler);\r\n        this.explicit_begin = t.explicit_begin;\r\n        this.explicit_end = t.explicit_end;\r\n        this.explicit_dur = t.explicit_dur;\r\n\r\n        this.timeContainer = elementGetTimeContainer(node, errorHandler);\r\n    };\r\n\r\n\r\n    /*\r\n     * Represents a TTML body element\r\n     */\r\n\r\n\r\n\r\n    function Body() {\r\n        ContentElement.call(this, 'body');\r\n    }\r\n\r\n\r\n    Body.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML div element\r\n     */\r\n\r\n    function Div() {\r\n        ContentElement.call(this, 'div');\r\n    }\r\n\r\n    Div.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML p element\r\n     */\r\n\r\n    function P() {\r\n        ContentElement.call(this, 'p');\r\n    }\r\n\r\n    P.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML span element\r\n     */\r\n\r\n    function Span() {\r\n        ContentElement.call(this, 'span');\r\n    }\r\n\r\n    Span.prototype.initFromNode = function (doc, parent, node, xmllang, xmlspace, errorHandler) {\r\n        StyledElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        ContainerElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.space = xmlspace;\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML anonymous span element\r\n     */\r\n\r\n    function AnonymousSpan() {\r\n        ContentElement.call(this, 'span');\r\n    }\r\n\r\n    AnonymousSpan.prototype.initFromText = function (doc, parent, text, xmllang, xmlspace, errorHandler) {\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, null, errorHandler);\r\n\r\n        this.text = text;\r\n        this.space = xmlspace;\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML br element\r\n     */\r\n\r\n    function Br() {\r\n        ContentElement.call(this, 'br');\r\n    }\r\n\r\n    Br.prototype.initFromNode = function (doc, parent, node, xmllang, errorHandler) {\r\n        LayoutElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Region element\r\n     * \r\n     */\r\n\r\n    function Region() {\r\n    }\r\n\r\n    Region.prototype.createDefaultRegion = function (xmllang) {\r\n        var r = new Region();\r\n\r\n        IdentifiedElement.call(r, '');\r\n        StyledElement.call(r, {});\r\n        AnimatedElement.call(r, []);\r\n        TimedElement.call(r, 0, Number.POSITIVE_INFINITY, null);\r\n\r\n        this.lang = xmllang;\r\n\r\n        return r;\r\n    };\r\n\r\n    Region.prototype.initFromNode = function (doc, node, xmllang, errorHandler) {\r\n        IdentifiedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        TimedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n        AnimatedElement.prototype.initFromNode.call(this, doc, null, node, errorHandler);\r\n\r\n        /* add specified styles */\r\n\r\n        this.styleAttrs = elementGetStyles(node, errorHandler);\r\n\r\n        /* remember referential styles for merging after nested styling is processed*/\r\n\r\n        this.styleRefs = elementGetStyleRefs(node);\r\n\r\n        /* xml:lang */\r\n\r\n        this.lang = xmllang;\r\n    };\r\n\r\n    /*\r\n     * Represents a TTML Set element\r\n     * \r\n     */\r\n\r\n    function Set() {\r\n    }\r\n\r\n    Set.prototype.initFromNode = function (doc, parent, node, errorHandler) {\r\n\r\n        TimedElement.prototype.initFromNode.call(this, doc, parent, node, errorHandler);\r\n\r\n        var styles = elementGetStyles(node, errorHandler);\r\n\r\n        this.qname = null;\r\n        this.value = null;\r\n\r\n        for (var qname in styles) {\r\n\r\n            if (this.qname) {\r\n\r\n                reportError(errorHandler, \"More than one style specified on set\");\r\n                break;\r\n\r\n            }\r\n\r\n            this.qname = qname;\r\n            this.value = styles[qname];\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /*\r\n     * Utility functions\r\n     * \r\n     */\r\n\r\n\r\n    function elementGetXMLID(node) {\r\n        return node && 'xml:id' in node.attributes ? node.attributes['xml:id'].value || null : null;\r\n    }\r\n\r\n    function elementGetRegionID(node) {\r\n        return node && 'region' in node.attributes ? node.attributes.region.value : '';\r\n    }\r\n\r\n    function elementGetTimeContainer(node, errorHandler) {\r\n\r\n        var tc = node && 'timeContainer' in node.attributes ? node.attributes.timeContainer.value : null;\r\n\r\n        if ((!tc) || tc === \"par\") {\r\n\r\n            return \"par\";\r\n\r\n        } else if (tc === \"seq\") {\r\n\r\n            return \"seq\";\r\n\r\n        } else {\r\n\r\n            reportError(errorHandler, \"Illegal value of timeContainer (assuming 'par')\");\r\n\r\n            return \"par\";\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function elementGetStyleRefs(node) {\r\n\r\n        return node && 'style' in node.attributes ? node.attributes.style.value.split(\" \") : [];\r\n\r\n    }\r\n\r\n    function elementGetStyles(node, errorHandler) {\r\n\r\n        var s = {};\r\n\r\n        if (node !== null) {\r\n\r\n            for (var i in node.attributes) {\r\n\r\n                var qname = node.attributes[i].uri + \" \" + node.attributes[i].local;\r\n\r\n                var sa = imscStyles.byQName[qname];\r\n\r\n                if (sa !== undefined) {\r\n\r\n                    var val = sa.parse(node.attributes[i].value);\r\n\r\n                    if (val !== null) {\r\n\r\n                        s[qname] = val;\r\n\r\n                        /* TODO: consider refactoring errorHandler into parse and compute routines */\r\n\r\n                        if (sa === imscStyles.byName.zIndex) {\r\n                            reportWarning(errorHandler, \"zIndex attribute present but not used by IMSC1 since regions do not overlap\");\r\n                        }\r\n\r\n                    } else {\r\n\r\n                        reportError(errorHandler, \"Cannot parse styling attribute \" + qname + \" --> \" + node.attributes[i].value);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    function findAttribute(node, ns, name) {\r\n        for (var i in node.attributes) {\r\n\r\n            if (node.attributes[i].uri === ns &&\r\n                    node.attributes[i].local === name) {\r\n\r\n                return node.attributes[i].value;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function extractAspectRatio(node, errorHandler) {\r\n\r\n        var ar = findAttribute(node, imscNames.ns_ittp, \"aspectRatio\");\r\n\r\n        if (ar === null) {\r\n            \r\n            ar = findAttribute(node, imscNames.ns_ttp, \"displayAspectRatio\");\r\n            \r\n        }\r\n\r\n        var rslt = null;\r\n\r\n        if (ar !== null) {\r\n\r\n            var ASPECT_RATIO_RE = /(\\d+)\\s+(\\d+)/;\r\n\r\n            var m = ASPECT_RATIO_RE.exec(ar);\r\n\r\n            if (m !== null) {\r\n\r\n                var w = parseInt(m[1]);\r\n\r\n                var h = parseInt(m[2]);\r\n\r\n                if (w !== 0 && h !== 0) {\r\n\r\n                    rslt = w / h;\r\n\r\n                } else {\r\n\r\n                    reportError(errorHandler, \"Illegal aspectRatio values (ignoring)\");\r\n                }\r\n\r\n            } else {\r\n\r\n                reportError(errorHandler, \"Malformed aspectRatio attribute (ignoring)\");\r\n            }\r\n\r\n        }\r\n\r\n        return rslt;\r\n\r\n    }\r\n\r\n    /*\r\n     * Returns the cellResolution attribute from a node\r\n     * \r\n     */\r\n    function extractCellResolution(node, errorHandler) {\r\n\r\n        var cr = findAttribute(node, imscNames.ns_ttp, \"cellResolution\");\r\n\r\n        // initial value\r\n\r\n        var h = 15;\r\n        var w = 32;\r\n\r\n        if (cr !== null) {\r\n\r\n            var CELL_RESOLUTION_RE = /(\\d+) (\\d+)/;\r\n\r\n            var m = CELL_RESOLUTION_RE.exec(cr);\r\n\r\n            if (m !== null) {\r\n\r\n                w = parseInt(m[1]);\r\n\r\n                h = parseInt(m[2]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed cellResolution value (using initial value instead)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return {'w': w, 'h': h};\r\n\r\n    }\r\n\r\n\r\n    function extractFrameAndTickRate(node, errorHandler) {\r\n\r\n        // subFrameRate is ignored per IMSC1 specification\r\n\r\n        // extract frame rate\r\n\r\n        var fps_attr = findAttribute(node, imscNames.ns_ttp, \"frameRate\");\r\n\r\n        // initial value\r\n\r\n        var fps = 30;\r\n\r\n        // match variable\r\n\r\n        var m;\r\n\r\n        if (fps_attr !== null) {\r\n\r\n            var FRAME_RATE_RE = /(\\d+)/;\r\n\r\n            m = FRAME_RATE_RE.exec(fps_attr);\r\n\r\n            if (m !== null) {\r\n\r\n                fps = parseInt(m[1]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed frame rate attribute (using initial value instead)\");\r\n            }\r\n\r\n        }\r\n\r\n        // extract frame rate multiplier\r\n\r\n        var frm_attr = findAttribute(node, imscNames.ns_ttp, \"frameRateMultiplier\");\r\n\r\n        // initial value\r\n\r\n        var frm = 1;\r\n\r\n        if (frm_attr !== null) {\r\n\r\n            var FRAME_RATE_MULT_RE = /(\\d+) (\\d+)/;\r\n\r\n            m = FRAME_RATE_MULT_RE.exec(frm_attr);\r\n\r\n            if (m !== null) {\r\n\r\n                frm = parseInt(m[1]) / parseInt(m[2]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed frame rate multiplier attribute (using initial value instead)\");\r\n            }\r\n\r\n        }\r\n\r\n        var efps = frm * fps;\r\n\r\n        // extract tick rate\r\n\r\n        var tr = 1;\r\n\r\n        var trattr = findAttribute(node, imscNames.ns_ttp, \"tickRate\");\r\n\r\n        if (trattr === null) {\r\n\r\n            if (fps_attr !== null)\r\n                tr = efps;\r\n\r\n        } else {\r\n\r\n            var TICK_RATE_RE = /(\\d+)/;\r\n\r\n            m = TICK_RATE_RE.exec(trattr);\r\n\r\n            if (m !== null) {\r\n\r\n                tr = parseInt(m[1]);\r\n\r\n            } else {\r\n\r\n                reportWarning(errorHandler, \"Malformed tick rate attribute (using initial value instead)\");\r\n            }\r\n\r\n        }\r\n\r\n        return {effectiveFrameRate: efps, tickRate: tr};\r\n\r\n    }\r\n\r\n    function extractExtent(node, errorHandler) {\r\n\r\n        var attr = findAttribute(node, imscNames.ns_tts, \"extent\");\r\n\r\n        if (attr === null)\r\n            return null;\r\n\r\n        var s = attr.split(\" \");\r\n\r\n        if (s.length !== 2) {\r\n\r\n            reportWarning(errorHandler, \"Malformed extent (ignoring)\");\r\n\r\n            return null;\r\n        }\r\n\r\n        var w = imscUtils.parseLength(s[0]);\r\n\r\n        var h = imscUtils.parseLength(s[1]);\r\n\r\n        if (!h || !w) {\r\n\r\n            reportWarning(errorHandler, \"Malformed extent values (ignoring)\");\r\n\r\n            return null;\r\n        }\r\n\r\n        return {'h': h, 'w': w};\r\n\r\n    }\r\n\r\n    function parseTimeExpression(tickRate, effectiveFrameRate, str) {\r\n\r\n        var CLOCK_TIME_FRACTION_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d(?:\\.\\d+)?)$/;\r\n        var CLOCK_TIME_FRAMES_RE = /^(\\d{2,}):(\\d\\d):(\\d\\d)\\:(\\d{2,})$/;\r\n        var OFFSET_FRAME_RE = /^(\\d+(?:\\.\\d+)?)f$/;\r\n        var OFFSET_TICK_RE = /^(\\d+(?:\\.\\d+)?)t$/;\r\n        var OFFSET_MS_RE = /^(\\d+(?:\\.\\d+)?)ms$/;\r\n        var OFFSET_S_RE = /^(\\d+(?:\\.\\d+)?)s$/;\r\n        var OFFSET_H_RE = /^(\\d+(?:\\.\\d+)?)h$/;\r\n        var OFFSET_M_RE = /^(\\d+(?:\\.\\d+)?)m$/;\r\n        var m;\r\n        var r = null;\r\n        if ((m = OFFSET_FRAME_RE.exec(str)) !== null) {\r\n\r\n            if (effectiveFrameRate !== null) {\r\n\r\n                r = parseFloat(m[1]) / effectiveFrameRate;\r\n            }\r\n\r\n        } else if ((m = OFFSET_TICK_RE.exec(str)) !== null) {\r\n\r\n            if (tickRate !== null) {\r\n\r\n                r = parseFloat(m[1]) / tickRate;\r\n            }\r\n\r\n        } else if ((m = OFFSET_MS_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]) / 1000.0;\r\n\r\n        } else if ((m = OFFSET_S_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]);\r\n\r\n        } else if ((m = OFFSET_H_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]) * 3600.0;\r\n\r\n        } else if ((m = OFFSET_M_RE.exec(str)) !== null) {\r\n\r\n            r = parseFloat(m[1]) * 60.0;\r\n\r\n        } else if ((m = CLOCK_TIME_FRACTION_RE.exec(str)) !== null) {\r\n\r\n            r = parseInt(m[1]) * 3600 +\r\n                    parseInt(m[2]) * 60 +\r\n                    parseFloat(m[3]);\r\n\r\n        } else if ((m = CLOCK_TIME_FRAMES_RE.exec(str)) !== null) {\r\n\r\n            /* this assumes that HH:MM:SS is a clock-time-with-fraction */\r\n\r\n            if (effectiveFrameRate !== null) {\r\n\r\n                r = parseInt(m[1]) * 3600 +\r\n                        parseInt(m[2]) * 60 +\r\n                        parseInt(m[3]) +\r\n                        (m[4] === null ? 0 : parseInt(m[4]) / effectiveFrameRate);\r\n            }\r\n\r\n        }\r\n\r\n        return r;\r\n    }\r\n\r\n    function processTiming(doc, parent, node, errorHandler) {\r\n\r\n        /* determine explicit begin */\r\n\r\n        var explicit_begin = null;\r\n\r\n        if (node && 'begin' in node.attributes) {\r\n\r\n            explicit_begin = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.begin.value);\r\n\r\n            if (explicit_begin === null) {\r\n\r\n                reportWarning(errorHandler, \"Malformed begin value \" + node.attributes.begin.value + \" (using 0)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* determine explicit duration */\r\n\r\n        var explicit_dur = null;\r\n\r\n        if (node && 'dur' in node.attributes) {\r\n\r\n            explicit_dur = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.dur.value);\r\n\r\n            if (explicit_dur === null) {\r\n\r\n                reportWarning(errorHandler, \"Malformed dur value \" + node.attributes.dur.value + \" (ignoring)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /* determine explicit end */\r\n\r\n        var explicit_end = null;\r\n\r\n        if (node && 'end' in node.attributes) {\r\n\r\n            explicit_end = parseTimeExpression(doc.tickRate, doc.effectiveFrameRate, node.attributes.end.value);\r\n\r\n            if (explicit_end === null) {\r\n\r\n                reportWarning(errorHandler, \"Malformed end value (ignoring)\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return {explicit_begin: explicit_begin,\r\n            explicit_end: explicit_end,\r\n            explicit_dur: explicit_dur};\r\n\r\n    }\r\n\r\n\r\n\r\n    function mergeChainedStyles(styling, style, errorHandler) {\r\n\r\n        while (style.styleRefs.length > 0) {\r\n\r\n            var sref = style.styleRefs.pop();\r\n\r\n            if (!(sref in styling.styles)) {\r\n                reportError(errorHandler, \"Non-existant style id referenced\");\r\n                continue;\r\n            }\r\n\r\n            mergeChainedStyles(styling, styling.styles[sref], errorHandler);\r\n\r\n            mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, style.styleAttrs);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function mergeReferencedStyles(styling, stylerefs, styleattrs, errorHandler) {\r\n\r\n        for (var i = stylerefs.length - 1; i >= 0; i--) {\r\n\r\n            var sref = stylerefs[i];\r\n\r\n            if (!(sref in styling.styles)) {\r\n                reportError(errorHandler, \"Non-existant style id referenced\");\r\n                continue;\r\n            }\r\n\r\n            mergeStylesIfNotPresent(styling.styles[sref].styleAttrs, styleattrs);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function mergeStylesIfNotPresent(from_styles, into_styles) {\r\n\r\n        for (var sname in from_styles) {\r\n\r\n            if (sname in into_styles)\r\n                continue;\r\n\r\n            into_styles[sname] = from_styles[sname];\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /* TODO: validate style format at parsing */\r\n\r\n\r\n    /*\r\n     * ERROR HANDLING UTILITY FUNCTIONS\r\n     * \r\n     */\r\n\r\n    function reportInfo(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.info && errorHandler.info(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportWarning(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.warn && errorHandler.warn(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportError(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.error && errorHandler.error(msg))\r\n            throw msg;\r\n\r\n    }\r\n\r\n    function reportFatal(errorHandler, msg) {\r\n\r\n        if (errorHandler && errorHandler.fatal)\r\n            errorHandler.fatal(msg);\r\n\r\n        throw msg;\r\n\r\n    }\r\n\r\n    /*\r\n     * Binary search utility function\r\n     * \r\n     * @typedef {Object} BinarySearchResult\r\n     * @property {boolean} found Was an exact match found?\r\n     * @property {number} index Position of the exact match or insert position\r\n     * \r\n     * @returns {BinarySearchResult}\r\n     */\r\n\r\n    function indexOf(arr, searchval) {\r\n\r\n        var min = 0;\r\n        var max = arr.length - 1;\r\n        var cur;\r\n\r\n        while (min <= max) {\r\n\r\n            cur = Math.floor((min + max) / 2);\r\n\r\n            var curval = arr[cur];\r\n\r\n            if (curval < searchval) {\r\n\r\n                min = cur + 1;\r\n\r\n            } else if (curval > searchval) {\r\n\r\n                max = cur - 1;\r\n\r\n            } else {\r\n\r\n                return {found: true, index: cur};\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return {found: false, index: min};\r\n    }\r\n\r\n\r\n})(typeof exports === 'undefined' ? this.imscDoc = {} : exports,\r\n        typeof sax === 'undefined' ? require(\"sax\") : sax,\r\n        typeof imscNames === 'undefined' ? require(\"./names\") : imscNames,\r\n        typeof imscStyles === 'undefined' ? require(\"./styles\") : imscStyles,\r\n        typeof imscUtils === 'undefined' ? require(\"./utils\") : imscUtils);\r\n"]},"metadata":{},"sourceType":"script"}