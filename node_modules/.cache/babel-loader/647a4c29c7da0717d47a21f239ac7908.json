{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* @class\n* @ignore\n*/\n\n\nvar SimpleXPath = function () {\n  function SimpleXPath(selector) {\n    var _this = this;\n\n    _classCallCheck(this, SimpleXPath); // establish validation of the path, to catch unsupported cases\n\n\n    this.valid = selector[0] == '/'; // first check, we only support absolute addressing\n    // establish parsed path, example:\n    // /MPD/Period[@id=\"foobar\"]/AdaptationSet[@id=\"2\"]/SegmentTemplate/SegmentTimeline\n\n    this.path = selector.split('/').filter(function (component) {\n      return component.length !== 0;\n    }) // remove excess empty components\n    .map(function (component) {\n      var parsed = {\n        name: component\n      };\n      var qualifierPoint = component.indexOf('[');\n\n      if (qualifierPoint != -1) {\n        parsed.name = component.substring(0, qualifierPoint);\n        var qualifier = component.substring(qualifierPoint + 1, component.length - 1); // quick sanity check are there additional qualifiers making this invalid\n\n        _this.valid = _this.valid && qualifier.indexOf('[') == -1;\n        var equalityPoint = qualifier.indexOf('=');\n\n        if (equalityPoint != -1) {\n          parsed.attribute = {\n            name: qualifier.substring(1, equalityPoint),\n            // skip the @\n            value: qualifier.substring(equalityPoint + 1)\n          }; // check for single and double quoted attribute values\n\n          if (['\\'', '\"'].indexOf(parsed.attribute.value[0]) != -1) {\n            parsed.attribute.value = parsed.attribute.value.substring(1, parsed.attribute.value.length - 1);\n          }\n        } else {\n          // positional access in xpath is 1-based index\n          // internal processes will assume 0-based so we normalize that here\n          parsed.position = parseInt(qualifier, 10) - 1;\n        }\n      }\n\n      return parsed;\n    });\n  }\n\n  _createClass(SimpleXPath, [{\n    key: 'isValid',\n    value: function isValid() {\n      return this.valid;\n    }\n  }, {\n    key: 'findsElement',\n    value: function findsElement() {\n      return !this.findsAttribute();\n    }\n  }, {\n    key: 'findsAttribute',\n    value: function findsAttribute() {\n      return this.path[this.path.length - 1].name.startsWith('@');\n    }\n  }, {\n    key: 'getMpdTarget',\n    value: function getMpdTarget(root, isSiblingOperation) {\n      var parent = null;\n      var leaf = root; // assume root is MPD and we start at next level match\n\n      var level = 1;\n      var name = 'MPD';\n\n      while (level < this.path.length && leaf !== null) {\n        // set parent to current\n        parent = leaf; // select next leaf based on component\n\n        var component = this.path[level];\n        name = component.name; // stop one early if this is the last element and an attribute\n\n        if (level !== this.path.length - 1 || !name.startsWith('@')) {\n          var children = parent[name + '_asArray'] || [];\n\n          if (children.length === 0 && parent[name]) {\n            children.push(parent[name]);\n          }\n\n          if (component.position) {\n            leaf = children[component.position] || null;\n          } else if (component.attribute) {\n            (function () {\n              var attr = component.attribute;\n              leaf = children.filter(function (elm) {\n                return elm[attr.name] == attr.value;\n              })[0] || null;\n            })();\n          } else {\n            // default case, select first\n            leaf = children[0] || null;\n          }\n        }\n\n        level++;\n      }\n\n      if (leaf === null) {\n        // given path not found in root\n        return null;\n      } // attributes the target is the leaf node, the name is the attribute\n\n\n      if (name.startsWith('@')) {\n        return {\n          name: name.substring(1),\n          leaf: leaf,\n          target: leaf\n        };\n      } // otherwise we target the parent for sibling operations and leaf for child operations\n\n\n      return {\n        name: name,\n        leaf: leaf,\n        target: isSiblingOperation ? parent : leaf\n      };\n    }\n  }]);\n\n  return SimpleXPath;\n}();\n\nexports.default = SimpleXPath;","map":{"version":3,"sources":["../../../../../src/dash/vo/SimpleXPath.js"],"names":["SimpleXPath","selector","component","parsed","name","qualifierPoint","qualifier","equalityPoint","value","parseInt","root","isSiblingOperation","parent","leaf","level","children","attr","elm","target"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;AAIMA,IAAAA,W;AACF,WAAA,WAAA,CAAA,QAAA,EAAsB;AAAA,QAAA,KAAA,GAAA,IAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,CAAA,CAAA,CAClB;;;AACA,SAAA,KAAA,GAAaC,QAAAA,CAAAA,CAAAA,CAAAA,IAAb,GAAA,CAFkB,CAEe;AAEjC;AACA;;AACA,SAAA,IAAA,GAAY,QAAA,CAAA,KAAA,CAAA,GAAA,EAAA,MAAA,CACA,UAAA,SAAA,EAAA;AAAA,aAAeC,SAAAA,CAAAA,MAAAA,KAAf,CAAA;AADA,KAAA,EACuC;AADvC,KAAA,GAAA,CAEH,UAAA,SAAA,EAAe;AAChB,UAAIC,MAAAA,GAAS;AACTC,QAAAA,IAAAA,EADJ;AAAa,OAAb;AAIA,UAAIC,cAAAA,GAAiBH,SAAAA,CAAAA,OAAAA,CAArB,GAAqBA,CAArB;;AACA,UAAIG,cAAAA,IAAkB,CAAtB,CAAA,EAA0B;AACtBF,QAAAA,MAAAA,CAAAA,IAAAA,GAAcD,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,EAAdC,cAAcD,CAAdC;AAEA,YAAIG,SAAAA,GAAYJ,SAAAA,CAAAA,SAAAA,CAAoBG,cAAAA,GAApBH,CAAAA,EAAwCA,SAAAA,CAAAA,MAAAA,GAAxD,CAAgBA,CAAhB,CAHsB,CAKtB;;AACA,QAAA,KAAA,CAAA,KAAA,GAAa,KAAA,CAAA,KAAA,IAAcI,SAAAA,CAAAA,OAAAA,CAAAA,GAAAA,KAA0B,CAArD,CAAA;AAEA,YAAIC,aAAAA,GAAgBD,SAAAA,CAAAA,OAAAA,CAApB,GAAoBA,CAApB;;AACA,YAAIC,aAAAA,IAAiB,CAArB,CAAA,EAAyB;AACrB,UAAA,MAAA,CAAA,SAAA,GAAmB;AACfH,YAAAA,IAAAA,EAAME,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,EADS,aACTA,CADS;AAC8B;AAC7CE,YAAAA,KAAAA,EAAOF,SAAAA,CAAAA,SAAAA,CAAoBC,aAAAA,GAF/B,CAEWD;AAFQ,WAAnB,CADqB,CAMrB;;AACA,cAAI,CAAA,IAAA,EAAA,GAAA,EAAA,OAAA,CAAoBH,MAAAA,CAAAA,SAAAA,CAAAA,KAAAA,CAApB,CAAoBA,CAApB,KAAkD,CAAtD,CAAA,EAA0D;AACtDA,YAAAA,MAAAA,CAAAA,SAAAA,CAAAA,KAAAA,GAAyBA,MAAAA,CAAAA,SAAAA,CAAAA,KAAAA,CAAAA,SAAAA,CAAAA,CAAAA,EAAoCA,MAAAA,CAAAA,SAAAA,CAAAA,KAAAA,CAAAA,MAAAA,GAA7DA,CAAyBA,CAAzBA;AAEP;AAVD,SAAA,MAUO;AACH;AACA;AACAA,UAAAA,MAAAA,CAAAA,QAAAA,GAAkBM,QAAAA,CAAAA,SAAAA,EAAAA,EAAAA,CAAAA,GAAlBN,CAAAA;AAEP;AAED;;AAAA,aAAA,MAAA;AAlCR,KAAY,CAAZ;;;;;8BAsCM;AACN,aAAO,KAAP,KAAA;;;;mCAGW;AACX,aAAO,CAAC,KAAR,cAAQ,EAAR;;;;qCAGa;AACb,aAAO,KAAA,IAAA,CAAU,KAAA,IAAA,CAAA,MAAA,GAAV,CAAA,EAAA,IAAA,CAAA,UAAA,CAAP,GAAO,CAAP;;;;iCAGSO,I,EAAMC,kB,EAAoB;AACnC,UAAIC,MAAAA,GAAJ,IAAA;AACA,UAAIC,IAAAA,GAAJ,IAAA,CAFmC,CAGnC;;AACA,UAAIC,KAAAA,GAAJ,CAAA;AACA,UAAIV,IAAAA,GAAJ,KAAA;;AAEA,aAAQU,KAAAA,GAAQ,KAAA,IAAA,CAARA,MAAAA,IAA4BD,IAAAA,KAApC,IAAA,EAAmD;AAC/C;AACAD,QAAAA,MAAAA,GAAAA,IAAAA,CAF+C,CAI/C;;AACA,YAAIV,SAAAA,GAAY,KAAA,IAAA,CAAhB,KAAgB,CAAhB;AACAE,QAAAA,IAAAA,GAAOF,SAAAA,CAAPE,IAAAA,CAN+C,CAQ/C;;AACA,YAAIU,KAAAA,KAAU,KAAA,IAAA,CAAA,MAAA,GAAVA,CAAAA,IAAkC,CAACV,IAAAA,CAAAA,UAAAA,CAAvC,GAAuCA,CAAvC,EAA6D;AACzD,cAAIW,QAAAA,GAAWH,MAAAA,CAAOR,IAAAA,GAAPQ,UAAAA,CAAAA,IAAf,EAAA;;AACA,cAAIG,QAAAA,CAAAA,MAAAA,KAAAA,CAAAA,IAAyBH,MAAAA,CAA7B,IAA6BA,CAA7B,EAA2C;AACvCG,YAAAA,QAAAA,CAAAA,IAAAA,CAAcH,MAAAA,CAAdG,IAAcH,CAAdG;AAGJ;;AAAA,cAAIb,SAAAA,CAAJ,QAAA,EAAwB;AACpBW,YAAAA,IAAAA,GAAOE,QAAAA,CAASb,SAAAA,CAATa,QAAAA,CAAAA,IAAPF,IAAAA;AADJ,WAAA,MAEO,IAAIX,SAAAA,CAAJ,SAAA,EAAyB;AAAA,aAAA,YAAA;AAC5B,kBAAIc,IAAAA,GAAOd,SAAAA,CAAX,SAAA;AACAW,cAAAA,IAAAA,GAAOE,QAAAA,CAAAA,MAAAA,CAAgB,UAAA,GAAA,EAAA;AAAA,uBAASE,GAAAA,CAAID,IAAAA,CAAJC,IAAAA,CAAAA,IAAkBD,IAAAA,CAA3B,KAAA;AAAhBD,eAAAA,EAAAA,CAAAA,KAFqB,IAE5BF;AAF4B,aAAA;AAAzB,WAAA,MAGA;AACH;AACAA,YAAAA,IAAAA,GAAOE,QAAAA,CAAAA,CAAAA,CAAAA,IAAPF,IAAAA;AAEP;AAEDC;;AAAAA,QAAAA,KAAAA;AAGJ;;AAAA,UAAID,IAAAA,KAAJ,IAAA,EAAmB;AACf;AACA,eAAA,IAAA;AAGJ,OAzCmC,CAyCnC;;;AACA,UAAIT,IAAAA,CAAAA,UAAAA,CAAJ,GAAIA,CAAJ,EAA0B;AACtB,eAAO;AACHA,UAAAA,IAAAA,EAAMA,IAAAA,CAAAA,SAAAA,CADH,CACGA,CADH;AAEHS,UAAAA,IAAAA,EAFG,IAAA;AAGHK,UAAAA,MAAAA,EAHJ;AAAO,SAAP;AAOJ,OAlDmC,CAkDnC;;;AACA,aAAO;AACHd,QAAAA,IAAAA,EADG,IAAA;AAEHS,QAAAA,IAAAA,EAFG,IAAA;AAGHK,QAAAA,MAAAA,EAAQP,kBAAAA,GAAAA,MAAAA,GAHZ;AAAO,OAAP;;;;;GA5GFX;;kBAoHSA,W","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * @class\n * @ignore\n */\nclass SimpleXPath {\n    constructor(selector) {\n        // establish validation of the path, to catch unsupported cases\n        this.valid = selector[0] == '/'; // first check, we only support absolute addressing\n\n        // establish parsed path, example:\n        // /MPD/Period[@id=\"foobar\"]/AdaptationSet[@id=\"2\"]/SegmentTemplate/SegmentTimeline\n        this.path = selector.split('/')\n            .filter((component) => component.length !== 0) // remove excess empty components\n            .map((component) => {\n                let parsed = {\n                    name: component\n                };\n\n                let qualifierPoint = component.indexOf('[');\n                if (qualifierPoint != -1) {\n                    parsed.name = component.substring(0, qualifierPoint);\n\n                    let qualifier = component.substring(qualifierPoint + 1, component.length - 1);\n\n                    // quick sanity check are there additional qualifiers making this invalid\n                    this.valid = this.valid && qualifier.indexOf('[') == -1;\n\n                    let equalityPoint = qualifier.indexOf('=');\n                    if (equalityPoint != -1) {\n                        parsed.attribute = {\n                            name: qualifier.substring(1, equalityPoint), // skip the @\n                            value: qualifier.substring(equalityPoint + 1)\n                        };\n\n                        // check for single and double quoted attribute values\n                        if (['\\'', '\"'].indexOf(parsed.attribute.value[0]) != -1) {\n                            parsed.attribute.value = parsed.attribute.value.substring(1, parsed.attribute.value.length - 1);\n                        }\n                    } else {\n                        // positional access in xpath is 1-based index\n                        // internal processes will assume 0-based so we normalize that here\n                        parsed.position = parseInt(qualifier, 10) - 1;\n                    }\n                }\n\n                return parsed;\n            });\n    }\n\n    isValid() {\n        return this.valid;\n    }\n\n    findsElement() {\n        return !this.findsAttribute();\n    }\n\n    findsAttribute() {\n        return this.path[this.path.length - 1].name.startsWith('@');\n    }\n\n    getMpdTarget(root, isSiblingOperation) {\n        let parent = null;\n        let leaf = root;\n        // assume root is MPD and we start at next level match\n        let level = 1;\n        let name = 'MPD';\n\n        while ( level < this.path.length && leaf !== null) {\n            // set parent to current\n            parent = leaf;\n\n            // select next leaf based on component\n            let component = this.path[level];\n            name = component.name;\n\n            // stop one early if this is the last element and an attribute\n            if (level !== this.path.length - 1 || !name.startsWith('@')) {\n                let children = parent[name + '_asArray'] || [];\n                if (children.length === 0 && parent[name]) {\n                    children.push(parent[name]);\n                }\n\n                if (component.position) {\n                    leaf = children[component.position] || null;\n                } else if (component.attribute) {\n                    let attr = component.attribute;\n                    leaf = children.filter((elm) => elm[attr.name] == attr.value)[0] || null;\n                } else {\n                    // default case, select first\n                    leaf = children[0] || null;\n                }\n            }\n\n            level++;\n        }\n\n        if (leaf === null) {\n            // given path not found in root\n            return null;\n        }\n\n        // attributes the target is the leaf node, the name is the attribute\n        if (name.startsWith('@')) {\n            return {\n                name: name.substring(1),\n                leaf: leaf,\n                target: leaf\n            };\n        }\n\n        // otherwise we target the parent for sibling operations and leaf for child operations\n        return {\n            name: name,\n            leaf: leaf,\n            target: isSiblingOperation ? parent : leaf\n        };\n    }\n}\n\nexport default SimpleXPath;\n"]},"metadata":{},"sourceType":"script"}