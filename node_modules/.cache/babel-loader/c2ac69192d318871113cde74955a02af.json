{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Debug = require('../../../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _LearningAbrController = require('./LearningAbrController');\n\nvar _LearningAbrController2 = _interopRequireDefault(_LearningAbrController);\n\nvar _LoLpQoEEvaluator = require('./LoLpQoEEvaluator');\n\nvar _LoLpQoEEvaluator2 = _interopRequireDefault(_LoLpQoEEvaluator);\n\nvar _SwitchRequest = require('../../SwitchRequest');\n\nvar _SwitchRequest2 = _interopRequireDefault(_SwitchRequest);\n\nvar _MetricsConstants = require('../../../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _LoLpWeightSelector = require('./LoLpWeightSelector');\n\nvar _LoLpWeightSelector2 = _interopRequireDefault(_LoLpWeightSelector);\n\nvar _Constants = require('../../../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nvar DWS_TARGET_LATENCY = 1.5;\nvar DWS_BUFFER_MIN = 0.3;\n\nfunction LoLPRule(config) {\n  config = config || {};\n  var dashMetrics = config.dashMetrics;\n  var context = this.context;\n  var logger = void 0,\n      instance = void 0,\n      learningController = void 0,\n      qoeEvaluator = void 0;\n\n  function _setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    learningController = (0, _LearningAbrController2.default)(context).create();\n    qoeEvaluator = (0, _LoLpQoEEvaluator2.default)(context).create();\n  }\n\n  function getMaxIndex(rulesContext) {\n    try {\n      var switchRequest = (0, _SwitchRequest2.default)(context).create();\n      var mediaType = rulesContext.getMediaInfo().type;\n      var abrController = rulesContext.getAbrController();\n      var streamInfo = rulesContext.getStreamInfo();\n      var currentQuality = abrController.getQualityFor(mediaType, streamInfo);\n      var mediaInfo = rulesContext.getMediaInfo();\n      var bufferStateVO = dashMetrics.getCurrentBufferState(mediaType);\n      var scheduleController = rulesContext.getScheduleController();\n      var currentBufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n      var isDynamic = streamInfo && streamInfo.manifestInfo ? streamInfo.manifestInfo.isDynamic : null;\n      var playbackController = scheduleController.getPlaybackController();\n      var latency = playbackController.getCurrentLiveLatency();\n\n      if (!rulesContext.useLoLPABR() || mediaType === _Constants2.default.AUDIO) {\n        return switchRequest;\n      }\n\n      if (!latency) {\n        latency = 0;\n      }\n\n      var playbackRate = playbackController.getPlaybackRate();\n      var throughputHistory = abrController.getThroughputHistory();\n      var throughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n      logger.debug('Throughput ' + Math.round(throughput) + ' kbps');\n\n      if (isNaN(throughput) || !bufferStateVO) {\n        return switchRequest;\n      }\n\n      if (abrController.getAbandonmentStateFor(mediaType) === _MetricsConstants2.default.ABANDON_LOAD) {\n        return switchRequest;\n      } // QoE parameters\n\n\n      var bitrateList = mediaInfo.bitrateList; // [{bandwidth: 200000, width: 640, height: 360}, ...]\n\n      var segmentDuration = rulesContext.getRepresentationInfo().fragmentDuration;\n      var minBitrateKbps = bitrateList[0].bandwidth / 1000.0; // min bitrate level\n\n      var maxBitrateKbps = bitrateList[bitrateList.length - 1].bandwidth / 1000.0; // max bitrate level\n\n      for (var i = 0; i < bitrateList.length; i++) {\n        // in case bitrateList is not sorted as expected\n        var b = bitrateList[i].bandwidth / 1000.0;\n        if (b > maxBitrateKbps) maxBitrateKbps = b;else if (b < minBitrateKbps) {\n          minBitrateKbps = b;\n        }\n      } // Learning rule pre-calculations\n\n\n      var currentBitrate = bitrateList[currentQuality].bandwidth;\n      var currentBitrateKbps = currentBitrate / 1000.0;\n      var httpRequest = dashMetrics.getCurrentHttpRequest(mediaType, true);\n      var lastFragmentDownloadTime = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;\n      var segmentRebufferTime = lastFragmentDownloadTime > segmentDuration ? lastFragmentDownloadTime - segmentDuration : 0;\n      qoeEvaluator.setupPerSegmentQoe(segmentDuration, maxBitrateKbps, minBitrateKbps);\n      qoeEvaluator.logSegmentMetrics(currentBitrateKbps, segmentRebufferTime, latency, playbackRate);\n      /*\n      * Dynamic Weights Selector (step 1/2: initialization)\n      */\n\n      var dynamicWeightsSelector = (0, _LoLpWeightSelector2.default)(context).create({\n        targetLatency: DWS_TARGET_LATENCY,\n        bufferMin: DWS_BUFFER_MIN,\n        segmentDuration: segmentDuration,\n        qoeEvaluator: qoeEvaluator\n      });\n      /*\n      * Select next quality\n      */\n\n      switchRequest.quality = learningController.getNextQuality(mediaInfo, throughput * 1000, latency, currentBufferLevel, playbackRate, currentQuality, dynamicWeightsSelector);\n      switchRequest.reason = {\n        throughput: throughput,\n        latency: latency\n      };\n      switchRequest.priority = _SwitchRequest2.default.PRIORITY.STRONG;\n      scheduleController.setTimeToLoadDelay(0);\n\n      if (switchRequest.quality !== currentQuality) {\n        console.log('[TgcLearningRule][' + mediaType + '] requesting switch to index: ', switchRequest.quality, 'Average throughput', Math.round(throughput), 'kbps');\n      }\n\n      return switchRequest;\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Reset objects to their initial state\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    learningController.reset();\n    qoeEvaluator.reset();\n  }\n  /**\n  * Reset the rule\n  */\n\n\n  function reset() {\n    _resetInitialSettings();\n  }\n\n  instance = {\n    getMaxIndex: getMaxIndex,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n\nLoLPRule.__dashjs_factory_name = 'LoLPRule';\nexports.default = _FactoryMaker2.default.getClassFactory(LoLPRule);","map":{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LoLpRule.js"],"names":["DWS_TARGET_LATENCY","DWS_BUFFER_MIN","config","dashMetrics","context","logger","instance","learningController","qoeEvaluator","switchRequest","mediaType","rulesContext","abrController","streamInfo","currentQuality","mediaInfo","bufferStateVO","scheduleController","currentBufferLevel","isDynamic","playbackController","latency","Constants","playbackRate","throughputHistory","throughput","Math","isNaN","MetricsConstants","bitrateList","segmentDuration","minBitrateKbps","maxBitrateKbps","i","b","currentBitrate","currentBitrateKbps","httpRequest","lastFragmentDownloadTime","segmentRebufferTime","dynamicWeightsSelector","targetLatency","bufferMin","SwitchRequest","console","_resetInitialSettings","getMaxIndex","reset","_setup","LoLPRule","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport Debug from '../../../../core/Debug';\nimport FactoryMaker from '../../../../core/FactoryMaker';\nimport LearningAbrController from './LearningAbrController';\nimport LoLpQoeEvaluator from './LoLpQoEEvaluator';\nimport SwitchRequest from '../../SwitchRequest';\nimport MetricsConstants from '../../../constants/MetricsConstants';\nimport LoLpWeightSelector from './LoLpWeightSelector';\nimport Constants from '../../../constants/Constants';\n\nconst DWS_TARGET_LATENCY = 1.5;\nconst DWS_BUFFER_MIN = 0.3;\n\nfunction LoLPRule(config) {\n\n    config = config || {};\n\n    let dashMetrics = config.dashMetrics;\n    let context = this.context;\n\n    let logger,\n        instance,\n        learningController,\n        qoeEvaluator;\n\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        learningController = LearningAbrController(context).create();\n        qoeEvaluator = LoLpQoeEvaluator(context).create();\n    }\n\n    function getMaxIndex(rulesContext) {\n        try {\n            let switchRequest = SwitchRequest(context).create();\n            let mediaType = rulesContext.getMediaInfo().type;\n            let abrController = rulesContext.getAbrController();\n            const streamInfo = rulesContext.getStreamInfo();\n            let currentQuality = abrController.getQualityFor(mediaType, streamInfo);\n            const mediaInfo = rulesContext.getMediaInfo();\n            const bufferStateVO = dashMetrics.getCurrentBufferState(mediaType);\n            const scheduleController = rulesContext.getScheduleController();\n            const currentBufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n            const isDynamic = streamInfo && streamInfo.manifestInfo ? streamInfo.manifestInfo.isDynamic : null;\n            const playbackController = scheduleController.getPlaybackController();\n            let latency = playbackController.getCurrentLiveLatency();\n\n            if (!rulesContext.useLoLPABR() || (mediaType === Constants.AUDIO)) {\n                return switchRequest;\n            }\n\n            if (!latency) {\n                latency = 0;\n            }\n\n            const playbackRate = playbackController.getPlaybackRate();\n            const throughputHistory = abrController.getThroughputHistory();\n            const throughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n            logger.debug(`Throughput ${Math.round(throughput)} kbps`);\n\n            if (isNaN(throughput) || !bufferStateVO) {\n                return switchRequest;\n            }\n\n            if (abrController.getAbandonmentStateFor(mediaType) === MetricsConstants.ABANDON_LOAD) {\n                return switchRequest;\n            }\n\n            // QoE parameters\n            let bitrateList = mediaInfo.bitrateList;  // [{bandwidth: 200000, width: 640, height: 360}, ...]\n            let segmentDuration = rulesContext.getRepresentationInfo().fragmentDuration;\n            let minBitrateKbps = bitrateList[0].bandwidth / 1000.0;                         // min bitrate level\n            let maxBitrateKbps = bitrateList[bitrateList.length - 1].bandwidth / 1000.0;    // max bitrate level\n            for (let i = 0; i < bitrateList.length; i++) {  // in case bitrateList is not sorted as expected\n                let b = bitrateList[i].bandwidth / 1000.0;\n                if (b > maxBitrateKbps)\n                    maxBitrateKbps = b;\n                else if (b < minBitrateKbps) {\n                    minBitrateKbps = b;\n                }\n            }\n\n            // Learning rule pre-calculations\n            let currentBitrate = bitrateList[currentQuality].bandwidth;\n            let currentBitrateKbps = currentBitrate / 1000.0;\n            let httpRequest = dashMetrics.getCurrentHttpRequest(mediaType, true);\n            let lastFragmentDownloadTime = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;\n            let segmentRebufferTime = lastFragmentDownloadTime > segmentDuration ? lastFragmentDownloadTime - segmentDuration : 0;\n            qoeEvaluator.setupPerSegmentQoe(segmentDuration, maxBitrateKbps, minBitrateKbps);\n            qoeEvaluator.logSegmentMetrics(currentBitrateKbps, segmentRebufferTime, latency, playbackRate);\n\n            /*\n            * Dynamic Weights Selector (step 1/2: initialization)\n            */\n            let dynamicWeightsSelector = LoLpWeightSelector(context).create({\n                targetLatency: DWS_TARGET_LATENCY,\n                bufferMin: DWS_BUFFER_MIN,\n                segmentDuration,\n                qoeEvaluator\n            });\n\n            /*\n             * Select next quality\n             */\n            switchRequest.quality = learningController.getNextQuality(mediaInfo, throughput * 1000, latency, currentBufferLevel, playbackRate, currentQuality, dynamicWeightsSelector);\n            switchRequest.reason = { throughput: throughput, latency: latency };\n            switchRequest.priority = SwitchRequest.PRIORITY.STRONG;\n\n            scheduleController.setTimeToLoadDelay(0);\n\n            if (switchRequest.quality !== currentQuality) {\n                console.log('[TgcLearningRule][' + mediaType + '] requesting switch to index: ', switchRequest.quality, 'Average throughput', Math.round(throughput), 'kbps');\n            }\n\n            return switchRequest;\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Reset objects to their initial state\n     * @private\n     */\n    function _resetInitialSettings() {\n        learningController.reset();\n        qoeEvaluator.reset();\n    }\n\n    /**\n     * Reset the rule\n     */\n    function reset() {\n        _resetInitialSettings();\n    }\n\n    instance = {\n        getMaxIndex,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLPRule.__dashjs_factory_name = 'LoLPRule';\nexport default FactoryMaker.getClassFactory(LoLPRule);\n"]},"metadata":{},"sourceType":"script"}