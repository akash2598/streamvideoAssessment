{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction LoLpWeightSelector(config) {\n  var targetLatency = config.targetLatency;\n  var bufferMin = config.bufferMin;\n  var segmentDuration = config.segmentDuration;\n  var qoeEvaluator = config.qoeEvaluator;\n  var instance = void 0,\n      valueList = void 0,\n      weightTypeCount = void 0,\n      weightOptions = void 0,\n      previousLatency = void 0;\n  /**\n  *\n  * @private\n  */\n\n  function _setup() {\n    _resetInitialSettings();\n  }\n  /**\n  *\n  * @private\n  */\n\n\n  function _resetInitialSettings() {\n    valueList = [0.2, 0.4, 0.6, 0.8, 1];\n    weightTypeCount = 4;\n    weightOptions = _getPermutations(valueList, weightTypeCount);\n    previousLatency = 0;\n  }\n  /**\n  * Next, at each segment boundary, ABR to input current neurons and target state (only used in Method II) to find the desired weight vector\n  * @param {array} neurons\n  * @param {number} currentLatency\n  * @param {number} currentBuffer\n  * @param {number} currentRebuffer\n  * @param {number} currentThroughput\n  * @param {number} playbackRate\n  * @return {null}\n  * @private\n  */\n\n\n  function findWeightVector(neurons, currentLatency, currentBuffer, currentRebuffer, currentThroughput, playbackRate) {\n    var maxQoE = null;\n    var winnerWeights = null;\n    var winnerBitrate = null;\n    var deltaLatency = Math.abs(currentLatency - previousLatency); // For each neuron, m\n\n    neurons.forEach(function (neuron) {\n      // For each possible weight vector, z\n      // E.g. For [ throughput, latency, buffer, playbackRate, QoE ]\n      //      Possible weightVector = [ 0.2, 0.4, 0.2, 0, 0.2 ]\n      weightOptions.forEach(function (weightVector) {\n        // Apply weightVector to neuron, compute utility and determine winnerWeights\n        // Method I: Utility based on QoE given current state\n        var weightsObj = {\n          throughput: weightVector[0],\n          latency: weightVector[1],\n          buffer: weightVector[2],\n          switch: weightVector[3]\n        };\n        var downloadTime = neuron.bitrate * segmentDuration / currentThroughput;\n        var nextBuffer = getNextBuffer(currentBuffer, downloadTime);\n        var rebuffer = Math.max(0.00001, downloadTime - nextBuffer);\n        var wt = void 0;\n\n        if (weightsObj.buffer === 0) {\n          wt = 10;\n        } else {\n          wt = 1 / weightsObj.buffer;\n        }\n\n        var weightedRebuffer = wt * rebuffer;\n\n        if (weightsObj.latency === 0) {\n          wt = 10;\n        } else {\n          wt = 1 / weightsObj.latency; // inverse the weight because wt and latency should have positive relationship, i.e., higher latency = higher wt\n        }\n\n        var weightedLatency = wt * neuron.state.latency;\n        var totalQoE = qoeEvaluator.calculateSingleUseQoe(neuron.bitrate, weightedRebuffer, weightedLatency, playbackRate);\n\n        if ((maxQoE === null || totalQoE > maxQoE) && _checkConstraints(currentLatency, nextBuffer, deltaLatency)) {\n          maxQoE = totalQoE;\n          winnerWeights = weightVector;\n          winnerBitrate = neuron.bitrate;\n        }\n      });\n    }); // winnerWeights was found, check if constraints are satisfied\n\n    if (winnerWeights === null && winnerBitrate === null) {\n      winnerWeights = -1;\n    }\n\n    previousLatency = currentLatency;\n    return winnerWeights;\n  }\n  /**\n  *\n  * @param {number} nextLatency\n  * @param {number} nextBuffer\n  * @param {number} deltaLatency\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _checkConstraints(nextLatency, nextBuffer, deltaLatency) {\n    // A1\n    // disabled till we find a better way of estimating latency\n    // fails for all with current value\n    if (nextLatency > targetLatency + deltaLatency) {\n      return false;\n    }\n\n    return nextBuffer >= bufferMin;\n  }\n  /**\n  *\n  * @param {array} list\n  * @param {number} length\n  * @return {*}\n  * @private\n  */\n\n\n  function _getPermutations(list, length) {\n    // Copy initial values as arrays\n    var perm = list.map(function (val) {\n      return [val];\n    }); // Our permutation generator\n\n    var generate = function generate(perm, length, currLen) {\n      // Reached desired length\n      if (currLen === length) {\n        return perm;\n      } // For each existing permutation\n\n\n      var len = perm.length;\n\n      for (var i = 0; i < len; i++) {\n        var currPerm = perm.shift(); // Create new permutation\n\n        for (var k = 0; k < list.length; k++) {\n          perm.push(currPerm.concat(list[k]));\n        }\n      } // Recurse\n\n\n      return generate(perm, length, currLen + 1);\n    }; // Start with size 1 because of initial values\n\n\n    return generate(perm, length, 1);\n  }\n  /**\n  *\n  * @return {number}\n  */\n\n\n  function getMinBuffer() {\n    return bufferMin;\n  }\n  /**\n  *\n  * @return {number}\n  */\n\n\n  function getSegmentDuration() {\n    return segmentDuration;\n  }\n  /**\n  *\n  * @param {number} bitrateToDownload\n  * @param {number} currentBuffer\n  * @param {number} currentThroughput\n  * @return {number}\n  */\n\n\n  function getNextBufferWithBitrate(bitrateToDownload, currentBuffer, currentThroughput) {\n    var downloadTime = bitrateToDownload * segmentDuration / currentThroughput;\n    return getNextBuffer(currentBuffer, downloadTime);\n  }\n  /**\n  *\n  * @param {number} currentBuffer\n  * @param {number} downloadTime\n  * @return {number}\n  */\n\n\n  function getNextBuffer(currentBuffer, downloadTime) {\n    var segmentDuration = getSegmentDuration();\n    var nextBuffer = void 0;\n\n    if (downloadTime > segmentDuration) {\n      nextBuffer = currentBuffer - segmentDuration;\n    } else {\n      nextBuffer = currentBuffer + segmentDuration - downloadTime;\n    }\n\n    return nextBuffer;\n  }\n\n  instance = {\n    getMinBuffer: getMinBuffer,\n    getSegmentDuration: getSegmentDuration,\n    getNextBufferWithBitrate: getNextBufferWithBitrate,\n    getNextBuffer: getNextBuffer,\n    findWeightVector: findWeightVector\n  };\n\n  _setup();\n\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nLoLpWeightSelector.__dashjs_factory_name = 'LoLpWeightSelector';\nexports.default = _FactoryMaker2.default.getClassFactory(LoLpWeightSelector);","map":{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LoLpWeightSelector.js"],"names":["targetLatency","config","bufferMin","segmentDuration","qoeEvaluator","instance","valueList","weightTypeCount","weightOptions","previousLatency","_resetInitialSettings","_getPermutations","maxQoE","winnerWeights","winnerBitrate","deltaLatency","Math","currentLatency","neurons","weightsObj","throughput","weightVector","latency","buffer","switch","downloadTime","neuron","nextBuffer","getNextBuffer","rebuffer","wt","weightedRebuffer","weightedLatency","totalQoE","_checkConstraints","nextLatency","perm","list","generate","currLen","len","i","currPerm","k","bitrateToDownload","getSegmentDuration","currentBuffer","getMinBuffer","getNextBufferWithBitrate","findWeightVector","_setup","LoLpWeightSelector","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport FactoryMaker from '../../../../core/FactoryMaker';\n\nfunction LoLpWeightSelector(config) {\n    let targetLatency = config.targetLatency;\n    let bufferMin = config.bufferMin;\n    let segmentDuration = config.segmentDuration;\n    let qoeEvaluator = config.qoeEvaluator;\n    let instance,\n        valueList,\n        weightTypeCount,\n        weightOptions,\n        previousLatency;\n\n    /**\n     *\n     * @private\n     */\n    function _setup() {\n        _resetInitialSettings();\n    }\n\n    /**\n     *\n     * @private\n     */\n    function _resetInitialSettings() {\n        valueList = [0.2, 0.4, 0.6, 0.8, 1];\n        weightTypeCount = 4;\n        weightOptions = _getPermutations(valueList, weightTypeCount);\n        previousLatency = 0;\n    }\n\n    /**\n     * Next, at each segment boundary, ABR to input current neurons and target state (only used in Method II) to find the desired weight vector\n     * @param {array} neurons\n     * @param {number} currentLatency\n     * @param {number} currentBuffer\n     * @param {number} currentRebuffer\n     * @param {number} currentThroughput\n     * @param {number} playbackRate\n     * @return {null}\n     * @private\n     */\n    function findWeightVector(neurons, currentLatency, currentBuffer, currentRebuffer, currentThroughput, playbackRate) {\n        let maxQoE = null;\n        let winnerWeights = null;\n        let winnerBitrate = null;\n        let deltaLatency = Math.abs(currentLatency - previousLatency);\n\n        // For each neuron, m\n        neurons.forEach((neuron) => {\n\n            // For each possible weight vector, z\n            // E.g. For [ throughput, latency, buffer, playbackRate, QoE ]\n            //      Possible weightVector = [ 0.2, 0.4, 0.2, 0, 0.2 ]\n            weightOptions.forEach((weightVector) => {\n\n                // Apply weightVector to neuron, compute utility and determine winnerWeights\n                // Method I: Utility based on QoE given current state\n\n                let weightsObj = {\n                    throughput: weightVector[0],\n                    latency: weightVector[1],\n                    buffer: weightVector[2],\n                    switch: weightVector[3]\n                };\n\n                let downloadTime = (neuron.bitrate * segmentDuration) / currentThroughput;\n                let nextBuffer = getNextBuffer(currentBuffer, downloadTime);\n                let rebuffer = Math.max(0.00001, (downloadTime - nextBuffer));\n                let wt;\n                if (weightsObj.buffer === 0) {\n                    wt = 10;\n                } else {\n                    wt = (1 / weightsObj.buffer);\n                }\n                let weightedRebuffer = wt * rebuffer;\n\n                if (weightsObj.latency === 0) {\n                    wt = 10;\n                } else {\n                    wt = (1 / weightsObj.latency); // inverse the weight because wt and latency should have positive relationship, i.e., higher latency = higher wt\n                }\n                let weightedLatency = wt * neuron.state.latency;\n\n                let totalQoE = qoeEvaluator.calculateSingleUseQoe(neuron.bitrate, weightedRebuffer, weightedLatency, playbackRate);\n                if ((maxQoE === null || totalQoE > maxQoE) && _checkConstraints(currentLatency, nextBuffer, deltaLatency)) {\n                    maxQoE = totalQoE;\n                    winnerWeights = weightVector;\n                    winnerBitrate = neuron.bitrate;\n                }\n            });\n        });\n\n        // winnerWeights was found, check if constraints are satisfied\n        if (winnerWeights === null && winnerBitrate === null) {\n            winnerWeights = -1;\n        }\n\n        previousLatency = currentLatency;\n        return winnerWeights;\n    }\n\n    /**\n     *\n     * @param {number} nextLatency\n     * @param {number} nextBuffer\n     * @param {number} deltaLatency\n     * @return {boolean}\n     * @private\n     */\n    function _checkConstraints(nextLatency, nextBuffer, deltaLatency) {\n        // A1\n        // disabled till we find a better way of estimating latency\n        // fails for all with current value\n        if (nextLatency > targetLatency + deltaLatency) {\n            return false;\n        }\n\n        return nextBuffer >= bufferMin;\n    }\n\n    /**\n     *\n     * @param {array} list\n     * @param {number} length\n     * @return {*}\n     * @private\n     */\n    function _getPermutations(list, length) {\n        // Copy initial values as arrays\n        let perm = list.map(function (val) {\n            return [val];\n        });\n        // Our permutation generator\n        let generate = function (perm, length, currLen) {\n            // Reached desired length\n            if (currLen === length) {\n                return perm;\n            }\n            // For each existing permutation\n            let len = perm.length;\n            for (let i = 0; i < len; i++) {\n                let currPerm = perm.shift();\n                // Create new permutation\n                for (let k = 0; k < list.length; k++) {\n                    perm.push(currPerm.concat(list[k]));\n                }\n            }\n            // Recurse\n            return generate(perm, length, currLen + 1);\n        };\n        // Start with size 1 because of initial values\n        return generate(perm, length, 1);\n    }\n\n    /**\n     *\n     * @return {number}\n     */\n    function getMinBuffer() {\n        return bufferMin;\n    }\n\n    /**\n     *\n     * @return {number}\n     */\n    function getSegmentDuration() {\n        return segmentDuration;\n    }\n\n    /**\n     *\n     * @param {number} bitrateToDownload\n     * @param {number} currentBuffer\n     * @param {number} currentThroughput\n     * @return {number}\n     */\n    function getNextBufferWithBitrate(bitrateToDownload, currentBuffer, currentThroughput) {\n        let downloadTime = (bitrateToDownload * segmentDuration) / currentThroughput;\n        return getNextBuffer(currentBuffer, downloadTime);\n    }\n\n    /**\n     *\n     * @param {number} currentBuffer\n     * @param {number} downloadTime\n     * @return {number}\n     */\n    function getNextBuffer(currentBuffer, downloadTime) {\n        const segmentDuration = getSegmentDuration();\n        let nextBuffer;\n        if (downloadTime > segmentDuration) {\n            nextBuffer = currentBuffer - segmentDuration;\n        } else {\n            nextBuffer = currentBuffer + segmentDuration - downloadTime;\n        }\n        return nextBuffer;\n    }\n\n    instance = {\n        getMinBuffer,\n        getSegmentDuration,\n        getNextBufferWithBitrate,\n        getNextBuffer,\n        findWeightVector\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLpWeightSelector.__dashjs_factory_name = 'LoLpWeightSelector';\nexport default FactoryMaker.getClassFactory(LoLpWeightSelector);\n"]},"metadata":{},"sourceType":"script"}