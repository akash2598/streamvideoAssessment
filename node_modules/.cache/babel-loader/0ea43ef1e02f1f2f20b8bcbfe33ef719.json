{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EventBus = require('../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _Errors = require('../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _DashConstants = require('../dash/constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _URLUtils = require('./utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ManifestUpdater() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      refreshDelay = void 0,\n      refreshTimer = void 0,\n      isPaused = void 0,\n      isStopped = void 0,\n      isUpdating = void 0,\n      manifestLoader = void 0,\n      manifestModel = void 0,\n      adapter = void 0,\n      errHandler = void 0,\n      settings = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.manifestModel) {\n      manifestModel = config.manifestModel;\n    }\n\n    if (config.adapter) {\n      adapter = config.adapter;\n    }\n\n    if (config.manifestLoader) {\n      manifestLoader = config.manifestLoader;\n    }\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.settings) {\n      settings = config.settings;\n    }\n  }\n\n  function initialize() {\n    resetInitialSettings();\n    eventBus.on(_Events2.default.STREAMS_COMPOSED, onStreamsComposed, this);\n    eventBus.on(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.on(_Events2.default.PLAYBACK_PAUSED, onPlaybackPaused, this);\n    eventBus.on(_Events2.default.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n  }\n\n  function setManifest(manifest) {\n    update(manifest);\n  }\n\n  function resetInitialSettings() {\n    refreshDelay = NaN;\n    isUpdating = false;\n    isPaused = true;\n    isStopped = false;\n    stopManifestRefreshTimer();\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.off(_Events2.default.PLAYBACK_PAUSED, onPlaybackPaused, this);\n    eventBus.off(_Events2.default.STREAMS_COMPOSED, onStreamsComposed, this);\n    eventBus.off(_Events2.default.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n    resetInitialSettings();\n  }\n\n  function stopManifestRefreshTimer() {\n    if (refreshTimer !== null) {\n      clearTimeout(refreshTimer);\n      refreshTimer = null;\n    }\n  }\n\n  function startManifestRefreshTimer(delay) {\n    stopManifestRefreshTimer();\n\n    if (isStopped) {\n      return;\n    }\n\n    if (isNaN(delay) && !isNaN(refreshDelay)) {\n      delay = refreshDelay * 1000;\n    }\n\n    if (!isNaN(delay)) {\n      logger.debug('Refresh manifest in ' + delay + ' milliseconds.');\n      refreshTimer = setTimeout(onRefreshTimer, delay);\n    }\n  }\n\n  function refreshManifest() {\n    var ignorePatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    isUpdating = true;\n    var manifest = manifestModel.getValue(); // default to the original url in the manifest\n\n    var url = manifest.url; // Check for PatchLocation and Location alternatives\n\n    var patchLocation = adapter.getPatchLocation(manifest);\n    var location = adapter.getLocation(manifest);\n\n    if (patchLocation && !ignorePatch) {\n      url = patchLocation;\n    } else if (location) {\n      url = location;\n    } // if one of the alternatives was relative, convert to absolute\n\n\n    if (urlUtils.isRelative(url)) {\n      url = urlUtils.resolve(url, manifest.url);\n    }\n\n    manifestLoader.load(url);\n  }\n\n  function update(manifest) {\n    if (!manifest) {\n      // successful update with no content implies existing manifest remains valid\n      manifest = manifestModel.getValue(); // override load time to avoid invalid latency tracking and ensure update cadence\n\n      manifest.loadedTime = new Date();\n    } else if (adapter.getIsPatch(manifest)) {\n      // with patches the in-memory manifest is our base\n      var patch = manifest;\n      manifest = manifestModel.getValue(); // check for patch validity\n\n      var isPatchValid = adapter.isPatchValid(manifest, patch);\n      var patchSuccessful = isPatchValid;\n\n      if (isPatchValid) {\n        // grab publish time before update\n        var publishTime = adapter.getPublishTime(manifest); // apply validated patch to manifest\n\n        patchSuccessful = adapter.applyPatchToManifest(manifest, patch); // get the updated publish time\n\n        var updatedPublishTime = adapter.getPublishTime(manifest); // ensure the patch properly updated the in-memory publish time\n\n        patchSuccessful = publishTime.getTime() != updatedPublishTime.getTime();\n      } // if the patch failed to apply, force a full manifest refresh\n\n\n      if (!patchSuccessful) {\n        logger.debug('Patch provided is invalid, performing full manifest refresh');\n        refreshManifest(true);\n        return;\n      } // override load time to avoid invalid latency tracking and ensure update cadence\n\n\n      manifest.loadedTime = new Date();\n    } // See DASH-IF IOP v4.3 section 4.6.4 \"Transition Phase between Live and On-Demand\"\n    // Stop manifest update, ignore static manifest and signal end of dynamic stream to detect end of stream\n\n\n    if (manifestModel.getValue() && manifestModel.getValue().type === _DashConstants2.default.DYNAMIC && manifest.type === _DashConstants2.default.STATIC) {\n      eventBus.trigger(_Events2.default.DYNAMIC_TO_STATIC);\n      isUpdating = false;\n      isStopped = true;\n      return;\n    }\n\n    manifestModel.setValue(manifest);\n    var date = new Date();\n    var latencyOfLastUpdate = (date.getTime() - manifest.loadedTime.getTime()) / 1000;\n    refreshDelay = adapter.getManifestUpdatePeriod(manifest, latencyOfLastUpdate); // setTimeout uses a 32 bit number to store the delay. Any number greater than it\n    // will cause event associated with setTimeout to trigger immediately\n\n    if (refreshDelay * 1000 > 0x7FFFFFFF) {\n      refreshDelay = 0x7FFFFFFF / 1000;\n    }\n\n    eventBus.trigger(_Events2.default.MANIFEST_UPDATED, {\n      manifest: manifest\n    });\n    logger.info('Manifest has been refreshed at ' + date + '[' + date.getTime() / 1000 + '] ');\n\n    if (!isPaused) {\n      startManifestRefreshTimer();\n    }\n  }\n\n  function onRefreshTimer() {\n    if (isPaused) {\n      return;\n    }\n\n    if (isUpdating) {\n      startManifestRefreshTimer(settings.get().streaming.manifestUpdateRetryInterval);\n      return;\n    }\n\n    refreshManifest();\n  }\n\n  function onManifestLoaded(e) {\n    if (!e.error) {\n      update(e.manifest);\n    } else if (e.error.code === _Errors2.default.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE) {\n      errHandler.error(e.error);\n    }\n  }\n\n  function onPlaybackStarted()\n  /*e*/\n  {\n    isPaused = false;\n    startManifestRefreshTimer();\n  }\n\n  function onPlaybackPaused()\n  /*e*/\n  {\n    isPaused = !settings.get().streaming.scheduleWhilePaused;\n\n    if (isPaused) {\n      stopManifestRefreshTimer();\n    }\n  }\n\n  function onStreamsComposed()\n  /*e*/\n  {\n    // When streams are ready we can consider manifest update completed. Resolve the update promise.\n    isUpdating = false;\n  }\n\n  instance = {\n    initialize: initialize,\n    setManifest: setManifest,\n    refreshManifest: refreshManifest,\n    setConfig: setConfig,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nManifestUpdater.__dashjs_factory_name = 'ManifestUpdater';\nexports.default = _FactoryMaker2.default.getClassFactory(ManifestUpdater);","map":{"version":3,"sources":["../../../../src/streaming/ManifestUpdater.js"],"names":["context","eventBus","urlUtils","instance","logger","refreshDelay","refreshTimer","isPaused","isStopped","isUpdating","manifestLoader","manifestModel","adapter","errHandler","settings","config","resetInitialSettings","Events","update","stopManifestRefreshTimer","clearTimeout","isNaN","delay","setTimeout","ignorePatch","manifest","url","patchLocation","location","patch","isPatchValid","patchSuccessful","publishTime","updatedPublishTime","refreshManifest","DashConstants","date","latencyOfLastUpdate","startManifestRefreshTimer","e","Errors","initialize","setManifest","setConfig","reset","setup","ManifestUpdater","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport Debug from '../core/Debug';\nimport Errors from '../core/errors/Errors';\nimport DashConstants from '../dash/constants/DashConstants';\nimport URLUtils from './utils/URLUtils';\n\nfunction ManifestUpdater() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        refreshDelay,\n        refreshTimer,\n        isPaused,\n        isStopped,\n        isUpdating,\n        manifestLoader,\n        manifestModel,\n        adapter,\n        errHandler,\n        settings;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.manifestLoader) {\n            manifestLoader = config.manifestLoader;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function initialize() {\n        resetInitialSettings();\n\n        eventBus.on(Events.STREAMS_COMPOSED, onStreamsComposed, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_PAUSED, onPlaybackPaused, this);\n        eventBus.on(Events.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n    }\n\n    function setManifest(manifest) {\n        update(manifest);\n    }\n\n    function resetInitialSettings() {\n        refreshDelay = NaN;\n        isUpdating = false;\n        isPaused = true;\n        isStopped = false;\n        stopManifestRefreshTimer();\n    }\n\n    function reset() {\n\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_PAUSED, onPlaybackPaused, this);\n        eventBus.off(Events.STREAMS_COMPOSED, onStreamsComposed, this);\n        eventBus.off(Events.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\n\n        resetInitialSettings();\n    }\n\n    function stopManifestRefreshTimer() {\n        if (refreshTimer !== null) {\n            clearTimeout(refreshTimer);\n            refreshTimer = null;\n        }\n    }\n\n    function startManifestRefreshTimer(delay) {\n        stopManifestRefreshTimer();\n\n        if (isStopped) {\n            return;\n        }\n\n        if (isNaN(delay) && !isNaN(refreshDelay)) {\n            delay = refreshDelay * 1000;\n        }\n\n        if (!isNaN(delay)) {\n            logger.debug('Refresh manifest in ' + delay + ' milliseconds.');\n            refreshTimer = setTimeout(onRefreshTimer, delay);\n        }\n    }\n\n    function refreshManifest(ignorePatch = false) {\n        isUpdating = true;\n        const manifest = manifestModel.getValue();\n\n        // default to the original url in the manifest\n        let url = manifest.url;\n\n        // Check for PatchLocation and Location alternatives\n        const patchLocation = adapter.getPatchLocation(manifest);\n        const location = adapter.getLocation(manifest);\n        if (patchLocation && !ignorePatch) {\n            url = patchLocation;\n        } else if (location) {\n            url = location;\n        }\n\n        // if one of the alternatives was relative, convert to absolute\n        if (urlUtils.isRelative(url)) {\n            url = urlUtils.resolve(url, manifest.url);\n        }\n\n        manifestLoader.load(url);\n    }\n\n    function update(manifest) {\n        if (!manifest) {\n            // successful update with no content implies existing manifest remains valid\n            manifest = manifestModel.getValue();\n\n            // override load time to avoid invalid latency tracking and ensure update cadence\n            manifest.loadedTime = new Date();\n        } else if (adapter.getIsPatch(manifest)) {\n            // with patches the in-memory manifest is our base\n            let patch = manifest;\n            manifest = manifestModel.getValue();\n\n            // check for patch validity\n            let isPatchValid = adapter.isPatchValid(manifest, patch);\n            let patchSuccessful = isPatchValid;\n\n            if (isPatchValid) {\n                // grab publish time before update\n                let publishTime = adapter.getPublishTime(manifest);\n\n                // apply validated patch to manifest\n                patchSuccessful = adapter.applyPatchToManifest(manifest, patch);\n\n                // get the updated publish time\n                let updatedPublishTime = adapter.getPublishTime(manifest);\n\n                // ensure the patch properly updated the in-memory publish time\n                patchSuccessful = publishTime.getTime() != updatedPublishTime.getTime();\n            }\n\n            // if the patch failed to apply, force a full manifest refresh\n            if (!patchSuccessful) {\n                logger.debug('Patch provided is invalid, performing full manifest refresh');\n                refreshManifest(true);\n                return;\n            }\n\n            // override load time to avoid invalid latency tracking and ensure update cadence\n            manifest.loadedTime = new Date();\n        }\n\n        // See DASH-IF IOP v4.3 section 4.6.4 \"Transition Phase between Live and On-Demand\"\n        // Stop manifest update, ignore static manifest and signal end of dynamic stream to detect end of stream\n        if (manifestModel.getValue() && manifestModel.getValue().type === DashConstants.DYNAMIC && manifest.type === DashConstants.STATIC) {\n            eventBus.trigger(Events.DYNAMIC_TO_STATIC);\n            isUpdating = false;\n            isStopped = true;\n            return;\n        }\n\n        manifestModel.setValue(manifest);\n\n        const date = new Date();\n        const latencyOfLastUpdate = (date.getTime() - manifest.loadedTime.getTime()) / 1000;\n        refreshDelay = adapter.getManifestUpdatePeriod(manifest, latencyOfLastUpdate);\n        // setTimeout uses a 32 bit number to store the delay. Any number greater than it\n        // will cause event associated with setTimeout to trigger immediately\n        if (refreshDelay * 1000 > 0x7FFFFFFF) {\n            refreshDelay = 0x7FFFFFFF / 1000;\n        }\n        eventBus.trigger(Events.MANIFEST_UPDATED, { manifest: manifest });\n        logger.info('Manifest has been refreshed at ' + date + '[' + date.getTime() / 1000 + '] ');\n\n        if (!isPaused) {\n            startManifestRefreshTimer();\n        }\n    }\n\n    function onRefreshTimer() {\n        if (isPaused) {\n            return;\n        }\n        if (isUpdating) {\n            startManifestRefreshTimer(settings.get().streaming.manifestUpdateRetryInterval);\n            return;\n        }\n        refreshManifest();\n    }\n\n    function onManifestLoaded(e) {\n        if (!e.error) {\n            update(e.manifest);\n        } else if (e.error.code === Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE) {\n            errHandler.error(e.error);\n        }\n    }\n\n    function onPlaybackStarted (/*e*/) {\n        isPaused = false;\n        startManifestRefreshTimer();\n    }\n\n    function onPlaybackPaused(/*e*/) {\n        isPaused = !settings.get().streaming.scheduleWhilePaused;\n\n        if (isPaused) {\n            stopManifestRefreshTimer();\n        }\n    }\n\n    function onStreamsComposed(/*e*/) {\n        // When streams are ready we can consider manifest update completed. Resolve the update promise.\n        isUpdating = false;\n    }\n\n    instance = {\n        initialize: initialize,\n        setManifest: setManifest,\n        refreshManifest: refreshManifest,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\nManifestUpdater.__dashjs_factory_name = 'ManifestUpdater';\nexport default FactoryMaker.getClassFactory(ManifestUpdater);\n"]},"metadata":{},"sourceType":"script"}