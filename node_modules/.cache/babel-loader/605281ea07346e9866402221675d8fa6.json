{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _MetricsConstants = require('../constants/MetricsConstants');\n\nvar _MetricsConstants2 = _interopRequireDefault(_MetricsConstants);\n\nvar _BufferLevelRule = require('../rules/scheduling/BufferLevelRule');\n\nvar _BufferLevelRule2 = _interopRequireDefault(_BufferLevelRule);\n\nvar _FragmentModel = require('../models/FragmentModel');\n\nvar _FragmentModel2 = _interopRequireDefault(_FragmentModel);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction ScheduleController(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var adapter = config.adapter;\n  var dashMetrics = config.dashMetrics;\n  var mediaPlayerModel = config.mediaPlayerModel;\n  var fragmentModel = config.fragmentModel;\n  var abrController = config.abrController;\n  var playbackController = config.playbackController;\n  var textController = config.textController;\n  var type = config.type;\n  var mimeType = config.mimeType;\n  var mediaController = config.mediaController;\n  var bufferController = config.bufferController;\n  var settings = config.settings;\n  var instance = void 0,\n      streamInfo = void 0,\n      logger = void 0,\n      currentRepresentationInfo = void 0,\n      initialRequest = void 0,\n      isStopped = void 0,\n      isFragmentProcessingInProgress = void 0,\n      timeToLoadDelay = void 0,\n      scheduleTimeout = void 0,\n      seekTarget = void 0,\n      hasVideoTrack = void 0,\n      bufferLevelRule = void 0,\n      lastFragmentRequest = void 0,\n      topQualityIndex = void 0,\n      lastInitializedRepresentationInfo = void 0,\n      replaceRequestArray = void 0,\n      switchTrack = void 0,\n      replacingBuffer = void 0,\n      mediaRequest = void 0,\n      checkPlaybackQuality = void 0,\n      isReplacementRequest = void 0;\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    resetInitialSettings();\n    streamInfo = config.streamInfo;\n  }\n\n  function initialize(_hasVideoTrack) {\n    hasVideoTrack = _hasVideoTrack;\n    bufferLevelRule = (0, _BufferLevelRule2.default)(context).create({\n      abrController: abrController,\n      dashMetrics: dashMetrics,\n      mediaPlayerModel: mediaPlayerModel,\n      textController: textController,\n      settings: settings\n    }); //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n\n    eventBus.on(_Events2.default.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n    eventBus.on(_Events2.default.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n    eventBus.on(_Events2.default.STREAM_COMPLETED, onStreamCompleted, this);\n    eventBus.on(_Events2.default.BUFFER_CLEARED, onBufferCleared, this);\n    eventBus.on(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n    eventBus.on(_Events2.default.QUOTA_EXCEEDED, onQuotaExceeded, this);\n    eventBus.on(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n    eventBus.on(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.on(_Events2.default.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n    eventBus.on(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n    eventBus.on(_Events2.default.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n    eventBus.on(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n    eventBus.on(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, this);\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function setCurrentRepresentation(representationInfo) {\n    currentRepresentationInfo = representationInfo;\n  }\n\n  function isStarted() {\n    return isStopped === false;\n  }\n\n  function start() {\n    if (!streamInfo) return;\n    if (isStarted()) return;\n    if (!currentRepresentationInfo || bufferController.getIsBufferingCompleted()) return;\n    logger.debug('Schedule Controller starts');\n    isStopped = false;\n    dashMetrics.createPlaylistTraceMetrics(currentRepresentationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n\n    if (initialRequest) {\n      initialRequest = false;\n    }\n\n    startScheduleTimer(0);\n  }\n\n  function stop() {\n    if (isStopped) return;\n    logger.debug('Schedule Controller stops');\n    logger.debug(type + ' Schedule Controller stops');\n    isStopped = true;\n    clearTimeout(scheduleTimeout);\n  }\n\n  function hasTopQualityChanged(type, id) {\n    topQualityIndex[id] = topQualityIndex[id] || {};\n    var newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n    if (topQualityIndex[id][type] != newTopQualityIndex) {\n      logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n      topQualityIndex[id][type] = newTopQualityIndex;\n      return true;\n    }\n\n    return false;\n  }\n\n  function schedule() {\n    if (!streamInfo) return;\n\n    if (isStopped || isFragmentProcessingInProgress || playbackController.isPaused() && !settings.get().streaming.scheduleWhilePaused || (type === _Constants2.default.FRAGMENTED_TEXT || type === _Constants2.default.TEXT) && !textController.isTextEnabled() || bufferController.getIsBufferingCompleted()) {\n      stop();\n      return;\n    }\n\n    validateExecutedFragmentRequest();\n    var isReplacement = replaceRequestArray.length > 0;\n    var lastInitializedQuality = lastInitializedRepresentationInfo ? lastInitializedRepresentationInfo.quality : NaN;\n\n    if (replacingBuffer || isNaN(lastInitializedQuality) || switchTrack || isReplacement || hasTopQualityChanged(type, streamInfo.id) || bufferLevelRule.execute(type, currentRepresentationInfo, hasVideoTrack)) {\n      var getNextFragment = function getNextFragment() {\n        if ((currentRepresentationInfo.quality !== lastInitializedQuality || switchTrack) && !replacingBuffer) {\n          if (switchTrack) {\n            logger.debug('Switch track for ' + type + ', representation id = ' + currentRepresentationInfo.id);\n            replacingBuffer = mediaController.getSwitchMode(type) === _Constants2.default.TRACK_SWITCH_MODE_ALWAYS_REPLACE;\n\n            if (replacingBuffer && bufferController.replaceBuffer) {\n              bufferController.replaceBuffer();\n            }\n\n            switchTrack = false;\n          } else {\n            logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n          }\n\n          eventBus.trigger(_Events2.default.INIT_FRAGMENT_NEEDED, {\n            representationId: currentRepresentationInfo.id,\n            sender: instance\n          }, {\n            streamId: streamInfo.id,\n            mediaType: type\n          });\n          checkPlaybackQuality = false;\n        } else {\n          var replacement = replaceRequestArray.shift();\n\n          if (replacement && replacement.isInitializationRequest()) {\n            // To be sure the specific init segment had not already been loaded\n            eventBus.trigger(_Events2.default.INIT_FRAGMENT_NEEDED, {\n              representationId: replacement.representationId,\n              sender: instance\n            }, {\n              streamId: streamInfo.id,\n              mediaType: type\n            });\n            checkPlaybackQuality = false;\n          } else {\n            eventBus.trigger(_Events2.default.MEDIA_FRAGMENT_NEEDED, {\n              seekTarget: seekTarget,\n              replacement: replacement\n            }, {\n              streamId: streamInfo.id,\n              mediaType: type\n            });\n            checkPlaybackQuality = true;\n          }\n        }\n      };\n\n      setFragmentProcessState(true);\n\n      if (!isReplacement && checkPlaybackQuality) {\n        abrController.checkPlaybackQuality(type);\n      }\n\n      getNextFragment();\n    } else {\n      startScheduleTimer(500);\n    }\n  }\n\n  function validateExecutedFragmentRequest() {\n    if (!isNaN(seekTarget)) return;\n    if (!lastInitializedRepresentationInfo) return; // Validate that the fragment request executed and appended into the source buffer is as\n    // good of quality as the current quality and is the correct media track.\n\n    var time = playbackController.getTime();\n    var safeBufferLevel = 1.5;\n\n    if (isNaN(lastInitializedRepresentationInfo.fragmentDuration)) {\n      //fragmentDuration of representationInfo is not defined,\n      // call metrics function to have data in the latest scheduling info...\n      // if no metric, returns 0. In this case, rule will return false.\n      var schedulingInfo = dashMetrics.getCurrentSchedulingInfo(currentRepresentationInfo.mediaInfo.type);\n      safeBufferLevel = schedulingInfo ? schedulingInfo.duration * 1.5 : 1.5;\n    }\n\n    var request = fragmentModel.getRequests({\n      state: _FragmentModel2.default.FRAGMENT_MODEL_EXECUTED,\n      time: time + safeBufferLevel,\n      threshold: 0\n    })[0];\n\n    if (request && replaceRequestArray.indexOf(request) === -1 && !adapter.getIsTextTrack(mimeType)) {\n      var fastSwitchModeEnabled = settings.get().streaming.fastSwitchEnabled;\n      var bufferLevel = bufferController.getBufferLevel();\n      var abandonmentState = abrController.getAbandonmentStateFor(type); // Only replace on track switch when NEVER_REPLACE\n\n      var trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === _Constants2.default.TRACK_SWITCH_MODE_NEVER_REPLACE;\n\n      var qualityChanged = request.quality < lastInitializedRepresentationInfo.quality;\n\n      if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== _MetricsConstants2.default.ABANDON_LOAD) {\n        replaceRequest(request);\n        isReplacementRequest = true;\n        logger.debug('Reloading outdated fragment at index: ', request.index);\n      } else if (request.quality > lastInitializedRepresentationInfo.quality && !replacingBuffer) {\n        // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n        setSeekTarget(playbackController.getTime() + bufferLevel);\n      }\n    }\n  }\n\n  function startScheduleTimer(value) {\n    clearTimeout(scheduleTimeout);\n    scheduleTimeout = setTimeout(schedule, value);\n  }\n\n  function setFragmentProcessState(state) {\n    if (isFragmentProcessingInProgress !== state) {\n      isFragmentProcessingInProgress = state;\n    } else {\n      logger.debug('isFragmentProcessingInProgress is already equal to', state);\n    }\n  }\n\n  function processInitRequest(request) {\n    if (request) {\n      setFragmentProcessState(true);\n      fragmentModel.executeRequest(request);\n    }\n  }\n\n  function processMediaRequest(request) {\n    if (request) {\n      logger.debug('Next fragment request url is ' + request.url);\n      fragmentModel.executeRequest(request);\n    } else {\n      // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n      if (playbackController.getIsDynamic()) {\n        logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n      }\n\n      setFragmentProcessState(false);\n      startScheduleTimer(settings.get().streaming.lowLatencyEnabled ? 100 : 500);\n    }\n  }\n\n  function switchTrackAsked() {\n    switchTrack = true;\n  }\n\n  function replaceRequest(request) {\n    replaceRequestArray.push(request);\n  }\n\n  function completeQualityChange(trigger) {\n    if (playbackController && fragmentModel) {\n      var item = fragmentModel.getRequests({\n        state: _FragmentModel2.default.FRAGMENT_MODEL_EXECUTED,\n        time: playbackController.getTime(),\n        threshold: 0\n      })[0];\n\n      if (item && playbackController.getTime() >= item.startTime) {\n        if ((!lastFragmentRequest.mediaInfo || item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id) && trigger) {\n          eventBus.trigger(_Events2.default.TRACK_CHANGE_RENDERED, {\n            mediaType: type,\n            oldMediaInfo: lastFragmentRequest.mediaInfo,\n            newMediaInfo: item.mediaInfo\n          });\n        }\n\n        if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n          eventBus.trigger(_Events2.default.QUALITY_CHANGE_RENDERED, {\n            mediaType: type,\n            oldQuality: lastFragmentRequest.quality,\n            newQuality: item.quality\n          });\n        }\n\n        lastFragmentRequest = {\n          mediaInfo: item.mediaInfo,\n          quality: item.quality,\n          adaptationIndex: item.adaptationIndex\n        };\n      }\n    }\n  }\n\n  function onStreamCompleted() {\n    stop();\n    setFragmentProcessState(false);\n    logger.info('Stream ' + streamInfo.id + ' is complete');\n  }\n\n  function onFragmentLoadingCompleted(e) {\n    if (e.request.mediaInfo.streamInfo.id !== streamInfo.id || e.request.mediaType !== type) return;\n    logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined', e.request.range ? ', Range:' + e.request.range : '');\n\n    if (adapter.getIsTextTrack(mimeType)) {\n      setFragmentProcessState(false);\n    }\n\n    if (e.error && e.request.serviceLocation && !isStopped) {\n      replaceRequest(e.request);\n      setFragmentProcessState(false);\n      startScheduleTimer(0);\n    }\n\n    if (replacingBuffer) {\n      mediaRequest = e.request;\n    }\n  }\n\n  function onPlaybackTimeUpdated() {\n    completeQualityChange(true);\n  }\n\n  function onBytesAppended(e) {\n    if (replacingBuffer && !isNaN(e.startTime)) {\n      replacingBuffer = false;\n      fragmentModel.addExecutedRequest(mediaRequest);\n    }\n\n    setFragmentProcessState(false);\n\n    if (isNaN(e.index)) {\n      lastInitializedRepresentationInfo = bufferController.getRepresentationInfo(e.quality);\n      logger.info('[' + type + '] ' + 'lastInitializedRepresentationInfo changed to ' + e.quality);\n    }\n\n    if (isReplacementRequest && !isNaN(e.startTime)) {\n      //replace requests process is in progress, call schedule in n seconds.\n      //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n      //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n      var currentTime = playbackController.getTime();\n      var fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n      var safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n\n      if (currentTime + safeBufferLevel >= fragEndTime) {\n        startScheduleTimer(0);\n      } else {\n        startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n      }\n\n      isReplacementRequest = false;\n    } else {\n      startScheduleTimer(0);\n    }\n  }\n\n  function onFragmentLoadingAbandoned(e) {\n    logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has been aborted');\n\n    if (!playbackController.isSeeking() && !switchTrack) {\n      logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n      replaceRequest(e.request);\n    }\n\n    setFragmentProcessState(false);\n    startScheduleTimer(0);\n  }\n\n  function onDataUpdateStarted()\n  /*e*/\n  {// stop();\n  }\n\n  function onBufferingCompleted()\n  /*e*/\n  {\n    stop();\n  }\n\n  function onBufferCleared(e) {\n    if (replacingBuffer && settings.get().streaming.flushBufferAtTrackSwitch) {\n      // For some devices (like chromecast) it is necessary to seek the video element to reset the internal decoding buffer,\n      // otherwise audio track switch will be effective only once after previous buffered track is consumed\n      playbackController.seek(playbackController.getTime() + 0.001, false, true);\n    } // (Re)start schedule once buffer has been pruned after a QuotaExceededError\n\n\n    if (e.hasEnoughSpaceToAppend && e.quotaExceeded) {\n      start();\n    }\n  }\n\n  function onQuotaExceeded()\n  /*e*/\n  {\n    // Stop scheduler (will be restarted once buffer is pruned)\n    stop();\n    setFragmentProcessState(false);\n  }\n\n  function onURLResolutionFailed() {\n    fragmentModel.abortRequests();\n    stop();\n  }\n\n  function onPlaybackStarted() {\n    if (isStopped || !settings.get().streaming.scheduleWhilePaused) {\n      start();\n    }\n  }\n\n  function onPlaybackSeeking(e) {\n    if (!streamInfo) return;\n    setSeekTarget(e.seekTime);\n    setTimeToLoadDelay(0);\n\n    if (isStopped) {\n      start();\n    }\n\n    var latency = currentRepresentationInfo && currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n    dashMetrics.updateManifestUpdateInfo({\n      latency: latency\n    });\n\n    if (!isFragmentProcessingInProgress) {\n      // No pending request, request next segment at seek target\n      startScheduleTimer(0);\n    } else {\n      // Abort current request\n      fragmentModel.abortRequests();\n    }\n  }\n\n  function onPlaybackRateChanged(e) {\n    dashMetrics.updatePlayListTraceMetrics({\n      playbackspeed: e.playbackRate.toString()\n    });\n  }\n\n  function setSeekTarget(value) {\n    seekTarget = value;\n  }\n\n  function setTimeToLoadDelay(value) {\n    timeToLoadDelay = value;\n  }\n\n  function getTimeToLoadDelay() {\n    return timeToLoadDelay;\n  }\n\n  function getBufferTarget() {\n    return bufferLevelRule.getBufferTarget(type, currentRepresentationInfo, hasVideoTrack);\n  }\n\n  function resetInitialSettings() {\n    checkPlaybackQuality = true;\n    isFragmentProcessingInProgress = false;\n    timeToLoadDelay = 0;\n    seekTarget = NaN;\n    initialRequest = true;\n    lastInitializedRepresentationInfo = undefined;\n    lastFragmentRequest = {\n      mediaInfo: undefined,\n      quality: NaN,\n      adaptationIndex: NaN\n    };\n    topQualityIndex = {};\n    replaceRequestArray = [];\n    isStopped = true;\n    switchTrack = false;\n    replacingBuffer = false;\n    mediaRequest = null;\n    isReplacementRequest = false;\n  }\n\n  function reset() {\n    //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n    eventBus.off(_Events2.default.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n    eventBus.off(_Events2.default.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n    eventBus.off(_Events2.default.STREAM_COMPLETED, onStreamCompleted, this);\n    eventBus.off(_Events2.default.BUFFER_CLEARED, onBufferCleared, this);\n    eventBus.off(_Events2.default.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n    eventBus.off(_Events2.default.QUOTA_EXCEEDED, onQuotaExceeded, this);\n    eventBus.off(_Events2.default.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n    eventBus.off(_Events2.default.PLAYBACK_STARTED, onPlaybackStarted, this);\n    eventBus.off(_Events2.default.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n    eventBus.off(_Events2.default.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n    eventBus.off(_Events2.default.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n    eventBus.off(_Events2.default.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n    eventBus.off(_Events2.default.BUFFERING_COMPLETED, onBufferingCompleted, this);\n    stop();\n    completeQualityChange(false);\n    resetInitialSettings();\n    streamInfo = null;\n  }\n\n  function getPlaybackController() {\n    return playbackController;\n  }\n\n  instance = {\n    initialize: initialize,\n    getType: getType,\n    getStreamId: getStreamId,\n    setCurrentRepresentation: setCurrentRepresentation,\n    setSeekTarget: setSeekTarget,\n    setTimeToLoadDelay: setTimeToLoadDelay,\n    getTimeToLoadDelay: getTimeToLoadDelay,\n    switchTrackAsked: switchTrackAsked,\n    isStarted: isStarted,\n    start: start,\n    stop: stop,\n    reset: reset,\n    getBufferTarget: getBufferTarget,\n    processInitRequest: processInitRequest,\n    processMediaRequest: processMediaRequest,\n    getPlaybackController: getPlaybackController\n  };\n  setup();\n  return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexports.default = _FactoryMaker2.default.getClassFactory(ScheduleController);","map":{"version":3,"sources":["../../../../../src/streaming/controllers/ScheduleController.js"],"names":["config","context","eventBus","adapter","dashMetrics","mediaPlayerModel","fragmentModel","abrController","playbackController","textController","type","mimeType","mediaController","bufferController","settings","instance","streamInfo","logger","currentRepresentationInfo","initialRequest","isStopped","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","hasVideoTrack","bufferLevelRule","lastFragmentRequest","topQualityIndex","lastInitializedRepresentationInfo","replaceRequestArray","switchTrack","replacingBuffer","mediaRequest","checkPlaybackQuality","isReplacementRequest","resetInitialSettings","Events","isStarted","startScheduleTimer","clearTimeout","newTopQualityIndex","Constants","stop","validateExecutedFragmentRequest","isReplacement","lastInitializedQuality","isNaN","hasTopQualityChanged","getNextFragment","representationId","sender","streamId","mediaType","replacement","setFragmentProcessState","time","safeBufferLevel","schedulingInfo","request","state","FragmentModel","threshold","fastSwitchModeEnabled","bufferLevel","abandonmentState","trackChanged","qualityChanged","MetricsConstants","replaceRequest","setSeekTarget","setTimeout","item","oldMediaInfo","newMediaInfo","oldQuality","newQuality","mediaInfo","quality","adaptationIndex","e","completeQualityChange","currentTime","fragEndTime","start","setTimeToLoadDelay","latency","playbackspeed","initialize","getType","getStreamId","setCurrentRepresentation","getTimeToLoadDelay","switchTrackAsked","reset","getBufferTarget","processInitRequest","processMediaRequest","getPlaybackController","setup","ScheduleController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nfunction ScheduleController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const fragmentModel = config.fragmentModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const textController = config.textController;\n    const type = config.type;\n    const mimeType = config.mimeType;\n    const mediaController = config.mediaController;\n    const bufferController = config.bufferController;\n    const settings = config.settings;\n\n    let instance,\n        streamInfo,\n        logger,\n        currentRepresentationInfo,\n        initialRequest,\n        isStopped,\n        isFragmentProcessingInProgress,\n        timeToLoadDelay,\n        scheduleTimeout,\n        seekTarget,\n        hasVideoTrack,\n        bufferLevelRule,\n        lastFragmentRequest,\n        topQualityIndex,\n        lastInitializedRepresentationInfo,\n        replaceRequestArray,\n        switchTrack,\n        replacingBuffer,\n        mediaRequest,\n        checkPlaybackQuality,\n        isReplacementRequest;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n        streamInfo = config.streamInfo;\n    }\n\n    function initialize(_hasVideoTrack) {\n        hasVideoTrack = _hasVideoTrack;\n\n        bufferLevelRule = BufferLevelRule(context).create({\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            textController: textController,\n            settings: settings\n        });\n\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function setCurrentRepresentation(representationInfo) {\n        currentRepresentationInfo = representationInfo;\n    }\n\n    function isStarted() {\n        return (isStopped === false);\n    }\n\n    function start() {\n        if (!streamInfo) return;\n        if (isStarted()) return;\n        if (!currentRepresentationInfo || bufferController.getIsBufferingCompleted()) return;\n\n        logger.debug('Schedule Controller starts');\n        isStopped = false;\n        dashMetrics.createPlaylistTraceMetrics(currentRepresentationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n\n        if (initialRequest) {\n            initialRequest = false;\n        }\n\n        startScheduleTimer(0);\n    }\n\n    function stop() {\n        if (isStopped) return;\n\n        logger.debug('Schedule Controller stops');\n        logger.debug(type + ' Schedule Controller stops');\n        isStopped = true;\n        clearTimeout(scheduleTimeout);\n    }\n\n    function hasTopQualityChanged(type, id) {\n        topQualityIndex[id] = topQualityIndex[id] || {};\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n            topQualityIndex[id][type] = newTopQualityIndex;\n            return true;\n        }\n        return false;\n\n    }\n\n    function schedule() {\n        if (!streamInfo) return;\n        if (isStopped || isFragmentProcessingInProgress ||\n            (playbackController.isPaused() && !settings.get().streaming.scheduleWhilePaused) ||\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled()) ||\n            bufferController.getIsBufferingCompleted()) {\n            stop();\n            return;\n        }\n\n        validateExecutedFragmentRequest();\n\n        const isReplacement = replaceRequestArray.length > 0;\n        const lastInitializedQuality = lastInitializedRepresentationInfo ? lastInitializedRepresentationInfo.quality : NaN;\n        if (replacingBuffer || isNaN(lastInitializedQuality) || switchTrack || isReplacement ||\n            hasTopQualityChanged(type, streamInfo.id) ||\n            bufferLevelRule.execute(type, currentRepresentationInfo, hasVideoTrack)) {\n            const getNextFragment = function () {\n                if ((currentRepresentationInfo.quality !== lastInitializedQuality || switchTrack) && (!replacingBuffer)) {\n                    if (switchTrack) {\n                        logger.debug('Switch track for ' + type + ', representation id = ' + currentRepresentationInfo.id);\n                        replacingBuffer = mediaController.getSwitchMode(type) === Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE;\n                        if (replacingBuffer && bufferController.replaceBuffer) {\n                            bufferController.replaceBuffer();\n                        }\n                        switchTrack = false;\n                    } else {\n                        logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n                    }\n                    eventBus.trigger(Events.INIT_FRAGMENT_NEEDED,\n                        { representationId: currentRepresentationInfo.id, sender: instance },\n                        { streamId: streamInfo.id, mediaType: type }\n                    );\n                    checkPlaybackQuality = false;\n                } else {\n                    const replacement = replaceRequestArray.shift();\n\n                    if (replacement && replacement.isInitializationRequest()) {\n                        // To be sure the specific init segment had not already been loaded\n                        eventBus.trigger(Events.INIT_FRAGMENT_NEEDED,\n                            { representationId: replacement.representationId, sender: instance },\n                            { streamId: streamInfo.id, mediaType: type }\n                        );\n                        checkPlaybackQuality = false;\n                    } else {\n                        eventBus.trigger(Events.MEDIA_FRAGMENT_NEEDED,\n                            { seekTarget: seekTarget, replacement: replacement },\n                            { streamId: streamInfo.id, mediaType: type }\n                        );\n                        checkPlaybackQuality = true;\n                    }\n                }\n            };\n\n            setFragmentProcessState(true);\n            if (!isReplacement && checkPlaybackQuality) {\n                abrController.checkPlaybackQuality(type);\n            }\n\n            getNextFragment();\n\n        } else {\n            startScheduleTimer(500);\n        }\n    }\n\n    function validateExecutedFragmentRequest() {\n        if (!isNaN(seekTarget)) return;\n        if (!lastInitializedRepresentationInfo) return;\n        // Validate that the fragment request executed and appended into the source buffer is as\n        // good of quality as the current quality and is the correct media track.\n        const time = playbackController.getTime();\n        let safeBufferLevel = 1.5;\n\n        if (isNaN(lastInitializedRepresentationInfo.fragmentDuration)) { //fragmentDuration of representationInfo is not defined,\n            // call metrics function to have data in the latest scheduling info...\n            // if no metric, returns 0. In this case, rule will return false.\n            const schedulingInfo = dashMetrics.getCurrentSchedulingInfo(currentRepresentationInfo.mediaInfo.type);\n            safeBufferLevel = schedulingInfo ? schedulingInfo.duration * 1.5 : 1.5;\n        }\n        const request = fragmentModel.getRequests({\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n            time: time + safeBufferLevel,\n            threshold: 0\n        })[0];\n\n        if (request && replaceRequestArray.indexOf(request) === -1 && !adapter.getIsTextTrack(mimeType)) {\n            const fastSwitchModeEnabled = settings.get().streaming.fastSwitchEnabled;\n            const bufferLevel = bufferController.getBufferLevel();\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\n\n            // Only replace on track switch when NEVER_REPLACE\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === Constants.TRACK_SWITCH_MODE_NEVER_REPLACE;\n            const qualityChanged = request.quality < lastInitializedRepresentationInfo.quality;\n\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== MetricsConstants.ABANDON_LOAD) {\n                replaceRequest(request);\n                isReplacementRequest = true;\n                logger.debug('Reloading outdated fragment at index: ', request.index);\n            } else if (request.quality > lastInitializedRepresentationInfo.quality && !replacingBuffer) {\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n                setSeekTarget(playbackController.getTime() + bufferLevel);\n            }\n        }\n    }\n\n    function startScheduleTimer(value) {\n        clearTimeout(scheduleTimeout);\n\n        scheduleTimeout = setTimeout(schedule, value);\n    }\n\n    function setFragmentProcessState (state) {\n        if (isFragmentProcessingInProgress !== state ) {\n            isFragmentProcessingInProgress = state;\n        } else {\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\n        }\n    }\n\n    function processInitRequest(request) {\n        if (request) {\n            setFragmentProcessState(true);\n            fragmentModel.executeRequest(request);\n        }\n    }\n\n    function processMediaRequest(request) {\n        if (request) {\n            logger.debug('Next fragment request url is ' + request.url);\n            fragmentModel.executeRequest(request);\n        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n            if (playbackController.getIsDynamic()) {\n                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n            }\n            setFragmentProcessState(false);\n            startScheduleTimer(settings.get().streaming.lowLatencyEnabled ? 100 : 500);\n        }\n    }\n\n    function switchTrackAsked() {\n        switchTrack = true;\n    }\n\n    function replaceRequest(request) {\n        replaceRequestArray.push(request);\n    }\n\n    function completeQualityChange(trigger) {\n        if (playbackController && fragmentModel) {\n            const item = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                time: playbackController.getTime(),\n                threshold: 0\n            })[0];\n            if (item && playbackController.getTime() >= item.startTime) {\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\n                        newMediaInfo: item.mediaInfo\n                    });\n                }\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldQuality: lastFragmentRequest.quality,\n                        newQuality: item.quality\n                    });\n                }\n                lastFragmentRequest = {\n                    mediaInfo: item.mediaInfo,\n                    quality: item.quality,\n                    adaptationIndex: item.adaptationIndex\n                };\n            }\n        }\n    }\n\n    function onStreamCompleted() {\n        stop();\n        setFragmentProcessState(false);\n        logger.info(`Stream ${streamInfo.id} is complete`);\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.request.mediaInfo.streamInfo.id !== streamInfo.id || e.request.mediaType !== type) return;\n\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined', e.request.range ? ', Range:' + e.request.range : '');\n\n        if (adapter.getIsTextTrack(mimeType)) {\n            setFragmentProcessState(false);\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            replaceRequest(e.request);\n            setFragmentProcessState(false);\n            startScheduleTimer(0);\n        }\n\n        if (replacingBuffer) {\n            mediaRequest = e.request;\n        }\n    }\n\n    function onPlaybackTimeUpdated() {\n        completeQualityChange(true);\n    }\n\n    function onBytesAppended(e) {\n        if (replacingBuffer && !isNaN(e.startTime)) {\n            replacingBuffer = false;\n            fragmentModel.addExecutedRequest(mediaRequest);\n        }\n\n        setFragmentProcessState(false);\n        if (isNaN(e.index)) {\n            lastInitializedRepresentationInfo = bufferController.getRepresentationInfo(e.quality);\n            logger.info('[' + type + '] ' + 'lastInitializedRepresentationInfo changed to ' + e.quality);\n        }\n        if (isReplacementRequest && !isNaN(e.startTime)) {\n            //replace requests process is in progress, call schedule in n seconds.\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n            const currentTime = playbackController.getTime();\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\n                startScheduleTimer(0);\n            } else {\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n            }\n            isReplacementRequest = false;\n        } else {\n            startScheduleTimer(0);\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has been aborted');\n        if (!playbackController.isSeeking() && !switchTrack) {\n            logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n            replaceRequest(e.request);\n        }\n        setFragmentProcessState(false);\n        startScheduleTimer(0);\n    }\n\n    function onDataUpdateStarted(/*e*/) {\n        // stop();\n    }\n\n    function onBufferingCompleted(/*e*/) {\n        stop();\n    }\n\n    function onBufferCleared(e) {\n        if (replacingBuffer && settings.get().streaming.flushBufferAtTrackSwitch) {\n            // For some devices (like chromecast) it is necessary to seek the video element to reset the internal decoding buffer,\n            // otherwise audio track switch will be effective only once after previous buffered track is consumed\n            playbackController.seek(playbackController.getTime() + 0.001, false, true);\n        }\n\n        // (Re)start schedule once buffer has been pruned after a QuotaExceededError\n        if (e.hasEnoughSpaceToAppend && e.quotaExceeded) {\n            start();\n        }\n    }\n\n    function onQuotaExceeded(/*e*/) {\n        // Stop scheduler (will be restarted once buffer is pruned)\n        stop();\n        setFragmentProcessState(false);\n    }\n\n    function onURLResolutionFailed() {\n        fragmentModel.abortRequests();\n        stop();\n    }\n\n    function onPlaybackStarted() {\n        if (isStopped || !settings.get().streaming.scheduleWhilePaused) {\n            start();\n        }\n    }\n\n    function onPlaybackSeeking(e) {\n        if (!streamInfo) return;\n        setSeekTarget(e.seekTime);\n        setTimeToLoadDelay(0);\n\n        if (isStopped) {\n            start();\n        }\n\n        const latency = currentRepresentationInfo && currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n        dashMetrics.updateManifestUpdateInfo({\n            latency: latency\n        });\n\n        if (!isFragmentProcessingInProgress) {\n            // No pending request, request next segment at seek target\n            startScheduleTimer(0);\n        } else {\n            // Abort current request\n            fragmentModel.abortRequests();\n        }\n    }\n\n    function onPlaybackRateChanged(e) {\n        dashMetrics.updatePlayListTraceMetrics({playbackspeed: e.playbackRate.toString()});\n    }\n\n    function setSeekTarget(value) {\n        seekTarget = value;\n    }\n\n    function setTimeToLoadDelay(value) {\n        timeToLoadDelay = value;\n    }\n\n    function getTimeToLoadDelay() {\n        return timeToLoadDelay;\n    }\n\n    function getBufferTarget() {\n        return bufferLevelRule.getBufferTarget(type, currentRepresentationInfo, hasVideoTrack);\n    }\n\n    function resetInitialSettings() {\n        checkPlaybackQuality = true;\n        isFragmentProcessingInProgress = false;\n        timeToLoadDelay = 0;\n        seekTarget = NaN;\n        initialRequest = true;\n        lastInitializedRepresentationInfo = undefined;\n        lastFragmentRequest = {\n            mediaInfo: undefined,\n            quality: NaN,\n            adaptationIndex: NaN\n        };\n        topQualityIndex = {};\n        replaceRequestArray = [];\n        isStopped = true;\n        switchTrack = false;\n        replacingBuffer = false;\n        mediaRequest = null;\n        isReplacementRequest = false;\n    }\n\n    function reset() {\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\n\n        stop();\n        completeQualityChange(false);\n        resetInitialSettings();\n        streamInfo = null;\n    }\n\n    function getPlaybackController() {\n        return playbackController;\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType,\n        getStreamId: getStreamId,\n        setCurrentRepresentation: setCurrentRepresentation,\n        setSeekTarget: setSeekTarget,\n        setTimeToLoadDelay: setTimeToLoadDelay,\n        getTimeToLoadDelay: getTimeToLoadDelay,\n        switchTrackAsked: switchTrackAsked,\n        isStarted: isStarted,\n        start: start,\n        stop: stop,\n        reset: reset,\n        getBufferTarget: getBufferTarget,\n        processInitRequest: processInitRequest,\n        processMediaRequest: processMediaRequest,\n        getPlaybackController\n    };\n\n    setup();\n\n    return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexport default FactoryMaker.getClassFactory(ScheduleController);\n"]},"metadata":{},"sourceType":"script"}