{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashJSError = require('../../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction RepresentationController(config) {\n  config = config || {};\n  var eventBus = config.eventBus;\n  var events = config.events;\n  var errors = config.errors;\n  var abrController = config.abrController;\n  var dashMetrics = config.dashMetrics;\n  var playbackController = config.playbackController;\n  var timelineConverter = config.timelineConverter;\n  var type = config.type;\n  var streamInfo = config.streamInfo;\n  var dashConstants = config.dashConstants;\n  var instance = void 0,\n      realAdaptation = void 0,\n      updating = void 0,\n      voAvailableRepresentations = void 0,\n      currentVoRepresentation = void 0;\n\n  function setup() {\n    resetInitialSettings();\n    eventBus.on(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.on(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n    eventBus.on(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n    eventBus.on(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n  }\n\n  function getStreamId() {\n    return streamInfo.id;\n  }\n\n  function getType() {\n    return type;\n  }\n\n  function checkConfig() {\n    if (!abrController || !dashMetrics || !playbackController || !timelineConverter) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function getData() {\n    return realAdaptation;\n  }\n\n  function isUpdating() {\n    return updating;\n  }\n\n  function getCurrentRepresentation() {\n    return currentVoRepresentation;\n  }\n\n  function resetInitialSettings() {\n    realAdaptation = null;\n    updating = true;\n    voAvailableRepresentations = [];\n  }\n\n  function reset() {\n    eventBus.off(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n    eventBus.off(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n    eventBus.off(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n    eventBus.off(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n    resetInitialSettings();\n  }\n\n  function updateData(newRealAdaptation, availableRepresentations, type, quality) {\n    checkConfig();\n    startDataUpdate();\n    voAvailableRepresentations = availableRepresentations;\n    currentVoRepresentation = getRepresentationForQuality(quality);\n    realAdaptation = newRealAdaptation;\n\n    if (type !== _Constants2.default.VIDEO && type !== _Constants2.default.AUDIO && type !== _Constants2.default.FRAGMENTED_TEXT) {\n      endDataUpdate();\n      return;\n    }\n\n    updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n  }\n\n  function addRepresentationSwitch() {\n    checkConfig();\n    var now = new Date();\n    var currentRepresentation = getCurrentRepresentation();\n    var currentVideoTimeMs = playbackController.getTime() * 1000;\n\n    if (currentRepresentation) {\n      dashMetrics.addRepresentationSwitch(currentRepresentation.adaptation.type, now, currentVideoTimeMs, currentRepresentation.id);\n    }\n  }\n\n  function getRepresentationForQuality(quality) {\n    return quality === null || quality === undefined || quality >= voAvailableRepresentations.length ? null : voAvailableRepresentations[quality];\n  }\n\n  function getQualityForRepresentation(voRepresentation) {\n    return voAvailableRepresentations.indexOf(voRepresentation);\n  }\n\n  function isAllRepresentationsUpdated() {\n    for (var i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n      var segmentInfoType = voAvailableRepresentations[i].segmentInfoType;\n\n      if (voAvailableRepresentations[i].segmentAvailabilityRange === null || !voAvailableRepresentations[i].hasInitialization() || (segmentInfoType === dashConstants.SEGMENT_BASE || segmentInfoType === dashConstants.BASE_URL) && !voAvailableRepresentations[i].segments) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function setExpectedLiveEdge(liveEdge) {\n    timelineConverter.setExpectedLiveEdge(liveEdge);\n    dashMetrics.updateManifestUpdateInfo({\n      presentationStartTime: liveEdge\n    });\n  }\n\n  function updateRepresentation(representation, isDynamic) {\n    representation.segmentAvailabilityRange = timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n\n    if (representation.segmentAvailabilityRange.end < representation.segmentAvailabilityRange.start) {\n      var error = new _DashJSError2.default(errors.SEGMENTS_UNAVAILABLE_ERROR_CODE, errors.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE, {\n        availabilityDelay: representation.segmentAvailabilityRange.start - representation.segmentAvailabilityRange.end\n      });\n      endDataUpdate(error);\n      return;\n    }\n\n    if (isDynamic) {\n      setExpectedLiveEdge(representation.segmentAvailabilityRange.end);\n    }\n  }\n\n  function updateAvailabilityWindow(isDynamic, notifyUpdate) {\n    checkConfig();\n\n    for (var i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n      updateRepresentation(voAvailableRepresentations[i], isDynamic);\n\n      if (notifyUpdate) {\n        eventBus.trigger(events.REPRESENTATION_UPDATE_STARTED, {\n          representation: voAvailableRepresentations[i]\n        }, {\n          streamId: streamInfo.id,\n          mediaType: type\n        });\n      }\n    }\n  }\n\n  function resetAvailabilityWindow() {\n    voAvailableRepresentations.forEach(function (rep) {\n      rep.segmentAvailabilityRange = null;\n    });\n  }\n\n  function startDataUpdate() {\n    updating = true;\n    eventBus.trigger(events.DATA_UPDATE_STARTED, {}, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function endDataUpdate(error) {\n    updating = false;\n    eventBus.trigger(events.DATA_UPDATE_COMPLETED, {\n      data: realAdaptation,\n      currentRepresentation: currentVoRepresentation,\n      error: error\n    }, {\n      streamId: streamInfo.id,\n      mediaType: type\n    });\n  }\n\n  function postponeUpdate(postponeTimePeriod) {\n    var delay = postponeTimePeriod;\n\n    var update = function update() {\n      if (isUpdating()) return;\n      startDataUpdate(); // clear the segmentAvailabilityRange for all reps.\n      // this ensures all are updated before the live edge search starts\n\n      resetAvailabilityWindow();\n      updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n    };\n\n    eventBus.trigger(events.AST_IN_FUTURE, {\n      delay: delay\n    });\n    setTimeout(update, delay);\n  }\n\n  function onRepresentationUpdated(e) {\n    if (!isUpdating()) return;\n\n    if (e.error) {\n      endDataUpdate(e.error);\n      return;\n    }\n\n    var r = e.representation;\n    var manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate();\n    var alreadyAdded = false;\n    var postponeTimePeriod = 0;\n    var repInfo = void 0,\n        err = void 0,\n        repSwitch = void 0;\n\n    if (r.adaptation.period.mpd.manifest.type === dashConstants.DYNAMIC && !r.adaptation.period.mpd.manifest.ignorePostponeTimePeriod && playbackController.getStreamController().getStreams().length <= 1) {\n      // We must put things to sleep unless till e.g. the startTime calculation in ScheduleController.onLiveEdgeSearchCompleted fall after the segmentAvailabilityRange.start\n      postponeTimePeriod = getRepresentationUpdatePostponeTimePeriod(r);\n    }\n\n    if (postponeTimePeriod > 0) {\n      postponeUpdate(postponeTimePeriod);\n      err = new _DashJSError2.default(errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE, errors.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE);\n      endDataUpdate(err);\n      return;\n    }\n\n    if (manifestUpdateInfo) {\n      for (var i = 0; i < manifestUpdateInfo.representationInfo.length; i++) {\n        repInfo = manifestUpdateInfo.representationInfo[i];\n\n        if (repInfo.index === r.index && repInfo.mediaType === getType()) {\n          alreadyAdded = true;\n          break;\n        }\n      }\n\n      if (!alreadyAdded) {\n        dashMetrics.addManifestUpdateRepresentationInfo(r, getType());\n      }\n    }\n\n    if (isAllRepresentationsUpdated()) {\n      abrController.setPlaybackQuality(getType(), streamInfo, getQualityForRepresentation(currentVoRepresentation));\n      dashMetrics.updateManifestUpdateInfo({\n        latency: currentVoRepresentation.segmentAvailabilityRange.end - playbackController.getTime()\n      });\n      repSwitch = dashMetrics.getCurrentRepresentationSwitch(getCurrentRepresentation().adaptation.type);\n\n      if (!repSwitch) {\n        addRepresentationSwitch();\n      }\n\n      endDataUpdate();\n    }\n  }\n\n  function getRepresentationUpdatePostponeTimePeriod(representation) {\n    try {\n      var streamController = playbackController.getStreamController();\n      var activeStreamInfo = streamController.getActiveStreamInfo();\n      var startTimeAnchor = representation.segmentAvailabilityRange.start;\n\n      if (activeStreamInfo && activeStreamInfo.id && activeStreamInfo.id !== streamInfo.id) {\n        // We need to consider the currently playing period if a period switch is performed.\n        startTimeAnchor = Math.min(playbackController.getTime(), startTimeAnchor);\n      }\n\n      var segmentAvailabilityTimePeriod = representation.segmentAvailabilityRange.end - startTimeAnchor;\n      var liveDelay = playbackController.getLiveDelay();\n      return (liveDelay - segmentAvailabilityTimePeriod) * 1000;\n    } catch (e) {\n      return 0;\n    }\n  }\n\n  function onWallclockTimeUpdated(e) {\n    if (e.isDynamic) {\n      updateAvailabilityWindow(e.isDynamic);\n    }\n  }\n\n  function onQualityChanged(e) {\n    currentVoRepresentation = getRepresentationForQuality(e.newQuality);\n    addRepresentationSwitch();\n  }\n\n  function onManifestValidityChanged(e) {\n    if (e.newDuration) {\n      var representation = getCurrentRepresentation();\n\n      if (representation && representation.adaptation.period) {\n        var period = representation.adaptation.period;\n        period.duration = e.newDuration;\n      }\n    }\n  }\n\n  instance = {\n    getStreamId: getStreamId,\n    getType: getType,\n    getData: getData,\n    isUpdating: isUpdating,\n    updateData: updateData,\n    updateRepresentation: updateRepresentation,\n    getCurrentRepresentation: getCurrentRepresentation,\n    getRepresentationForQuality: getRepresentationForQuality,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nRepresentationController.__dashjs_factory_name = 'RepresentationController';\nexports.default = _FactoryMaker2.default.getClassFactory(RepresentationController);","map":{"version":3,"sources":["../../../../../src/dash/controllers/RepresentationController.js"],"names":["config","eventBus","events","errors","abrController","dashMetrics","playbackController","timelineConverter","type","streamInfo","dashConstants","instance","realAdaptation","updating","voAvailableRepresentations","currentVoRepresentation","resetInitialSettings","Constants","checkConfig","startDataUpdate","getRepresentationForQuality","endDataUpdate","updateAvailabilityWindow","now","currentRepresentation","getCurrentRepresentation","currentVideoTimeMs","quality","i","ln","segmentInfoType","presentationStartTime","representation","error","DashJSError","availabilityDelay","setExpectedLiveEdge","updateRepresentation","streamId","mediaType","rep","data","delay","update","isUpdating","resetAvailabilityWindow","setTimeout","e","r","manifestUpdateInfo","alreadyAdded","postponeTimePeriod","repInfo","err","repSwitch","getRepresentationUpdatePostponeTimePeriod","postponeUpdate","getType","isAllRepresentationsUpdated","getQualityForRepresentation","latency","addRepresentationSwitch","streamController","activeStreamInfo","startTimeAnchor","Math","segmentAvailabilityTimePeriod","liveDelay","period","getStreamId","getData","updateData","reset","setup","RepresentationController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../../streaming/constants/Constants';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction RepresentationController(config) {\n\n    config = config || {};\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const errors = config.errors;\n    const abrController = config.abrController;\n    const dashMetrics = config.dashMetrics;\n    const playbackController = config.playbackController;\n    const timelineConverter = config.timelineConverter;\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n    const dashConstants = config.dashConstants;\n\n    let instance,\n        realAdaptation,\n        updating,\n        voAvailableRepresentations,\n        currentVoRepresentation;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.on(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.on(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.on(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function checkConfig() {\n        if (!abrController || !dashMetrics || !playbackController || !timelineConverter) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getData() {\n        return realAdaptation;\n    }\n\n    function isUpdating() {\n        return updating;\n    }\n\n    function getCurrentRepresentation() {\n        return currentVoRepresentation;\n    }\n\n    function resetInitialSettings() {\n        realAdaptation = null;\n        updating = true;\n        voAvailableRepresentations = [];\n    }\n\n    function reset() {\n        eventBus.off(events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.off(events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.off(events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.off(events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n\n        resetInitialSettings();\n    }\n\n    function updateData(newRealAdaptation, availableRepresentations, type, quality) {\n        checkConfig();\n\n        startDataUpdate();\n\n        voAvailableRepresentations = availableRepresentations;\n\n        currentVoRepresentation = getRepresentationForQuality(quality);\n        realAdaptation = newRealAdaptation;\n\n        if (type !== Constants.VIDEO && type !== Constants.AUDIO && type !== Constants.FRAGMENTED_TEXT) {\n            endDataUpdate();\n            return;\n        }\n\n        updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n    }\n\n    function addRepresentationSwitch() {\n        checkConfig();\n        const now = new Date();\n        const currentRepresentation = getCurrentRepresentation();\n        const currentVideoTimeMs = playbackController.getTime() * 1000;\n        if (currentRepresentation) {\n            dashMetrics.addRepresentationSwitch(currentRepresentation.adaptation.type, now, currentVideoTimeMs, currentRepresentation.id);\n        }\n    }\n\n    function getRepresentationForQuality(quality) {\n        return quality === null || quality === undefined || quality >= voAvailableRepresentations.length ? null : voAvailableRepresentations[quality];\n    }\n\n    function getQualityForRepresentation(voRepresentation) {\n        return voAvailableRepresentations.indexOf(voRepresentation);\n    }\n\n    function isAllRepresentationsUpdated() {\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            let segmentInfoType = voAvailableRepresentations[i].segmentInfoType;\n            if (voAvailableRepresentations[i].segmentAvailabilityRange === null || !voAvailableRepresentations[i].hasInitialization() ||\n                ((segmentInfoType === dashConstants.SEGMENT_BASE || segmentInfoType === dashConstants.BASE_URL) && !voAvailableRepresentations[i].segments)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function updateRepresentation(representation, isDynamic) {\n        representation.segmentAvailabilityRange = timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n\n        if (representation.segmentAvailabilityRange.end < representation.segmentAvailabilityRange.start) {\n            let error = new DashJSError(errors.SEGMENTS_UNAVAILABLE_ERROR_CODE, errors.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE, {availabilityDelay: representation.segmentAvailabilityRange.start - representation.segmentAvailabilityRange.end});\n            endDataUpdate(error);\n            return;\n        }\n\n        if (isDynamic) {\n            setExpectedLiveEdge(representation.segmentAvailabilityRange.end);\n        }\n    }\n\n    function updateAvailabilityWindow(isDynamic, notifyUpdate) {\n        checkConfig();\n\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            updateRepresentation(voAvailableRepresentations[i], isDynamic);\n            if (notifyUpdate) {\n                eventBus.trigger(events.REPRESENTATION_UPDATE_STARTED,\n                    { representation: voAvailableRepresentations[i] },\n                    { streamId: streamInfo.id, mediaType: type }\n                );\n            }\n        }\n    }\n\n    function resetAvailabilityWindow() {\n        voAvailableRepresentations.forEach(rep => {\n            rep.segmentAvailabilityRange = null;\n        });\n    }\n\n    function startDataUpdate() {\n        updating = true;\n        eventBus.trigger(events.DATA_UPDATE_STARTED,\n            {},\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function endDataUpdate(error) {\n        updating = false;\n        eventBus.trigger(events.DATA_UPDATE_COMPLETED,\n            {\n                data: realAdaptation,\n                currentRepresentation: currentVoRepresentation,\n                error: error\n            },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function postponeUpdate(postponeTimePeriod) {\n        let delay = postponeTimePeriod;\n        let update = function () {\n            if (isUpdating()) return;\n\n            startDataUpdate();\n\n            // clear the segmentAvailabilityRange for all reps.\n            // this ensures all are updated before the live edge search starts\n            resetAvailabilityWindow();\n\n            updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n        };\n        eventBus.trigger(events.AST_IN_FUTURE, { delay: delay });\n        setTimeout(update, delay);\n    }\n\n    function onRepresentationUpdated(e) {\n        if (!isUpdating()) return;\n\n        if (e.error) {\n            endDataUpdate(e.error);\n            return;\n        }\n\n        let r = e.representation;\n        let manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate();\n        let alreadyAdded = false;\n        let postponeTimePeriod = 0;\n        let repInfo,\n            err,\n            repSwitch;\n\n        if (r.adaptation.period.mpd.manifest.type === dashConstants.DYNAMIC && !r.adaptation.period.mpd.manifest.ignorePostponeTimePeriod && playbackController.getStreamController().getStreams().length <= 1) {\n            // We must put things to sleep unless till e.g. the startTime calculation in ScheduleController.onLiveEdgeSearchCompleted fall after the segmentAvailabilityRange.start\n            postponeTimePeriod = getRepresentationUpdatePostponeTimePeriod(r);\n        }\n\n        if (postponeTimePeriod > 0) {\n            postponeUpdate(postponeTimePeriod);\n            err = new DashJSError(errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE, errors.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE);\n            endDataUpdate(err);\n            return;\n        }\n\n        if (manifestUpdateInfo) {\n            for (let i = 0; i < manifestUpdateInfo.representationInfo.length; i++) {\n                repInfo = manifestUpdateInfo.representationInfo[i];\n                if (repInfo.index === r.index && repInfo.mediaType === getType()) {\n                    alreadyAdded = true;\n                    break;\n                }\n            }\n\n            if (!alreadyAdded) {\n                dashMetrics.addManifestUpdateRepresentationInfo(r, getType());\n            }\n        }\n\n        if (isAllRepresentationsUpdated()) {\n            abrController.setPlaybackQuality(getType(), streamInfo, getQualityForRepresentation(currentVoRepresentation));\n            dashMetrics.updateManifestUpdateInfo({latency: currentVoRepresentation.segmentAvailabilityRange.end - playbackController.getTime()});\n\n            repSwitch = dashMetrics.getCurrentRepresentationSwitch(getCurrentRepresentation().adaptation.type);\n\n            if (!repSwitch) {\n                addRepresentationSwitch();\n            }\n            endDataUpdate();\n        }\n    }\n\n    function getRepresentationUpdatePostponeTimePeriod(representation) {\n        try {\n            const streamController = playbackController.getStreamController();\n            const activeStreamInfo = streamController.getActiveStreamInfo();\n            let startTimeAnchor = representation.segmentAvailabilityRange.start;\n\n            if (activeStreamInfo && activeStreamInfo.id && activeStreamInfo.id !== streamInfo.id) {\n                // We need to consider the currently playing period if a period switch is performed.\n                startTimeAnchor = Math.min(playbackController.getTime(), startTimeAnchor);\n            }\n\n            let segmentAvailabilityTimePeriod = representation.segmentAvailabilityRange.end - startTimeAnchor;\n            let liveDelay = playbackController.getLiveDelay();\n\n            return (liveDelay - segmentAvailabilityTimePeriod) * 1000;\n        } catch (e) {\n            return 0;\n        }\n    }\n\n    function onWallclockTimeUpdated(e) {\n        if (e.isDynamic) {\n            updateAvailabilityWindow(e.isDynamic);\n        }\n    }\n\n    function onQualityChanged(e) {\n        currentVoRepresentation = getRepresentationForQuality(e.newQuality);\n        addRepresentationSwitch();\n    }\n\n    function onManifestValidityChanged(e) {\n        if (e.newDuration) {\n            const representation = getCurrentRepresentation();\n            if (representation && representation.adaptation.period) {\n                const period = representation.adaptation.period;\n                period.duration = e.newDuration;\n            }\n        }\n    }\n\n    instance = {\n        getStreamId: getStreamId,\n        getType: getType,\n        getData: getData,\n        isUpdating: isUpdating,\n        updateData: updateData,\n        updateRepresentation: updateRepresentation,\n        getCurrentRepresentation: getCurrentRepresentation,\n        getRepresentationForQuality: getRepresentationForQuality,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nRepresentationController.__dashjs_factory_name = 'RepresentationController';\nexport default FactoryMaker.getClassFactory(RepresentationController);\n"]},"metadata":{},"sourceType":"script"}