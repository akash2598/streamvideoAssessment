{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* Creates an instance of an EBMLParser class which implements a large subset\n* of the functionality required to parse Matroska EBML\n*\n* @param {Object} config object with data member which is the buffer to parse\n* @ignore\n*/\n\n\nfunction EBMLParser(config) {\n  config = config || {};\n  var instance = void 0;\n  var data = new DataView(config.data);\n  var pos = 0;\n\n  function getPos() {\n    return pos;\n  }\n\n  function setPos(value) {\n    pos = value;\n  }\n  /**\n  * Consumes an EBML tag from the data stream.\n  *\n  * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n  * {boolean} required flag.\n  * @param {boolean} test whether or not the function should throw if a required\n  * tag is not found\n  * @return {boolean} whether or not the tag was found\n  * @throws will throw an exception if a required tag is not found and test\n  * param is false or undefined, or if the stream is malformed.\n  * @memberof EBMLParser\n  */\n\n\n  function consumeTag(tag, test) {\n    var found = true;\n    var bytesConsumed = 0;\n    var p1 = void 0,\n        p2 = void 0;\n\n    if (test === undefined) {\n      test = false;\n    }\n\n    if (tag.tag > 0xFFFFFF) {\n      if (data.getUint32(pos) !== tag.tag) {\n        found = false;\n      }\n\n      bytesConsumed = 4;\n    } else if (tag.tag > 0xFFFF) {\n      // 3 bytes\n      p1 = data.getUint16(pos);\n      p2 = data.getUint8(pos + 2); // shift p1 over a byte and add p2\n\n      if (p1 * 256 + p2 !== tag.tag) {\n        found = false;\n      }\n\n      bytesConsumed = 3;\n    } else if (tag.tag > 0xFF) {\n      if (data.getUint16(pos) !== tag.tag) {\n        found = false;\n      }\n\n      bytesConsumed = 2;\n    } else {\n      if (data.getUint8(pos) !== tag.tag) {\n        found = false;\n      }\n\n      bytesConsumed = 1;\n    }\n\n    if (!found && tag.required && !test) {\n      throw new Error('required tag not found');\n    }\n\n    if (found) {\n      pos += bytesConsumed;\n    }\n\n    return found;\n  }\n  /**\n  * Consumes an EBML tag from the data stream.   If the tag is found then this\n  * function will also remove the size field which follows the tag from the\n  * data stream.\n  *\n  * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n  * {boolean} required flag.\n  * @param {boolean} test whether or not the function should throw if a required\n  * tag is not found\n  * @return {boolean} whether or not the tag was found\n  * @throws will throw an exception if a required tag is not found and test\n  * param is false or undefined, or if the stream is malformedata.\n  * @memberof EBMLParser\n  */\n\n\n  function consumeTagAndSize(tag, test) {\n    var found = consumeTag(tag, test);\n\n    if (found) {\n      getMatroskaCodedNum();\n    }\n\n    return found;\n  }\n  /**\n  * Consumes an EBML tag from the data stream.   If the tag is found then this\n  * function will also remove the size field which follows the tag from the\n  * data stream.  It will use the value of the size field to parse a binary\n  * field, using a parser defined in the tag itself\n  *\n  * @param {Object} tag to parse, A tag is an object with at least a {number} tag,\n  * {boolean} required flag, and a parse function which takes a size parameter\n  * @return {boolean} whether or not the tag was found\n  * @throws will throw an exception if a required tag is not found,\n  * or if the stream is malformed\n  * @memberof EBMLParser\n  */\n\n\n  function parseTag(tag) {\n    var size = void 0;\n    consumeTag(tag);\n    size = getMatroskaCodedNum();\n    return instance[tag.parse](size);\n  }\n  /**\n  * Consumes an EBML tag from the data stream.   If the tag is found then this\n  * function will also remove the size field which follows the tag from the\n  * data stream.  It will use the value of the size field to skip over the\n  * entire section of EBML encapsulated by the tag.\n  *\n  * @param {Object} tag to parse, A tag is an object with at least a {number} tag, and\n  * {boolean} required flag\n  * @param {boolean} test a flag to indicate if an exception should be thrown\n  * if a required tag is not found\n  * @return {boolean} whether or not the tag was found\n  * @throws will throw an exception if a required tag is not found and test is\n  * false or undefined or if the stream is malformed\n  * @memberof EBMLParser\n  */\n\n\n  function skipOverElement(tag, test) {\n    var found = consumeTag(tag, test);\n    var headerSize = void 0;\n\n    if (found) {\n      headerSize = getMatroskaCodedNum();\n      pos += headerSize;\n    }\n\n    return found;\n  }\n  /**\n  * Returns and consumes a number encoded according to the Matroska EBML\n  * specification from the bitstream.\n  *\n  * @param {boolean} retainMSB whether or not to retain the Most Significant Bit (the\n  * first 1). this is usually true when reading Tag IDs.\n  * @return {number} the decoded number\n  * @throws will throw an exception if the bit stream is malformed or there is\n  * not enough data\n  * @memberof EBMLParser\n  */\n\n\n  function getMatroskaCodedNum(retainMSB) {\n    var bytesUsed = 1;\n    var mask = 0x80;\n    var maxBytes = 8;\n    var extraBytes = -1;\n    var num = 0;\n    var ch = data.getUint8(pos);\n    var i = 0;\n\n    for (i = 0; i < maxBytes; i += 1) {\n      if ((ch & mask) === mask) {\n        num = retainMSB === undefined ? ch & ~mask : ch;\n        extraBytes = i;\n        break;\n      }\n\n      mask >>= 1;\n    }\n\n    for (i = 0; i < extraBytes; i += 1, bytesUsed += 1) {\n      num = num << 8 | 0xff & data.getUint8(pos + bytesUsed);\n    }\n\n    pos += bytesUsed;\n    return num;\n  }\n  /**\n  * Returns and consumes a float from the bitstream.\n  *\n  * @param {number} size 4 or 8 byte floats are supported\n  * @return {number} the decoded number\n  * @throws will throw an exception if the bit stream is malformed or there is\n  * not enough data\n  * @memberof EBMLParser\n  */\n\n\n  function getMatroskaFloat(size) {\n    var outFloat = void 0;\n\n    switch (size) {\n      case 4:\n        outFloat = data.getFloat32(pos);\n        pos += 4;\n        break;\n\n      case 8:\n        outFloat = data.getFloat64(pos);\n        pos += 8;\n        break;\n    }\n\n    return outFloat;\n  }\n  /**\n  * Consumes and returns an unsigned int from the bitstream.\n  *\n  * @param {number} size 1 to 8 bytes\n  * @return {number} the decoded number\n  * @throws will throw an exception if the bit stream is malformed or there is\n  * not enough data\n  * @memberof EBMLParser\n  */\n\n\n  function getMatroskaUint(size) {\n    var val = 0;\n\n    for (var i = 0; i < size; i += 1) {\n      val <<= 8;\n      val |= data.getUint8(pos + i) & 0xff;\n    }\n\n    pos += size;\n    return val;\n  }\n  /**\n  * Tests whether there is more data in the bitstream for parsing\n  *\n  * @return {boolean} whether there is more data to parse\n  * @memberof EBMLParser\n  */\n\n\n  function moreData() {\n    return pos < data.byteLength;\n  }\n\n  instance = {\n    getPos: getPos,\n    setPos: setPos,\n    consumeTag: consumeTag,\n    consumeTagAndSize: consumeTagAndSize,\n    parseTag: parseTag,\n    skipOverElement: skipOverElement,\n    getMatroskaCodedNum: getMatroskaCodedNum,\n    getMatroskaFloat: getMatroskaFloat,\n    getMatroskaUint: getMatroskaUint,\n    moreData: moreData\n  };\n  return instance;\n}\n\nEBMLParser.__dashjs_factory_name = 'EBMLParser';\nexports.default = _FactoryMaker2.default.getClassFactory(EBMLParser);","map":{"version":3,"sources":["../../../../../src/streaming/utils/EBMLParser.js"],"names":["config","instance","data","pos","found","bytesConsumed","p1","p2","test","tag","consumeTag","getMatroskaCodedNum","size","headerSize","bytesUsed","mask","maxBytes","extraBytes","num","ch","i","retainMSB","outFloat","val","getPos","setPos","consumeTagAndSize","parseTag","skipOverElement","getMatroskaFloat","getMatroskaUint","moreData","EBMLParser","FactoryMaker"],"mappings":"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","sourcesContent":["import FactoryMaker from '../../core/FactoryMaker';\n\n/**\n * Creates an instance of an EBMLParser class which implements a large subset\n * of the functionality required to parse Matroska EBML\n *\n * @param {Object} config object with data member which is the buffer to parse\n * @ignore\n */\nfunction EBMLParser(config) {\n\n    config = config || {};\n    let instance;\n\n    let data = new DataView(config.data);\n    let pos = 0;\n\n    function getPos() {\n        return pos;\n    }\n\n    function setPos(value) {\n        pos = value;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n     * {boolean} required flag.\n     * @param {boolean} test whether or not the function should throw if a required\n     * tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test\n     * param is false or undefined, or if the stream is malformed.\n     * @memberof EBMLParser\n     */\n    function consumeTag(tag, test) {\n        let found = true;\n        let bytesConsumed = 0;\n        let p1,\n            p2;\n\n        if (test === undefined) {\n            test = false;\n        }\n\n        if (tag.tag > 0xFFFFFF) {\n            if (data.getUint32(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 4;\n        } else if (tag.tag > 0xFFFF) {\n            // 3 bytes\n            p1 = data.getUint16(pos);\n            p2 = data.getUint8(pos + 2);\n\n            // shift p1 over a byte and add p2\n            if (p1 * 256 + p2 !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 3;\n        } else if (tag.tag > 0xFF) {\n            if (data.getUint16(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 2;\n        } else {\n            if (data.getUint8(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 1;\n        }\n\n        if (!found && tag.required && !test) {\n            throw new Error('required tag not found');\n        }\n\n        if (found) {\n            pos += bytesConsumed;\n        }\n\n        return found;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n     * {boolean} required flag.\n     * @param {boolean} test whether or not the function should throw if a required\n     * tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test\n     * param is false or undefined, or if the stream is malformedata.\n     * @memberof EBMLParser\n     */\n    function consumeTagAndSize(tag, test) {\n        let found = consumeTag(tag, test);\n\n        if (found) {\n            getMatroskaCodedNum();\n        }\n\n        return found;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.  It will use the value of the size field to parse a binary\n     * field, using a parser defined in the tag itself\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag,\n     * {boolean} required flag, and a parse function which takes a size parameter\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found,\n     * or if the stream is malformed\n     * @memberof EBMLParser\n     */\n    function parseTag(tag) {\n        let size;\n\n        consumeTag(tag);\n        size = getMatroskaCodedNum();\n        return instance[tag.parse](size);\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.  It will use the value of the size field to skip over the\n     * entire section of EBML encapsulated by the tag.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag, and\n     * {boolean} required flag\n     * @param {boolean} test a flag to indicate if an exception should be thrown\n     * if a required tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test is\n     * false or undefined or if the stream is malformed\n     * @memberof EBMLParser\n     */\n    function skipOverElement(tag, test) {\n        let found = consumeTag(tag, test);\n        let headerSize;\n\n        if (found) {\n            headerSize = getMatroskaCodedNum();\n            pos += headerSize;\n        }\n\n        return found;\n    }\n\n    /**\n     * Returns and consumes a number encoded according to the Matroska EBML\n     * specification from the bitstream.\n     *\n     * @param {boolean} retainMSB whether or not to retain the Most Significant Bit (the\n     * first 1). this is usually true when reading Tag IDs.\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaCodedNum(retainMSB) {\n        let bytesUsed = 1;\n        let mask = 0x80;\n        let maxBytes = 8;\n        let extraBytes = -1;\n        let num = 0;\n        let ch = data.getUint8(pos);\n        let i = 0;\n\n        for (i = 0; i < maxBytes; i += 1) {\n            if ((ch & mask) === mask) {\n                num = (retainMSB === undefined) ? ch & ~mask : ch;\n                extraBytes = i;\n                break;\n            }\n            mask >>= 1;\n        }\n\n        for (i = 0; i < extraBytes; i += 1, bytesUsed += 1) {\n            num = (num << 8) | (0xff & data.getUint8(pos + bytesUsed));\n        }\n\n        pos += bytesUsed;\n\n        return num;\n    }\n\n    /**\n     * Returns and consumes a float from the bitstream.\n     *\n     * @param {number} size 4 or 8 byte floats are supported\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaFloat(size) {\n        let outFloat;\n\n        switch (size) {\n        case 4:\n            outFloat = data.getFloat32(pos);\n            pos += 4;\n            break;\n        case 8:\n            outFloat = data.getFloat64(pos);\n            pos += 8;\n            break;\n        }\n        return outFloat;\n    }\n\n    /**\n     * Consumes and returns an unsigned int from the bitstream.\n     *\n     * @param {number} size 1 to 8 bytes\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaUint(size) {\n        let val = 0;\n\n        for (let i = 0; i < size; i += 1) {\n            val <<= 8;\n            val |= data.getUint8(pos + i) & 0xff;\n        }\n\n        pos += size;\n        return val;\n    }\n\n    /**\n     * Tests whether there is more data in the bitstream for parsing\n     *\n     * @return {boolean} whether there is more data to parse\n     * @memberof EBMLParser\n     */\n    function moreData() {\n        return pos < data.byteLength;\n    }\n\n    instance = {\n        getPos: getPos,\n        setPos: setPos,\n        consumeTag: consumeTag,\n        consumeTagAndSize: consumeTagAndSize,\n        parseTag: parseTag,\n        skipOverElement: skipOverElement,\n        getMatroskaCodedNum: getMatroskaCodedNum,\n        getMatroskaFloat: getMatroskaFloat,\n        getMatroskaUint: getMatroskaUint,\n        moreData: moreData\n    };\n\n    return instance;\n}\n\nEBMLParser.__dashjs_factory_name = 'EBMLParser';\nexport default FactoryMaker.getClassFactory(EBMLParser);"]},"metadata":{},"sourceType":"script"}