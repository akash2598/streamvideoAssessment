{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _QoeInfo = require('./QoeInfo');\n\nvar _QoeInfo2 = _interopRequireDefault(_QoeInfo);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Authors:\n* Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n* Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n* May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n*/\n\n\nfunction LoLpQoeEvaluator() {\n  var instance = void 0,\n      voPerSegmentQoeInfo = void 0,\n      segmentDuration = void 0,\n      maxBitrateKbps = void 0,\n      minBitrateKbps = void 0;\n\n  function _setup() {\n    _resetInitialSettings();\n  }\n\n  function _resetInitialSettings() {\n    voPerSegmentQoeInfo = null;\n    segmentDuration = null;\n    maxBitrateKbps = null;\n    minBitrateKbps = null;\n  }\n\n  function setupPerSegmentQoe(sDuration, maxBrKbps, minBrKbps) {\n    // Set up Per Segment QoeInfo\n    voPerSegmentQoeInfo = _createQoeInfo('segment', sDuration, maxBrKbps, minBrKbps);\n    segmentDuration = sDuration;\n    maxBitrateKbps = maxBrKbps;\n    minBitrateKbps = minBrKbps;\n  }\n\n  function _createQoeInfo(fragmentType, fragmentDuration, maxBitrateKbps, minBitrateKbps) {\n    /*\n    * [Weights][Source: Abdelhak Bentaleb, 2020 (last updated: 30 Mar 2020)]\n    * bitrateReward:           segment duration, e.g. 0.5s\n    * bitrateSwitchPenalty:    0.02s or 1s if the bitrate switch is too important\n    * rebufferPenalty:         max encoding bitrate, e.g. 1000kbps\n    * latencyPenalty:          if L ≤ 1.1 seconds then = min encoding bitrate * 0.05, otherwise = max encoding bitrate * 0.1\n    * playbackSpeedPenalty:    min encoding bitrate, e.g. 200kbps\n    */\n    // Create new QoeInfo object\n    var qoeInfo = new _QoeInfo2.default();\n    qoeInfo.type = fragmentType; // Set weight: bitrateReward\n    // set some safe value, else consider throwing error\n\n    if (!fragmentDuration) {\n      qoeInfo.weights.bitrateReward = 1;\n    } else {\n      qoeInfo.weights.bitrateReward = fragmentDuration;\n    } // Set weight: bitrateSwitchPenalty\n    // qoeInfo.weights.bitrateSwitchPenalty = 0.02;\n\n\n    qoeInfo.weights.bitrateSwitchPenalty = 1; // Set weight: rebufferPenalty\n    // set some safe value, else consider throwing error\n\n    if (!maxBitrateKbps) {\n      qoeInfo.weights.rebufferPenalty = 1000;\n    } else {\n      qoeInfo.weights.rebufferPenalty = maxBitrateKbps;\n    } // Set weight: latencyPenalty\n\n\n    qoeInfo.weights.latencyPenalty = [];\n    qoeInfo.weights.latencyPenalty.push({\n      threshold: 1.1,\n      penalty: minBitrateKbps * 0.05\n    });\n    qoeInfo.weights.latencyPenalty.push({\n      threshold: 100000000,\n      penalty: maxBitrateKbps * 0.1\n    }); // Set weight: playbackSpeedPenalty\n\n    if (!minBitrateKbps) qoeInfo.weights.playbackSpeedPenalty = 200; // set some safe value, else consider throwing error\n    else qoeInfo.weights.playbackSpeedPenalty = minBitrateKbps;\n    return qoeInfo;\n  }\n\n  function logSegmentMetrics(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n    if (voPerSegmentQoeInfo) {\n      _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, voPerSegmentQoeInfo);\n    }\n  }\n\n  function _logMetricsInQoeInfo(bitrate, rebufferTime, latency, playbackSpeed, qoeInfo) {\n    // Update: bitrate Weighted Sum value\n    qoeInfo.bitrateWSum += qoeInfo.weights.bitrateReward * bitrate; // Update: bitrateSwitch Weighted Sum value\n\n    if (qoeInfo.lastBitrate) {\n      qoeInfo.bitrateSwitchWSum += qoeInfo.weights.bitrateSwitchPenalty * Math.abs(bitrate - qoeInfo.lastBitrate);\n    }\n\n    qoeInfo.lastBitrate = bitrate; // Update: rebuffer Weighted Sum value\n\n    qoeInfo.rebufferWSum += qoeInfo.weights.rebufferPenalty * rebufferTime; // Update: latency Weighted Sum value\n\n    for (var i = 0; i < qoeInfo.weights.latencyPenalty.length; i++) {\n      var latencyRange = qoeInfo.weights.latencyPenalty[i];\n\n      if (latency <= latencyRange.threshold) {\n        qoeInfo.latencyWSum += latencyRange.penalty * latency;\n        break;\n      }\n    } // Update: playbackSpeed Weighted Sum value\n\n\n    qoeInfo.playbackSpeedWSum += qoeInfo.weights.playbackSpeedPenalty * Math.abs(1 - playbackSpeed); // Update: Total Qoe value\n\n    qoeInfo.totalQoe = qoeInfo.bitrateWSum - qoeInfo.bitrateSwitchWSum - qoeInfo.rebufferWSum - qoeInfo.latencyWSum - qoeInfo.playbackSpeedWSum;\n  } // Returns current Per Segment QoeInfo\n\n\n  function getPerSegmentQoe() {\n    return voPerSegmentQoeInfo;\n  } // For one-time use only\n  // Returns totalQoe based on a single set of metrics.\n\n\n  function calculateSingleUseQoe(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n    var singleUseQoeInfo = null;\n\n    if (segmentDuration && maxBitrateKbps && minBitrateKbps) {\n      singleUseQoeInfo = _createQoeInfo('segment', segmentDuration, maxBitrateKbps, minBitrateKbps);\n    }\n\n    if (singleUseQoeInfo) {\n      _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, singleUseQoeInfo);\n\n      return singleUseQoeInfo.totalQoe;\n    } else {\n      // Something went wrong..\n      return 0;\n    }\n  }\n\n  function reset() {\n    _resetInitialSettings();\n  }\n\n  instance = {\n    setupPerSegmentQoe: setupPerSegmentQoe,\n    logSegmentMetrics: logSegmentMetrics,\n    getPerSegmentQoe: getPerSegmentQoe,\n    calculateSingleUseQoe: calculateSingleUseQoe,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n\nLoLpQoeEvaluator.__dashjs_factory_name = 'LoLpQoeEvaluator';\nexports.default = _FactoryMaker2.default.getClassFactory(LoLpQoeEvaluator);","map":{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LoLpQoEEvaluator.js"],"names":["instance","voPerSegmentQoeInfo","segmentDuration","maxBitrateKbps","minBitrateKbps","_resetInitialSettings","_createQoeInfo","qoeInfo","QoeInfo","threshold","penalty","_logMetricsInQoeInfo","Math","bitrate","i","latencyRange","latency","singleUseQoeInfo","setupPerSegmentQoe","logSegmentMetrics","getPerSegmentQoe","calculateSingleUseQoe","reset","_setup","LoLpQoeEvaluator","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\nimport FactoryMaker from '../../../../core/FactoryMaker';\nimport QoeInfo from './QoeInfo';\n\nfunction LoLpQoeEvaluator() {\n\n    let instance,\n        voPerSegmentQoeInfo,\n        segmentDuration,\n        maxBitrateKbps,\n        minBitrateKbps;\n\n    function _setup() {\n        _resetInitialSettings();\n    }\n\n    function _resetInitialSettings() {\n        voPerSegmentQoeInfo = null;\n        segmentDuration = null;\n        maxBitrateKbps = null;\n        minBitrateKbps = null;\n    }\n\n    function setupPerSegmentQoe(sDuration, maxBrKbps, minBrKbps) {\n        // Set up Per Segment QoeInfo\n        voPerSegmentQoeInfo = _createQoeInfo('segment', sDuration, maxBrKbps, minBrKbps);\n        segmentDuration = sDuration;\n        maxBitrateKbps = maxBrKbps;\n        minBitrateKbps = minBrKbps;\n    }\n\n    function _createQoeInfo(fragmentType, fragmentDuration, maxBitrateKbps, minBitrateKbps) {\n        /*\n         * [Weights][Source: Abdelhak Bentaleb, 2020 (last updated: 30 Mar 2020)]\n         * bitrateReward:           segment duration, e.g. 0.5s\n         * bitrateSwitchPenalty:    0.02s or 1s if the bitrate switch is too important\n         * rebufferPenalty:         max encoding bitrate, e.g. 1000kbps\n         * latencyPenalty:          if L ≤ 1.1 seconds then = min encoding bitrate * 0.05, otherwise = max encoding bitrate * 0.1\n         * playbackSpeedPenalty:    min encoding bitrate, e.g. 200kbps\n         */\n\n        // Create new QoeInfo object\n        let qoeInfo = new QoeInfo();\n        qoeInfo.type = fragmentType;\n\n        // Set weight: bitrateReward\n        // set some safe value, else consider throwing error\n        if (!fragmentDuration) {\n            qoeInfo.weights.bitrateReward = 1;\n        }\n        else {\n            qoeInfo.weights.bitrateReward = fragmentDuration;\n        }\n\n        // Set weight: bitrateSwitchPenalty\n        // qoeInfo.weights.bitrateSwitchPenalty = 0.02;\n        qoeInfo.weights.bitrateSwitchPenalty = 1;\n\n        // Set weight: rebufferPenalty\n        // set some safe value, else consider throwing error\n        if (!maxBitrateKbps) {\n            qoeInfo.weights.rebufferPenalty = 1000;\n        }\n        else {\n            qoeInfo.weights.rebufferPenalty = maxBitrateKbps;\n        }\n\n        // Set weight: latencyPenalty\n        qoeInfo.weights.latencyPenalty = [];\n        qoeInfo.weights.latencyPenalty.push({ threshold: 1.1, penalty: (minBitrateKbps * 0.05) });\n        qoeInfo.weights.latencyPenalty.push({ threshold: 100000000, penalty: (maxBitrateKbps * 0.1) });\n\n        // Set weight: playbackSpeedPenalty\n        if (!minBitrateKbps) qoeInfo.weights.playbackSpeedPenalty = 200;   // set some safe value, else consider throwing error\n        else qoeInfo.weights.playbackSpeedPenalty = minBitrateKbps;\n\n        return qoeInfo;\n    }\n\n    function logSegmentMetrics(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n        if (voPerSegmentQoeInfo) {\n            _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, voPerSegmentQoeInfo);\n        }\n    }\n\n    function _logMetricsInQoeInfo(bitrate, rebufferTime, latency, playbackSpeed, qoeInfo) {\n        // Update: bitrate Weighted Sum value\n        qoeInfo.bitrateWSum += (qoeInfo.weights.bitrateReward * bitrate);\n\n        // Update: bitrateSwitch Weighted Sum value\n        if (qoeInfo.lastBitrate) {\n            qoeInfo.bitrateSwitchWSum += (qoeInfo.weights.bitrateSwitchPenalty * Math.abs(bitrate - qoeInfo.lastBitrate));\n        }\n        qoeInfo.lastBitrate = bitrate;\n\n        // Update: rebuffer Weighted Sum value\n        qoeInfo.rebufferWSum += (qoeInfo.weights.rebufferPenalty * rebufferTime);\n\n        // Update: latency Weighted Sum value\n        for (let i = 0; i < qoeInfo.weights.latencyPenalty.length; i++) {\n            let latencyRange = qoeInfo.weights.latencyPenalty[i];\n            if (latency <= latencyRange.threshold) {\n                qoeInfo.latencyWSum += (latencyRange.penalty * latency);\n                break;\n            }\n        }\n\n        // Update: playbackSpeed Weighted Sum value\n        qoeInfo.playbackSpeedWSum += (qoeInfo.weights.playbackSpeedPenalty * Math.abs(1 - playbackSpeed));\n\n        // Update: Total Qoe value\n        qoeInfo.totalQoe = qoeInfo.bitrateWSum - qoeInfo.bitrateSwitchWSum - qoeInfo.rebufferWSum - qoeInfo.latencyWSum - qoeInfo.playbackSpeedWSum;\n    }\n\n    // Returns current Per Segment QoeInfo\n    function getPerSegmentQoe() {\n        return voPerSegmentQoeInfo;\n    }\n\n    // For one-time use only\n    // Returns totalQoe based on a single set of metrics.\n    function calculateSingleUseQoe(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed) {\n        let singleUseQoeInfo = null;\n\n        if (segmentDuration && maxBitrateKbps && minBitrateKbps) {\n            singleUseQoeInfo = _createQoeInfo('segment', segmentDuration, maxBitrateKbps, minBitrateKbps);\n        }\n\n        if (singleUseQoeInfo) {\n            _logMetricsInQoeInfo(segmentBitrate, segmentRebufferTime, currentLatency, currentPlaybackSpeed, singleUseQoeInfo);\n            return singleUseQoeInfo.totalQoe;\n        } else {\n            // Something went wrong..\n            return 0;\n        }\n    }\n\n    function reset() {\n        _resetInitialSettings();\n    }\n\n    instance = {\n        setupPerSegmentQoe,\n        logSegmentMetrics,\n        getPerSegmentQoe,\n        calculateSingleUseQoe,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLpQoeEvaluator.__dashjs_factory_name = 'LoLpQoeEvaluator';\nexport default FactoryMaker.getClassFactory(LoLpQoeEvaluator);\n\n"]},"metadata":{},"sourceType":"script"}