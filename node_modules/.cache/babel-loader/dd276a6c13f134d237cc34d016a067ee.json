{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Constants = require('../../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _SegmentsUtils = require('./SegmentsUtils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction TimelineSegmentsGetter(config, isDynamic) {\n  config = config || {};\n  var timelineConverter = config.timelineConverter;\n  var instance = void 0;\n\n  function checkConfig() {\n    if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') || !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function iterateSegments(representation, iterFunc) {\n    var base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate || representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\n    var timeline = base.SegmentTimeline;\n    var list = base.SegmentURL_asArray;\n    var time = 0;\n    var scaledTime = 0;\n    var availabilityIdx = -1;\n    var fragments = void 0,\n        frag = void 0,\n        i = void 0,\n        len = void 0,\n        j = void 0,\n        repeat = void 0,\n        repeatEndTime = void 0,\n        nextFrag = void 0,\n        fTimescale = void 0;\n    fTimescale = representation.timescale;\n    fragments = timeline.S_asArray;\n    var breakIterator = false;\n\n    for (i = 0, len = fragments.length; i < len && !breakIterator; i++) {\n      frag = fragments[i];\n      repeat = 0;\n\n      if (frag.hasOwnProperty('r')) {\n        repeat = frag.r;\n      } // For a repeated S element, t belongs only to the first segment\n\n\n      if (frag.hasOwnProperty('t')) {\n        time = frag.t;\n        scaledTime = time / fTimescale;\n      } // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n      // next MPD update.\"\n\n\n      if (repeat < 0) {\n        nextFrag = fragments[i + 1];\n\n        if (nextFrag && nextFrag.hasOwnProperty('t')) {\n          repeatEndTime = nextFrag.t / fTimescale;\n        } else {\n          var availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end;\n          repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\n          representation.segmentDuration = frag.d / fTimescale;\n        }\n\n        repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\n      }\n\n      for (j = 0; j <= repeat && !breakIterator; j++) {\n        availabilityIdx++;\n        breakIterator = iterFunc(time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i);\n\n        if (breakIterator) {\n          representation.segmentDuration = frag.d / fTimescale; // check if there is at least one more segment\n\n          if (j < repeat - 1 || i < len - 1) {\n            availabilityIdx++;\n          }\n        }\n\n        time += frag.d;\n        scaledTime = time / fTimescale;\n      }\n    }\n\n    representation.availableSegmentsNumber = availabilityIdx;\n  }\n\n  function getSegmentByIndex(representation, index, lastSegmentTime) {\n    checkConfig();\n\n    if (!representation) {\n      return null;\n    }\n\n    var segment = null;\n    var found = false;\n    iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n      if (found || lastSegmentTime < 0) {\n        var media = base.media;\n        var mediaRange = frag.mediaRange;\n\n        if (list) {\n          media = list[i].media || '';\n          mediaRange = list[i].mediaRange;\n        }\n\n        segment = (0, _SegmentsUtils.getTimeBasedSegment)(timelineConverter, isDynamic, representation, time, frag.d, fTimescale, media, mediaRange, availabilityIdx, frag.tManifest);\n        return true;\n      } else if (scaledTime >= lastSegmentTime - frag.d * 0.5 / fTimescale) {\n        // same logic, if deviation is\n        // 50% of segment duration, segment is found if scaledTime is greater than or equal to (startTime of previous segment - half of the previous segment duration)\n        found = true;\n      }\n\n      return false;\n    });\n    return segment;\n  }\n\n  function getSegmentByTime(representation, requestedTime) {\n    checkConfig();\n\n    if (!representation) {\n      return null;\n    }\n\n    if (requestedTime === undefined) {\n      requestedTime = null;\n    }\n\n    var segment = null;\n    var requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\n    iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n      // In some cases when requiredMediaTime = actual end time of the last segment\n      // it is possible that this time a bit exceeds the declared end time of the last segment.\n      // in this case we still need to include the last segment in the segment list.\n      if (requiredMediaTime < scaledTime + frag.d / fTimescale) {\n        var media = base.media;\n        var mediaRange = frag.mediaRange;\n\n        if (list) {\n          media = list[i].media || '';\n          mediaRange = list[i].mediaRange;\n        }\n\n        segment = (0, _SegmentsUtils.getTimeBasedSegment)(timelineConverter, isDynamic, representation, time, frag.d, fTimescale, media, mediaRange, availabilityIdx, frag.tManifest);\n        return true;\n      }\n\n      return false;\n    });\n    return segment;\n  }\n\n  instance = {\n    getSegmentByIndex: getSegmentByIndex,\n    getSegmentByTime: getSegmentByTime\n  };\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\n\nvar factory = _FactoryMaker2.default.getClassFactory(TimelineSegmentsGetter);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../src/dash/utils/TimelineSegmentsGetter.js"],"names":["config","timelineConverter","instance","Constants","base","representation","timeline","list","time","scaledTime","availabilityIdx","fragments","frag","i","len","j","repeat","repeatEndTime","nextFrag","fTimescale","breakIterator","availabilityEnd","Math","iterFunc","checkConfig","segment","found","lastSegmentTime","media","mediaRange","requestedTime","requiredMediaTime","iterateSegments","getSegmentByIndex","getSegmentByTime","TimelineSegmentsGetter","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Constants from '../../streaming/constants/Constants';\n\nimport { getTimeBasedSegment } from './SegmentsUtils';\n\nfunction TimelineSegmentsGetter(config, isDynamic) {\n\n    config = config || {};\n    const timelineConverter = config.timelineConverter;\n\n    let instance;\n\n    function checkConfig() {\n        if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') ||\n            !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function iterateSegments(representation, iterFunc) {\n        const base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate ||\n            representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n                AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\n        const timeline = base.SegmentTimeline;\n        const list = base.SegmentURL_asArray;\n\n        let time = 0;\n        let scaledTime = 0;\n        let availabilityIdx = -1;\n\n        let fragments,\n            frag,\n            i,\n            len,\n            j,\n            repeat,\n            repeatEndTime,\n            nextFrag,\n            fTimescale;\n\n        fTimescale = representation.timescale;\n        fragments = timeline.S_asArray;\n\n        let breakIterator = false;\n\n        for (i = 0, len = fragments.length; i < len && !breakIterator; i++) {\n            frag = fragments[i];\n            repeat = 0;\n            if (frag.hasOwnProperty('r')) {\n                repeat = frag.r;\n            }\n\n            // For a repeated S element, t belongs only to the first segment\n            if (frag.hasOwnProperty('t')) {\n                time = frag.t;\n                scaledTime = time / fTimescale;\n            }\n\n            // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n            // next MPD update.\"\n            if (repeat < 0) {\n                nextFrag = fragments[i + 1];\n\n                if (nextFrag && nextFrag.hasOwnProperty('t')) {\n                    repeatEndTime = nextFrag.t / fTimescale;\n                } else {\n                    const availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : (timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end);\n                    repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\n                    representation.segmentDuration = frag.d / fTimescale;\n                }\n\n                repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\n            }\n\n            for (j = 0; j <= repeat && !breakIterator; j++) {\n                availabilityIdx++;\n\n                breakIterator = iterFunc(time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i);\n\n                if (breakIterator) {\n                    representation.segmentDuration = frag.d / fTimescale;\n\n                    // check if there is at least one more segment\n                    if (j < repeat - 1 || i < len - 1) {\n                        availabilityIdx++;\n                    }\n                }\n\n                time += frag.d;\n                scaledTime = time / fTimescale;\n            }\n        }\n\n        representation.availableSegmentsNumber = availabilityIdx;\n    }\n\n    function getSegmentByIndex(representation, index, lastSegmentTime) {\n        checkConfig();\n\n        if (!representation) {\n            return null;\n        }\n\n        let segment = null;\n        let found = false;\n\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n            if (found || lastSegmentTime < 0) {\n                let media = base.media;\n                let mediaRange = frag.mediaRange;\n\n                if (list) {\n                    media = list[i].media || '';\n                    mediaRange = list[i].mediaRange;\n                }\n\n                segment = getTimeBasedSegment(\n                    timelineConverter,\n                    isDynamic,\n                    representation,\n                    time,\n                    frag.d,\n                    fTimescale,\n                    media,\n                    mediaRange,\n                    availabilityIdx,\n                    frag.tManifest);\n\n                return true;\n            } else if (scaledTime >= lastSegmentTime - frag.d * 0.5 / fTimescale) { // same logic, if deviation is\n                // 50% of segment duration, segment is found if scaledTime is greater than or equal to (startTime of previous segment - half of the previous segment duration)\n                found = true;\n            }\n\n            return false;\n        });\n\n        return segment;\n    }\n\n    function getSegmentByTime(representation, requestedTime) {\n        checkConfig();\n\n        if (!representation) {\n            return null;\n        }\n\n        if (requestedTime === undefined) {\n            requestedTime = null;\n        }\n\n        let segment = null;\n        const requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\n\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n            // In some cases when requiredMediaTime = actual end time of the last segment\n            // it is possible that this time a bit exceeds the declared end time of the last segment.\n            // in this case we still need to include the last segment in the segment list.\n            if (requiredMediaTime < (scaledTime + (frag.d / fTimescale))) {\n                let media = base.media;\n                let mediaRange = frag.mediaRange;\n\n                if (list) {\n                    media = list[i].media || '';\n                    mediaRange = list[i].mediaRange;\n                }\n\n                segment = getTimeBasedSegment(\n                    timelineConverter,\n                    isDynamic,\n                    representation,\n                    time,\n                    frag.d,\n                    fTimescale,\n                    media,\n                    mediaRange,\n                    availabilityIdx,\n                    frag.tManifest);\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return segment;\n    }\n\n\n    instance = {\n        getSegmentByIndex: getSegmentByIndex,\n        getSegmentByTime: getSegmentByTime\n    };\n\n    return instance;\n}\n\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\nconst factory = FactoryMaker.getClassFactory(TimelineSegmentsGetter);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}