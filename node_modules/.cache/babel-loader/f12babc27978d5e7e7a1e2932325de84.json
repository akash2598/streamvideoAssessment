{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _XHRLoader = require('./XHRLoader');\n\nvar _XHRLoader2 = _interopRequireDefault(_XHRLoader);\n\nvar _FetchLoader = require('./FetchLoader');\n\nvar _FetchLoader2 = _interopRequireDefault(_FetchLoader);\n\nvar _HTTPRequest = require('../vo/metrics/HTTPRequest');\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashJSError = require('../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _CmcdModel = require('../models/CmcdModel');\n\nvar _CmcdModel2 = _interopRequireDefault(_CmcdModel);\n\nvar _Utils = require('../../core/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _Settings = require('../../core/Settings');\n\nvar _Settings2 = _interopRequireDefault(_Settings);\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* @module HTTPLoader\n* @ignore\n* @description Manages download of resources via HTTP.\n* @param {Object} cfg - dependancies from parent\n*/\n\n\nfunction HTTPLoader(cfg) {\n  cfg = cfg || {};\n  var context = this.context;\n  var errHandler = cfg.errHandler;\n  var dashMetrics = cfg.dashMetrics;\n  var mediaPlayerModel = cfg.mediaPlayerModel;\n  var requestModifier = cfg.requestModifier;\n  var boxParser = cfg.boxParser;\n  var useFetch = cfg.useFetch || false;\n  var errors = cfg.errors;\n  var requestTimeout = cfg.requestTimeout || 0;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var settings = (0, _Settings2.default)(context).getInstance();\n  var instance = void 0,\n      requests = void 0,\n      delayedRequests = void 0,\n      retryRequests = void 0,\n      downloadErrorToRequestTypeMap = void 0,\n      cmcdModel = void 0,\n      logger = void 0;\n\n  function setup() {\n    var _downloadErrorToReque;\n\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n    requests = [];\n    delayedRequests = [];\n    retryRequests = [];\n    cmcdModel = (0, _CmcdModel2.default)(context).getInstance();\n    downloadErrorToRequestTypeMap = (_downloadErrorToReque = {}, _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.MPD_TYPE, errors.DOWNLOAD_ERROR_ID_MANIFEST_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.XLINK_EXPANSION_TYPE, errors.DOWNLOAD_ERROR_ID_XLINK_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.INIT_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.INDEX_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _defineProperty(_downloadErrorToReque, _HTTPRequest.HTTPRequest.OTHER_TYPE, errors.DOWNLOAD_ERROR_ID_CONTENT_CODE), _downloadErrorToReque);\n  }\n\n  function internalLoad(config, remainingAttempts) {\n    var request = config.request;\n    var traces = [];\n    var firstProgress = true;\n    var needFailureReport = true;\n    var requestStartTime = new Date();\n    var lastTraceTime = requestStartTime;\n    var lastTraceReceivedCount = 0;\n    var httpRequest = void 0;\n\n    if (!requestModifier || !dashMetrics || !errHandler) {\n      throw new Error('config object is not correct or missing');\n    }\n\n    var handleLoaded = function handleLoaded(success) {\n      needFailureReport = false;\n      request.requestStartDate = requestStartTime;\n      request.requestEndDate = new Date();\n      request.firstByteDate = request.firstByteDate || requestStartTime;\n\n      if (!request.checkExistenceOnly) {\n        dashMetrics.addHttpRequest(request, httpRequest.response ? httpRequest.response.responseURL : null, httpRequest.response ? httpRequest.response.status : null, httpRequest.response && httpRequest.response.getAllResponseHeaders ? httpRequest.response.getAllResponseHeaders() : httpRequest.response ? httpRequest.response.responseHeaders : [], success ? traces : null);\n\n        if (request.type === _HTTPRequest.HTTPRequest.MPD_TYPE) {\n          dashMetrics.addManifestUpdate(request);\n        }\n      }\n    };\n\n    var onloadend = function onloadend() {\n      if (requests.indexOf(httpRequest) === -1) {\n        return;\n      } else {\n        requests.splice(requests.indexOf(httpRequest), 1);\n      }\n\n      if (needFailureReport) {\n        handleLoaded(false);\n\n        if (remainingAttempts > 0) {\n          // If we get a 404 to a media segment we should check the client clock again and perform a UTC sync in the background.\n          try {\n            if (settings.get().streaming.utcSynchronization.enableBackgroundSyncAfterSegmentDownloadError && request.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE) {\n              // Only trigger a sync if the loading failed for the first time\n              var initialNumberOfAttempts = mediaPlayerModel.getRetryAttemptsForType(_HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE);\n\n              if (initialNumberOfAttempts === remainingAttempts) {\n                eventBus.trigger(_Events2.default.ATTEMPT_BACKGROUND_SYNC);\n              }\n            }\n          } catch (e) {}\n\n          remainingAttempts--;\n          var retryRequest = {\n            config: config\n          };\n          retryRequests.push(retryRequest);\n          retryRequest.timeout = setTimeout(function () {\n            if (retryRequests.indexOf(retryRequest) === -1) {\n              return;\n            } else {\n              retryRequests.splice(retryRequests.indexOf(retryRequest), 1);\n            }\n\n            internalLoad(config, remainingAttempts);\n          }, mediaPlayerModel.getRetryIntervalsForType(request.type));\n        } else {\n          if (request.type === _HTTPRequest.HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n            return;\n          }\n\n          errHandler.error(new _DashJSError2.default(downloadErrorToRequestTypeMap[request.type], request.url + ' is not available', {\n            request: request,\n            response: httpRequest.response\n          }));\n\n          if (config.error) {\n            config.error(request, 'error', httpRequest.response.statusText);\n          }\n\n          if (config.complete) {\n            config.complete(request, httpRequest.response.statusText);\n          }\n        }\n      }\n    };\n\n    var progress = function progress(event) {\n      var currentTime = new Date();\n\n      if (firstProgress) {\n        firstProgress = false;\n\n        if (!event.lengthComputable || event.lengthComputable && event.total !== event.loaded) {\n          request.firstByteDate = currentTime;\n        }\n      }\n\n      if (event.lengthComputable) {\n        request.bytesLoaded = event.loaded;\n        request.bytesTotal = event.total;\n      }\n\n      if (!event.noTrace) {\n        traces.push({\n          s: lastTraceTime,\n          d: event.time ? event.time : currentTime.getTime() - lastTraceTime.getTime(),\n          b: [event.loaded ? event.loaded - lastTraceReceivedCount : 0]\n        });\n        lastTraceTime = currentTime;\n        lastTraceReceivedCount = event.loaded;\n      }\n\n      if (config.progress && event) {\n        config.progress(event);\n      }\n    };\n\n    var onload = function onload() {\n      if (httpRequest.response.status >= 200 && httpRequest.response.status <= 299) {\n        handleLoaded(true);\n\n        if (config.success) {\n          config.success(httpRequest.response.response, httpRequest.response.statusText, httpRequest.response.responseURL);\n        }\n\n        if (config.complete) {\n          config.complete(request, httpRequest.response.statusText);\n        }\n      }\n    };\n\n    var onabort = function onabort() {\n      if (config.abort) {\n        config.abort(request);\n      }\n    };\n\n    var ontimeout = function ontimeout(event) {\n      var timeoutMessage = void 0;\n\n      if (event.lengthComputable) {\n        var percentageComplete = event.loaded / event.total * 100;\n        timeoutMessage = 'Request timeout: loaded: ' + event.loaded + ', out of: ' + event.total + ' : ' + percentageComplete.toFixed(3) + '% Completed';\n      } else {\n        timeoutMessage = 'Request timeout: non-computable download size';\n      }\n\n      logger.warn(timeoutMessage);\n    };\n\n    var loader = void 0;\n\n    if (useFetch && window.fetch && request.responseType === 'arraybuffer' && request.type === _HTTPRequest.HTTPRequest.MEDIA_SEGMENT_TYPE) {\n      loader = (0, _FetchLoader2.default)(context).create({\n        requestModifier: requestModifier,\n        boxParser: boxParser\n      });\n    } else {\n      loader = (0, _XHRLoader2.default)(context).create({\n        requestModifier: requestModifier\n      });\n    }\n\n    var headers = null;\n    var modifiedUrl = requestModifier.modifyRequestURL(request.url);\n\n    if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n      var cmcdMode = settings.get().streaming.cmcd.mode;\n\n      if (cmcdMode === _Constants2.default.CMCD_MODE_QUERY) {\n        var additionalQueryParameter = _getAdditionalQueryParameter(request);\n\n        modifiedUrl = _Utils2.default.addAditionalQueryParameterToUrl(modifiedUrl, additionalQueryParameter);\n      } else if (cmcdMode === _Constants2.default.CMCD_MODE_HEADER) {\n        headers = cmcdModel.getHeaderParameters(request);\n      }\n    }\n\n    var verb = request.checkExistenceOnly ? _HTTPRequest.HTTPRequest.HEAD : _HTTPRequest.HTTPRequest.GET;\n    var withCredentials = mediaPlayerModel.getXHRWithCredentialsForType(request.type);\n    httpRequest = {\n      url: modifiedUrl,\n      method: verb,\n      withCredentials: withCredentials,\n      request: request,\n      onload: onload,\n      onend: onloadend,\n      onerror: onloadend,\n      progress: progress,\n      onabort: onabort,\n      ontimeout: ontimeout,\n      loader: loader,\n      timeout: requestTimeout,\n      headers: headers\n    }; // Adds the ability to delay single fragment loading time to control buffer.\n\n    var now = new Date().getTime();\n\n    if (isNaN(request.delayLoadingTime) || now >= request.delayLoadingTime) {\n      // no delay - just send\n      requests.push(httpRequest);\n      loader.load(httpRequest);\n    } else {\n      // delay\n      var delayedRequest = {\n        httpRequest: httpRequest\n      };\n      delayedRequests.push(delayedRequest);\n      delayedRequest.delayTimeout = setTimeout(function () {\n        if (delayedRequests.indexOf(delayedRequest) === -1) {\n          return;\n        } else {\n          delayedRequests.splice(delayedRequests.indexOf(delayedRequest), 1);\n        }\n\n        try {\n          requestStartTime = new Date();\n          lastTraceTime = requestStartTime;\n          requests.push(delayedRequest.httpRequest);\n          loader.load(delayedRequest.httpRequest);\n        } catch (e) {\n          delayedRequest.httpRequest.onerror();\n        }\n      }, request.delayLoadingTime - now);\n    }\n  }\n\n  function _getAdditionalQueryParameter(request) {\n    try {\n      var additionalQueryParameter = [];\n      var cmcdQueryParameter = cmcdModel.getQueryParameter(request);\n\n      if (cmcdQueryParameter) {\n        additionalQueryParameter.push(cmcdQueryParameter);\n      }\n\n      return additionalQueryParameter;\n    } catch (e) {\n      return [];\n    }\n  }\n  /**\n  * Initiates a download of the resource described by config.request\n  * @param {Object} config - contains request (FragmentRequest or derived type), and callbacks\n  * @memberof module:HTTPLoader\n  * @instance\n  */\n\n\n  function load(config) {\n    if (config.request) {\n      internalLoad(config, mediaPlayerModel.getRetryAttemptsForType(config.request.type));\n    } else {\n      if (config.error) {\n        config.error(config.request, 'error');\n      }\n    }\n  }\n  /**\n  * Aborts any inflight downloads\n  * @memberof module:HTTPLoader\n  * @instance\n  */\n\n\n  function abort() {\n    retryRequests.forEach(function (t) {\n      clearTimeout(t.timeout); // abort request in order to trigger LOADING_ABANDONED event\n\n      if (t.config.request && t.config.abort) {\n        t.config.abort(t.config.request);\n      }\n    });\n    retryRequests = [];\n    delayedRequests.forEach(function (x) {\n      return clearTimeout(x.delayTimeout);\n    });\n    delayedRequests = [];\n    requests.forEach(function (x) {\n      // MSS patch: ignore FragmentInfo requests\n      if (x.request.type === _HTTPRequest.HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n        return;\n      } // abort will trigger onloadend which we don't want\n      // when deliberately aborting inflight requests -\n      // set them to undefined so they are not called\n\n\n      x.onloadend = x.onerror = x.onprogress = undefined;\n      x.loader.abort(x);\n    });\n    requests = [];\n  }\n\n  instance = {\n    load: load,\n    abort: abort\n  };\n  setup();\n  return instance;\n}\n\nHTTPLoader.__dashjs_factory_name = 'HTTPLoader';\n\nvar factory = _FactoryMaker2.default.getClassFactory(HTTPLoader);\n\nexports.default = factory;","map":{"version":3,"sources":["../../../../../src/streaming/net/HTTPLoader.js"],"names":["cfg","context","errHandler","dashMetrics","mediaPlayerModel","requestModifier","boxParser","useFetch","errors","requestTimeout","eventBus","settings","instance","requests","delayedRequests","retryRequests","downloadErrorToRequestTypeMap","cmcdModel","logger","HTTPRequest","request","config","traces","firstProgress","needFailureReport","requestStartTime","lastTraceTime","lastTraceReceivedCount","httpRequest","handleLoaded","success","onloadend","remainingAttempts","initialNumberOfAttempts","Events","retryRequest","setTimeout","internalLoad","DashJSError","response","progress","currentTime","event","s","d","b","onload","onabort","ontimeout","timeoutMessage","percentageComplete","loader","window","headers","modifiedUrl","cmcdMode","Constants","additionalQueryParameter","_getAdditionalQueryParameter","Utils","verb","withCredentials","url","method","onend","onerror","timeout","now","isNaN","delayedRequest","cmcdQueryParameter","clearTimeout","t","x","load","abort","setup","HTTPLoader","factory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport XHRLoader from './XHRLoader';\nimport FetchLoader from './FetchLoader';\nimport {HTTPRequest} from '../vo/metrics/HTTPRequest';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport DashJSError from '../vo/DashJSError';\nimport CmcdModel from '../models/CmcdModel';\nimport Utils from '../../core/Utils';\nimport Debug from '../../core/Debug';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport Settings from '../../core/Settings';\nimport Constants from '../constants/Constants';\n\n/**\n * @module HTTPLoader\n * @ignore\n * @description Manages download of resources via HTTP.\n * @param {Object} cfg - dependancies from parent\n */\nfunction HTTPLoader(cfg) {\n\n    cfg = cfg || {};\n\n    const context = this.context;\n    const errHandler = cfg.errHandler;\n    const dashMetrics = cfg.dashMetrics;\n    const mediaPlayerModel = cfg.mediaPlayerModel;\n    const requestModifier = cfg.requestModifier;\n    const boxParser = cfg.boxParser;\n    const useFetch = cfg.useFetch || false;\n    const errors = cfg.errors;\n    const requestTimeout = cfg.requestTimeout || 0;\n    const eventBus = EventBus(context).getInstance();\n    const settings = Settings(context).getInstance();\n\n    let instance,\n        requests,\n        delayedRequests,\n        retryRequests,\n        downloadErrorToRequestTypeMap,\n        cmcdModel,\n        logger;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        requests = [];\n        delayedRequests = [];\n        retryRequests = [];\n        cmcdModel = CmcdModel(context).getInstance();\n\n        downloadErrorToRequestTypeMap = {\n            [HTTPRequest.MPD_TYPE]: errors.DOWNLOAD_ERROR_ID_MANIFEST_CODE,\n            [HTTPRequest.XLINK_EXPANSION_TYPE]: errors.DOWNLOAD_ERROR_ID_XLINK_CODE,\n            [HTTPRequest.INIT_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE,\n            [HTTPRequest.MEDIA_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE,\n            [HTTPRequest.INDEX_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE,\n            [HTTPRequest.BITSTREAM_SWITCHING_SEGMENT_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE,\n            [HTTPRequest.OTHER_TYPE]: errors.DOWNLOAD_ERROR_ID_CONTENT_CODE\n        };\n    }\n\n    function internalLoad(config, remainingAttempts) {\n        const request = config.request;\n        const traces = [];\n        let firstProgress = true;\n        let needFailureReport = true;\n        let requestStartTime = new Date();\n        let lastTraceTime = requestStartTime;\n        let lastTraceReceivedCount = 0;\n        let httpRequest;\n\n        if (!requestModifier || !dashMetrics || !errHandler) {\n            throw new Error('config object is not correct or missing');\n        }\n\n        const handleLoaded = function (success) {\n            needFailureReport = false;\n\n            request.requestStartDate = requestStartTime;\n            request.requestEndDate = new Date();\n            request.firstByteDate = request.firstByteDate || requestStartTime;\n\n            if (!request.checkExistenceOnly) {\n                dashMetrics.addHttpRequest(request, httpRequest.response ? httpRequest.response.responseURL : null,\n                    httpRequest.response ? httpRequest.response.status : null,\n                    httpRequest.response && httpRequest.response.getAllResponseHeaders ? httpRequest.response.getAllResponseHeaders() :\n                        httpRequest.response ? httpRequest.response.responseHeaders : [],\n                    success ? traces : null);\n\n                if (request.type === HTTPRequest.MPD_TYPE) {\n                    dashMetrics.addManifestUpdate(request);\n                }\n            }\n        };\n\n        const onloadend = function () {\n            if (requests.indexOf(httpRequest) === -1) {\n                return;\n            } else {\n                requests.splice(requests.indexOf(httpRequest), 1);\n            }\n\n            if (needFailureReport) {\n                handleLoaded(false);\n\n                if (remainingAttempts > 0) {\n\n                    // If we get a 404 to a media segment we should check the client clock again and perform a UTC sync in the background.\n                    try {\n                        if (settings.get().streaming.utcSynchronization.enableBackgroundSyncAfterSegmentDownloadError && request.type === HTTPRequest.MEDIA_SEGMENT_TYPE) {\n                            // Only trigger a sync if the loading failed for the first time\n                            const initialNumberOfAttempts = mediaPlayerModel.getRetryAttemptsForType(HTTPRequest.MEDIA_SEGMENT_TYPE);\n                            if (initialNumberOfAttempts === remainingAttempts) {\n                                eventBus.trigger(Events.ATTEMPT_BACKGROUND_SYNC);\n                            }\n                        }\n                    } catch (e) {\n\n                    }\n\n                    remainingAttempts--;\n                    let retryRequest = { config: config };\n                    retryRequests.push(retryRequest);\n                    retryRequest.timeout = setTimeout(function () {\n                        if (retryRequests.indexOf(retryRequest) === -1) {\n                            return;\n                        } else {\n                            retryRequests.splice(retryRequests.indexOf(retryRequest), 1);\n                        }\n                        internalLoad(config, remainingAttempts);\n                    }, mediaPlayerModel.getRetryIntervalsForType(request.type));\n                } else {\n                    if (request.type === HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n                        return;\n                    }\n\n                    errHandler.error(new DashJSError(downloadErrorToRequestTypeMap[request.type], request.url + ' is not available', {\n                        request: request,\n                        response: httpRequest.response\n                    }));\n\n                    if (config.error) {\n                        config.error(request, 'error', httpRequest.response.statusText);\n                    }\n\n                    if (config.complete) {\n                        config.complete(request, httpRequest.response.statusText);\n                    }\n                }\n            }\n        };\n\n        const progress = function (event) {\n            const currentTime = new Date();\n\n            if (firstProgress) {\n                firstProgress = false;\n                if (!event.lengthComputable ||\n                    (event.lengthComputable && event.total !== event.loaded)) {\n                    request.firstByteDate = currentTime;\n                }\n            }\n\n            if (event.lengthComputable) {\n                request.bytesLoaded = event.loaded;\n                request.bytesTotal = event.total;\n            }\n\n            if (!event.noTrace) {\n                traces.push({\n                    s: lastTraceTime,\n                    d: event.time ? event.time : currentTime.getTime() - lastTraceTime.getTime(),\n                    b: [event.loaded ? event.loaded - lastTraceReceivedCount : 0]\n                });\n\n                lastTraceTime = currentTime;\n                lastTraceReceivedCount = event.loaded;\n            }\n\n            if (config.progress && event) {\n                config.progress(event);\n            }\n        };\n\n        const onload = function () {\n            if (httpRequest.response.status >= 200 && httpRequest.response.status <= 299) {\n                handleLoaded(true);\n\n                if (config.success) {\n                    config.success(httpRequest.response.response, httpRequest.response.statusText, httpRequest.response.responseURL);\n                }\n\n                if (config.complete) {\n                    config.complete(request, httpRequest.response.statusText);\n                }\n            }\n        };\n\n        const onabort = function () {\n            if (config.abort) {\n                config.abort(request);\n            }\n        };\n\n        const ontimeout = function (event) {\n            let timeoutMessage;\n            if (event.lengthComputable) {\n                let percentageComplete = (event.loaded / event.total) * 100;\n                timeoutMessage = 'Request timeout: loaded: ' + event.loaded + ', out of: ' + event.total + ' : ' + percentageComplete.toFixed(3) + '% Completed';\n            } else {\n                timeoutMessage = 'Request timeout: non-computable download size';\n            }\n            logger.warn(timeoutMessage);\n        };\n\n        let loader;\n        if (useFetch && window.fetch && request.responseType === 'arraybuffer' && request.type === HTTPRequest.MEDIA_SEGMENT_TYPE) {\n            loader = FetchLoader(context).create({\n                requestModifier: requestModifier,\n                boxParser: boxParser\n            });\n        } else {\n            loader = XHRLoader(context).create({\n                requestModifier: requestModifier\n            });\n        }\n\n        let headers = null;\n        let modifiedUrl = requestModifier.modifyRequestURL(request.url);\n        if (settings.get().streaming.cmcd && settings.get().streaming.cmcd.enabled) {\n            const cmcdMode = settings.get().streaming.cmcd.mode;\n            if (cmcdMode === Constants.CMCD_MODE_QUERY) {\n                const additionalQueryParameter = _getAdditionalQueryParameter(request);\n                modifiedUrl = Utils.addAditionalQueryParameterToUrl(modifiedUrl, additionalQueryParameter);\n            }\n            else if (cmcdMode === Constants.CMCD_MODE_HEADER) {\n                headers = cmcdModel.getHeaderParameters(request);\n            }\n        }\n        const verb = request.checkExistenceOnly ? HTTPRequest.HEAD : HTTPRequest.GET;\n        const withCredentials = mediaPlayerModel.getXHRWithCredentialsForType(request.type);\n\n\n        httpRequest = {\n            url: modifiedUrl,\n            method: verb,\n            withCredentials: withCredentials,\n            request: request,\n            onload: onload,\n            onend: onloadend,\n            onerror: onloadend,\n            progress: progress,\n            onabort: onabort,\n            ontimeout: ontimeout,\n            loader: loader,\n            timeout: requestTimeout,\n            headers: headers\n        };\n\n        // Adds the ability to delay single fragment loading time to control buffer.\n        let now = new Date().getTime();\n        if (isNaN(request.delayLoadingTime) || now >= request.delayLoadingTime) {\n            // no delay - just send\n            requests.push(httpRequest);\n            loader.load(httpRequest);\n        } else {\n            // delay\n            let delayedRequest = { httpRequest: httpRequest };\n            delayedRequests.push(delayedRequest);\n            delayedRequest.delayTimeout = setTimeout(function () {\n                if (delayedRequests.indexOf(delayedRequest) === -1) {\n                    return;\n                } else {\n                    delayedRequests.splice(delayedRequests.indexOf(delayedRequest), 1);\n                }\n                try {\n                    requestStartTime = new Date();\n                    lastTraceTime = requestStartTime;\n                    requests.push(delayedRequest.httpRequest);\n                    loader.load(delayedRequest.httpRequest);\n                } catch (e) {\n                    delayedRequest.httpRequest.onerror();\n                }\n            }, (request.delayLoadingTime - now));\n        }\n    }\n\n    function _getAdditionalQueryParameter(request) {\n        try {\n            const additionalQueryParameter = [];\n            const cmcdQueryParameter = cmcdModel.getQueryParameter(request);\n\n            if (cmcdQueryParameter) {\n                additionalQueryParameter.push(cmcdQueryParameter);\n            }\n\n            return additionalQueryParameter;\n        } catch (e) {\n            return [];\n        }\n    }\n\n    /**\n     * Initiates a download of the resource described by config.request\n     * @param {Object} config - contains request (FragmentRequest or derived type), and callbacks\n     * @memberof module:HTTPLoader\n     * @instance\n     */\n    function load(config) {\n        if (config.request) {\n            internalLoad(\n                config,\n                mediaPlayerModel.getRetryAttemptsForType(\n                    config.request.type\n                )\n            );\n        } else {\n            if (config.error) {\n                config.error(config.request, 'error');\n            }\n        }\n    }\n\n    /**\n     * Aborts any inflight downloads\n     * @memberof module:HTTPLoader\n     * @instance\n     */\n    function abort() {\n        retryRequests.forEach(t => {\n            clearTimeout(t.timeout);\n            // abort request in order to trigger LOADING_ABANDONED event\n            if (t.config.request && t.config.abort) {\n                t.config.abort(t.config.request);\n            }\n        });\n        retryRequests = [];\n\n        delayedRequests.forEach(x => clearTimeout(x.delayTimeout));\n        delayedRequests = [];\n\n        requests.forEach(x => {\n            // MSS patch: ignore FragmentInfo requests\n            if (x.request.type === HTTPRequest.MSS_FRAGMENT_INFO_SEGMENT_TYPE) {\n                return;\n            }\n\n            // abort will trigger onloadend which we don't want\n            // when deliberately aborting inflight requests -\n            // set them to undefined so they are not called\n            x.onloadend = x.onerror = x.onprogress = undefined;\n            x.loader.abort(x);\n        });\n        requests = [];\n    }\n\n    instance = {\n        load: load,\n        abort: abort\n    };\n\n    setup();\n\n    return instance;\n}\n\nHTTPLoader.__dashjs_factory_name = 'HTTPLoader';\n\nconst factory = FactoryMaker.getClassFactory(HTTPLoader);\nexport default factory;\n"]},"metadata":{},"sourceType":"script"}