{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _Events = require('../../core/events/Events');\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _DashConstants = require('../constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _DashManifestModel = require('../models/DashManifestModel');\n\nvar _DashManifestModel2 = _interopRequireDefault(_DashManifestModel);\n\nvar _Settings = require('../../core/Settings');\n\nvar _Settings2 = _interopRequireDefault(_Settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nfunction TimelineConverter() {\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var settings = (0, _Settings2.default)(context).getInstance();\n  var instance = void 0,\n      dashManifestModel = void 0,\n      clientServerTimeShift = void 0,\n      isClientServerTimeSyncCompleted = void 0,\n      expectedLiveEdge = void 0;\n\n  function setup() {\n    dashManifestModel = (0, _DashManifestModel2.default)(context).getInstance();\n    reset();\n  }\n\n  function initialize() {\n    resetInitialSettings();\n    eventBus.on(_Events2.default.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n  }\n\n  function getClientTimeOffset() {\n    return clientServerTimeShift;\n  }\n\n  function setClientTimeOffset(value) {\n    clientServerTimeShift = value;\n  }\n\n  function getExpectedLiveEdge() {\n    return expectedLiveEdge;\n  }\n\n  function setExpectedLiveEdge(value) {\n    expectedLiveEdge = value;\n  }\n\n  function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n    var availabilityTime = NaN;\n\n    if (calculateEnd) {\n      //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n      // to be available for a Media Presentation with type 'dynamic'.\n      // When not present, the value is infinite.\n      if (isDynamic && mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY) {\n        availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime + mpd.timeShiftBufferDepth) * 1000);\n      } else {\n        availabilityTime = mpd.availabilityEndTime;\n      }\n    } else {\n      if (isDynamic) {\n        availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n      } else {\n        // in static mpd, all segments are available at the same time\n        availabilityTime = mpd.availabilityStartTime;\n      }\n    }\n\n    return availabilityTime;\n  }\n\n  function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n    return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n  }\n\n  function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n    return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n  }\n\n  function calcPresentationTimeFromWallTime(wallTime, period) {\n    return (wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000;\n  }\n\n  function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n    var periodStart = representation.adaptation.period.start;\n    var presentationOffset = representation.presentationTimeOffset;\n    return mediaTime + (periodStart - presentationOffset);\n  }\n\n  function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n    var periodStart = representation.adaptation.period.start;\n    var presentationOffset = representation.presentationTimeOffset;\n    return presentationTime - periodStart + presentationOffset;\n  }\n\n  function calcWallTimeForSegment(segment, isDynamic) {\n    var suggestedPresentationDelay = void 0,\n        displayStartTime = void 0,\n        wallTime = void 0;\n\n    if (isDynamic) {\n      suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n      displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n      wallTime = new Date(segment.availabilityStartTime.getTime() + displayStartTime * 1000);\n    }\n\n    return wallTime;\n  }\n\n  function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n    // Static Range Finder\n    var voPeriod = voRepresentation.adaptation.period;\n    var range = {\n      start: voPeriod.start,\n      end: voPeriod.start + voPeriod.duration\n    };\n    if (!isDynamic) return range;\n\n    if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n      return voRepresentation.segmentAvailabilityRange;\n    } // Dynamic Range Finder\n\n\n    var d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0); // Specific use case of SegmentTimeline without timeShiftBufferDepth\n\n    if (voRepresentation.segmentInfoType === _DashConstants2.default.SEGMENT_TIMELINE && settings.get().streaming.calcSegmentAvailabilityRangeFromTimeline) {\n      return calcSegmentAvailabilityRangeFromTimeline(voRepresentation);\n    }\n\n    var now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n    var periodEnd = voPeriod.start + voPeriod.duration;\n    range.start = Math.max(now - voPeriod.mpd.timeShiftBufferDepth, voPeriod.start);\n    var endOffset = voRepresentation.availabilityTimeOffset !== undefined && voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n    range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n    return range;\n  }\n\n  function calcSegmentAvailabilityRangeFromTimeline(voRepresentation) {\n    var adaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n    var representation = dashManifestModel.getRepresentationFor(voRepresentation.index, adaptation);\n    var timeline = representation.SegmentTemplate.SegmentTimeline;\n    var timescale = representation.SegmentTemplate.timescale;\n    var segments = timeline.S_asArray;\n    var range = {\n      start: 0,\n      end: 0\n    };\n    var d = 0;\n    var segment = void 0,\n        repeat = void 0,\n        i = void 0,\n        len = void 0;\n    range.start = calcPresentationTimeFromMediaTime(segments[0].t / timescale, voRepresentation);\n\n    for (i = 0, len = segments.length; i < len; i++) {\n      segment = segments[i];\n      repeat = 0;\n\n      if (segment.hasOwnProperty('r')) {\n        repeat = segment.r;\n      }\n\n      d += segment.d / timescale * (1 + repeat);\n    }\n\n    range.end = range.start + d;\n    return range;\n  }\n\n  function getPeriodEnd(voRepresentation, isDynamic) {\n    // Static Range Finder\n    var voPeriod = voRepresentation.adaptation.period;\n\n    if (!isDynamic) {\n      return voPeriod.start + voPeriod.duration;\n    }\n\n    if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n      return voRepresentation.segmentAvailabilityRange;\n    } // Dynamic Range Finder\n\n\n    var d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n    var now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n    var periodEnd = voPeriod.start + voPeriod.duration;\n    var endOffset = voRepresentation.availabilityTimeOffset !== undefined && voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n    return Math.min(now - endOffset, periodEnd);\n  }\n\n  function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n    var periodStartTime = representation.adaptation.period.start;\n    return mpdRelativeTime - periodStartTime;\n  }\n  /*\n  * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n  * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n  * FYI StreamController's onManifestUpdated entry point to timeSync\n  * */\n\n\n  function _onUpdateTimeSyncOffset(e) {\n    if (e.offset !== undefined) {\n      setClientTimeOffset(e.offset / 1000);\n      isClientServerTimeSyncCompleted = true;\n    }\n  }\n\n  function resetInitialSettings() {\n    clientServerTimeShift = 0;\n    isClientServerTimeSyncCompleted = false;\n    expectedLiveEdge = NaN;\n  }\n\n  function reset() {\n    eventBus.off(_Events2.default.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n    resetInitialSettings();\n  }\n\n  instance = {\n    initialize: initialize,\n    getClientTimeOffset: getClientTimeOffset,\n    setClientTimeOffset: setClientTimeOffset,\n    getExpectedLiveEdge: getExpectedLiveEdge,\n    setExpectedLiveEdge: setExpectedLiveEdge,\n    calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n    calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n    calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n    calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n    calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n    calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n    calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n    getPeriodEnd: getPeriodEnd,\n    calcWallTimeForSegment: calcWallTimeForSegment,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexports.default = _FactoryMaker2.default.getSingletonFactory(TimelineConverter);","map":{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":["context","eventBus","settings","instance","dashManifestModel","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","reset","resetInitialSettings","Events","availabilityTime","isDynamic","mpd","Number","presentationTime","calcAvailabilityTimeFromPresentationTime","wallTime","period","periodStart","representation","presentationOffset","mediaTime","suggestedPresentationDelay","displayStartTime","segment","voPeriod","voRepresentation","range","start","end","d","DashConstants","calcSegmentAvailabilityRangeFromTimeline","now","calcPresentationTimeFromWallTime","periodEnd","Math","endOffset","adaptation","timeline","timescale","segments","repeat","i","len","calcPresentationTimeFromMediaTime","periodStartTime","mpdRelativeTime","e","setClientTimeOffset","initialize","getClientTimeOffset","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityStartTimeFromPresentationTime","calcAvailabilityEndTimeFromPresentationTime","calcPeriodRelativeTimeFromMpdRelativeTime","calcMediaTimeFromPresentationTime","calcSegmentAvailabilityRange","getPeriodEnd","calcWallTimeForSegment","setup","TimelineConverter","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport DashConstants from '../constants/DashConstants';\nimport DashManifestModel from '../models/DashManifestModel';\nimport Settings from '../../core/Settings';\n\nfunction TimelineConverter() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const settings = Settings(context).getInstance();\n\n    let instance,\n        dashManifestModel,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function setup() {\n        dashManifestModel = DashManifestModel(context).getInstance();\n        reset();\n    }\n\n    function initialize() {\n        resetInitialSettings();\n        eventBus.on(Events.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = {start: voPeriod.start, end: voPeriod.start + voPeriod.duration};\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n\n        // Specific use case of SegmentTimeline without timeShiftBufferDepth\n        if (voRepresentation.segmentInfoType === DashConstants.SEGMENT_TIMELINE && settings.get().streaming.calcSegmentAvailabilityRangeFromTimeline) {\n            return calcSegmentAvailabilityRangeFromTimeline(voRepresentation);\n        }\n\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n\n        return range;\n    }\n\n    function calcSegmentAvailabilityRangeFromTimeline(voRepresentation) {\n        const adaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n        const representation = dashManifestModel.getRepresentationFor(voRepresentation.index, adaptation);\n        const timeline = representation.SegmentTemplate.SegmentTimeline;\n        const timescale = representation.SegmentTemplate.timescale;\n        const segments = timeline.S_asArray;\n        const range = {start: 0, end: 0};\n        let d = 0;\n        let segment,\n            repeat,\n            i,\n            len;\n\n        range.start = calcPresentationTimeFromMediaTime(segments[0].t / timescale, voRepresentation);\n\n        for (i = 0, len = segments.length; i < len; i++) {\n            segment = segments[i];\n            repeat = 0;\n            if (segment.hasOwnProperty('r')) {\n                repeat = segment.r;\n            }\n            d += (segment.d / timescale) * (1 + repeat);\n        }\n\n        range.end = range.start + d;\n\n        return range;\n    }\n\n    function getPeriodEnd(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        if (!isDynamic) {\n            return voPeriod.start + voPeriod.duration;\n        }\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        return Math.min(now - endOffset, periodEnd);\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function _onUpdateTimeSyncOffset(e) {\n        if (e.offset !== undefined) {\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n        }\n    }\n\n    function resetInitialSettings() {\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    function reset() {\n        eventBus.off(Events.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        getPeriodEnd: getPeriodEnd,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);\n"]},"metadata":{},"sourceType":"script"}