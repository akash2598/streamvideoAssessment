{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // throughput generally stored in kbit/s\n// latency generally stored in ms\n\n/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2017, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nfunction ThroughputHistory(config) {\n  config = config || {}; // sliding window constants\n\n  var MAX_MEASUREMENTS_TO_KEEP = 20;\n  var AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE = 3;\n  var AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD = 4;\n  var AVERAGE_LATENCY_SAMPLE_AMOUNT = 4;\n  var THROUGHPUT_DECREASE_SCALE = 1.3;\n  var THROUGHPUT_INCREASE_SCALE = 1.3; // EWMA constants\n\n  var EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS = 8;\n  var EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS = 3;\n  var EWMA_LATENCY_SLOW_HALF_LIFE_COUNT = 2;\n  var EWMA_LATENCY_FAST_HALF_LIFE_COUNT = 1;\n  var settings = config.settings;\n  var throughputDict = void 0,\n      latencyDict = void 0,\n      ewmaThroughputDict = void 0,\n      ewmaLatencyDict = void 0,\n      ewmaHalfLife = void 0;\n\n  function setup() {\n    ewmaHalfLife = {\n      throughputHalfLife: {\n        fast: EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS,\n        slow: EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS\n      },\n      latencyHalfLife: {\n        fast: EWMA_LATENCY_FAST_HALF_LIFE_COUNT,\n        slow: EWMA_LATENCY_SLOW_HALF_LIFE_COUNT\n      }\n    };\n    reset();\n  }\n\n  function isCachedResponse(mediaType, latencyMs, downloadTimeMs) {\n    if (mediaType === _Constants2.default.VIDEO) {\n      return downloadTimeMs < settings.get().streaming.cacheLoadThresholds[_Constants2.default.VIDEO];\n    } else if (mediaType === _Constants2.default.AUDIO) {\n      return downloadTimeMs < settings.get().streaming.cacheLoadThresholds[_Constants2.default.AUDIO];\n    }\n  }\n\n  function push(mediaType, httpRequest, useDeadTimeLatency) {\n    if (!httpRequest.trace || !httpRequest.trace.length) {\n      return;\n    }\n\n    var latencyTimeInMilliseconds = httpRequest.tresponse.getTime() - httpRequest.trequest.getTime() || 1;\n    var downloadTimeInMilliseconds = httpRequest._tfinish.getTime() - httpRequest.tresponse.getTime() || 1; //Make sure never 0 we divide by this value. Avoid infinity!\n\n    var downloadBytes = httpRequest.trace.reduce(function (a, b) {\n      return a + b.b[0];\n    }, 0);\n    var throughputMeasureTime = void 0;\n\n    if (settings.get().streaming.lowLatencyEnabled) {\n      throughputMeasureTime = httpRequest.trace.reduce(function (a, b) {\n        return a + b.d;\n      }, 0);\n    } else {\n      throughputMeasureTime = useDeadTimeLatency ? downloadTimeInMilliseconds : latencyTimeInMilliseconds + downloadTimeInMilliseconds;\n    }\n\n    var throughput = Math.round(8 * downloadBytes / throughputMeasureTime); // bits/ms = kbits/s\n\n    checkSettingsForMediaType(mediaType);\n\n    if (isCachedResponse(mediaType, latencyTimeInMilliseconds, downloadTimeInMilliseconds)) {\n      if (throughputDict[mediaType].length > 0 && !throughputDict[mediaType].hasCachedEntries) {\n        // already have some entries which are not cached entries\n        // prevent cached fragment loads from skewing the average values\n        return;\n      } else {\n        // have no entries || have cached entries\n        // no uncached entries yet, rely on cached entries because ABR rules need something to go by\n        throughputDict[mediaType].hasCachedEntries = true;\n      }\n    } else if (throughputDict[mediaType] && throughputDict[mediaType].hasCachedEntries) {\n      // if we are here then we have some entries already, but they are cached, and now we have a new uncached entry\n      clearSettingsForMediaType(mediaType);\n    }\n\n    throughputDict[mediaType].push(throughput);\n\n    if (throughputDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\n      throughputDict[mediaType].shift();\n    }\n\n    latencyDict[mediaType].push(latencyTimeInMilliseconds);\n\n    if (latencyDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\n      latencyDict[mediaType].shift();\n    }\n\n    updateEwmaEstimate(ewmaThroughputDict[mediaType], throughput, 0.001 * downloadTimeInMilliseconds, ewmaHalfLife.throughputHalfLife);\n    updateEwmaEstimate(ewmaLatencyDict[mediaType], latencyTimeInMilliseconds, 1, ewmaHalfLife.latencyHalfLife);\n  }\n\n  function updateEwmaEstimate(ewmaObj, value, weight, halfLife) {\n    // Note about startup:\n    // Estimates start at 0, so early values are underestimated.\n    // This effect is countered in getAverageEwma() by dividing the estimates by:\n    //     1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\n    var fastAlpha = Math.pow(0.5, weight / halfLife.fast);\n    ewmaObj.fastEstimate = (1 - fastAlpha) * value + fastAlpha * ewmaObj.fastEstimate;\n    var slowAlpha = Math.pow(0.5, weight / halfLife.slow);\n    ewmaObj.slowEstimate = (1 - slowAlpha) * value + slowAlpha * ewmaObj.slowEstimate;\n    ewmaObj.totalWeight += weight;\n  }\n\n  function getSampleSize(isThroughput, mediaType, isLive) {\n    var arr = void 0,\n        sampleSize = void 0;\n\n    if (isThroughput) {\n      arr = throughputDict[mediaType];\n      sampleSize = isLive ? AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE : AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD;\n    } else {\n      arr = latencyDict[mediaType];\n      sampleSize = AVERAGE_LATENCY_SAMPLE_AMOUNT;\n    }\n\n    if (!arr) {\n      sampleSize = 0;\n    } else if (sampleSize >= arr.length) {\n      sampleSize = arr.length;\n    } else if (isThroughput) {\n      // if throughput samples vary a lot, average over a wider sample\n      for (var i = 1; i < sampleSize; ++i) {\n        var ratio = arr[arr.length - i] / arr[arr.length - i - 1];\n\n        if (ratio >= THROUGHPUT_INCREASE_SCALE || ratio <= 1 / THROUGHPUT_DECREASE_SCALE) {\n          sampleSize += 1;\n\n          if (sampleSize === arr.length) {\n            // cannot increase sampleSize beyond arr.length\n            break;\n          }\n        }\n      }\n    }\n\n    return sampleSize;\n  }\n\n  function getAverage(isThroughput, mediaType, isDynamic) {\n    // only two moving average methods defined at the moment\n    return settings.get().streaming.abr.movingAverageMethod !== _Constants2.default.MOVING_AVERAGE_SLIDING_WINDOW ? getAverageEwma(isThroughput, mediaType) : getAverageSlidingWindow(isThroughput, mediaType, isDynamic);\n  }\n\n  function getAverageSlidingWindow(isThroughput, mediaType, isDynamic) {\n    var sampleSize = getSampleSize(isThroughput, mediaType, isDynamic);\n    var dict = isThroughput ? throughputDict : latencyDict;\n    var arr = dict[mediaType];\n\n    if (sampleSize === 0 || !arr || arr.length === 0) {\n      return NaN;\n    }\n\n    arr = arr.slice(-sampleSize); // still works if sampleSize too large\n    // arr.length >= 1\n\n    return arr.reduce(function (total, elem) {\n      return total + elem;\n    }) / arr.length;\n  }\n\n  function getAverageEwma(isThroughput, mediaType) {\n    var halfLife = isThroughput ? ewmaHalfLife.throughputHalfLife : ewmaHalfLife.latencyHalfLife;\n    var ewmaObj = isThroughput ? ewmaThroughputDict[mediaType] : ewmaLatencyDict[mediaType];\n\n    if (!ewmaObj || ewmaObj.totalWeight <= 0) {\n      return NaN;\n    } // to correct for startup, divide by zero factor = 1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\n\n\n    var fastEstimate = ewmaObj.fastEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.fast));\n    var slowEstimate = ewmaObj.slowEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.slow));\n    return isThroughput ? Math.min(fastEstimate, slowEstimate) : Math.max(fastEstimate, slowEstimate);\n  }\n\n  function getAverageThroughput(mediaType, isDynamic) {\n    return getAverage(true, mediaType, isDynamic);\n  }\n\n  function getSafeAverageThroughput(mediaType, isDynamic) {\n    var average = getAverageThroughput(mediaType, isDynamic);\n\n    if (!isNaN(average)) {\n      average *= settings.get().streaming.abr.bandwidthSafetyFactor;\n    }\n\n    return average;\n  }\n\n  function getAverageLatency(mediaType) {\n    return getAverage(false, mediaType);\n  }\n\n  function checkSettingsForMediaType(mediaType) {\n    throughputDict[mediaType] = throughputDict[mediaType] || [];\n    latencyDict[mediaType] = latencyDict[mediaType] || [];\n    ewmaThroughputDict[mediaType] = ewmaThroughputDict[mediaType] || {\n      fastEstimate: 0,\n      slowEstimate: 0,\n      totalWeight: 0\n    };\n    ewmaLatencyDict[mediaType] = ewmaLatencyDict[mediaType] || {\n      fastEstimate: 0,\n      slowEstimate: 0,\n      totalWeight: 0\n    };\n  }\n\n  function clearSettingsForMediaType(mediaType) {\n    delete throughputDict[mediaType];\n    delete latencyDict[mediaType];\n    delete ewmaThroughputDict[mediaType];\n    delete ewmaLatencyDict[mediaType];\n    checkSettingsForMediaType(mediaType);\n  }\n\n  function reset() {\n    throughputDict = {};\n    latencyDict = {};\n    ewmaThroughputDict = {};\n    ewmaLatencyDict = {};\n  }\n\n  var instance = {\n    push: push,\n    getAverageThroughput: getAverageThroughput,\n    getSafeAverageThroughput: getSafeAverageThroughput,\n    getAverageLatency: getAverageLatency,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n\nThroughputHistory.__dashjs_factory_name = 'ThroughputHistory';\nexports.default = _FactoryMaker2.default.getClassFactory(ThroughputHistory);","map":{"version":3,"sources":["../../../../../src/streaming/rules/ThroughputHistory.js"],"names":["config","MAX_MEASUREMENTS_TO_KEEP","AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE","AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD","AVERAGE_LATENCY_SAMPLE_AMOUNT","THROUGHPUT_DECREASE_SCALE","THROUGHPUT_INCREASE_SCALE","EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS","EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS","EWMA_LATENCY_SLOW_HALF_LIFE_COUNT","EWMA_LATENCY_FAST_HALF_LIFE_COUNT","settings","throughputDict","latencyDict","ewmaThroughputDict","ewmaLatencyDict","ewmaHalfLife","throughputHalfLife","fast","slow","latencyHalfLife","reset","mediaType","Constants","downloadTimeMs","httpRequest","latencyTimeInMilliseconds","downloadTimeInMilliseconds","downloadBytes","a","b","throughputMeasureTime","useDeadTimeLatency","throughput","Math","checkSettingsForMediaType","isCachedResponse","clearSettingsForMediaType","updateEwmaEstimate","fastAlpha","weight","halfLife","ewmaObj","slowAlpha","arr","sampleSize","isLive","i","ratio","getAverageEwma","getAverageSlidingWindow","getSampleSize","dict","isThroughput","total","fastEstimate","slowEstimate","getAverage","average","getAverageThroughput","isNaN","totalWeight","instance","push","getSafeAverageThroughput","getAverageLatency","setup","ThroughputHistory","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2017, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Constants from '../constants/Constants';\nimport FactoryMaker from '../../core/FactoryMaker';\n\n// throughput generally stored in kbit/s\n// latency generally stored in ms\n\nfunction ThroughputHistory(config) {\n\n    config = config || {};\n    // sliding window constants\n    const MAX_MEASUREMENTS_TO_KEEP = 20;\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE = 3;\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD = 4;\n    const AVERAGE_LATENCY_SAMPLE_AMOUNT = 4;\n    const THROUGHPUT_DECREASE_SCALE = 1.3;\n    const THROUGHPUT_INCREASE_SCALE = 1.3;\n\n    // EWMA constants\n    const EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS = 8;\n    const EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS = 3;\n    const EWMA_LATENCY_SLOW_HALF_LIFE_COUNT = 2;\n    const EWMA_LATENCY_FAST_HALF_LIFE_COUNT = 1;\n\n    const settings = config.settings;\n\n    let throughputDict,\n        latencyDict,\n        ewmaThroughputDict,\n        ewmaLatencyDict,\n        ewmaHalfLife;\n\n    function setup() {\n        ewmaHalfLife = {\n            throughputHalfLife: { fast: EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS, slow: EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS },\n            latencyHalfLife:    { fast: EWMA_LATENCY_FAST_HALF_LIFE_COUNT,      slow: EWMA_LATENCY_SLOW_HALF_LIFE_COUNT }\n        };\n\n        reset();\n    }\n\n    function isCachedResponse(mediaType, latencyMs, downloadTimeMs) {\n        if (mediaType === Constants.VIDEO) {\n            return downloadTimeMs < settings.get().streaming.cacheLoadThresholds[Constants.VIDEO];\n        } else if (mediaType === Constants.AUDIO) {\n            return downloadTimeMs < settings.get().streaming.cacheLoadThresholds[Constants.AUDIO];\n        }\n    }\n\n    function push(mediaType, httpRequest, useDeadTimeLatency) {\n        if (!httpRequest.trace || !httpRequest.trace.length) {\n            return;\n        }\n\n        const latencyTimeInMilliseconds = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) || 1;\n        const downloadTimeInMilliseconds = (httpRequest._tfinish.getTime() - httpRequest.tresponse.getTime()) || 1; //Make sure never 0 we divide by this value. Avoid infinity!\n        const downloadBytes = httpRequest.trace.reduce((a, b) => a + b.b[0], 0);\n\n        let throughputMeasureTime;\n        if (settings.get().streaming.lowLatencyEnabled) {\n            throughputMeasureTime = httpRequest.trace.reduce((a, b) => a + b.d, 0);\n        } else {\n            throughputMeasureTime = useDeadTimeLatency ? downloadTimeInMilliseconds : latencyTimeInMilliseconds + downloadTimeInMilliseconds;\n        }\n\n        const throughput = Math.round((8 * downloadBytes) / throughputMeasureTime); // bits/ms = kbits/s\n\n        checkSettingsForMediaType(mediaType);\n\n        if (isCachedResponse(mediaType, latencyTimeInMilliseconds, downloadTimeInMilliseconds)) {\n            if (throughputDict[mediaType].length > 0 && !throughputDict[mediaType].hasCachedEntries) {\n                // already have some entries which are not cached entries\n                // prevent cached fragment loads from skewing the average values\n                return;\n            } else { // have no entries || have cached entries\n                // no uncached entries yet, rely on cached entries because ABR rules need something to go by\n                throughputDict[mediaType].hasCachedEntries = true;\n            }\n        } else if (throughputDict[mediaType] && throughputDict[mediaType].hasCachedEntries) {\n            // if we are here then we have some entries already, but they are cached, and now we have a new uncached entry\n            clearSettingsForMediaType(mediaType);\n        }\n\n        throughputDict[mediaType].push(throughput);\n        if (throughputDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\n            throughputDict[mediaType].shift();\n        }\n\n        latencyDict[mediaType].push(latencyTimeInMilliseconds);\n        if (latencyDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\n            latencyDict[mediaType].shift();\n        }\n\n        updateEwmaEstimate(ewmaThroughputDict[mediaType], throughput, 0.001 * downloadTimeInMilliseconds, ewmaHalfLife.throughputHalfLife);\n        updateEwmaEstimate(ewmaLatencyDict[mediaType], latencyTimeInMilliseconds, 1, ewmaHalfLife.latencyHalfLife);\n    }\n\n    function updateEwmaEstimate(ewmaObj, value, weight, halfLife) {\n        // Note about startup:\n        // Estimates start at 0, so early values are underestimated.\n        // This effect is countered in getAverageEwma() by dividing the estimates by:\n        //     1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\n\n        const fastAlpha = Math.pow(0.5, weight / halfLife.fast);\n        ewmaObj.fastEstimate = (1 - fastAlpha) * value + fastAlpha * ewmaObj.fastEstimate;\n\n        const slowAlpha = Math.pow(0.5, weight / halfLife.slow);\n        ewmaObj.slowEstimate = (1 - slowAlpha) * value + slowAlpha * ewmaObj.slowEstimate;\n\n        ewmaObj.totalWeight += weight;\n    }\n\n    function getSampleSize(isThroughput, mediaType, isLive) {\n        let arr,\n            sampleSize;\n\n        if (isThroughput) {\n            arr = throughputDict[mediaType];\n            sampleSize = isLive ? AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE : AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD;\n        } else {\n            arr = latencyDict[mediaType];\n            sampleSize = AVERAGE_LATENCY_SAMPLE_AMOUNT;\n        }\n\n        if (!arr) {\n            sampleSize = 0;\n        } else if (sampleSize >= arr.length) {\n            sampleSize = arr.length;\n        } else if (isThroughput) {\n            // if throughput samples vary a lot, average over a wider sample\n            for (let i = 1; i < sampleSize; ++i) {\n                const ratio = arr[arr.length - i] / arr[arr.length - i - 1];\n                if (ratio >= THROUGHPUT_INCREASE_SCALE || ratio <= 1 / THROUGHPUT_DECREASE_SCALE) {\n                    sampleSize += 1;\n                    if (sampleSize === arr.length) { // cannot increase sampleSize beyond arr.length\n                        break;\n                    }\n                }\n            }\n        }\n\n        return sampleSize;\n    }\n\n    function getAverage(isThroughput, mediaType, isDynamic) {\n        // only two moving average methods defined at the moment\n        return settings.get().streaming.abr.movingAverageMethod !== Constants.MOVING_AVERAGE_SLIDING_WINDOW ?\n            getAverageEwma(isThroughput, mediaType) : getAverageSlidingWindow(isThroughput, mediaType, isDynamic);\n    }\n\n    function getAverageSlidingWindow(isThroughput, mediaType, isDynamic) {\n        const sampleSize = getSampleSize(isThroughput, mediaType, isDynamic);\n        const dict = isThroughput ? throughputDict : latencyDict;\n        let arr = dict[mediaType];\n\n        if (sampleSize === 0 || !arr || arr.length === 0) {\n            return NaN;\n        }\n\n        arr = arr.slice(-sampleSize); // still works if sampleSize too large\n        // arr.length >= 1\n        return arr.reduce((total, elem) => total + elem) / arr.length;\n    }\n\n    function getAverageEwma(isThroughput, mediaType) {\n        const halfLife = isThroughput ? ewmaHalfLife.throughputHalfLife : ewmaHalfLife.latencyHalfLife;\n        const ewmaObj = isThroughput ? ewmaThroughputDict[mediaType] : ewmaLatencyDict[mediaType];\n\n        if (!ewmaObj || ewmaObj.totalWeight <= 0) {\n            return NaN;\n        }\n\n        // to correct for startup, divide by zero factor = 1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\n        const fastEstimate = ewmaObj.fastEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.fast));\n        const slowEstimate = ewmaObj.slowEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.slow));\n        return isThroughput ? Math.min(fastEstimate, slowEstimate) : Math.max(fastEstimate, slowEstimate);\n    }\n\n    function getAverageThroughput(mediaType, isDynamic) {\n        return getAverage(true, mediaType, isDynamic);\n    }\n\n    function getSafeAverageThroughput(mediaType, isDynamic) {\n        let average = getAverageThroughput(mediaType, isDynamic);\n        if (!isNaN(average)) {\n            average *= settings.get().streaming.abr.bandwidthSafetyFactor;\n        }\n        return average;\n    }\n\n    function getAverageLatency(mediaType) {\n        return getAverage(false, mediaType);\n    }\n\n    function checkSettingsForMediaType(mediaType) {\n        throughputDict[mediaType] = throughputDict[mediaType] || [];\n        latencyDict[mediaType] = latencyDict[mediaType] || [];\n        ewmaThroughputDict[mediaType] = ewmaThroughputDict[mediaType] || {fastEstimate: 0, slowEstimate: 0, totalWeight: 0};\n        ewmaLatencyDict[mediaType] = ewmaLatencyDict[mediaType] || {fastEstimate: 0, slowEstimate: 0, totalWeight: 0};\n    }\n\n    function clearSettingsForMediaType(mediaType) {\n        delete throughputDict[mediaType];\n        delete latencyDict[mediaType];\n        delete ewmaThroughputDict[mediaType];\n        delete ewmaLatencyDict[mediaType];\n        checkSettingsForMediaType(mediaType);\n    }\n\n    function reset() {\n        throughputDict = {};\n        latencyDict = {};\n        ewmaThroughputDict = {};\n        ewmaLatencyDict = {};\n    }\n\n    const instance = {\n        push: push,\n        getAverageThroughput: getAverageThroughput,\n        getSafeAverageThroughput: getSafeAverageThroughput,\n        getAverageLatency: getAverageLatency,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nThroughputHistory.__dashjs_factory_name = 'ThroughputHistory';\nexport default FactoryMaker.getClassFactory(ThroughputHistory);\n"]},"metadata":{},"sourceType":"script"}