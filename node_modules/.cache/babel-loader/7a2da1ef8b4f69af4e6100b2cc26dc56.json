{"ast":null,"code":"/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\n\n/**\r\n * @module imscUtils\r\n */\n;\n\n(function (imscUtils) {\n  // wrapper for non-node envs\n\n  /* Documents the error handler interface */\n\n  /**\r\n   * @classdesc Generic interface for handling events. The interface exposes four\r\n   * methods:\r\n   * * <pre>info</pre>: unusual event that does not result in an inconsistent state\r\n   * * <pre>warn</pre>: unexpected event that should not result in an inconsistent state\r\n   * * <pre>error</pre>: unexpected event that may result in an inconsistent state\r\n   * * <pre>fatal</pre>: unexpected event that results in an inconsistent state\r\n   *   and termination of processing\r\n   * Each method takes a single <pre>string</pre> describing the event as argument,\r\n   * and returns a single <pre>boolean</pre>, which terminates processing if <pre>true</pre>.\r\n   *\r\n   * @name ErrorHandler\r\n   * @class\r\n   */\n\n  /*\r\n   * Parses a TTML color expression\r\n   * \r\n   */\n  var HEX_COLOR_RE = /#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?/;\n  var DEC_COLOR_RE = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/;\n  var DEC_COLORA_RE = /rgba\\(\\s*(\\d+),\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/;\n  var NAMED_COLOR = {\n    transparent: [0, 0, 0, 0],\n    black: [0, 0, 0, 255],\n    silver: [192, 192, 192, 255],\n    gray: [128, 128, 128, 255],\n    white: [255, 255, 255, 255],\n    maroon: [128, 0, 0, 255],\n    red: [255, 0, 0, 255],\n    purple: [128, 0, 128, 255],\n    fuchsia: [255, 0, 255, 255],\n    magenta: [255, 0, 255, 255],\n    green: [0, 128, 0, 255],\n    lime: [0, 255, 0, 255],\n    olive: [128, 128, 0, 255],\n    yellow: [255, 255, 0, 255],\n    navy: [0, 0, 128, 255],\n    blue: [0, 0, 255, 255],\n    teal: [0, 128, 128, 255],\n    aqua: [0, 255, 255, 255],\n    cyan: [0, 255, 255, 255]\n  };\n\n  imscUtils.parseColor = function (str) {\n    var m;\n    var r = null;\n    var nc = NAMED_COLOR[str.toLowerCase()];\n\n    if (nc !== undefined) {\n      r = nc;\n    } else if ((m = HEX_COLOR_RE.exec(str)) !== null) {\n      r = [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), m[4] !== undefined ? parseInt(m[4], 16) : 255];\n    } else if ((m = DEC_COLOR_RE.exec(str)) !== null) {\n      r = [parseInt(m[1]), parseInt(m[2]), parseInt(m[3]), 255];\n    } else if ((m = DEC_COLORA_RE.exec(str)) !== null) {\n      r = [parseInt(m[1]), parseInt(m[2]), parseInt(m[3]), parseInt(m[4])];\n    }\n\n    return r;\n  };\n\n  var LENGTH_RE = /^((?:\\+|\\-)?\\d*(?:\\.\\d+)?)(px|em|c|%|rh|rw)$/;\n\n  imscUtils.parseLength = function (str) {\n    var m;\n    var r = null;\n\n    if ((m = LENGTH_RE.exec(str)) !== null) {\n      r = {\n        value: parseFloat(m[1]),\n        unit: m[2]\n      };\n    }\n\n    return r;\n  };\n\n  imscUtils.parseTextShadow = function (str) {\n    var shadows = str.split(\",\");\n    var r = [];\n\n    for (var i in shadows) {\n      var shadow = shadows[i].split(\" \");\n\n      if (shadow.length === 1 && shadow[0] === \"none\") {\n        return \"none\";\n      } else if (shadow.length > 1 && shadow.length < 5) {\n        var out_shadow = [null, null, null, null];\n        /* x offset */\n\n        var l = imscUtils.parseLength(shadow.shift());\n        if (l === null) return null;\n        out_shadow[0] = l;\n        /* y offset */\n\n        l = imscUtils.parseLength(shadow.shift());\n        if (l === null) return null;\n        out_shadow[1] = l;\n        /* is there a third component */\n\n        if (shadow.length === 0) {\n          r.push(out_shadow);\n          continue;\n        }\n\n        l = imscUtils.parseLength(shadow[0]);\n\n        if (l !== null) {\n          out_shadow[2] = l;\n          shadow.shift();\n        }\n\n        if (shadow.length === 0) {\n          r.push(out_shadow);\n          continue;\n        }\n\n        var c = imscUtils.parseColor(shadow[0]);\n        if (c === null) return null;\n        out_shadow[3] = c;\n        r.push(out_shadow);\n      }\n    }\n\n    return r;\n  };\n\n  imscUtils.parsePosition = function (str) {\n    /* see https://www.w3.org/TR/ttml2/#style-value-position */\n    var s = str.split(\" \");\n\n    var isKeyword = function (str) {\n      return str === \"center\" || str === \"left\" || str === \"top\" || str === \"bottom\" || str === \"right\";\n    };\n\n    if (s.length > 4) {\n      return null;\n    }\n    /* initial clean-up pass */\n\n\n    for (var j in s) {\n      if (!isKeyword(s[j])) {\n        var l = imscUtils.parseLength(s[j]);\n        if (l === null) return null;\n        s[j] = l;\n      }\n    }\n    /* position default */\n\n\n    var pos = {\n      h: {\n        edge: \"left\",\n        offset: {\n          value: 50,\n          unit: \"%\"\n        }\n      },\n      v: {\n        edge: \"top\",\n        offset: {\n          value: 50,\n          unit: \"%\"\n        }\n      }\n    };\n    /* update position */\n\n    for (var i = 0; i < s.length;) {\n      /* extract the current component */\n      var comp = s[i++];\n\n      if (isKeyword(comp)) {\n        /* we have a keyword */\n        var offset = {\n          value: 0,\n          unit: \"%\"\n        };\n        /* peek at the next component */\n\n        if (s.length !== 2 && i < s.length && !isKeyword(s[i])) {\n          /* followed by an offset */\n          offset = s[i++];\n        }\n        /* skip if center */\n\n\n        if (comp === \"right\") {\n          pos.h.edge = comp;\n          pos.h.offset = offset;\n        } else if (comp === \"bottom\") {\n          pos.v.edge = comp;\n          pos.v.offset = offset;\n        } else if (comp === \"left\") {\n          pos.h.offset = offset;\n        } else if (comp === \"top\") {\n          pos.v.offset = offset;\n        }\n      } else if (s.length === 1 || s.length === 2) {\n        /* we have a bare value */\n        if (i === 1) {\n          /* assign it to left edge if first bare value */\n          pos.h.offset = comp;\n        } else {\n          /* assign it to top edge if second bare value */\n          pos.v.offset = comp;\n        }\n      } else {\n        /* error condition */\n        return null;\n      }\n    }\n\n    return pos;\n  };\n\n  imscUtils.ComputedLength = function (rw, rh) {\n    this.rw = rw;\n    this.rh = rh;\n  };\n\n  imscUtils.ComputedLength.prototype.toUsedLength = function (width, height) {\n    return width * this.rw + height * this.rh;\n  };\n\n  imscUtils.ComputedLength.prototype.isZero = function () {\n    return this.rw === 0 && this.rh === 0;\n  };\n  /**\r\n   * Computes a specified length to a root container relative length\r\n   * \r\n   * @param {number} lengthVal Length value to be computed\r\n   * @param {string} lengthUnit Units of the length value\r\n   * @param {number} emScale length of 1em, or null if em is not allowed\r\n   * @param {number} percentScale length to which , or null if perecentage is not allowed\r\n   * @param {number} cellScale length of 1c, or null if c is not allowed\r\n   * @param {number} pxScale length of 1px, or null if px is not allowed\r\n   * @param {number} direction 0 if the length is computed in the horizontal direction, 1 if the length is computed in the vertical direction\r\n   * @return {number} Computed length\r\n   */\n\n\n  imscUtils.toComputedLength = function (lengthVal, lengthUnit, emLength, percentLength, cellLength, pxLength) {\n    if (lengthUnit === \"%\" && percentLength) {\n      return new imscUtils.ComputedLength(percentLength.rw * lengthVal / 100, percentLength.rh * lengthVal / 100);\n    } else if (lengthUnit === \"em\" && emLength) {\n      return new imscUtils.ComputedLength(emLength.rw * lengthVal, emLength.rh * lengthVal);\n    } else if (lengthUnit === \"c\" && cellLength) {\n      return new imscUtils.ComputedLength(lengthVal * cellLength.rw, lengthVal * cellLength.rh);\n    } else if (lengthUnit === \"px\" && pxLength) {\n      return new imscUtils.ComputedLength(lengthVal * pxLength.rw, lengthVal * pxLength.rh);\n    } else if (lengthUnit === \"rh\") {\n      return new imscUtils.ComputedLength(0, lengthVal / 100);\n    } else if (lengthUnit === \"rw\") {\n      return new imscUtils.ComputedLength(lengthVal / 100, 0);\n    } else {\n      return null;\n    }\n  };\n})(typeof exports === 'undefined' ? this.imscUtils = {} : exports);","map":{"version":3,"sources":["/Users/webwerks1/Documents/Project/React Js Training/streamvideo/node_modules/imsc/src/main/js/utils.js"],"names":["imscUtils","HEX_COLOR_RE","DEC_COLOR_RE","DEC_COLORA_RE","NAMED_COLOR","transparent","black","silver","gray","white","maroon","red","purple","fuchsia","magenta","green","lime","olive","yellow","navy","blue","teal","aqua","cyan","parseColor","str","m","r","nc","toLowerCase","undefined","exec","parseInt","LENGTH_RE","parseLength","value","parseFloat","unit","parseTextShadow","shadows","split","i","shadow","length","out_shadow","l","shift","push","c","parsePosition","s","isKeyword","j","pos","h","edge","offset","v","comp","ComputedLength","rw","rh","prototype","toUsedLength","width","height","isZero","toComputedLength","lengthVal","lengthUnit","emLength","percentLength","cellLength","pxLength","exports"],"mappings":"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","sourcesContent":["/* \r\n * Copyright (c) 2016, Pierre-Anthony Lemieux <pal@sandflow.com>\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * @module imscUtils\r\n */\r\n\r\n;\r\n(function (imscUtils) { // wrapper for non-node envs\r\n\r\n    /* Documents the error handler interface */\r\n\r\n    /**\r\n     * @classdesc Generic interface for handling events. The interface exposes four\r\n     * methods:\r\n     * * <pre>info</pre>: unusual event that does not result in an inconsistent state\r\n     * * <pre>warn</pre>: unexpected event that should not result in an inconsistent state\r\n     * * <pre>error</pre>: unexpected event that may result in an inconsistent state\r\n     * * <pre>fatal</pre>: unexpected event that results in an inconsistent state\r\n     *   and termination of processing\r\n     * Each method takes a single <pre>string</pre> describing the event as argument,\r\n     * and returns a single <pre>boolean</pre>, which terminates processing if <pre>true</pre>.\r\n     *\r\n     * @name ErrorHandler\r\n     * @class\r\n     */\r\n\r\n\r\n    /*\r\n     * Parses a TTML color expression\r\n     * \r\n     */\r\n\r\n    var HEX_COLOR_RE = /#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?/;\r\n    var DEC_COLOR_RE = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/;\r\n    var DEC_COLORA_RE = /rgba\\(\\s*(\\d+),\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/;\r\n    var NAMED_COLOR = {\r\n        transparent: [0, 0, 0, 0],\r\n        black: [0, 0, 0, 255],\r\n        silver: [192, 192, 192, 255],\r\n        gray: [128, 128, 128, 255],\r\n        white: [255, 255, 255, 255],\r\n        maroon: [128, 0, 0, 255],\r\n        red: [255, 0, 0, 255],\r\n        purple: [128, 0, 128, 255],\r\n        fuchsia: [255, 0, 255, 255],\r\n        magenta: [255, 0, 255, 255],\r\n        green: [0, 128, 0, 255],\r\n        lime: [0, 255, 0, 255],\r\n        olive: [128, 128, 0, 255],\r\n        yellow: [255, 255, 0, 255],\r\n        navy: [0, 0, 128, 255],\r\n        blue: [0, 0, 255, 255],\r\n        teal: [0, 128, 128, 255],\r\n        aqua: [0, 255, 255, 255],\r\n        cyan: [0, 255, 255, 255]\r\n    };\r\n\r\n    imscUtils.parseColor = function (str) {\r\n\r\n        var m;\r\n        \r\n        var r = null;\r\n        \r\n        var nc = NAMED_COLOR[str.toLowerCase()];\r\n        \r\n        if (nc !== undefined) {\r\n\r\n            r = nc;\r\n\r\n        } else if ((m = HEX_COLOR_RE.exec(str)) !== null) {\r\n\r\n            r = [parseInt(m[1], 16),\r\n                parseInt(m[2], 16),\r\n                parseInt(m[3], 16),\r\n                (m[4] !== undefined ? parseInt(m[4], 16) : 255)];\r\n            \r\n        } else if ((m = DEC_COLOR_RE.exec(str)) !== null) {\r\n\r\n            r = [parseInt(m[1]),\r\n                parseInt(m[2]),\r\n                parseInt(m[3]),\r\n                255];\r\n            \r\n        } else if ((m = DEC_COLORA_RE.exec(str)) !== null) {\r\n\r\n            r = [parseInt(m[1]),\r\n                parseInt(m[2]),\r\n                parseInt(m[3]),\r\n                parseInt(m[4])];\r\n            \r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    var LENGTH_RE = /^((?:\\+|\\-)?\\d*(?:\\.\\d+)?)(px|em|c|%|rh|rw)$/;\r\n\r\n    imscUtils.parseLength = function (str) {\r\n\r\n        var m;\r\n\r\n        var r = null;\r\n\r\n        if ((m = LENGTH_RE.exec(str)) !== null) {\r\n\r\n            r = {value: parseFloat(m[1]), unit: m[2]};\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    imscUtils.parseTextShadow = function (str) {\r\n\r\n        var shadows = str.split(\",\");\r\n\r\n        var r = [];\r\n\r\n        for (var i in shadows) {\r\n\r\n            var shadow = shadows[i].split(\" \");\r\n\r\n            if (shadow.length === 1 && shadow[0] === \"none\") {\r\n\r\n                return \"none\";\r\n\r\n            } else if (shadow.length > 1 && shadow.length < 5) {\r\n\r\n                var out_shadow = [null, null, null, null];\r\n\r\n                /* x offset */\r\n\r\n                var l = imscUtils.parseLength(shadow.shift());\r\n\r\n                if (l === null)\r\n                    return null;\r\n\r\n                out_shadow[0] = l;\r\n\r\n                /* y offset */\r\n\r\n                l = imscUtils.parseLength(shadow.shift());\r\n\r\n                if (l === null)\r\n                    return null;\r\n\r\n                out_shadow[1] = l;\r\n\r\n                /* is there a third component */\r\n\r\n                if (shadow.length === 0) {\r\n                    r.push(out_shadow);\r\n                    continue;\r\n                }\r\n\r\n                l = imscUtils.parseLength(shadow[0]);\r\n\r\n                if (l !== null) {\r\n\r\n                    out_shadow[2] = l;\r\n\r\n                    shadow.shift();\r\n\r\n                }\r\n\r\n                if (shadow.length === 0) {\r\n                    r.push(out_shadow);\r\n                    continue;\r\n                }\r\n\r\n                var c = imscUtils.parseColor(shadow[0]);\r\n\r\n                if (c === null)\r\n                    return null;\r\n\r\n                out_shadow[3] = c;\r\n\r\n                r.push(out_shadow);\r\n            }\r\n\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n\r\n    imscUtils.parsePosition = function (str) {\r\n\r\n        /* see https://www.w3.org/TR/ttml2/#style-value-position */\r\n\r\n        var s = str.split(\" \");\r\n\r\n        var isKeyword = function (str) {\r\n\r\n            return str === \"center\" ||\r\n                    str === \"left\" ||\r\n                    str === \"top\" ||\r\n                    str === \"bottom\" ||\r\n                    str === \"right\";\r\n\r\n        };\r\n\r\n        if (s.length > 4) {\r\n\r\n            return null;\r\n\r\n        }\r\n\r\n        /* initial clean-up pass */\r\n\r\n        for (var j in s) {\r\n\r\n            if (!isKeyword(s[j])) {\r\n\r\n                var l = imscUtils.parseLength(s[j]);\r\n\r\n                if (l === null)\r\n                    return null;\r\n\r\n                s[j] = l;\r\n            }\r\n\r\n        }\r\n\r\n        /* position default */\r\n\r\n        var pos = {\r\n            h: {edge: \"left\", offset: {value: 50, unit: \"%\"}},\r\n            v: {edge: \"top\", offset: {value: 50, unit: \"%\"}}\r\n        };\r\n\r\n        /* update position */\r\n\r\n        for (var i = 0; i < s.length; ) {\r\n\r\n            /* extract the current component */\r\n\r\n            var comp = s[i++];\r\n\r\n            if (isKeyword(comp)) {\r\n\r\n                /* we have a keyword */\r\n\r\n                var offset = {value: 0, unit: \"%\"};\r\n\r\n                /* peek at the next component */\r\n\r\n                if (s.length !== 2 && i < s.length && (!isKeyword(s[i]))) {\r\n\r\n                    /* followed by an offset */\r\n\r\n                    offset = s[i++];\r\n\r\n                }\r\n\r\n                /* skip if center */\r\n\r\n                if (comp === \"right\") {\r\n\r\n                    pos.h.edge = comp;\r\n\r\n                    pos.h.offset = offset;\r\n\r\n                } else if (comp === \"bottom\") {\r\n\r\n                    pos.v.edge = comp;\r\n\r\n\r\n                    pos.v.offset = offset;\r\n\r\n\r\n                } else if (comp === \"left\") {\r\n\r\n                    pos.h.offset = offset;\r\n\r\n\r\n                } else if (comp === \"top\") {\r\n\r\n                    pos.v.offset = offset;\r\n\r\n\r\n                }\r\n\r\n            } else if (s.length === 1 || s.length === 2) {\r\n\r\n                /* we have a bare value */\r\n\r\n                if (i === 1) {\r\n\r\n                    /* assign it to left edge if first bare value */\r\n\r\n                    pos.h.offset = comp;\r\n\r\n                } else {\r\n\r\n                    /* assign it to top edge if second bare value */\r\n\r\n                    pos.v.offset = comp;\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                /* error condition */\r\n\r\n                return null;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return pos;\r\n    };\r\n\r\n\r\n    imscUtils.ComputedLength = function (rw, rh) {\r\n        this.rw = rw;\r\n        this.rh = rh;\r\n    };\r\n\r\n    imscUtils.ComputedLength.prototype.toUsedLength = function (width, height) {\r\n        return width * this.rw + height * this.rh;\r\n    };\r\n\r\n    imscUtils.ComputedLength.prototype.isZero = function () {\r\n        return this.rw === 0 && this.rh === 0;\r\n    };\r\n\r\n    /**\r\n     * Computes a specified length to a root container relative length\r\n     * \r\n     * @param {number} lengthVal Length value to be computed\r\n     * @param {string} lengthUnit Units of the length value\r\n     * @param {number} emScale length of 1em, or null if em is not allowed\r\n     * @param {number} percentScale length to which , or null if perecentage is not allowed\r\n     * @param {number} cellScale length of 1c, or null if c is not allowed\r\n     * @param {number} pxScale length of 1px, or null if px is not allowed\r\n     * @param {number} direction 0 if the length is computed in the horizontal direction, 1 if the length is computed in the vertical direction\r\n     * @return {number} Computed length\r\n     */\r\n    imscUtils.toComputedLength = function(lengthVal, lengthUnit, emLength, percentLength, cellLength, pxLength) {\r\n\r\n        if (lengthUnit === \"%\" && percentLength) {\r\n\r\n            return new imscUtils.ComputedLength(\r\n                    percentLength.rw * lengthVal / 100,\r\n                    percentLength.rh * lengthVal / 100\r\n                    );\r\n\r\n        } else if (lengthUnit === \"em\" && emLength) {\r\n\r\n            return new imscUtils.ComputedLength(\r\n                    emLength.rw * lengthVal,\r\n                    emLength.rh * lengthVal\r\n                    );\r\n\r\n        } else if (lengthUnit === \"c\" && cellLength) {\r\n\r\n            return new imscUtils.ComputedLength(\r\n                    lengthVal * cellLength.rw,\r\n                    lengthVal * cellLength.rh\r\n                    );\r\n\r\n        } else if (lengthUnit === \"px\" && pxLength) {\r\n\r\n            return new imscUtils.ComputedLength(\r\n                    lengthVal * pxLength.rw,\r\n                    lengthVal * pxLength.rh\r\n                    );\r\n\r\n        } else if (lengthUnit === \"rh\") {\r\n\r\n            return new imscUtils.ComputedLength(\r\n                    0,\r\n                    lengthVal / 100\r\n                    );\r\n\r\n        } else if (lengthUnit === \"rw\") {\r\n\r\n            return new imscUtils.ComputedLength(\r\n                    lengthVal / 100,\r\n                    0                    \r\n                    );\r\n\r\n        } else {\r\n\r\n            return null;\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n\r\n})(typeof exports === 'undefined' ? this.imscUtils = {} : exports);\r\n"]},"metadata":{},"sourceType":"script"}