{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Constants = require('../../streaming/constants/Constants');\n\nvar _Constants2 = _interopRequireDefault(_Constants);\n\nvar _DashConstants = require('../constants/DashConstants');\n\nvar _DashConstants2 = _interopRequireDefault(_DashConstants);\n\nvar _Representation = require('../vo/Representation');\n\nvar _Representation2 = _interopRequireDefault(_Representation);\n\nvar _AdaptationSet = require('../vo/AdaptationSet');\n\nvar _AdaptationSet2 = _interopRequireDefault(_AdaptationSet);\n\nvar _Period = require('../vo/Period');\n\nvar _Period2 = _interopRequireDefault(_Period);\n\nvar _Mpd = require('../vo/Mpd');\n\nvar _Mpd2 = _interopRequireDefault(_Mpd);\n\nvar _UTCTiming = require('../vo/UTCTiming');\n\nvar _UTCTiming2 = _interopRequireDefault(_UTCTiming);\n\nvar _Event = require('../vo/Event');\n\nvar _Event2 = _interopRequireDefault(_Event);\n\nvar _BaseURL = require('../vo/BaseURL');\n\nvar _BaseURL2 = _interopRequireDefault(_BaseURL);\n\nvar _EventStream = require('../vo/EventStream');\n\nvar _EventStream2 = _interopRequireDefault(_EventStream);\n\nvar _ObjectUtils = require('../../streaming/utils/ObjectUtils');\n\nvar _ObjectUtils2 = _interopRequireDefault(_ObjectUtils);\n\nvar _URLUtils = require('../../streaming/utils/URLUtils');\n\nvar _URLUtils2 = _interopRequireDefault(_URLUtils);\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _DashJSError = require('../../streaming/vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _Errors = require('../../core/errors/Errors');\n\nvar _Errors2 = _interopRequireDefault(_Errors);\n\nvar _ThumbnailTracks = require('../../streaming/thumbnail/ThumbnailTracks');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction DashManifestModel() {\n  var instance = void 0,\n      logger = void 0,\n      errHandler = void 0,\n      BASE64 = void 0;\n  var context = this.context;\n  var urlUtils = (0, _URLUtils2.default)(context).getInstance();\n\n  var isInteger = Number.isInteger || function (value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n  };\n\n  function setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n  }\n\n  function getIsTypeOf(adaptation, type) {\n    var i = void 0,\n        len = void 0,\n        representation = void 0,\n        col = void 0,\n        mimeTypeRegEx = void 0,\n        codecs = void 0;\n    var result = false;\n    var found = false;\n\n    if (!adaptation) {\n      throw new Error('adaptation is not defined');\n    }\n\n    if (!type) {\n      throw new Error('type is not defined');\n    }\n\n    if (adaptation.hasOwnProperty('ContentComponent_asArray')) {\n      col = adaptation.ContentComponent_asArray;\n    }\n\n    mimeTypeRegEx = type !== _Constants2.default.TEXT ? new RegExp(type) : new RegExp('(vtt|ttml)');\n\n    if (adaptation.Representation_asArray && adaptation.Representation_asArray.length && adaptation.Representation_asArray.length > 0) {\n      var essentialProperties = getEssentialPropertiesForRepresentation(adaptation.Representation_asArray[0]);\n\n      if (essentialProperties && essentialProperties.length > 0 && _ThumbnailTracks.THUMBNAILS_SCHEME_ID_URIS.indexOf(essentialProperties[0].schemeIdUri) >= 0) {\n        return type === _Constants2.default.IMAGE;\n      }\n\n      if (adaptation.Representation_asArray[0].hasOwnProperty(_DashConstants2.default.CODECS)) {\n        // Just check the start of the codecs string\n        codecs = adaptation.Representation_asArray[0].codecs;\n\n        if (codecs.search(_Constants2.default.STPP) === 0 || codecs.search(_Constants2.default.WVTT) === 0) {\n          return type === _Constants2.default.FRAGMENTED_TEXT;\n        }\n      }\n    }\n\n    if (col) {\n      if (col.length > 1) {\n        return type === _Constants2.default.MUXED;\n      } else if (col[0] && col[0].contentType === type) {\n        result = true;\n        found = true;\n      }\n    }\n\n    if (adaptation.hasOwnProperty(_DashConstants2.default.MIME_TYPE)) {\n      result = mimeTypeRegEx.test(adaptation.mimeType);\n      found = true;\n    } // couldn't find on adaptationset, so check a representation\n\n\n    if (!found) {\n      i = 0;\n      len = adaptation.Representation_asArray && adaptation.Representation_asArray.length ? adaptation.Representation_asArray.length : 0;\n\n      while (!found && i < len) {\n        representation = adaptation.Representation_asArray[i];\n\n        if (representation.hasOwnProperty(_DashConstants2.default.MIME_TYPE)) {\n          result = mimeTypeRegEx.test(representation.mimeType);\n          found = true;\n        }\n\n        i++;\n      }\n    }\n\n    return result;\n  }\n\n  function getIsAudio(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.AUDIO);\n  }\n\n  function getIsVideo(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.VIDEO);\n  }\n\n  function getIsFragmentedText(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.FRAGMENTED_TEXT);\n  }\n\n  function getIsMuxed(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.MUXED);\n  }\n\n  function getIsImage(adaptation) {\n    return getIsTypeOf(adaptation, _Constants2.default.IMAGE);\n  }\n\n  function getIsTextTrack(type) {\n    return type === 'text/vtt' || type === 'application/ttml+xml';\n  }\n\n  function getLanguageForAdaptation(adaptation) {\n    var lang = '';\n\n    if (adaptation && adaptation.hasOwnProperty(_DashConstants2.default.LANG)) {\n      //Filter out any other characters not allowed according to RFC5646\n      lang = adaptation.lang.replace(/[^A-Za-z0-9-]/g, '');\n    }\n\n    return lang;\n  }\n\n  function getViewpointForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.VIEWPOINT) ? adaptation.Viewpoint : null;\n  }\n\n  function getRolesForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.ROLE_ASARRAY) ? adaptation.Role_asArray : [];\n  }\n\n  function getAccessibilityForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.ACCESSIBILITY_ASARRAY) ? adaptation.Accessibility_asArray : [];\n  }\n\n  function getAudioChannelConfigurationForAdaptation(adaptation) {\n    return adaptation && adaptation.hasOwnProperty(_DashConstants2.default.AUDIOCHANNELCONFIGURATION_ASARRAY) ? adaptation.AudioChannelConfiguration_asArray : [];\n  }\n\n  function getAudioChannelConfigurationForRepresentation(representation) {\n    return representation && representation.hasOwnProperty(_DashConstants2.default.AUDIOCHANNELCONFIGURATION_ASARRAY) ? representation.AudioChannelConfiguration_asArray : [];\n  }\n\n  function getRepresentationSortFunction() {\n    return function (a, b) {\n      return a.bandwidth - b.bandwidth;\n    };\n  }\n\n  function processAdaptation(realAdaptation) {\n    if (realAdaptation && Array.isArray(realAdaptation.Representation_asArray)) {\n      realAdaptation.Representation_asArray.sort(getRepresentationSortFunction());\n    }\n\n    return realAdaptation;\n  }\n\n  function getRealAdaptations(manifest, periodIndex) {\n    return manifest && manifest.Period_asArray && isInteger(periodIndex) ? manifest.Period_asArray[periodIndex] ? manifest.Period_asArray[periodIndex].AdaptationSet_asArray : [] : [];\n  }\n\n  function getRealPeriods(manifest) {\n    return manifest && manifest.Period_asArray ? manifest.Period_asArray : [];\n  }\n\n  function getRealPeriodForIndex(index, manifest) {\n    var realPeriods = getRealPeriods(manifest);\n\n    if (realPeriods.length > 0 && isInteger(index)) {\n      return realPeriods[index];\n    } else {\n      return null;\n    }\n  }\n\n  function getAdaptationForId(id, manifest, periodIndex) {\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n    var i = void 0,\n        len = void 0;\n\n    for (i = 0, len = realAdaptations.length; i < len; i++) {\n      if (realAdaptations[i].hasOwnProperty(_DashConstants2.default.ID) && realAdaptations[i].id === id) {\n        return realAdaptations[i];\n      }\n    }\n\n    return null;\n  }\n\n  function getAdaptationForIndex(index, manifest, periodIndex) {\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n\n    if (realAdaptations.length > 0 && isInteger(index)) {\n      return realAdaptations[index];\n    } else {\n      return null;\n    }\n  }\n\n  function getIndexForAdaptation(realAdaptation, manifest, periodIndex) {\n    if (!realAdaptation) {\n      return -1;\n    }\n\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n\n    for (var i = 0; i < realAdaptations.length; i++) {\n      var objectUtils = (0, _ObjectUtils2.default)(context).getInstance();\n\n      if (objectUtils.areEqual(realAdaptations[i], realAdaptation)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getAdaptationsForType(manifest, periodIndex, type) {\n    var realAdaptations = getRealAdaptations(manifest, periodIndex);\n    var i = void 0,\n        len = void 0;\n    var adaptations = [];\n\n    for (i = 0, len = realAdaptations.length; i < len; i++) {\n      if (getIsTypeOf(realAdaptations[i], type)) {\n        adaptations.push(processAdaptation(realAdaptations[i]));\n      }\n    }\n\n    return adaptations;\n  }\n\n  function getCodec(adaptation, representationId, addResolutionInfo) {\n    var codec = null;\n\n    if (adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0) {\n      var representation = isInteger(representationId) && representationId >= 0 && representationId < adaptation.Representation_asArray.length ? adaptation.Representation_asArray[representationId] : adaptation.Representation_asArray[0];\n\n      if (representation) {\n        codec = representation.mimeType + ';codecs=\"' + representation.codecs + '\"';\n\n        if (addResolutionInfo && representation.width !== undefined) {\n          codec += ';width=\"' + representation.width + '\";height=\"' + representation.height + '\"';\n        }\n      }\n    } // If the codec contains a profiles parameter we remove it. Otherwise it will cause problems when checking for codec capabilities of the platform\n\n\n    if (codec) {\n      codec = codec.replace(/\\sprofiles=[^;]*/g, '');\n    }\n\n    return codec;\n  }\n\n  function getMimeType(adaptation) {\n    return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 ? adaptation.Representation_asArray[0].mimeType : null;\n  }\n\n  function getKID(adaptation) {\n    if (!adaptation || !adaptation.hasOwnProperty(_DashConstants2.default.CENC_DEFAULT_KID)) {\n      return null;\n    }\n\n    return adaptation[_DashConstants2.default.CENC_DEFAULT_KID];\n  }\n\n  function getLabelsForAdaptation(adaptation) {\n    if (!adaptation || !Array.isArray(adaptation.Label_asArray)) {\n      return [];\n    }\n\n    var labelArray = [];\n\n    for (var i = 0; i < adaptation.Label_asArray.length; i++) {\n      labelArray.push({\n        lang: adaptation.Label_asArray[i].lang,\n        text: adaptation.Label_asArray[i].__text || adaptation.Label_asArray[i]\n      });\n    }\n\n    return labelArray;\n  }\n\n  function getContentProtectionData(adaptation) {\n    if (!adaptation || !adaptation.hasOwnProperty(_DashConstants2.default.CONTENTPROTECTION_ASARRAY) || adaptation.ContentProtection_asArray.length === 0) {\n      return null;\n    }\n\n    return adaptation.ContentProtection_asArray;\n  }\n\n  function getIsDynamic(manifest) {\n    var isDynamic = false;\n\n    if (manifest && manifest.hasOwnProperty('type')) {\n      isDynamic = manifest.type === _DashConstants2.default.DYNAMIC;\n    }\n\n    return isDynamic;\n  }\n\n  function getId(manifest) {\n    return manifest && manifest[_DashConstants2.default.ID] || null;\n  }\n\n  function hasProfile(manifest, profile) {\n    var has = false;\n\n    if (manifest && manifest.profiles && manifest.profiles.length > 0) {\n      has = manifest.profiles.indexOf(profile) !== -1;\n    }\n\n    return has;\n  }\n\n  function getDuration(manifest) {\n    var mpdDuration = void 0; //@mediaPresentationDuration specifies the duration of the entire Media Presentation.\n    //If the attribute is not present, the duration of the Media Presentation is unknown.\n\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.MEDIA_PRESENTATION_DURATION)) {\n      mpdDuration = manifest.mediaPresentationDuration;\n    } else if (manifest && manifest.type == 'dynamic') {\n      mpdDuration = Number.POSITIVE_INFINITY;\n    } else {\n      mpdDuration = Number.MAX_SAFE_INTEGER || Number.MAX_VALUE;\n    }\n\n    return mpdDuration;\n  }\n\n  function getBandwidth(representation) {\n    return representation && representation.bandwidth ? representation.bandwidth : NaN;\n  }\n\n  function getManifestUpdatePeriod(manifest) {\n    var latencyOfLastUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var delay = NaN;\n\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.MINIMUM_UPDATE_PERIOD)) {\n      delay = manifest.minimumUpdatePeriod;\n    }\n\n    return isNaN(delay) ? delay : Math.max(delay - latencyOfLastUpdate, 1);\n  }\n\n  function getPublishTime(manifest) {\n    return manifest && manifest.hasOwnProperty(_DashConstants2.default.PUBLISH_TIME) ? new Date(manifest[_DashConstants2.default.PUBLISH_TIME]) : null;\n  }\n\n  function getRepresentationCount(adaptation) {\n    return adaptation && Array.isArray(adaptation.Representation_asArray) ? adaptation.Representation_asArray.length : 0;\n  }\n\n  function getBitrateListForAdaptation(realAdaptation) {\n    var processedRealAdaptation = processAdaptation(realAdaptation);\n    var realRepresentations = processedRealAdaptation && Array.isArray(processedRealAdaptation.Representation_asArray) ? processedRealAdaptation.Representation_asArray : [];\n    return realRepresentations.map(function (realRepresentation) {\n      return {\n        bandwidth: realRepresentation.bandwidth,\n        width: realRepresentation.width || 0,\n        height: realRepresentation.height || 0,\n        scanType: realRepresentation.scanType || null,\n        id: realRepresentation.id || null\n      };\n    });\n  }\n\n  function getEssentialPropertiesForRepresentation(realRepresentation) {\n    if (!realRepresentation || !realRepresentation.EssentialProperty_asArray || !realRepresentation.EssentialProperty_asArray.length) return null;\n    return realRepresentation.EssentialProperty_asArray.map(function (prop) {\n      return {\n        schemeIdUri: prop.schemeIdUri,\n        value: prop.value\n      };\n    });\n  }\n\n  function getRepresentationFor(index, adaptation) {\n    return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 && isInteger(index) ? adaptation.Representation_asArray[index] : null;\n  }\n\n  function getRealAdaptationFor(voAdaptation) {\n    if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n      var periodArray = voAdaptation.period.mpd.manifest.Period_asArray[voAdaptation.period.index];\n\n      if (periodArray && periodArray.AdaptationSet_asArray && isInteger(voAdaptation.index)) {\n        return processAdaptation(periodArray.AdaptationSet_asArray[voAdaptation.index]);\n      }\n    }\n  }\n\n  function getRepresentationsForAdaptation(voAdaptation) {\n    var voRepresentations = [];\n    var processedRealAdaptation = getRealAdaptationFor(voAdaptation);\n    var segmentInfo = void 0,\n        baseUrl = void 0;\n\n    if (processedRealAdaptation && processedRealAdaptation.Representation_asArray) {\n      // TODO: TO BE REMOVED. We should get just the baseUrl elements that affects to the representations\n      // that we are processing. Making it works properly will require much further changes and given\n      // parsing base Urls parameters is needed for our ultra low latency examples, we will\n      // keep this \"tricky\" code until the real (and good) solution comes\n      if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n        var baseUrls = getBaseURLsFromElement(voAdaptation.period.mpd.manifest);\n\n        if (baseUrls) {\n          baseUrl = baseUrls[0];\n        }\n      }\n\n      for (var i = 0, len = processedRealAdaptation.Representation_asArray.length; i < len; ++i) {\n        var realRepresentation = processedRealAdaptation.Representation_asArray[i];\n        var voRepresentation = new _Representation2.default();\n        voRepresentation.index = i;\n        voRepresentation.adaptation = voAdaptation;\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.ID)) {\n          voRepresentation.id = realRepresentation.id;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.CODECS)) {\n          voRepresentation.codecs = realRepresentation.codecs;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.CODEC_PRIVATE_DATA)) {\n          voRepresentation.codecPrivateData = realRepresentation.codecPrivateData;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.BANDWITH)) {\n          voRepresentation.bandwidth = realRepresentation.bandwidth;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.WIDTH)) {\n          voRepresentation.width = realRepresentation.width;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.HEIGHT)) {\n          voRepresentation.height = realRepresentation.height;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.SCAN_TYPE)) {\n          voRepresentation.scanType = realRepresentation.scanType;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.MAX_PLAYOUT_RATE)) {\n          voRepresentation.maxPlayoutRate = realRepresentation.maxPlayoutRate;\n        }\n\n        if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_BASE)) {\n          segmentInfo = realRepresentation.SegmentBase;\n          voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_BASE;\n        } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_LIST)) {\n          segmentInfo = realRepresentation.SegmentList;\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.SEGMENT_TIMELINE)) {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_TIMELINE;\n          } else {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_LIST;\n          }\n        } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_TEMPLATE)) {\n          segmentInfo = realRepresentation.SegmentTemplate;\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.SEGMENT_TIMELINE)) {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_TIMELINE;\n          } else {\n            voRepresentation.segmentInfoType = _DashConstants2.default.SEGMENT_TEMPLATE;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.INITIALIZATION_MINUS)) {\n            voRepresentation.initialization = segmentInfo.initialization.split('$Bandwidth$').join(realRepresentation.bandwidth).split('$RepresentationID$').join(realRepresentation.id);\n          }\n        } else {\n          voRepresentation.segmentInfoType = _DashConstants2.default.BASE_URL;\n        }\n\n        voRepresentation.essentialProperties = getEssentialPropertiesForRepresentation(realRepresentation);\n\n        if (segmentInfo) {\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.INITIALIZATION)) {\n            var initialization = segmentInfo.Initialization;\n\n            if (initialization.hasOwnProperty(_DashConstants2.default.SOURCE_URL)) {\n              voRepresentation.initialization = initialization.sourceURL;\n            }\n\n            if (initialization.hasOwnProperty(_DashConstants2.default.RANGE)) {\n              voRepresentation.range = initialization.range; // initialization source url will be determined from\n              // BaseURL when resolved at load time.\n            }\n          } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.MIME_TYPE) && getIsTextTrack(realRepresentation.mimeType)) {\n            voRepresentation.range = 0;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.TIMESCALE)) {\n            voRepresentation.timescale = segmentInfo.timescale;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.DURATION)) {\n            // TODO according to the spec @maxSegmentDuration specifies the maximum duration of any Segment in any Representation in the Media Presentation\n            // It is also said that for a SegmentTimeline any @d value shall not exceed the value of MPD@maxSegmentDuration, but nothing is said about\n            // SegmentTemplate @duration attribute. We need to find out if @maxSegmentDuration should be used instead of calculated duration if the the duration\n            // exceeds @maxSegmentDuration\n            voRepresentation.segmentDuration = segmentInfo.duration / voRepresentation.timescale;\n          } else if (realRepresentation.hasOwnProperty(_DashConstants2.default.SEGMENT_TEMPLATE)) {\n            segmentInfo = realRepresentation.SegmentTemplate;\n\n            if (segmentInfo.hasOwnProperty(_DashConstants2.default.SEGMENT_TIMELINE)) {\n              voRepresentation.segmentDuration = calcSegmentDuration(segmentInfo.SegmentTimeline) / voRepresentation.timescale;\n            }\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.MEDIA)) {\n            voRepresentation.media = segmentInfo.media;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.START_NUMBER)) {\n            voRepresentation.startNumber = segmentInfo.startNumber;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.INDEX_RANGE)) {\n            voRepresentation.indexRange = segmentInfo.indexRange;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.PRESENTATION_TIME_OFFSET)) {\n            voRepresentation.presentationTimeOffset = segmentInfo.presentationTimeOffset / voRepresentation.timescale;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_OFFSET)) {\n            voRepresentation.availabilityTimeOffset = segmentInfo.availabilityTimeOffset;\n          } else if (baseUrl && baseUrl.availabilityTimeOffset !== undefined) {\n            voRepresentation.availabilityTimeOffset = baseUrl.availabilityTimeOffset;\n          }\n\n          if (segmentInfo.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_COMPLETE)) {\n            voRepresentation.availabilityTimeComplete = segmentInfo.availabilityTimeComplete !== 'false';\n          } else if (baseUrl && baseUrl.availabilityTimeComplete !== undefined) {\n            voRepresentation.availabilityTimeComplete = baseUrl.availabilityTimeComplete;\n          }\n        }\n\n        voRepresentation.MSETimeOffset = calcMSETimeOffset(voRepresentation);\n        voRepresentation.path = [voAdaptation.period.index, voAdaptation.index, i];\n        voRepresentations.push(voRepresentation);\n      }\n    }\n\n    return voRepresentations;\n  }\n\n  function calcSegmentDuration(segmentTimeline) {\n    var s0 = segmentTimeline.S_asArray[0];\n    var s1 = segmentTimeline.S_asArray[1];\n    return s0.hasOwnProperty('d') ? s0.d : s1.t - s0.t;\n  }\n\n  function calcMSETimeOffset(representation) {\n    // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n    var presentationOffset = representation.presentationTimeOffset;\n    var periodStart = representation.adaptation.period.start;\n    return periodStart - presentationOffset;\n  }\n\n  function getAdaptationsForPeriod(voPeriod) {\n    var realPeriod = voPeriod && isInteger(voPeriod.index) ? voPeriod.mpd.manifest.Period_asArray[voPeriod.index] : null;\n    var voAdaptations = [];\n    var voAdaptationSet = void 0,\n        realAdaptationSet = void 0,\n        i = void 0;\n\n    if (realPeriod && realPeriod.AdaptationSet_asArray) {\n      for (i = 0; i < realPeriod.AdaptationSet_asArray.length; i++) {\n        realAdaptationSet = realPeriod.AdaptationSet_asArray[i];\n        voAdaptationSet = new _AdaptationSet2.default();\n\n        if (realAdaptationSet.hasOwnProperty(_DashConstants2.default.ID)) {\n          voAdaptationSet.id = realAdaptationSet.id;\n        }\n\n        voAdaptationSet.index = i;\n        voAdaptationSet.period = voPeriod;\n\n        if (getIsMuxed(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.MUXED;\n        } else if (getIsAudio(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.AUDIO;\n        } else if (getIsVideo(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.VIDEO;\n        } else if (getIsFragmentedText(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.FRAGMENTED_TEXT;\n        } else if (getIsImage(realAdaptationSet)) {\n          voAdaptationSet.type = _Constants2.default.IMAGE;\n        } else {\n          voAdaptationSet.type = _Constants2.default.TEXT;\n        }\n\n        voAdaptations.push(voAdaptationSet);\n      }\n    }\n\n    return voAdaptations;\n  }\n\n  function getRegularPeriods(mpd) {\n    var isDynamic = mpd ? getIsDynamic(mpd.manifest) : false;\n    var voPeriods = [];\n    var realPreviousPeriod = null;\n    var realPeriod = null;\n    var voPreviousPeriod = null;\n    var voPeriod = null;\n    var len = void 0,\n        i = void 0;\n\n    for (i = 0, len = mpd && mpd.manifest && mpd.manifest.Period_asArray ? mpd.manifest.Period_asArray.length : 0; i < len; i++) {\n      realPeriod = mpd.manifest.Period_asArray[i]; // If the attribute @start is present in the Period, then the\n      // Period is a regular Period and the PeriodStart is equal\n      // to the value of this attribute.\n\n      if (realPeriod.hasOwnProperty(_DashConstants2.default.START)) {\n        voPeriod = new _Period2.default();\n        voPeriod.start = realPeriod.start;\n      } // If the @start attribute is absent, but the previous Period\n      // element contains a @duration attribute then then this new\n      // Period is also a regular Period. The start time of the new\n      // Period PeriodStart is the sum of the start time of the previous\n      // Period PeriodStart and the value of the attribute @duration\n      // of the previous Period.\n      else if (realPreviousPeriod !== null && realPreviousPeriod.hasOwnProperty(_DashConstants2.default.DURATION) && voPreviousPeriod !== null) {\n          voPeriod = new _Period2.default();\n          voPeriod.start = parseFloat((voPreviousPeriod.start + voPreviousPeriod.duration).toFixed(5));\n        } // If (i) @start attribute is absent, and (ii) the Period element\n        // is the first in the MPD, and (iii) the MPD@type is 'static',\n        // then the PeriodStart time shall be set to zero.\n        else if (i === 0 && !isDynamic) {\n            voPeriod = new _Period2.default();\n            voPeriod.start = 0;\n          } // The Period extends until the PeriodStart of the next Period.\n      // The difference between the PeriodStart time of a Period and\n      // the PeriodStart time of the following Period.\n\n\n      if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n        if (voPeriod !== null) {\n          voPreviousPeriod.duration = parseFloat((voPeriod.start - voPreviousPeriod.start).toFixed(5));\n        } else {\n          logger.warn('First period duration could not be calculated because lack of start and duration period properties. This will cause timing issues during playback');\n        }\n      }\n\n      if (voPeriod !== null) {\n        voPeriod.id = getPeriodId(realPeriod, i);\n        voPeriod.index = i;\n        voPeriod.mpd = mpd;\n\n        if (realPeriod.hasOwnProperty(_DashConstants2.default.DURATION)) {\n          voPeriod.duration = realPeriod.duration;\n        }\n\n        voPeriods.push(voPeriod);\n        realPreviousPeriod = realPeriod;\n        voPreviousPeriod = voPeriod;\n      }\n\n      realPeriod = null;\n      voPeriod = null;\n    }\n\n    if (voPeriods.length === 0) {\n      return voPeriods;\n    } // The last Period extends until the end of the Media Presentation.\n    // The difference between the PeriodStart time of the last Period\n    // and the mpd duration\n\n\n    if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n      voPreviousPeriod.duration = parseFloat((getEndTimeForLastPeriod(voPreviousPeriod) - voPreviousPeriod.start).toFixed(5));\n    }\n\n    return voPeriods;\n  }\n\n  function getPeriodId(realPeriod, i) {\n    if (!realPeriod) {\n      throw new Error('Period cannot be null or undefined');\n    }\n\n    var id = _Period2.default.DEFAULT_ID + '_' + i;\n\n    if (realPeriod.hasOwnProperty(_DashConstants2.default.ID) && realPeriod.id.length > 0 && realPeriod.id !== '__proto__') {\n      id = realPeriod.id;\n    }\n\n    return id;\n  }\n\n  function getMpd(manifest) {\n    var mpd = new _Mpd2.default();\n\n    if (manifest) {\n      mpd.manifest = manifest;\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.AVAILABILITY_START_TIME)) {\n        mpd.availabilityStartTime = new Date(manifest.availabilityStartTime.getTime());\n      } else {\n        if (manifest.loadedTime) {\n          mpd.availabilityStartTime = new Date(manifest.loadedTime.getTime());\n        }\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.AVAILABILITY_END_TIME)) {\n        mpd.availabilityEndTime = new Date(manifest.availabilityEndTime.getTime());\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.MINIMUM_UPDATE_PERIOD)) {\n        mpd.minimumUpdatePeriod = manifest.minimumUpdatePeriod;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.MEDIA_PRESENTATION_DURATION)) {\n        mpd.mediaPresentationDuration = manifest.mediaPresentationDuration;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.SUGGESTED_PRESENTATION_DELAY)) {\n        mpd.suggestedPresentationDelay = manifest.suggestedPresentationDelay;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.TIMESHIFT_BUFFER_DEPTH)) {\n        mpd.timeShiftBufferDepth = manifest.timeShiftBufferDepth;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.MAX_SEGMENT_DURATION)) {\n        mpd.maxSegmentDuration = manifest.maxSegmentDuration;\n      }\n\n      if (manifest.hasOwnProperty(_DashConstants2.default.PUBLISH_TIME)) {\n        mpd.publishTime = new Date(manifest.publishTime);\n      }\n    }\n\n    return mpd;\n  }\n\n  function checkConfig() {\n    if (!errHandler || !errHandler.hasOwnProperty('error')) {\n      throw new Error(_Constants2.default.MISSING_CONFIG_ERROR);\n    }\n  }\n\n  function getEndTimeForLastPeriod(voPeriod) {\n    checkConfig();\n    var isDynamic = getIsDynamic(voPeriod.mpd.manifest);\n    var periodEnd = void 0;\n\n    if (voPeriod.mpd.manifest.mediaPresentationDuration) {\n      periodEnd = voPeriod.mpd.manifest.mediaPresentationDuration;\n    } else if (voPeriod.duration) {\n      periodEnd = voPeriod.duration;\n    } else if (isDynamic) {\n      periodEnd = Number.POSITIVE_INFINITY;\n    } else {\n      errHandler.error(new _DashJSError2.default(_Errors2.default.MANIFEST_ERROR_ID_PARSE_CODE, 'Must have @mediaPresentationDuration on MPD or an explicit @duration on the last period.', voPeriod));\n    }\n\n    return periodEnd;\n  }\n\n  function getEventsForPeriod(period) {\n    var manifest = period && period.mpd && period.mpd.manifest ? period.mpd.manifest : null;\n    var periodArray = manifest ? manifest.Period_asArray : null;\n    var eventStreams = periodArray && period && isInteger(period.index) ? periodArray[period.index].EventStream_asArray : null;\n    var events = [];\n    var i = void 0,\n        j = void 0;\n\n    if (eventStreams) {\n      for (i = 0; i < eventStreams.length; i++) {\n        var eventStream = new _EventStream2.default();\n        eventStream.period = period;\n        eventStream.timescale = 1;\n\n        if (eventStreams[i].hasOwnProperty(_Constants2.default.SCHEME_ID_URI)) {\n          eventStream.schemeIdUri = eventStreams[i][_Constants2.default.SCHEME_ID_URI];\n        } else {\n          throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n        }\n\n        if (eventStreams[i].hasOwnProperty(_DashConstants2.default.TIMESCALE)) {\n          eventStream.timescale = eventStreams[i][_DashConstants2.default.TIMESCALE];\n        }\n\n        if (eventStreams[i].hasOwnProperty(_DashConstants2.default.VALUE)) {\n          eventStream.value = eventStreams[i][_DashConstants2.default.VALUE];\n        }\n\n        if (eventStreams[i].hasOwnProperty(_DashConstants2.default.PRESENTATION_TIME_OFFSET)) {\n          eventStream.presentationTimeOffset = eventStreams[i][_DashConstants2.default.PRESENTATION_TIME_OFFSET];\n        }\n\n        for (j = 0; eventStreams[i].Event_asArray && j < eventStreams[i].Event_asArray.length; j++) {\n          var currentMpdEvent = eventStreams[i].Event_asArray[j];\n          var event = new _Event2.default();\n          event.presentationTime = 0;\n          event.eventStream = eventStream;\n\n          if (currentMpdEvent.hasOwnProperty(_DashConstants2.default.PRESENTATION_TIME)) {\n            event.presentationTime = currentMpdEvent.presentationTime;\n            var presentationTimeOffset = eventStream.presentationTimeOffset ? eventStream.presentationTimeOffset / eventStream.timescale : 0;\n            event.calculatedPresentationTime = event.presentationTime / eventStream.timescale + period.start - presentationTimeOffset;\n          }\n\n          if (currentMpdEvent.hasOwnProperty(_DashConstants2.default.DURATION)) {\n            event.duration = currentMpdEvent.duration / eventStream.timescale;\n          }\n\n          if (currentMpdEvent.hasOwnProperty(_DashConstants2.default.ID)) {\n            event.id = currentMpdEvent.id;\n          }\n\n          if (currentMpdEvent.Signal && currentMpdEvent.Signal.Binary) {\n            // toString is used to manage both regular and namespaced tags\n            event.messageData = BASE64.decodeArray(currentMpdEvent.Signal.Binary.toString());\n          } else {\n            // From Cor.1: 'NOTE: this attribute is an alternative\n            // to specifying a complete XML element(s) in the Event.\n            // It is useful when an event leans itself to a compact\n            // string representation'.\n            event.messageData = currentMpdEvent.messageData || currentMpdEvent.__text;\n          }\n\n          events.push(event);\n        }\n      }\n    }\n\n    return events;\n  }\n\n  function getEventStreams(inbandStreams, representation) {\n    var eventStreams = [];\n    var i = void 0;\n    if (!inbandStreams) return eventStreams;\n\n    for (i = 0; i < inbandStreams.length; i++) {\n      var eventStream = new _EventStream2.default();\n      eventStream.timescale = 1;\n      eventStream.representation = representation;\n\n      if (inbandStreams[i].hasOwnProperty(_Constants2.default.SCHEME_ID_URI)) {\n        eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;\n      } else {\n        throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n      }\n\n      if (inbandStreams[i].hasOwnProperty(_DashConstants2.default.TIMESCALE)) {\n        eventStream.timescale = inbandStreams[i].timescale;\n      }\n\n      if (inbandStreams[i].hasOwnProperty(_DashConstants2.default.VALUE)) {\n        eventStream.value = inbandStreams[i].value;\n      }\n\n      eventStreams.push(eventStream);\n    }\n\n    return eventStreams;\n  }\n\n  function getEventStreamForAdaptationSet(manifest, adaptation) {\n    var inbandStreams = void 0,\n        periodArray = void 0,\n        adaptationArray = void 0;\n\n    if (manifest && manifest.Period_asArray && adaptation && adaptation.period && isInteger(adaptation.period.index)) {\n      periodArray = manifest.Period_asArray[adaptation.period.index];\n\n      if (periodArray && periodArray.AdaptationSet_asArray && isInteger(adaptation.index)) {\n        adaptationArray = periodArray.AdaptationSet_asArray[adaptation.index];\n\n        if (adaptationArray) {\n          inbandStreams = adaptationArray.InbandEventStream_asArray;\n        }\n      }\n    }\n\n    return getEventStreams(inbandStreams, null);\n  }\n\n  function getEventStreamForRepresentation(manifest, representation) {\n    var inbandStreams = void 0,\n        periodArray = void 0,\n        adaptationArray = void 0,\n        representationArray = void 0;\n\n    if (manifest && manifest.Period_asArray && representation && representation.adaptation && representation.adaptation.period && isInteger(representation.adaptation.period.index)) {\n      periodArray = manifest.Period_asArray[representation.adaptation.period.index];\n\n      if (periodArray && periodArray.AdaptationSet_asArray && isInteger(representation.adaptation.index)) {\n        adaptationArray = periodArray.AdaptationSet_asArray[representation.adaptation.index];\n\n        if (adaptationArray && adaptationArray.Representation_asArray && isInteger(representation.index)) {\n          representationArray = adaptationArray.Representation_asArray[representation.index];\n\n          if (representationArray) {\n            inbandStreams = representationArray.InbandEventStream_asArray;\n          }\n        }\n      }\n    }\n\n    return getEventStreams(inbandStreams, representation);\n  }\n\n  function getUTCTimingSources(manifest) {\n    var isDynamic = getIsDynamic(manifest);\n    var hasAST = manifest ? manifest.hasOwnProperty(_DashConstants2.default.AVAILABILITY_START_TIME) : false;\n    var utcTimingsArray = manifest ? manifest.UTCTiming_asArray : null;\n    var utcTimingEntries = []; // do not bother synchronizing the clock unless MPD is live,\n    // or it is static and has availabilityStartTime attribute\n\n    if (isDynamic || hasAST) {\n      if (utcTimingsArray) {\n        // the order is important here - 23009-1 states that the order\n        // in the manifest \"indicates relative preference, first having\n        // the highest, and the last the lowest priority\".\n        utcTimingsArray.forEach(function (utcTiming) {\n          var entry = new _UTCTiming2.default();\n\n          if (utcTiming.hasOwnProperty(_Constants2.default.SCHEME_ID_URI)) {\n            entry.schemeIdUri = utcTiming.schemeIdUri;\n          } else {\n            // entries of type DescriptorType with no schemeIdUri\n            // are meaningless. let's just ignore this entry and\n            // move on.\n            return;\n          } // this is (incorrectly) interpreted as a number - schema\n          // defines it as a string\n\n\n          if (utcTiming.hasOwnProperty(_DashConstants2.default.VALUE)) {\n            entry.value = utcTiming.value.toString();\n          } else {\n            // without a value, there's not a lot we can do with\n            // this entry. let's just ignore this one and move on\n            return;\n          } // we're not interested in the optional id or any other\n          // attributes which might be attached to the entry\n\n\n          utcTimingEntries.push(entry);\n        });\n      }\n    }\n\n    return utcTimingEntries;\n  }\n\n  function getBaseURLsFromElement(node) {\n    var baseUrls = []; // if node.BaseURL_asArray and node.baseUri are undefined entries\n    // will be [undefined] which entries.some will just skip\n\n    var entries = node.BaseURL_asArray || [node.baseUri];\n    var earlyReturn = false;\n    entries.some(function (entry) {\n      if (entry) {\n        var baseUrl = new _BaseURL2.default();\n        var text = entry.__text || entry;\n\n        if (urlUtils.isRelative(text)) {\n          // it doesn't really make sense to have relative and\n          // absolute URLs at the same level, or multiple\n          // relative URLs at the same level, so assume we are\n          // done from this level of the MPD\n          earlyReturn = true; // deal with the specific case where the MPD@BaseURL\n          // is specified and is relative. when no MPD@BaseURL\n          // entries exist, that case is handled by the\n          // [node.baseUri] in the entries definition.\n\n          if (node.baseUri) {\n            text = urlUtils.resolve(text, node.baseUri);\n          }\n        }\n\n        baseUrl.url = text; // serviceLocation is optional, but we need it in order\n        // to blacklist correctly. if it's not available, use\n        // anything unique since there's no relationship to any\n        // other BaseURL and, in theory, the url should be\n        // unique so use this instead.\n\n        if (entry.hasOwnProperty(_DashConstants2.default.SERVICE_LOCATION) && entry.serviceLocation.length) {\n          baseUrl.serviceLocation = entry.serviceLocation;\n        } else {\n          baseUrl.serviceLocation = text;\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.DVB_PRIORITY)) {\n          baseUrl.dvb_priority = entry[_DashConstants2.default.DVB_PRIORITY];\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.DVB_WEIGHT)) {\n          baseUrl.dvb_weight = entry[_DashConstants2.default.DVB_WEIGHT];\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_OFFSET)) {\n          baseUrl.availabilityTimeOffset = entry[_DashConstants2.default.AVAILABILITY_TIME_OFFSET];\n        }\n\n        if (entry.hasOwnProperty(_DashConstants2.default.AVAILABILITY_TIME_COMPLETE)) {\n          baseUrl.availabilityTimeComplete = entry[_DashConstants2.default.AVAILABILITY_TIME_COMPLETE] !== 'false';\n        }\n        /* NOTE: byteRange currently unused\n        */\n\n\n        baseUrls.push(baseUrl);\n        return earlyReturn;\n      }\n    });\n    return baseUrls;\n  }\n\n  function getLocation(manifest) {\n    if (manifest && manifest.hasOwnProperty(_Constants2.default.LOCATION)) {\n      // for now, do not support multiple Locations -\n      // just set Location to the first Location.\n      manifest.Location = manifest.Location_asArray[0];\n      return manifest.Location;\n    } // may well be undefined\n\n\n    return undefined;\n  }\n\n  function getPatchLocation(manifest) {\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.PATCH_LOCATION)) {\n      // only include support for single patch location currently\n      manifest.PatchLocation = manifest.PatchLocation_asArray[0];\n      return manifest.PatchLocation;\n    } // no patch location provided\n\n\n    return undefined;\n  }\n\n  function getSuggestedPresentationDelay(mpd) {\n    return mpd && mpd.hasOwnProperty(_DashConstants2.default.SUGGESTED_PRESENTATION_DELAY) ? mpd.suggestedPresentationDelay : null;\n  }\n\n  function getAvailabilityStartTime(mpd) {\n    return mpd && mpd.hasOwnProperty(_DashConstants2.default.AVAILABILITY_START_TIME) && mpd.availabilityStartTime !== null ? mpd.availabilityStartTime.getTime() : null;\n  }\n\n  function getServiceDescriptions(manifest) {\n    var serviceDescriptions = [];\n\n    if (manifest && manifest.hasOwnProperty(_DashConstants2.default.SERVICE_DESCRIPTION)) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = manifest.ServiceDescription_asArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var sd = _step.value; // Convert each of the properties defined in\n\n          var id = void 0,\n              schemeIdUri = void 0,\n              latency = void 0,\n              playbackRate = void 0;\n\n          for (var prop in sd) {\n            if (sd.hasOwnProperty(prop)) {\n              if (prop === _DashConstants2.default.ID) {\n                id = sd[prop];\n              } else if (prop === _DashConstants2.default.SERVICE_DESCRIPTION_SCOPE) {\n                schemeIdUri = sd[prop].schemeIdUri;\n              } else if (prop === _DashConstants2.default.SERVICE_DESCRIPTION_LATENCY) {\n                latency = {\n                  target: sd[prop].target,\n                  max: sd[prop].max,\n                  min: sd[prop].min\n                };\n              } else if (prop === _DashConstants2.default.SERVICE_DESCRIPTION_PLAYBACK_RATE) {\n                playbackRate = {\n                  max: sd[prop].max,\n                  min: sd[prop].min\n                };\n              }\n            }\n          } // we have a ServiceDescription for low latency. Add it if it really has parameters defined\n\n\n          if (schemeIdUri === _Constants2.default.SERVICE_DESCRIPTION_LL_SCHEME && (latency || playbackRate)) {\n            serviceDescriptions.push({\n              id: id,\n              schemeIdUri: schemeIdUri,\n              latency: latency,\n              playbackRate: playbackRate\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return serviceDescriptions;\n  }\n\n  function getSupplementalPropperties(adaptation) {\n    var supplementalProperties = {};\n\n    if (adaptation && adaptation.hasOwnProperty(_DashConstants2.default.SUPPLEMENTAL_PROPERTY)) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = adaptation.SupplementalProperty_asArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var sp = _step2.value;\n\n          if (sp.hasOwnProperty(_Constants2.default.SCHEME_ID_URI) && sp.hasOwnProperty(_DashConstants2.default.VALUE)) {\n            supplementalProperties[sp[_Constants2.default.SCHEME_ID_URI]] = sp[_DashConstants2.default.VALUE];\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return supplementalProperties;\n  }\n\n  function setConfig(config) {\n    if (!config) return;\n\n    if (config.errHandler) {\n      errHandler = config.errHandler;\n    }\n\n    if (config.BASE64) {\n      BASE64 = config.BASE64;\n    }\n  }\n\n  instance = {\n    getIsTypeOf: getIsTypeOf,\n    getIsTextTrack: getIsTextTrack,\n    getLanguageForAdaptation: getLanguageForAdaptation,\n    getViewpointForAdaptation: getViewpointForAdaptation,\n    getRolesForAdaptation: getRolesForAdaptation,\n    getAccessibilityForAdaptation: getAccessibilityForAdaptation,\n    getAudioChannelConfigurationForAdaptation: getAudioChannelConfigurationForAdaptation,\n    getAudioChannelConfigurationForRepresentation: getAudioChannelConfigurationForRepresentation,\n    getAdaptationForIndex: getAdaptationForIndex,\n    getIndexForAdaptation: getIndexForAdaptation,\n    getAdaptationForId: getAdaptationForId,\n    getAdaptationsForType: getAdaptationsForType,\n    getRealPeriods: getRealPeriods,\n    getRealPeriodForIndex: getRealPeriodForIndex,\n    getCodec: getCodec,\n    getMimeType: getMimeType,\n    getKID: getKID,\n    getLabelsForAdaptation: getLabelsForAdaptation,\n    getContentProtectionData: getContentProtectionData,\n    getIsDynamic: getIsDynamic,\n    getId: getId,\n    hasProfile: hasProfile,\n    getDuration: getDuration,\n    getBandwidth: getBandwidth,\n    getManifestUpdatePeriod: getManifestUpdatePeriod,\n    getPublishTime: getPublishTime,\n    getRepresentationCount: getRepresentationCount,\n    getBitrateListForAdaptation: getBitrateListForAdaptation,\n    getRepresentationFor: getRepresentationFor,\n    getRepresentationsForAdaptation: getRepresentationsForAdaptation,\n    getAdaptationsForPeriod: getAdaptationsForPeriod,\n    getRegularPeriods: getRegularPeriods,\n    getMpd: getMpd,\n    getEventsForPeriod: getEventsForPeriod,\n    getEssentialPropertiesForRepresentation: getEssentialPropertiesForRepresentation,\n    getEventStreamForAdaptationSet: getEventStreamForAdaptationSet,\n    getEventStreamForRepresentation: getEventStreamForRepresentation,\n    getUTCTimingSources: getUTCTimingSources,\n    getBaseURLsFromElement: getBaseURLsFromElement,\n    getRepresentationSortFunction: getRepresentationSortFunction,\n    getLocation: getLocation,\n    getPatchLocation: getPatchLocation,\n    getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n    getAvailabilityStartTime: getAvailabilityStartTime,\n    getServiceDescriptions: getServiceDescriptions,\n    getSupplementalPropperties: getSupplementalPropperties,\n    setConfig: setConfig\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nDashManifestModel.__dashjs_factory_name = 'DashManifestModel';\nexports.default = _FactoryMaker2.default.getSingletonFactory(DashManifestModel);","map":{"version":3,"sources":["../../../../../src/dash/models/DashManifestModel.js"],"names":["instance","logger","errHandler","BASE64","context","urlUtils","isInteger","Number","isFinite","Math","i","len","representation","col","mimeTypeRegEx","codecs","result","found","adaptation","type","Constants","essentialProperties","getEssentialPropertiesForRepresentation","THUMBNAILS_SCHEME_ID_URIS","DashConstants","getIsTypeOf","lang","a","b","realAdaptation","Array","getRepresentationSortFunction","manifest","realPeriods","getRealPeriods","realAdaptations","getRealAdaptations","objectUtils","adaptations","processAdaptation","codec","representationId","addResolutionInfo","labelArray","text","isDynamic","has","mpdDuration","latencyOfLastUpdate","delay","isNaN","processedRealAdaptation","realRepresentations","bandwidth","realRepresentation","width","height","scanType","id","schemeIdUri","prop","value","voAdaptation","periodArray","voRepresentations","getRealAdaptationFor","segmentInfo","baseUrl","baseUrls","getBaseURLsFromElement","voRepresentation","Representation","initialization","getIsTextTrack","calcSegmentDuration","calcMSETimeOffset","s0","segmentTimeline","s1","presentationOffset","periodStart","realPeriod","voPeriod","voAdaptations","voAdaptationSet","realAdaptationSet","AdaptationSet","getIsMuxed","getIsAudio","getIsVideo","getIsFragmentedText","getIsImage","mpd","getIsDynamic","voPeriods","realPreviousPeriod","voPreviousPeriod","Period","parseFloat","getPeriodId","getEndTimeForLastPeriod","Mpd","checkConfig","periodEnd","DashJSError","Errors","period","eventStreams","events","j","eventStream","EventStream","currentMpdEvent","event","Event","presentationTimeOffset","inbandStreams","adaptationArray","getEventStreams","representationArray","hasAST","utcTimingsArray","utcTimingEntries","entry","UTCTiming","utcTiming","entries","node","earlyReturn","BaseURL","serviceDescriptions","sd","latency","playbackRate","target","max","min","supplementalProperties","sp","config","getLanguageForAdaptation","getViewpointForAdaptation","getRolesForAdaptation","getAccessibilityForAdaptation","getAudioChannelConfigurationForAdaptation","getAudioChannelConfigurationForRepresentation","getAdaptationForIndex","getIndexForAdaptation","getAdaptationForId","getAdaptationsForType","getRealPeriodForIndex","getCodec","getMimeType","getKID","getLabelsForAdaptation","getContentProtectionData","getId","hasProfile","getDuration","getBandwidth","getManifestUpdatePeriod","getPublishTime","getRepresentationCount","getBitrateListForAdaptation","getRepresentationFor","getRepresentationsForAdaptation","getAdaptationsForPeriod","getRegularPeriods","getMpd","getEventsForPeriod","getEventStreamForAdaptationSet","getEventStreamForRepresentation","getUTCTimingSources","getLocation","getPatchLocation","getSuggestedPresentationDelay","getAvailabilityStartTime","getServiceDescriptions","getSupplementalPropperties","setConfig","setup","DashManifestModel","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../../streaming/constants/Constants';\nimport DashConstants from '../constants/DashConstants';\nimport Representation from '../vo/Representation';\nimport AdaptationSet from '../vo/AdaptationSet';\nimport Period from '../vo/Period';\nimport Mpd from '../vo/Mpd';\nimport UTCTiming from '../vo/UTCTiming';\nimport Event from '../vo/Event';\nimport BaseURL from '../vo/BaseURL';\nimport EventStream from '../vo/EventStream';\nimport ObjectUtils from '../../streaming/utils/ObjectUtils';\nimport URLUtils from '../../streaming/utils/URLUtils';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\nimport {THUMBNAILS_SCHEME_ID_URIS} from '../../streaming/thumbnail/ThumbnailTracks';\n\nfunction DashManifestModel() {\n    let instance,\n        logger,\n        errHandler,\n        BASE64;\n\n    const context = this.context;\n    const urlUtils = URLUtils(context).getInstance();\n\n    const isInteger = Number.isInteger || function (value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            Math.floor(value) === value;\n    };\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function getIsTypeOf(adaptation, type) {\n\n        let i,\n            len,\n            representation,\n            col,\n            mimeTypeRegEx,\n            codecs;\n        let result = false;\n        let found = false;\n\n        if (!adaptation) {\n            throw new Error('adaptation is not defined');\n        }\n\n        if (!type) {\n            throw new Error('type is not defined');\n        }\n\n        if (adaptation.hasOwnProperty('ContentComponent_asArray')) {\n            col = adaptation.ContentComponent_asArray;\n        }\n\n        mimeTypeRegEx = (type !== Constants.TEXT) ? new RegExp(type) : new RegExp('(vtt|ttml)');\n\n        if (adaptation.Representation_asArray && adaptation.Representation_asArray.length && adaptation.Representation_asArray.length > 0) {\n            let essentialProperties = getEssentialPropertiesForRepresentation(adaptation.Representation_asArray[0]);\n            if (essentialProperties && essentialProperties.length > 0 && THUMBNAILS_SCHEME_ID_URIS.indexOf(essentialProperties[0].schemeIdUri) >= 0) {\n                return type === Constants.IMAGE;\n            }\n            if (adaptation.Representation_asArray[0].hasOwnProperty(DashConstants.CODECS)) {\n                // Just check the start of the codecs string\n                codecs = adaptation.Representation_asArray[0].codecs;\n                if (codecs.search(Constants.STPP) === 0 || codecs.search(Constants.WVTT) === 0) {\n                    return type === Constants.FRAGMENTED_TEXT;\n                }\n            }\n        }\n\n        if (col) {\n            if (col.length > 1) {\n                return (type === Constants.MUXED);\n            } else if (col[0] && col[0].contentType === type) {\n                result = true;\n                found = true;\n            }\n        }\n\n        if (adaptation.hasOwnProperty(DashConstants.MIME_TYPE)) {\n            result = mimeTypeRegEx.test(adaptation.mimeType);\n            found = true;\n        }\n\n        // couldn't find on adaptationset, so check a representation\n        if (!found) {\n            i = 0;\n            len = adaptation.Representation_asArray && adaptation.Representation_asArray.length ? adaptation.Representation_asArray.length : 0;\n            while (!found && i < len) {\n                representation = adaptation.Representation_asArray[i];\n\n                if (representation.hasOwnProperty(DashConstants.MIME_TYPE)) {\n                    result = mimeTypeRegEx.test(representation.mimeType);\n                    found = true;\n                }\n\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    function getIsAudio(adaptation) {\n        return getIsTypeOf(adaptation, Constants.AUDIO);\n    }\n\n    function getIsVideo(adaptation) {\n        return getIsTypeOf(adaptation, Constants.VIDEO);\n    }\n\n    function getIsFragmentedText(adaptation) {\n        return getIsTypeOf(adaptation, Constants.FRAGMENTED_TEXT);\n    }\n\n    function getIsMuxed(adaptation) {\n        return getIsTypeOf(adaptation, Constants.MUXED);\n    }\n\n    function getIsImage(adaptation) {\n        return getIsTypeOf(adaptation, Constants.IMAGE);\n    }\n\n    function getIsTextTrack(type) {\n        return (type === 'text/vtt' || type === 'application/ttml+xml');\n    }\n\n    function getLanguageForAdaptation(adaptation) {\n        let lang = '';\n\n        if (adaptation && adaptation.hasOwnProperty(DashConstants.LANG)) {\n            //Filter out any other characters not allowed according to RFC5646\n            lang = adaptation.lang.replace(/[^A-Za-z0-9-]/g, '');\n        }\n\n        return lang;\n    }\n\n    function getViewpointForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.VIEWPOINT) ? adaptation.Viewpoint : null;\n    }\n\n    function getRolesForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.ROLE_ASARRAY) ? adaptation.Role_asArray : [];\n    }\n\n    function getAccessibilityForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.ACCESSIBILITY_ASARRAY) ? adaptation.Accessibility_asArray : [];\n    }\n\n    function getAudioChannelConfigurationForAdaptation(adaptation) {\n        return adaptation && adaptation.hasOwnProperty(DashConstants.AUDIOCHANNELCONFIGURATION_ASARRAY) ? adaptation.AudioChannelConfiguration_asArray : [];\n    }\n\n    function getAudioChannelConfigurationForRepresentation(representation) {\n        return representation && representation.hasOwnProperty(DashConstants.AUDIOCHANNELCONFIGURATION_ASARRAY) ? representation.AudioChannelConfiguration_asArray : [];\n    }\n\n    function getRepresentationSortFunction() {\n        return (a, b) => a.bandwidth - b.bandwidth;\n    }\n\n    function processAdaptation(realAdaptation) {\n        if (realAdaptation && Array.isArray(realAdaptation.Representation_asArray)) {\n            realAdaptation.Representation_asArray.sort(getRepresentationSortFunction());\n        }\n\n        return realAdaptation;\n    }\n\n    function getRealAdaptations(manifest, periodIndex) {\n        return manifest && manifest.Period_asArray && isInteger(periodIndex) ? manifest.Period_asArray[periodIndex] ? manifest.Period_asArray[periodIndex].AdaptationSet_asArray : [] : [];\n    }\n\n    function getRealPeriods(manifest) {\n        return manifest && manifest.Period_asArray ? manifest.Period_asArray : [];\n    }\n\n    function getRealPeriodForIndex(index, manifest) {\n        const realPeriods = getRealPeriods(manifest);\n        if (realPeriods.length > 0 && isInteger(index)) {\n            return realPeriods[index];\n        } else {\n            return null;\n        }\n    }\n\n    function getAdaptationForId(id, manifest, periodIndex) {\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n        let i,\n            len;\n\n        for (i = 0, len = realAdaptations.length; i < len; i++) {\n            if (realAdaptations[i].hasOwnProperty(DashConstants.ID) && realAdaptations[i].id === id) {\n                return realAdaptations[i];\n            }\n        }\n\n        return null;\n    }\n\n    function getAdaptationForIndex(index, manifest, periodIndex) {\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n        if (realAdaptations.length > 0 && isInteger(index)) {\n            return realAdaptations[index];\n        } else {\n            return null;\n        }\n    }\n\n    function getIndexForAdaptation(realAdaptation, manifest, periodIndex) {\n        if (!realAdaptation) {\n            return -1;\n        }\n\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n\n        for (let i = 0; i < realAdaptations.length; i++) {\n            let objectUtils = ObjectUtils(context).getInstance();\n            if (objectUtils.areEqual(realAdaptations[i], realAdaptation)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    function getAdaptationsForType(manifest, periodIndex, type) {\n        const realAdaptations = getRealAdaptations(manifest, periodIndex);\n        let i,\n            len;\n        const adaptations = [];\n\n        for (i = 0, len = realAdaptations.length; i < len; i++) {\n            if (getIsTypeOf(realAdaptations[i], type)) {\n                adaptations.push(processAdaptation(realAdaptations[i]));\n            }\n        }\n\n        return adaptations;\n    }\n\n    function getCodec(adaptation, representationId, addResolutionInfo) {\n        let codec = null;\n\n        if (adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0) {\n            const representation = isInteger(representationId) && representationId >= 0 && representationId < adaptation.Representation_asArray.length ?\n                adaptation.Representation_asArray[representationId] : adaptation.Representation_asArray[0];\n            if (representation) {\n                codec = representation.mimeType + ';codecs=\"' + representation.codecs + '\"';\n                if (addResolutionInfo && representation.width !== undefined) {\n                    codec += ';width=\"' + representation.width + '\";height=\"' + representation.height + '\"';\n                }\n            }\n        }\n\n        // If the codec contains a profiles parameter we remove it. Otherwise it will cause problems when checking for codec capabilities of the platform\n        if (codec) {\n            codec = codec.replace(/\\sprofiles=[^;]*/g, '');\n        }\n\n        return codec;\n    }\n\n    function getMimeType(adaptation) {\n        return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 ? adaptation.Representation_asArray[0].mimeType : null;\n    }\n\n    function getKID(adaptation) {\n        if (!adaptation || !adaptation.hasOwnProperty(DashConstants.CENC_DEFAULT_KID)) {\n            return null;\n        }\n        return adaptation[DashConstants.CENC_DEFAULT_KID];\n    }\n\n    function getLabelsForAdaptation(adaptation) {\n        if (!adaptation || !Array.isArray(adaptation.Label_asArray)) {\n            return [];\n        }\n\n        const labelArray = [];\n\n        for (let i = 0; i < adaptation.Label_asArray.length; i++) {\n            labelArray.push({\n                lang: adaptation.Label_asArray[i].lang,\n                text: adaptation.Label_asArray[i].__text || adaptation.Label_asArray[i]\n            });\n        }\n\n        return labelArray;\n    }\n\n    function getContentProtectionData(adaptation) {\n        if (!adaptation || !adaptation.hasOwnProperty(DashConstants.CONTENTPROTECTION_ASARRAY) || adaptation.ContentProtection_asArray.length === 0) {\n            return null;\n        }\n        return adaptation.ContentProtection_asArray;\n    }\n\n    function getIsDynamic(manifest) {\n        let isDynamic = false;\n        if (manifest && manifest.hasOwnProperty('type')) {\n            isDynamic = (manifest.type === DashConstants.DYNAMIC);\n        }\n        return isDynamic;\n    }\n\n    function getId(manifest) {\n        return (manifest && manifest[DashConstants.ID]) || null;\n    }\n\n    function hasProfile(manifest, profile) {\n        let has = false;\n\n        if (manifest && manifest.profiles && manifest.profiles.length > 0) {\n            has = (manifest.profiles.indexOf(profile) !== -1);\n        }\n\n        return has;\n    }\n\n    function getDuration(manifest) {\n        let mpdDuration;\n        //@mediaPresentationDuration specifies the duration of the entire Media Presentation.\n        //If the attribute is not present, the duration of the Media Presentation is unknown.\n        if (manifest && manifest.hasOwnProperty(DashConstants.MEDIA_PRESENTATION_DURATION)) {\n            mpdDuration = manifest.mediaPresentationDuration;\n        } else if (manifest && manifest.type == 'dynamic') {\n            mpdDuration = Number.POSITIVE_INFINITY;\n        } else {\n            mpdDuration = Number.MAX_SAFE_INTEGER || Number.MAX_VALUE;\n        }\n\n        return mpdDuration;\n    }\n\n    function getBandwidth(representation) {\n        return representation && representation.bandwidth ? representation.bandwidth : NaN;\n    }\n\n    function getManifestUpdatePeriod(manifest, latencyOfLastUpdate = 0) {\n        let delay = NaN;\n        if (manifest && manifest.hasOwnProperty(DashConstants.MINIMUM_UPDATE_PERIOD)) {\n            delay = manifest.minimumUpdatePeriod;\n        }\n        return isNaN(delay) ? delay : Math.max(delay - latencyOfLastUpdate, 1);\n    }\n\n    function getPublishTime(manifest) {\n        return manifest && manifest.hasOwnProperty(DashConstants.PUBLISH_TIME) ? new Date(manifest[DashConstants.PUBLISH_TIME]) : null;\n    }\n\n    function getRepresentationCount(adaptation) {\n        return adaptation && Array.isArray(adaptation.Representation_asArray) ? adaptation.Representation_asArray.length : 0;\n    }\n\n    function getBitrateListForAdaptation(realAdaptation) {\n        const processedRealAdaptation = processAdaptation(realAdaptation);\n        const realRepresentations = processedRealAdaptation && Array.isArray(processedRealAdaptation.Representation_asArray) ? processedRealAdaptation.Representation_asArray : [];\n\n        return realRepresentations.map((realRepresentation) => {\n            return {\n                bandwidth: realRepresentation.bandwidth,\n                width: realRepresentation.width || 0,\n                height: realRepresentation.height || 0,\n                scanType: realRepresentation.scanType || null,\n                id: realRepresentation.id || null\n            };\n        });\n    }\n\n    function getEssentialPropertiesForRepresentation(realRepresentation) {\n        if (!realRepresentation || !realRepresentation.EssentialProperty_asArray || !realRepresentation.EssentialProperty_asArray.length) return null;\n\n        return realRepresentation.EssentialProperty_asArray.map((prop) => {\n            return {\n                schemeIdUri: prop.schemeIdUri,\n                value: prop.value\n            };\n        });\n    }\n\n    function getRepresentationFor(index, adaptation) {\n        return adaptation && adaptation.Representation_asArray && adaptation.Representation_asArray.length > 0 &&\n        isInteger(index) ? adaptation.Representation_asArray[index] : null;\n    }\n\n    function getRealAdaptationFor(voAdaptation) {\n        if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n            const periodArray = voAdaptation.period.mpd.manifest.Period_asArray[voAdaptation.period.index];\n            if (periodArray && periodArray.AdaptationSet_asArray && isInteger(voAdaptation.index)) {\n                return processAdaptation(periodArray.AdaptationSet_asArray[voAdaptation.index]);\n            }\n        }\n    }\n\n    function getRepresentationsForAdaptation(voAdaptation) {\n        const voRepresentations = [];\n        const processedRealAdaptation = getRealAdaptationFor(voAdaptation);\n        let segmentInfo,\n            baseUrl;\n\n        if (processedRealAdaptation && processedRealAdaptation.Representation_asArray) {\n            // TODO: TO BE REMOVED. We should get just the baseUrl elements that affects to the representations\n            // that we are processing. Making it works properly will require much further changes and given\n            // parsing base Urls parameters is needed for our ultra low latency examples, we will\n            // keep this \"tricky\" code until the real (and good) solution comes\n            if (voAdaptation && voAdaptation.period && isInteger(voAdaptation.period.index)) {\n                const baseUrls = getBaseURLsFromElement(voAdaptation.period.mpd.manifest);\n                if (baseUrls) {\n                    baseUrl = baseUrls[0];\n                }\n            }\n            for (let i = 0, len = processedRealAdaptation.Representation_asArray.length; i < len; ++i) {\n                const realRepresentation = processedRealAdaptation.Representation_asArray[i];\n                const voRepresentation = new Representation();\n                voRepresentation.index = i;\n                voRepresentation.adaptation = voAdaptation;\n\n                if (realRepresentation.hasOwnProperty(DashConstants.ID)) {\n                    voRepresentation.id = realRepresentation.id;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.CODECS)) {\n                    voRepresentation.codecs = realRepresentation.codecs;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.CODEC_PRIVATE_DATA)) {\n                    voRepresentation.codecPrivateData = realRepresentation.codecPrivateData;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.BANDWITH)) {\n                    voRepresentation.bandwidth = realRepresentation.bandwidth;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.WIDTH)) {\n                    voRepresentation.width = realRepresentation.width;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.HEIGHT)) {\n                    voRepresentation.height = realRepresentation.height;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.SCAN_TYPE)) {\n                    voRepresentation.scanType = realRepresentation.scanType;\n                }\n                if (realRepresentation.hasOwnProperty(DashConstants.MAX_PLAYOUT_RATE)) {\n                    voRepresentation.maxPlayoutRate = realRepresentation.maxPlayoutRate;\n                }\n\n                if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_BASE)) {\n                    segmentInfo = realRepresentation.SegmentBase;\n                    voRepresentation.segmentInfoType = DashConstants.SEGMENT_BASE;\n                } else if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_LIST)) {\n                    segmentInfo = realRepresentation.SegmentList;\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.SEGMENT_TIMELINE)) {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_TIMELINE;\n                    } else {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_LIST;\n                    }\n                } else if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_TEMPLATE)) {\n                    segmentInfo = realRepresentation.SegmentTemplate;\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.SEGMENT_TIMELINE)) {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_TIMELINE;\n                    } else {\n                        voRepresentation.segmentInfoType = DashConstants.SEGMENT_TEMPLATE;\n                    }\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.INITIALIZATION_MINUS)) {\n                        voRepresentation.initialization = segmentInfo.initialization.split('$Bandwidth$')\n                            .join(realRepresentation.bandwidth).split('$RepresentationID$').join(realRepresentation.id);\n                    }\n                } else {\n                    voRepresentation.segmentInfoType = DashConstants.BASE_URL;\n                }\n\n                voRepresentation.essentialProperties = getEssentialPropertiesForRepresentation(realRepresentation);\n\n                if (segmentInfo) {\n                    if (segmentInfo.hasOwnProperty(DashConstants.INITIALIZATION)) {\n                        const initialization = segmentInfo.Initialization;\n\n                        if (initialization.hasOwnProperty(DashConstants.SOURCE_URL)) {\n                            voRepresentation.initialization = initialization.sourceURL;\n                        }\n\n                        if (initialization.hasOwnProperty(DashConstants.RANGE)) {\n                            voRepresentation.range = initialization.range;\n                            // initialization source url will be determined from\n                            // BaseURL when resolved at load time.\n                        }\n                    } else if (realRepresentation.hasOwnProperty(DashConstants.MIME_TYPE) && getIsTextTrack(realRepresentation.mimeType)) {\n                        voRepresentation.range = 0;\n                    }\n\n                    if (segmentInfo.hasOwnProperty(DashConstants.TIMESCALE)) {\n                        voRepresentation.timescale = segmentInfo.timescale;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.DURATION)) {\n                        // TODO according to the spec @maxSegmentDuration specifies the maximum duration of any Segment in any Representation in the Media Presentation\n                        // It is also said that for a SegmentTimeline any @d value shall not exceed the value of MPD@maxSegmentDuration, but nothing is said about\n                        // SegmentTemplate @duration attribute. We need to find out if @maxSegmentDuration should be used instead of calculated duration if the the duration\n                        // exceeds @maxSegmentDuration\n                        voRepresentation.segmentDuration = segmentInfo.duration / voRepresentation.timescale;\n                    } else if (realRepresentation.hasOwnProperty(DashConstants.SEGMENT_TEMPLATE)) {\n                        segmentInfo = realRepresentation.SegmentTemplate;\n\n                        if (segmentInfo.hasOwnProperty(DashConstants.SEGMENT_TIMELINE)) {\n                            voRepresentation.segmentDuration = calcSegmentDuration(segmentInfo.SegmentTimeline) / voRepresentation.timescale;\n                        }\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.MEDIA)) {\n                        voRepresentation.media = segmentInfo.media;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.START_NUMBER)) {\n                        voRepresentation.startNumber = segmentInfo.startNumber;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.INDEX_RANGE)) {\n                        voRepresentation.indexRange = segmentInfo.indexRange;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.PRESENTATION_TIME_OFFSET)) {\n                        voRepresentation.presentationTimeOffset = segmentInfo.presentationTimeOffset / voRepresentation.timescale;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.AVAILABILITY_TIME_OFFSET)) {\n                        voRepresentation.availabilityTimeOffset = segmentInfo.availabilityTimeOffset;\n                    } else if (baseUrl && baseUrl.availabilityTimeOffset !== undefined) {\n                        voRepresentation.availabilityTimeOffset = baseUrl.availabilityTimeOffset;\n                    }\n                    if (segmentInfo.hasOwnProperty(DashConstants.AVAILABILITY_TIME_COMPLETE)) {\n                        voRepresentation.availabilityTimeComplete = segmentInfo.availabilityTimeComplete !== 'false';\n                    } else if (baseUrl && baseUrl.availabilityTimeComplete !== undefined) {\n                        voRepresentation.availabilityTimeComplete = baseUrl.availabilityTimeComplete;\n                    }\n                }\n\n                voRepresentation.MSETimeOffset = calcMSETimeOffset(voRepresentation);\n                voRepresentation.path = [voAdaptation.period.index, voAdaptation.index, i];\n                voRepresentations.push(voRepresentation);\n            }\n        }\n\n        return voRepresentations;\n    }\n\n    function calcSegmentDuration(segmentTimeline) {\n        let s0 = segmentTimeline.S_asArray[0];\n        let s1 = segmentTimeline.S_asArray[1];\n        return s0.hasOwnProperty('d') ? s0.d : (s1.t - s0.t);\n    }\n\n    function calcMSETimeOffset(representation) {\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n        const presentationOffset = representation.presentationTimeOffset;\n        const periodStart = representation.adaptation.period.start;\n        return (periodStart - presentationOffset);\n    }\n\n    function getAdaptationsForPeriod(voPeriod) {\n        const realPeriod = voPeriod && isInteger(voPeriod.index) ? voPeriod.mpd.manifest.Period_asArray[voPeriod.index] : null;\n        const voAdaptations = [];\n        let voAdaptationSet,\n            realAdaptationSet,\n            i;\n\n        if (realPeriod && realPeriod.AdaptationSet_asArray) {\n            for (i = 0; i < realPeriod.AdaptationSet_asArray.length; i++) {\n                realAdaptationSet = realPeriod.AdaptationSet_asArray[i];\n                voAdaptationSet = new AdaptationSet();\n                if (realAdaptationSet.hasOwnProperty(DashConstants.ID)) {\n                    voAdaptationSet.id = realAdaptationSet.id;\n                }\n                voAdaptationSet.index = i;\n                voAdaptationSet.period = voPeriod;\n\n                if (getIsMuxed(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.MUXED;\n                } else if (getIsAudio(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.AUDIO;\n                } else if (getIsVideo(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.VIDEO;\n                } else if (getIsFragmentedText(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.FRAGMENTED_TEXT;\n                } else if (getIsImage(realAdaptationSet)) {\n                    voAdaptationSet.type = Constants.IMAGE;\n                } else {\n                    voAdaptationSet.type = Constants.TEXT;\n                }\n                voAdaptations.push(voAdaptationSet);\n            }\n        }\n\n        return voAdaptations;\n    }\n\n    function getRegularPeriods(mpd) {\n        const isDynamic = mpd ? getIsDynamic(mpd.manifest) : false;\n        const voPeriods = [];\n        let realPreviousPeriod = null;\n        let realPeriod = null;\n        let voPreviousPeriod = null;\n        let voPeriod = null;\n        let len,\n            i;\n\n        for (i = 0, len = mpd && mpd.manifest && mpd.manifest.Period_asArray ? mpd.manifest.Period_asArray.length : 0; i < len; i++) {\n            realPeriod = mpd.manifest.Period_asArray[i];\n\n            // If the attribute @start is present in the Period, then the\n            // Period is a regular Period and the PeriodStart is equal\n            // to the value of this attribute.\n            if (realPeriod.hasOwnProperty(DashConstants.START)) {\n                voPeriod = new Period();\n                voPeriod.start = realPeriod.start;\n            }\n            // If the @start attribute is absent, but the previous Period\n            // element contains a @duration attribute then then this new\n            // Period is also a regular Period. The start time of the new\n            // Period PeriodStart is the sum of the start time of the previous\n            // Period PeriodStart and the value of the attribute @duration\n            // of the previous Period.\n            else if (realPreviousPeriod !== null && realPreviousPeriod.hasOwnProperty(DashConstants.DURATION) && voPreviousPeriod !== null) {\n                voPeriod = new Period();\n                voPeriod.start = parseFloat((voPreviousPeriod.start + voPreviousPeriod.duration).toFixed(5));\n            }\n            // If (i) @start attribute is absent, and (ii) the Period element\n            // is the first in the MPD, and (iii) the MPD@type is 'static',\n            // then the PeriodStart time shall be set to zero.\n            else if (i === 0 && !isDynamic) {\n                voPeriod = new Period();\n                voPeriod.start = 0;\n            }\n\n            // The Period extends until the PeriodStart of the next Period.\n            // The difference between the PeriodStart time of a Period and\n            // the PeriodStart time of the following Period.\n            if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n                if (voPeriod !== null) {\n                    voPreviousPeriod.duration = parseFloat((voPeriod.start - voPreviousPeriod.start).toFixed(5));\n                } else {\n                    logger.warn('First period duration could not be calculated because lack of start and duration period properties. This will cause timing issues during playback');\n                }\n            }\n\n            if (voPeriod !== null) {\n                voPeriod.id = getPeriodId(realPeriod, i);\n                voPeriod.index = i;\n                voPeriod.mpd = mpd;\n\n                if (realPeriod.hasOwnProperty(DashConstants.DURATION)) {\n                    voPeriod.duration = realPeriod.duration;\n                }\n\n                voPeriods.push(voPeriod);\n                realPreviousPeriod = realPeriod;\n                voPreviousPeriod = voPeriod;\n            }\n\n            realPeriod = null;\n            voPeriod = null;\n        }\n\n        if (voPeriods.length === 0) {\n            return voPeriods;\n        }\n\n        // The last Period extends until the end of the Media Presentation.\n        // The difference between the PeriodStart time of the last Period\n        // and the mpd duration\n        if (voPreviousPeriod !== null && isNaN(voPreviousPeriod.duration)) {\n            voPreviousPeriod.duration = parseFloat((getEndTimeForLastPeriod(voPreviousPeriod) - voPreviousPeriod.start).toFixed(5));\n        }\n\n        return voPeriods;\n    }\n\n    function getPeriodId(realPeriod, i) {\n        if (!realPeriod) {\n            throw new Error('Period cannot be null or undefined');\n        }\n\n        let id = Period.DEFAULT_ID + '_' + i;\n\n        if (realPeriod.hasOwnProperty(DashConstants.ID) && realPeriod.id.length > 0 && realPeriod.id !== '__proto__') {\n            id = realPeriod.id;\n        }\n\n        return id;\n    }\n\n    function getMpd(manifest) {\n        const mpd = new Mpd();\n\n        if (manifest) {\n            mpd.manifest = manifest;\n\n            if (manifest.hasOwnProperty(DashConstants.AVAILABILITY_START_TIME)) {\n                mpd.availabilityStartTime = new Date(manifest.availabilityStartTime.getTime());\n            } else {\n                if (manifest.loadedTime) {\n                    mpd.availabilityStartTime = new Date(manifest.loadedTime.getTime());\n                }\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.AVAILABILITY_END_TIME)) {\n                mpd.availabilityEndTime = new Date(manifest.availabilityEndTime.getTime());\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.MINIMUM_UPDATE_PERIOD)) {\n                mpd.minimumUpdatePeriod = manifest.minimumUpdatePeriod;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.MEDIA_PRESENTATION_DURATION)) {\n                mpd.mediaPresentationDuration = manifest.mediaPresentationDuration;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.SUGGESTED_PRESENTATION_DELAY)) {\n                mpd.suggestedPresentationDelay = manifest.suggestedPresentationDelay;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.TIMESHIFT_BUFFER_DEPTH)) {\n                mpd.timeShiftBufferDepth = manifest.timeShiftBufferDepth;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.MAX_SEGMENT_DURATION)) {\n                mpd.maxSegmentDuration = manifest.maxSegmentDuration;\n            }\n\n            if (manifest.hasOwnProperty(DashConstants.PUBLISH_TIME)) {\n                mpd.publishTime = new Date(manifest.publishTime);\n            }\n        }\n\n        return mpd;\n    }\n\n    function checkConfig() {\n        if (!errHandler || !errHandler.hasOwnProperty('error')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getEndTimeForLastPeriod(voPeriod) {\n        checkConfig();\n        const isDynamic = getIsDynamic(voPeriod.mpd.manifest);\n\n        let periodEnd;\n        if (voPeriod.mpd.manifest.mediaPresentationDuration) {\n            periodEnd = voPeriod.mpd.manifest.mediaPresentationDuration;\n        } else if (voPeriod.duration) {\n            periodEnd = voPeriod.duration;\n        } else if (isDynamic) {\n            periodEnd = Number.POSITIVE_INFINITY;\n        } else {\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_PARSE_CODE, 'Must have @mediaPresentationDuration on MPD or an explicit @duration on the last period.', voPeriod));\n        }\n\n        return periodEnd;\n    }\n\n    function getEventsForPeriod(period) {\n        const manifest = period && period.mpd && period.mpd.manifest ? period.mpd.manifest : null;\n        const periodArray = manifest ? manifest.Period_asArray : null;\n        const eventStreams = periodArray && period && isInteger(period.index) ? periodArray[period.index].EventStream_asArray : null;\n        const events = [];\n        let i,\n            j;\n\n        if (eventStreams) {\n            for (i = 0; i < eventStreams.length; i++) {\n                const eventStream = new EventStream();\n                eventStream.period = period;\n                eventStream.timescale = 1;\n\n                if (eventStreams[i].hasOwnProperty(Constants.SCHEME_ID_URI)) {\n                    eventStream.schemeIdUri = eventStreams[i][Constants.SCHEME_ID_URI];\n                } else {\n                    throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n                }\n                if (eventStreams[i].hasOwnProperty(DashConstants.TIMESCALE)) {\n                    eventStream.timescale = eventStreams[i][DashConstants.TIMESCALE];\n                }\n                if (eventStreams[i].hasOwnProperty(DashConstants.VALUE)) {\n                    eventStream.value = eventStreams[i][DashConstants.VALUE];\n                }\n                if (eventStreams[i].hasOwnProperty(DashConstants.PRESENTATION_TIME_OFFSET)) {\n                    eventStream.presentationTimeOffset = eventStreams[i][DashConstants.PRESENTATION_TIME_OFFSET];\n                }\n                for (j = 0; eventStreams[i].Event_asArray && j < eventStreams[i].Event_asArray.length; j++) {\n                    const currentMpdEvent = eventStreams[i].Event_asArray[j];\n                    const event = new Event();\n                    event.presentationTime = 0;\n                    event.eventStream = eventStream;\n\n                    if (currentMpdEvent.hasOwnProperty(DashConstants.PRESENTATION_TIME)) {\n                        event.presentationTime = currentMpdEvent.presentationTime;\n                        const presentationTimeOffset = eventStream.presentationTimeOffset ? eventStream.presentationTimeOffset / eventStream.timescale : 0;\n                        event.calculatedPresentationTime = event.presentationTime / eventStream.timescale + period.start - presentationTimeOffset;\n                    }\n                    if (currentMpdEvent.hasOwnProperty(DashConstants.DURATION)) {\n                        event.duration = currentMpdEvent.duration / eventStream.timescale;\n                    }\n                    if (currentMpdEvent.hasOwnProperty(DashConstants.ID)) {\n                        event.id = currentMpdEvent.id;\n                    }\n\n                    if (currentMpdEvent.Signal && currentMpdEvent.Signal.Binary) {\n                        // toString is used to manage both regular and namespaced tags\n                        event.messageData = BASE64.decodeArray(currentMpdEvent.Signal.Binary.toString());\n                    } else {\n                        // From Cor.1: 'NOTE: this attribute is an alternative\n                        // to specifying a complete XML element(s) in the Event.\n                        // It is useful when an event leans itself to a compact\n                        // string representation'.\n                        event.messageData =\n                            currentMpdEvent.messageData ||\n                            currentMpdEvent.__text;\n                    }\n\n                    events.push(event);\n                }\n            }\n        }\n\n        return events;\n    }\n\n    function getEventStreams(inbandStreams, representation) {\n        const eventStreams = [];\n        let i;\n\n        if (!inbandStreams) return eventStreams;\n\n        for (i = 0; i < inbandStreams.length; i++) {\n            const eventStream = new EventStream();\n            eventStream.timescale = 1;\n            eventStream.representation = representation;\n\n            if (inbandStreams[i].hasOwnProperty(Constants.SCHEME_ID_URI)) {\n                eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;\n            } else {\n                throw new Error('Invalid EventStream. SchemeIdUri has to be set');\n            }\n            if (inbandStreams[i].hasOwnProperty(DashConstants.TIMESCALE)) {\n                eventStream.timescale = inbandStreams[i].timescale;\n            }\n            if (inbandStreams[i].hasOwnProperty(DashConstants.VALUE)) {\n                eventStream.value = inbandStreams[i].value;\n            }\n            eventStreams.push(eventStream);\n        }\n\n        return eventStreams;\n    }\n\n    function getEventStreamForAdaptationSet(manifest, adaptation) {\n        let inbandStreams,\n            periodArray,\n            adaptationArray;\n\n        if (manifest && manifest.Period_asArray && adaptation && adaptation.period && isInteger(adaptation.period.index)) {\n            periodArray = manifest.Period_asArray[adaptation.period.index];\n            if (periodArray && periodArray.AdaptationSet_asArray && isInteger(adaptation.index)) {\n                adaptationArray = periodArray.AdaptationSet_asArray[adaptation.index];\n                if (adaptationArray) {\n                    inbandStreams = adaptationArray.InbandEventStream_asArray;\n                }\n            }\n        }\n\n        return getEventStreams(inbandStreams, null);\n    }\n\n    function getEventStreamForRepresentation(manifest, representation) {\n        let inbandStreams,\n            periodArray,\n            adaptationArray,\n            representationArray;\n\n        if (manifest && manifest.Period_asArray && representation && representation.adaptation && representation.adaptation.period && isInteger(representation.adaptation.period.index)) {\n            periodArray = manifest.Period_asArray[representation.adaptation.period.index];\n            if (periodArray && periodArray.AdaptationSet_asArray && isInteger(representation.adaptation.index)) {\n                adaptationArray = periodArray.AdaptationSet_asArray[representation.adaptation.index];\n                if (adaptationArray && adaptationArray.Representation_asArray && isInteger(representation.index)) {\n                    representationArray = adaptationArray.Representation_asArray[representation.index];\n                    if (representationArray) {\n                        inbandStreams = representationArray.InbandEventStream_asArray;\n                    }\n                }\n            }\n        }\n\n        return getEventStreams(inbandStreams, representation);\n    }\n\n    function getUTCTimingSources(manifest) {\n        const isDynamic = getIsDynamic(manifest);\n        const hasAST = manifest ? manifest.hasOwnProperty(DashConstants.AVAILABILITY_START_TIME) : false;\n        const utcTimingsArray = manifest ? manifest.UTCTiming_asArray : null;\n        const utcTimingEntries = [];\n\n        // do not bother synchronizing the clock unless MPD is live,\n        // or it is static and has availabilityStartTime attribute\n        if ((isDynamic || hasAST)) {\n            if (utcTimingsArray) {\n                // the order is important here - 23009-1 states that the order\n                // in the manifest \"indicates relative preference, first having\n                // the highest, and the last the lowest priority\".\n                utcTimingsArray.forEach(function (utcTiming) {\n                    const entry = new UTCTiming();\n\n                    if (utcTiming.hasOwnProperty(Constants.SCHEME_ID_URI)) {\n                        entry.schemeIdUri = utcTiming.schemeIdUri;\n                    } else {\n                        // entries of type DescriptorType with no schemeIdUri\n                        // are meaningless. let's just ignore this entry and\n                        // move on.\n                        return;\n                    }\n\n                    // this is (incorrectly) interpreted as a number - schema\n                    // defines it as a string\n                    if (utcTiming.hasOwnProperty(DashConstants.VALUE)) {\n                        entry.value = utcTiming.value.toString();\n                    } else {\n                        // without a value, there's not a lot we can do with\n                        // this entry. let's just ignore this one and move on\n                        return;\n                    }\n\n                    // we're not interested in the optional id or any other\n                    // attributes which might be attached to the entry\n\n                    utcTimingEntries.push(entry);\n                });\n            }\n        }\n\n        return utcTimingEntries;\n    }\n\n    function getBaseURLsFromElement(node) {\n        const baseUrls = [];\n        // if node.BaseURL_asArray and node.baseUri are undefined entries\n        // will be [undefined] which entries.some will just skip\n        const entries = node.BaseURL_asArray || [node.baseUri];\n        let earlyReturn = false;\n\n        entries.some(entry => {\n            if (entry) {\n                const baseUrl = new BaseURL();\n                let text = entry.__text || entry;\n\n                if (urlUtils.isRelative(text)) {\n                    // it doesn't really make sense to have relative and\n                    // absolute URLs at the same level, or multiple\n                    // relative URLs at the same level, so assume we are\n                    // done from this level of the MPD\n                    earlyReturn = true;\n\n                    // deal with the specific case where the MPD@BaseURL\n                    // is specified and is relative. when no MPD@BaseURL\n                    // entries exist, that case is handled by the\n                    // [node.baseUri] in the entries definition.\n                    if (node.baseUri) {\n                        text = urlUtils.resolve(text, node.baseUri);\n                    }\n                }\n\n                baseUrl.url = text;\n\n                // serviceLocation is optional, but we need it in order\n                // to blacklist correctly. if it's not available, use\n                // anything unique since there's no relationship to any\n                // other BaseURL and, in theory, the url should be\n                // unique so use this instead.\n                if (entry.hasOwnProperty(DashConstants.SERVICE_LOCATION) &&\n                    entry.serviceLocation.length) {\n                    baseUrl.serviceLocation = entry.serviceLocation;\n                } else {\n                    baseUrl.serviceLocation = text;\n                }\n\n                if (entry.hasOwnProperty(DashConstants.DVB_PRIORITY)) {\n                    baseUrl.dvb_priority = entry[DashConstants.DVB_PRIORITY];\n                }\n\n                if (entry.hasOwnProperty(DashConstants.DVB_WEIGHT)) {\n                    baseUrl.dvb_weight = entry[DashConstants.DVB_WEIGHT];\n                }\n\n                if (entry.hasOwnProperty(DashConstants.AVAILABILITY_TIME_OFFSET)) {\n                    baseUrl.availabilityTimeOffset = entry[DashConstants.AVAILABILITY_TIME_OFFSET];\n                }\n\n                if (entry.hasOwnProperty(DashConstants.AVAILABILITY_TIME_COMPLETE)) {\n                    baseUrl.availabilityTimeComplete = entry[DashConstants.AVAILABILITY_TIME_COMPLETE] !== 'false';\n                }\n                /* NOTE: byteRange currently unused\n                 */\n\n                baseUrls.push(baseUrl);\n\n                return earlyReturn;\n            }\n        });\n\n        return baseUrls;\n    }\n\n    function getLocation(manifest) {\n        if (manifest && manifest.hasOwnProperty(Constants.LOCATION)) {\n            // for now, do not support multiple Locations -\n            // just set Location to the first Location.\n            manifest.Location = manifest.Location_asArray[0];\n\n            return manifest.Location;\n        }\n\n        // may well be undefined\n        return undefined;\n    }\n\n    function getPatchLocation(manifest) {\n        if (manifest && manifest.hasOwnProperty(DashConstants.PATCH_LOCATION)) {\n            // only include support for single patch location currently\n            manifest.PatchLocation = manifest.PatchLocation_asArray[0];\n\n            return manifest.PatchLocation;\n        }\n\n        // no patch location provided\n        return undefined;\n    }\n\n    function getSuggestedPresentationDelay(mpd) {\n        return mpd && mpd.hasOwnProperty(DashConstants.SUGGESTED_PRESENTATION_DELAY) ? mpd.suggestedPresentationDelay : null;\n    }\n\n    function getAvailabilityStartTime(mpd) {\n        return mpd && mpd.hasOwnProperty(DashConstants.AVAILABILITY_START_TIME) && mpd.availabilityStartTime !== null ? mpd.availabilityStartTime.getTime() : null;\n    }\n\n    function getServiceDescriptions(manifest) {\n        const serviceDescriptions = [];\n        if (manifest && manifest.hasOwnProperty(DashConstants.SERVICE_DESCRIPTION)) {\n            for (const sd of manifest.ServiceDescription_asArray) {\n                // Convert each of the properties defined in\n                let id, schemeIdUri, latency, playbackRate;\n                for (const prop in sd) {\n                    if (sd.hasOwnProperty(prop)) {\n                        if (prop === DashConstants.ID) {\n                            id = sd[prop];\n                        } else if (prop === DashConstants.SERVICE_DESCRIPTION_SCOPE) {\n                            schemeIdUri = sd[prop].schemeIdUri;\n                        } else if (prop === DashConstants.SERVICE_DESCRIPTION_LATENCY) {\n                            latency = {\n                                target: sd[prop].target,\n                                max: sd[prop].max,\n                                min: sd[prop].min\n                            };\n                        } else if (prop === DashConstants.SERVICE_DESCRIPTION_PLAYBACK_RATE) {\n                            playbackRate = {\n                                max: sd[prop].max,\n                                min: sd[prop].min\n                            };\n                        }\n                    }\n                }\n                // we have a ServiceDescription for low latency. Add it if it really has parameters defined\n                if (schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME && (latency || playbackRate)) {\n                    serviceDescriptions.push({\n                        id,\n                        schemeIdUri,\n                        latency,\n                        playbackRate\n                    });\n                }\n            }\n        }\n\n        return serviceDescriptions;\n    }\n\n    function getSupplementalPropperties(adaptation) {\n        const supplementalProperties = {};\n\n        if (adaptation && adaptation.hasOwnProperty(DashConstants.SUPPLEMENTAL_PROPERTY)) {\n            for (const sp of adaptation.SupplementalProperty_asArray) {\n                if (sp.hasOwnProperty(Constants.SCHEME_ID_URI) && sp.hasOwnProperty(DashConstants.VALUE)) {\n                    supplementalProperties[sp[Constants.SCHEME_ID_URI]] = sp[DashConstants.VALUE];\n                }\n            }\n        }\n        return supplementalProperties;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n\n        if (config.BASE64) {\n            BASE64 = config.BASE64;\n        }\n    }\n\n    instance = {\n        getIsTypeOf: getIsTypeOf,\n        getIsTextTrack: getIsTextTrack,\n        getLanguageForAdaptation: getLanguageForAdaptation,\n        getViewpointForAdaptation: getViewpointForAdaptation,\n        getRolesForAdaptation: getRolesForAdaptation,\n        getAccessibilityForAdaptation: getAccessibilityForAdaptation,\n        getAudioChannelConfigurationForAdaptation: getAudioChannelConfigurationForAdaptation,\n        getAudioChannelConfigurationForRepresentation: getAudioChannelConfigurationForRepresentation,\n        getAdaptationForIndex: getAdaptationForIndex,\n        getIndexForAdaptation: getIndexForAdaptation,\n        getAdaptationForId: getAdaptationForId,\n        getAdaptationsForType: getAdaptationsForType,\n        getRealPeriods,\n        getRealPeriodForIndex,\n        getCodec: getCodec,\n        getMimeType: getMimeType,\n        getKID: getKID,\n        getLabelsForAdaptation: getLabelsForAdaptation,\n        getContentProtectionData: getContentProtectionData,\n        getIsDynamic: getIsDynamic,\n        getId: getId,\n        hasProfile: hasProfile,\n        getDuration: getDuration,\n        getBandwidth: getBandwidth,\n        getManifestUpdatePeriod: getManifestUpdatePeriod,\n        getPublishTime: getPublishTime,\n        getRepresentationCount: getRepresentationCount,\n        getBitrateListForAdaptation: getBitrateListForAdaptation,\n        getRepresentationFor: getRepresentationFor,\n        getRepresentationsForAdaptation: getRepresentationsForAdaptation,\n        getAdaptationsForPeriod: getAdaptationsForPeriod,\n        getRegularPeriods: getRegularPeriods,\n        getMpd: getMpd,\n        getEventsForPeriod: getEventsForPeriod,\n        getEssentialPropertiesForRepresentation,\n        getEventStreamForAdaptationSet: getEventStreamForAdaptationSet,\n        getEventStreamForRepresentation: getEventStreamForRepresentation,\n        getUTCTimingSources: getUTCTimingSources,\n        getBaseURLsFromElement: getBaseURLsFromElement,\n        getRepresentationSortFunction: getRepresentationSortFunction,\n        getLocation: getLocation,\n        getPatchLocation: getPatchLocation,\n        getSuggestedPresentationDelay: getSuggestedPresentationDelay,\n        getAvailabilityStartTime: getAvailabilityStartTime,\n        getServiceDescriptions: getServiceDescriptions,\n        getSupplementalPropperties: getSupplementalPropperties,\n        setConfig: setConfig\n    };\n\n    setup();\n\n    return instance;\n}\n\nDashManifestModel.__dashjs_factory_name = 'DashManifestModel';\nexport default FactoryMaker.getSingletonFactory(DashManifestModel);\n"]},"metadata":{},"sourceType":"script"}