{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ProtectionKeyController = require('../controllers/ProtectionKeyController');\n\nvar _ProtectionKeyController2 = _interopRequireDefault(_ProtectionKeyController);\n\nvar _NeedKey = require('../vo/NeedKey');\n\nvar _NeedKey2 = _interopRequireDefault(_NeedKey);\n\nvar _DashJSError = require('../../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _KeyMessage = require('../vo/KeyMessage');\n\nvar _KeyMessage2 = _interopRequireDefault(_KeyMessage);\n\nvar _KeySystemConfiguration = require('../vo/KeySystemConfiguration');\n\nvar _KeySystemConfiguration2 = _interopRequireDefault(_KeySystemConfiguration);\n\nvar _KeySystemAccess = require('../vo/KeySystemAccess');\n\nvar _KeySystemAccess2 = _interopRequireDefault(_KeySystemAccess);\n\nvar _ProtectionErrors = require('../errors/ProtectionErrors');\n\nvar _ProtectionErrors2 = _interopRequireDefault(_ProtectionErrors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ProtectionModel_01b(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = config.eventBus; //Need to pass in here so we can use same instance since this is optional module\n\n  var events = config.events;\n  var debug = config.debug;\n  var api = config.api;\n  var errHandler = config.errHandler;\n  var instance = void 0,\n      logger = void 0,\n      videoElement = void 0,\n      keySystem = void 0,\n      protectionKeyController = void 0,\n      // With this version of the EME APIs, sessionIDs are not assigned to\n  // sessions until the first key message is received.  We are assuming\n  // that in the case of multiple sessions, key messages will be received\n  // in the order that generateKeyRequest() is called.\n  // Holding spot for newly-created sessions until we determine whether or\n  // not the CDM supports sessionIDs\n  pendingSessions = void 0,\n      // List of sessions that have been initialized.  Only the first position will\n  // be used in the case that the CDM does not support sessionIDs\n  sessions = void 0,\n      // Not all CDMs support the notion of sessionIDs.  Without sessionIDs\n  // there is no way for us to differentiate between sessions, therefore\n  // we must only allow a single session.  Once we receive the first key\n  // message we can set this flag to determine if more sessions are allowed\n  moreSessionsAllowed = void 0,\n      // This is our main event handler for all desired HTMLMediaElement events\n  // related to EME.  These events are translated into our API-independent\n  // versions of the same events\n  eventHandler = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    videoElement = null;\n    keySystem = null;\n    pendingSessions = [];\n    sessions = [];\n    protectionKeyController = (0, _ProtectionKeyController2.default)(context).getInstance();\n    eventHandler = createEventHandler();\n  }\n\n  function reset() {\n    if (videoElement) {\n      removeEventListeners();\n    }\n\n    for (var i = 0; i < sessions.length; i++) {\n      closeKeySession(sessions[i]);\n    }\n\n    eventBus.trigger(events.TEARDOWN_COMPLETE);\n  }\n\n  function getKeySystem() {\n    return keySystem;\n  }\n\n  function getAllInitData() {\n    var retVal = [];\n\n    for (var i = 0; i < pendingSessions.length; i++) {\n      retVal.push(pendingSessions[i].initData);\n    }\n\n    for (var _i = 0; _i < sessions.length; _i++) {\n      retVal.push(sessions[_i].initData);\n    }\n\n    return retVal;\n  }\n\n  function requestKeySystemAccess(ksConfigurations) {\n    var ve = videoElement;\n\n    if (!ve) {\n      // Must have a video element to do this capability tests\n      ve = document.createElement('video');\n    } // Try key systems in order, first one with supported key system configuration\n    // is used\n\n\n    var found = false;\n\n    for (var ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\n      var systemString = ksConfigurations[ksIdx].ks.systemString;\n      var configs = ksConfigurations[ksIdx].configs;\n      var supportedAudio = null;\n      var supportedVideo = null; // Try key system configs in order, first one with supported audio/video\n      // is used\n\n      for (var configIdx = 0; configIdx < configs.length; configIdx++) {\n        //let audios = configs[configIdx].audioCapabilities;\n        var videos = configs[configIdx].videoCapabilities; // Look for supported video container/codecs\n\n        if (videos && videos.length !== 0) {\n          supportedVideo = []; // Indicates that we have a requested video config\n\n          for (var videoIdx = 0; videoIdx < videos.length; videoIdx++) {\n            if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== '') {\n              supportedVideo.push(videos[videoIdx]);\n            }\n          }\n        } // No supported audio or video in this configuration OR we have\n        // requested audio or video configuration that is not supported\n\n\n        if (!supportedAudio && !supportedVideo || supportedAudio && supportedAudio.length === 0 || supportedVideo && supportedVideo.length === 0) {\n          continue;\n        } // This configuration is supported\n\n\n        found = true;\n        var ksConfig = new _KeySystemConfiguration2.default(supportedAudio, supportedVideo);\n        var ks = protectionKeyController.getKeySystemBySystemString(systemString);\n        eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n          data: new _KeySystemAccess2.default(ks, ksConfig)\n        });\n        break;\n      }\n    }\n\n    if (!found) {\n      eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n        error: 'Key system access denied! -- No valid audio/video content configurations detected!'\n      });\n    }\n  }\n\n  function selectKeySystem(keySystemAccess) {\n    keySystem = keySystemAccess.keySystem;\n    eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n  }\n\n  function setMediaElement(mediaElement) {\n    if (videoElement === mediaElement) {\n      return;\n    } // Replacing the previous element\n\n\n    if (videoElement) {\n      removeEventListeners(); // Close any open sessions - avoids memory leak on LG webOS 2016/2017 TVs\n\n      for (var i = 0; i < sessions.length; i++) {\n        closeKeySession(sessions[i]);\n      }\n\n      sessions = [];\n    }\n\n    videoElement = mediaElement; // Only if we are not detaching from the existing element\n\n    if (videoElement) {\n      videoElement.addEventListener(api.keyerror, eventHandler);\n      videoElement.addEventListener(api.needkey, eventHandler);\n      videoElement.addEventListener(api.keymessage, eventHandler);\n      videoElement.addEventListener(api.keyadded, eventHandler);\n      eventBus.trigger(events.VIDEO_ELEMENT_SELECTED);\n    }\n  }\n\n  function createKeySession(initData\n  /*, protData, keySystemType */\n  ) {\n    if (!keySystem) {\n      throw new Error('Can not create sessions until you have selected a key system');\n    } // Determine if creating a new session is allowed\n\n\n    if (moreSessionsAllowed || sessions.length === 0) {\n      var newSession = {\n        // Implements SessionToken\n        sessionID: null,\n        initData: initData,\n        getSessionID: function getSessionID() {\n          return this.sessionID;\n        },\n        getExpirationTime: function getExpirationTime() {\n          return NaN;\n        },\n        getSessionType: function getSessionType() {\n          return 'temporary';\n        }\n      };\n      pendingSessions.push(newSession); // Send our request to the CDM\n\n      videoElement[api.generateKeyRequest](keySystem.systemString, new Uint8Array(initData));\n      return newSession;\n    } else {\n      throw new Error('Multiple sessions not allowed!');\n    }\n  }\n\n  function updateKeySession(sessionToken, message) {\n    var sessionID = sessionToken.sessionID;\n\n    if (!protectionKeyController.isClearKey(keySystem)) {\n      // Send our request to the CDM\n      videoElement[api.addKey](keySystem.systemString, new Uint8Array(message), new Uint8Array(sessionToken.initData), sessionID);\n    } else {\n      // For clearkey, message is a ClearKeyKeySet\n      for (var i = 0; i < message.keyPairs.length; i++) {\n        videoElement[api.addKey](keySystem.systemString, message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID);\n      }\n    }\n  }\n\n  function closeKeySession(sessionToken) {\n    // Send our request to the CDM\n    try {\n      videoElement[api.cancelKeyRequest](keySystem.systemString, sessionToken.sessionID);\n    } catch (error) {\n      eventBus.trigger(events.KEY_SESSION_CLOSED, {\n        data: null,\n        error: 'Error closing session (' + sessionToken.sessionID + ') ' + error.message\n      });\n    }\n  }\n\n  function setServerCertificate()\n  /*serverCertificate*/\n  {\n    /* Not supported */\n  }\n\n  function loadKeySession()\n  /*sessionID*/\n  {\n    /* Not supported */\n  }\n\n  function removeKeySession()\n  /*sessionToken*/\n  {\n    /* Not supported */\n  }\n\n  function createEventHandler() {\n    return {\n      handleEvent: function handleEvent(event) {\n        var sessionToken = null;\n\n        switch (event.type) {\n          case api.needkey:\n            var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n            eventBus.trigger(events.NEED_KEY, {\n              key: new _NeedKey2.default(initData, 'cenc')\n            });\n            break;\n\n          case api.keyerror:\n            sessionToken = findSessionByID(sessions, event.sessionId);\n\n            if (!sessionToken) {\n              sessionToken = findSessionByID(pendingSessions, event.sessionId);\n            }\n\n            if (sessionToken) {\n              var code = _ProtectionErrors2.default.MEDIA_KEYERR_CODE;\n              var msg = '';\n\n              switch (event.errorCode.code) {\n                case 1:\n                  code = _ProtectionErrors2.default.MEDIA_KEYERR_UNKNOWN_CODE;\n                  msg += 'MEDIA_KEYERR_UNKNOWN - ' + _ProtectionErrors2.default.MEDIA_KEYERR_UNKNOWN_MESSAGE;\n                  break;\n\n                case 2:\n                  code = _ProtectionErrors2.default.MEDIA_KEYERR_CLIENT_CODE;\n                  msg += 'MEDIA_KEYERR_CLIENT - ' + _ProtectionErrors2.default.MEDIA_KEYERR_CLIENT_MESSAGE;\n                  break;\n\n                case 3:\n                  code = _ProtectionErrors2.default.MEDIA_KEYERR_SERVICE_CODE;\n                  msg += 'MEDIA_KEYERR_SERVICE - ' + _ProtectionErrors2.default.MEDIA_KEYERR_SERVICE_MESSAGE;\n                  break;\n\n                case 4:\n                  code = _ProtectionErrors2.default.MEDIA_KEYERR_OUTPUT_CODE;\n                  msg += 'MEDIA_KEYERR_OUTPUT - ' + _ProtectionErrors2.default.MEDIA_KEYERR_OUTPUT_MESSAGE;\n                  break;\n\n                case 5:\n                  code = _ProtectionErrors2.default.MEDIA_KEYERR_HARDWARECHANGE_CODE;\n                  msg += 'MEDIA_KEYERR_HARDWARECHANGE - ' + _ProtectionErrors2.default.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE;\n                  break;\n\n                case 6:\n                  code = _ProtectionErrors2.default.MEDIA_KEYERR_DOMAIN_CODE;\n                  msg += 'MEDIA_KEYERR_DOMAIN - ' + _ProtectionErrors2.default.MEDIA_KEYERR_DOMAIN_MESSAGE;\n                  break;\n              }\n\n              msg += '  System Code = ' + event.systemCode; // TODO: Build error string based on key error\n\n              eventBus.trigger(events.KEY_ERROR, {\n                data: new _DashJSError2.default(code, msg, sessionToken)\n              });\n            } else {\n              logger.error('No session token found for key error');\n            }\n\n            break;\n\n          case api.keyadded:\n            sessionToken = findSessionByID(sessions, event.sessionId);\n\n            if (!sessionToken) {\n              sessionToken = findSessionByID(pendingSessions, event.sessionId);\n            }\n\n            if (sessionToken) {\n              logger.debug('DRM: Key added.');\n              eventBus.trigger(events.KEY_ADDED, {\n                data: sessionToken\n              }); //TODO not sure anything is using sessionToken? why there?\n            } else {\n              logger.debug('No session token found for key added');\n            }\n\n            break;\n\n          case api.keymessage:\n            // If this CDM does not support session IDs, we will be limited\n            // to a single session\n            moreSessionsAllowed = event.sessionId !== null && event.sessionId !== undefined; // SessionIDs supported\n\n            if (moreSessionsAllowed) {\n              // Attempt to find an uninitialized token with this sessionID\n              sessionToken = findSessionByID(sessions, event.sessionId);\n\n              if (!sessionToken && pendingSessions.length > 0) {\n                // This is the first message for our latest session, so set the\n                // sessionID and add it to our list\n                sessionToken = pendingSessions.shift();\n                sessions.push(sessionToken);\n                sessionToken.sessionID = event.sessionId;\n                eventBus.trigger(events.KEY_SESSION_CREATED, {\n                  data: sessionToken\n                });\n              }\n            } else if (pendingSessions.length > 0) {\n              // SessionIDs not supported\n              sessionToken = pendingSessions.shift();\n              sessions.push(sessionToken);\n\n              if (pendingSessions.length !== 0) {\n                errHandler.error(new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEY_MESSAGE_ERROR_CODE, _ProtectionErrors2.default.MEDIA_KEY_MESSAGE_ERROR_MESSAGE));\n              }\n            }\n\n            if (sessionToken) {\n              var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message; // For ClearKey, the spec mandates that you pass this message to the\n              // addKey method, so we always save it to the token since there is no\n              // way to tell which key system is in use\n\n              sessionToken.keyMessage = message;\n              eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {\n                data: new _KeyMessage2.default(sessionToken, message, event.defaultURL)\n              });\n            } else {\n              logger.warn('No session token found for key message');\n            }\n\n            break;\n        }\n      }\n    };\n  }\n  /**\n  * Helper function to retrieve the stored session token based on a given\n  * sessionID value\n  *\n  * @param {Array} sessionArray - the array of sessions to search\n  * @param {*} sessionID - the sessionID to search for\n  * @returns {*} the session token with the given sessionID\n  */\n\n\n  function findSessionByID(sessionArray, sessionID) {\n    if (!sessionID || !sessionArray) {\n      return null;\n    } else {\n      var len = sessionArray.length;\n\n      for (var i = 0; i < len; i++) {\n        if (sessionArray[i].sessionID == sessionID) {\n          return sessionArray[i];\n        }\n      }\n\n      return null;\n    }\n  }\n\n  function removeEventListeners() {\n    videoElement.removeEventListener(api.keyerror, eventHandler);\n    videoElement.removeEventListener(api.needkey, eventHandler);\n    videoElement.removeEventListener(api.keymessage, eventHandler);\n    videoElement.removeEventListener(api.keyadded, eventHandler);\n  }\n\n  instance = {\n    getAllInitData: getAllInitData,\n    requestKeySystemAccess: requestKeySystemAccess,\n    getKeySystem: getKeySystem,\n    selectKeySystem: selectKeySystem,\n    setMediaElement: setMediaElement,\n    createKeySession: createKeySession,\n    updateKeySession: updateKeySession,\n    closeKeySession: closeKeySession,\n    setServerCertificate: setServerCertificate,\n    loadKeySession: loadKeySession,\n    removeKeySession: removeKeySession,\n    stop: reset,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Initial implementation of EME\n*\n* Implemented by Google Chrome prior to v36\n*\n* @implements ProtectionModel\n* @class\n*/\n\n\nProtectionModel_01b.__dashjs_factory_name = 'ProtectionModel_01b';\nexports.default = dashjs.FactoryMaker.getClassFactory(ProtectionModel_01b);\n/* jshint ignore:line */","map":{"version":3,"sources":["../../../../../../src/streaming/protection/models/ProtectionModel_01b.js"],"names":["config","context","eventBus","events","debug","api","errHandler","instance","logger","videoElement","keySystem","protectionKeyController","pendingSessions","sessions","moreSessionsAllowed","eventHandler","createEventHandler","removeEventListeners","i","closeKeySession","retVal","ve","document","found","ksIdx","ksConfigurations","systemString","configs","supportedAudio","supportedVideo","configIdx","videos","videoIdx","ksConfig","KeySystemConfiguration","ks","data","KeySystemAccess","error","keySystemAccess","initData","newSession","sessionID","getSessionID","getExpirationTime","getSessionType","sessionToken","message","handleEvent","event","ArrayBuffer","key","NeedKey","findSessionByID","code","ProtectionErrors","msg","DashJSError","KeyMessage","len","sessionArray","getAllInitData","requestKeySystemAccess","getKeySystem","selectKeySystem","setMediaElement","createKeySession","updateKeySession","setServerCertificate","loadKeySession","removeKeySession","stop","reset","setup","ProtectionModel_01b","dashjs"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Initial implementation of EME\n *\n * Implemented by Google Chrome prior to v36\n *\n * @implements ProtectionModel\n * @class\n */\nimport ProtectionKeyController from '../controllers/ProtectionKeyController';\nimport NeedKey from '../vo/NeedKey';\nimport DashJSError from '../../vo/DashJSError';\nimport KeyMessage from '../vo/KeyMessage';\nimport KeySystemConfiguration from '../vo/KeySystemConfiguration';\nimport KeySystemAccess from '../vo/KeySystemAccess';\nimport ProtectionErrors from '../errors/ProtectionErrors';\n\nfunction ProtectionModel_01b(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module\n    const events = config.events;\n    const debug = config.debug;\n    const api = config.api;\n    const errHandler = config.errHandler;\n\n    let instance,\n        logger,\n        videoElement,\n        keySystem,\n        protectionKeyController,\n\n        // With this version of the EME APIs, sessionIDs are not assigned to\n        // sessions until the first key message is received.  We are assuming\n        // that in the case of multiple sessions, key messages will be received\n        // in the order that generateKeyRequest() is called.\n        // Holding spot for newly-created sessions until we determine whether or\n        // not the CDM supports sessionIDs\n        pendingSessions,\n\n        // List of sessions that have been initialized.  Only the first position will\n        // be used in the case that the CDM does not support sessionIDs\n        sessions,\n\n        // Not all CDMs support the notion of sessionIDs.  Without sessionIDs\n        // there is no way for us to differentiate between sessions, therefore\n        // we must only allow a single session.  Once we receive the first key\n        // message we can set this flag to determine if more sessions are allowed\n        moreSessionsAllowed,\n\n        // This is our main event handler for all desired HTMLMediaElement events\n        // related to EME.  These events are translated into our API-independent\n        // versions of the same events\n        eventHandler;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        videoElement = null;\n        keySystem = null;\n        pendingSessions = [];\n        sessions = [];\n        protectionKeyController = ProtectionKeyController(context).getInstance();\n        eventHandler = createEventHandler();\n    }\n\n    function reset() {\n        if (videoElement) {\n            removeEventListeners();\n        }\n        for (let i = 0; i < sessions.length; i++) {\n            closeKeySession(sessions[i]);\n        }\n        eventBus.trigger(events.TEARDOWN_COMPLETE);\n    }\n\n    function getKeySystem() {\n        return keySystem;\n    }\n\n    function getAllInitData() {\n        const retVal = [];\n        for (let i = 0; i < pendingSessions.length; i++) {\n            retVal.push(pendingSessions[i].initData);\n        }\n        for (let i = 0; i < sessions.length; i++) {\n            retVal.push(sessions[i].initData);\n        }\n        return retVal;\n    }\n\n    function requestKeySystemAccess(ksConfigurations) {\n        let ve = videoElement;\n        if (!ve) { // Must have a video element to do this capability tests\n            ve = document.createElement('video');\n        }\n\n        // Try key systems in order, first one with supported key system configuration\n        // is used\n        let found = false;\n        for (let ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\n            const systemString = ksConfigurations[ksIdx].ks.systemString;\n            const configs = ksConfigurations[ksIdx].configs;\n            let supportedAudio = null;\n            let supportedVideo = null;\n\n            // Try key system configs in order, first one with supported audio/video\n            // is used\n            for (let configIdx = 0; configIdx < configs.length; configIdx++) {\n                //let audios = configs[configIdx].audioCapabilities;\n                const videos = configs[configIdx].videoCapabilities;\n                // Look for supported video container/codecs\n                if (videos && videos.length !== 0) {\n                    supportedVideo = []; // Indicates that we have a requested video config\n                    for (let videoIdx = 0; videoIdx < videos.length; videoIdx++) {\n                        if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== '') {\n                            supportedVideo.push(videos[videoIdx]);\n                        }\n                    }\n                }\n\n                // No supported audio or video in this configuration OR we have\n                // requested audio or video configuration that is not supported\n                if ((!supportedAudio && !supportedVideo) ||\n                    (supportedAudio && supportedAudio.length === 0) ||\n                    (supportedVideo && supportedVideo.length === 0)) {\n                    continue;\n                }\n\n                // This configuration is supported\n                found = true;\n                const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo);\n                const ks = protectionKeyController.getKeySystemBySystemString(systemString);\n                eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) });\n                break;\n            }\n        }\n        if (!found) {\n            eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Key system access denied! -- No valid audio/video content configurations detected!' });\n        }\n    }\n\n    function selectKeySystem(keySystemAccess) {\n        keySystem = keySystemAccess.keySystem;\n        eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n    }\n\n    function setMediaElement(mediaElement) {\n        if (videoElement === mediaElement) {\n            return;\n        }\n\n        // Replacing the previous element\n        if (videoElement) {\n            removeEventListeners();\n\n            // Close any open sessions - avoids memory leak on LG webOS 2016/2017 TVs\n            for (var i = 0; i < sessions.length; i++) {\n                closeKeySession(sessions[i]);\n            }\n            sessions = [];\n        }\n\n        videoElement = mediaElement;\n\n        // Only if we are not detaching from the existing element\n        if (videoElement) {\n            videoElement.addEventListener(api.keyerror, eventHandler);\n            videoElement.addEventListener(api.needkey, eventHandler);\n            videoElement.addEventListener(api.keymessage, eventHandler);\n            videoElement.addEventListener(api.keyadded, eventHandler);\n            eventBus.trigger(events.VIDEO_ELEMENT_SELECTED);\n        }\n    }\n\n    function createKeySession(initData /*, protData, keySystemType */) {\n        if (!keySystem) {\n            throw new Error('Can not create sessions until you have selected a key system');\n        }\n\n        // Determine if creating a new session is allowed\n        if (moreSessionsAllowed || sessions.length === 0) {\n            const newSession = { // Implements SessionToken\n                sessionID: null,\n                initData: initData,\n                getSessionID: function () {\n                    return this.sessionID;\n                },\n\n                getExpirationTime: function () {\n                    return NaN;\n                },\n\n                getSessionType: function () {\n                    return 'temporary';\n                }\n            };\n            pendingSessions.push(newSession);\n\n            // Send our request to the CDM\n            videoElement[api.generateKeyRequest](keySystem.systemString, new Uint8Array(initData));\n\n            return newSession;\n\n        } else {\n            throw new Error('Multiple sessions not allowed!');\n        }\n\n    }\n\n    function updateKeySession(sessionToken, message) {\n        const sessionID = sessionToken.sessionID;\n        if (!protectionKeyController.isClearKey(keySystem)) {\n            // Send our request to the CDM\n            videoElement[api.addKey](keySystem.systemString,\n                new Uint8Array(message), new Uint8Array(sessionToken.initData), sessionID);\n        } else {\n            // For clearkey, message is a ClearKeyKeySet\n            for (let i = 0; i < message.keyPairs.length; i++) {\n                videoElement[api.addKey](keySystem.systemString,\n                    message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID);\n            }\n        }\n    }\n\n    function closeKeySession(sessionToken) {\n        // Send our request to the CDM\n        try {\n            videoElement[api.cancelKeyRequest](keySystem.systemString, sessionToken.sessionID);\n        } catch (error) {\n            eventBus.trigger(events.KEY_SESSION_CLOSED, { data: null, error: 'Error closing session (' + sessionToken.sessionID + ') ' + error.message });\n        }\n    }\n\n    function setServerCertificate(/*serverCertificate*/) { /* Not supported */ }\n    function loadKeySession(/*sessionID*/) { /* Not supported */ }\n    function removeKeySession(/*sessionToken*/) { /* Not supported */ }\n\n    function createEventHandler() {\n        return {\n            handleEvent: function (event) {\n                let sessionToken = null;\n                switch (event.type) {\n                    case api.needkey:\n                        let initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                        eventBus.trigger(events.NEED_KEY, { key: new NeedKey(initData, 'cenc') });\n                        break;\n\n                    case api.keyerror:\n                        sessionToken = findSessionByID(sessions, event.sessionId);\n                        if (!sessionToken) {\n                            sessionToken = findSessionByID(pendingSessions, event.sessionId);\n                        }\n\n                        if (sessionToken) {\n                            let code = ProtectionErrors.MEDIA_KEYERR_CODE;\n                            let msg = '';\n                            switch (event.errorCode.code) {\n                                case 1:\n                                    code = ProtectionErrors.MEDIA_KEYERR_UNKNOWN_CODE;\n                                    msg += 'MEDIA_KEYERR_UNKNOWN - ' + ProtectionErrors.MEDIA_KEYERR_UNKNOWN_MESSAGE;\n                                    break;\n                                case 2:\n                                    code = ProtectionErrors.MEDIA_KEYERR_CLIENT_CODE;\n                                    msg += 'MEDIA_KEYERR_CLIENT - ' + ProtectionErrors.MEDIA_KEYERR_CLIENT_MESSAGE;\n                                    break;\n                                case 3:\n                                    code = ProtectionErrors.MEDIA_KEYERR_SERVICE_CODE;\n                                    msg += 'MEDIA_KEYERR_SERVICE - ' + ProtectionErrors.MEDIA_KEYERR_SERVICE_MESSAGE;\n                                    break;\n                                case 4:\n                                    code = ProtectionErrors.MEDIA_KEYERR_OUTPUT_CODE;\n                                    msg += 'MEDIA_KEYERR_OUTPUT - ' + ProtectionErrors.MEDIA_KEYERR_OUTPUT_MESSAGE;\n                                    break;\n                                case 5:\n                                    code = ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_CODE;\n                                    msg += 'MEDIA_KEYERR_HARDWARECHANGE - ' + ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE;\n                                    break;\n                                case 6:\n                                    code = ProtectionErrors.MEDIA_KEYERR_DOMAIN_CODE;\n                                    msg += 'MEDIA_KEYERR_DOMAIN - ' + ProtectionErrors.MEDIA_KEYERR_DOMAIN_MESSAGE;\n                                    break;\n                            }\n                            msg += '  System Code = ' + event.systemCode;\n                            // TODO: Build error string based on key error\n                            eventBus.trigger(events.KEY_ERROR, { data: new DashJSError(code, msg, sessionToken) });\n                        } else {\n                            logger.error('No session token found for key error');\n                        }\n                        break;\n\n                    case api.keyadded:\n                        sessionToken = findSessionByID(sessions, event.sessionId);\n                        if (!sessionToken) {\n                            sessionToken = findSessionByID(pendingSessions, event.sessionId);\n                        }\n\n                        if (sessionToken) {\n                            logger.debug('DRM: Key added.');\n                            eventBus.trigger(events.KEY_ADDED, { data: sessionToken });//TODO not sure anything is using sessionToken? why there?\n                        } else {\n                            logger.debug('No session token found for key added');\n                        }\n                        break;\n\n                    case api.keymessage:\n                        // If this CDM does not support session IDs, we will be limited\n                        // to a single session\n                        moreSessionsAllowed = (event.sessionId !== null) && (event.sessionId !== undefined);\n\n                        // SessionIDs supported\n                        if (moreSessionsAllowed) {\n                            // Attempt to find an uninitialized token with this sessionID\n                            sessionToken = findSessionByID(sessions, event.sessionId);\n                            if (!sessionToken && pendingSessions.length > 0) {\n\n                                // This is the first message for our latest session, so set the\n                                // sessionID and add it to our list\n                                sessionToken = pendingSessions.shift();\n                                sessions.push(sessionToken);\n                                sessionToken.sessionID = event.sessionId;\n\n                                eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken });\n                            }\n                        } else if (pendingSessions.length > 0) { // SessionIDs not supported\n                            sessionToken = pendingSessions.shift();\n                            sessions.push(sessionToken);\n\n                            if (pendingSessions.length !== 0) {\n                                errHandler.error(new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_MESSAGE));\n                            }\n                        }\n\n                        if (sessionToken) {\n                            let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n\n                            // For ClearKey, the spec mandates that you pass this message to the\n                            // addKey method, so we always save it to the token since there is no\n                            // way to tell which key system is in use\n                            sessionToken.keyMessage = message;\n                            eventBus.trigger(events.INTERNAL_KEY_MESSAGE, { data: new KeyMessage(sessionToken, message, event.defaultURL) });\n\n                        } else {\n                            logger.warn('No session token found for key message');\n                        }\n                        break;\n                }\n            }\n        };\n    }\n\n\n    /**\n     * Helper function to retrieve the stored session token based on a given\n     * sessionID value\n     *\n     * @param {Array} sessionArray - the array of sessions to search\n     * @param {*} sessionID - the sessionID to search for\n     * @returns {*} the session token with the given sessionID\n     */\n    function findSessionByID(sessionArray, sessionID) {\n        if (!sessionID || !sessionArray) {\n            return null;\n        } else {\n            const len = sessionArray.length;\n            for (let i = 0; i < len; i++) {\n                if (sessionArray[i].sessionID == sessionID) {\n                    return sessionArray[i];\n                }\n            }\n            return null;\n        }\n    }\n\n    function removeEventListeners() {\n        videoElement.removeEventListener(api.keyerror, eventHandler);\n        videoElement.removeEventListener(api.needkey, eventHandler);\n        videoElement.removeEventListener(api.keymessage, eventHandler);\n        videoElement.removeEventListener(api.keyadded, eventHandler);\n    }\n\n    instance = {\n        getAllInitData: getAllInitData,\n        requestKeySystemAccess: requestKeySystemAccess,\n        getKeySystem: getKeySystem,\n        selectKeySystem: selectKeySystem,\n        setMediaElement: setMediaElement,\n        createKeySession: createKeySession,\n        updateKeySession: updateKeySession,\n        closeKeySession: closeKeySession,\n        setServerCertificate: setServerCertificate,\n        loadKeySession: loadKeySession,\n        removeKeySession: removeKeySession,\n        stop: reset,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nProtectionModel_01b.__dashjs_factory_name = 'ProtectionModel_01b';\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionModel_01b); /* jshint ignore:line */\n"]},"metadata":{},"sourceType":"script"}