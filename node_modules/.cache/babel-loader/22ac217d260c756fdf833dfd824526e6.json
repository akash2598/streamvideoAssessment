{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FactoryMaker = require('../../core/FactoryMaker');\n\nvar _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);\n\nvar _Debug = require('../../core/Debug');\n\nvar _Debug2 = _interopRequireDefault(_Debug);\n\nvar _EventBus = require('../../core/EventBus');\n\nvar _EventBus2 = _interopRequireDefault(_EventBus);\n\nvar _MediaPlayerEvents = require('../../streaming/MediaPlayerEvents');\n\nvar _MediaPlayerEvents2 = _interopRequireDefault(_MediaPlayerEvents);\n\nvar _XHRLoader = require('../net/XHRLoader');\n\nvar _XHRLoader2 = _interopRequireDefault(_XHRLoader);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction EventController() {\n  var MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\n  var MPD_RELOAD_VALUE = 1;\n  var MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\n  var MPD_CALLBACK_VALUE = 1;\n  var REMAINING_EVENTS_THRESHOLD = 300;\n  var EVENT_HANDLED_STATES = {\n    DISCARDED: 'discarded',\n    UPDATED: 'updated',\n    ADDED: 'added'\n  };\n  var context = this.context;\n  var eventBus = (0, _EventBus2.default)(context).getInstance();\n  var instance = void 0,\n      logger = void 0,\n      inlineEvents = void 0,\n      // Holds all Inline Events not triggered yet\n  inbandEvents = void 0,\n      // Holds all Inband Events not triggered yet\n  eventInterval = void 0,\n      // variable holding the setInterval\n  lastEventTimerCall = void 0,\n      manifestUpdater = void 0,\n      playbackController = void 0,\n      settings = void 0,\n      eventHandlingInProgress = void 0,\n      isStarted = void 0;\n  /**\n  * Internal setup when class is instanced\n  */\n\n  function _setup() {\n    logger = (0, _Debug2.default)(context).getInstance().getLogger(instance);\n\n    _resetInitialSettings();\n  }\n  /**\n  * Checks if the provded configuration is valid\n  */\n\n\n  function checkConfig() {\n    if (!manifestUpdater || !playbackController) {\n      throw new Error('setConfig function has to be called previously');\n    }\n  }\n  /**\n  * Reset to initial settings\n  */\n\n\n  function _resetInitialSettings() {\n    isStarted = false;\n    inlineEvents = {}; // Format inlineEvents[schemeIdUri]\n\n    inbandEvents = {}; // Format inlineEvents[schemeIdUri]\n\n    eventInterval = null;\n    eventHandlingInProgress = false;\n    lastEventTimerCall = Date.now() / 1000;\n  }\n  /**\n  * Stops the EventController by clearing the event interval\n  */\n\n\n  function _stop() {\n    try {\n      if (eventInterval !== null && isStarted) {\n        clearInterval(eventInterval);\n        eventInterval = null;\n        isStarted = false;\n\n        _onStopEventController();\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Starts the interval function of the EventController\n  */\n\n\n  function start() {\n    try {\n      checkConfig();\n      logger.debug('Start Event Controller');\n      var refreshDelay = settings.get().streaming.eventControllerRefreshDelay;\n\n      if (!isStarted && !isNaN(refreshDelay)) {\n        isStarted = true;\n        eventInterval = setInterval(_onEventTimer, refreshDelay);\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Add MPD events to the list of events.\n  * Events that are not in the MPD anymore but not triggered yet will still be deleted.\n  * Existing events might get updated.\n  * @param {Array.<Object>} values\n  */\n\n\n  function addInlineEvents(values) {\n    try {\n      checkConfig();\n\n      if (values) {\n        for (var i = 0; i < values.length; i++) {\n          var event = values[i];\n\n          var result = _addOrUpdateEvent(event, inlineEvents, true);\n\n          if (result === EVENT_HANDLED_STATES.ADDED) {\n            logger.debug('Added inline event with id ' + event.id); // If we see the event for the first time we trigger it in onReceive mode\n\n            _startEvent(event, values, _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE);\n          } else if (result === EVENT_HANDLED_STATES.UPDATED) {\n            logger.debug('Updated inline event with id ' + event.id);\n          }\n        }\n      }\n\n      logger.debug('Added ' + values.length + ' inline events');\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Add EMSG events to the list of events\n  * Messages with the same id within the scope of the same scheme_id_uri and value pair are equivalent , i.e. processing of any one event message box with the same id is sufficient.\n  * @param {Array.<Object>} values\n  */\n\n\n  function addInbandEvents(values) {\n    try {\n      checkConfig();\n\n      for (var i = 0; i < values.length; i++) {\n        var event = values[i];\n\n        var result = _addOrUpdateEvent(event, inbandEvents, false);\n\n        if (result === EVENT_HANDLED_STATES.ADDED) {\n          if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\n            _handleManifestReloadEvent(event);\n          }\n\n          logger.debug('Added inband event with id ' + event.id);\n\n          _startEvent(event, values, _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE);\n        } else {\n          logger.debug('Inband event with scheme_id_uri ' + event.eventStream.schemeIdUri + ', value ' + event.eventStream.value + ' and id ' + event.id + ' was ignored because it has been added before.');\n        }\n      }\n\n      _onEventTimer();\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Adds or updates an event to/in the list of events\n  * @param {object} event\n  * @param {object} events\n  * @param {boolean} shouldOverwriteExistingEvents\n  * @return {string}\n  * @private\n  */\n\n\n  function _addOrUpdateEvent(event, events) {\n    var shouldOverwriteExistingEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var schemeIdUri = event.eventStream.schemeIdUri;\n    var value = event.eventStream.value;\n    var id = event.id;\n    var eventState = EVENT_HANDLED_STATES.DISCARDED;\n\n    if (!events[schemeIdUri]) {\n      events[schemeIdUri] = [];\n    }\n\n    var indexOfExistingEvent = events[schemeIdUri].findIndex(function (e) {\n      return (!value || e.eventStream.value && e.eventStream.value === value) && e.id === id;\n    });\n\n    if (indexOfExistingEvent === -1) {\n      events[schemeIdUri].push(event);\n      eventState = EVENT_HANDLED_STATES.ADDED;\n    } else if (shouldOverwriteExistingEvents) {\n      events[schemeIdUri][indexOfExistingEvent] = event;\n      eventState = EVENT_HANDLED_STATES.UPDATED;\n    }\n\n    return eventState;\n  }\n  /**\n  * Triggers an MPD reload\n  * @param {object} event\n  * @private\n  */\n\n\n  function _handleManifestReloadEvent(event) {\n    try {\n      if (event.eventStream.value == MPD_RELOAD_VALUE) {\n        var validUntil = event.calculatedPresentationTime;\n        var newDuration = void 0;\n\n        if (event.calculatedPresentationTime == 0xFFFFFFFF) {\n          //0xFF... means remaining duration unknown\n          newDuration = NaN;\n        } else {\n          newDuration = event.calculatedPresentationTime + event.duration;\n        } //logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\n\n\n        eventBus.trigger(_MediaPlayerEvents2.default.MANIFEST_VALIDITY_CHANGED, {\n          id: event.id,\n          validUntil: validUntil,\n          newDuration: newDuration,\n          newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\n\n        }, {\n          mode: _MediaPlayerEvents2.default.EVENT_MODE_ON_START\n        });\n      }\n    } catch (e) {}\n  }\n  /**\n  * Iterate through the eventList and trigger the events\n  */\n\n\n  function _onEventTimer() {\n    try {\n      if (!eventHandlingInProgress) {\n        eventHandlingInProgress = true;\n        var currentVideoTime = playbackController.getTime();\n        var presentationTimeThreshold = currentVideoTime - lastEventTimerCall; // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\n\n        presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\n\n        _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\n\n        _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\n\n        lastEventTimerCall = currentVideoTime;\n        eventHandlingInProgress = false;\n      }\n    } catch (e) {\n      eventHandlingInProgress = false;\n    }\n  }\n  /**\n  * When the EventController is stopped this callback is triggered. Starts the remaining events.\n  * @private\n  */\n\n\n  function _onStopEventController() {\n    try {\n      // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\n      _triggerRemainingEvents(inbandEvents);\n\n      _triggerRemainingEvents(inlineEvents);\n    } catch (e) {}\n  }\n  /**\n  * Iterate over a list of events and trigger the ones for which the presentation time is within the current timing interval\n  * @param {object} events\n  * @param {number} presentationTimeThreshold\n  * @param {number} currentVideoTime\n  * @private\n  */\n\n\n  function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\n    try {\n      var callback = function callback(event) {\n        if (event !== undefined) {\n          var duration = !isNaN(event.duration) ? event.duration : 0; // The event is either about to start or has already been started and we are within its duration\n\n          if (event.calculatedPresentationTime <= currentVideoTime && event.calculatedPresentationTime + presentationTimeThreshold + duration >= currentVideoTime) {\n            _startEvent(event, events, _MediaPlayerEvents2.default.EVENT_MODE_ON_START);\n          } else if (_eventHasExpired(currentVideoTime, duration + presentationTimeThreshold, event.calculatedPresentationTime) || _eventIsInvalid(event)) {\n            logger.debug('Deleting event ' + event.id + ' as it is expired or invalid');\n\n            _removeEvent(events, event);\n          }\n        }\n      };\n\n      _iterateAndTriggerCallback(events, callback);\n    } catch (e) {}\n  }\n  /**\n  * Triggers the remaining events after the EventController has been stopped\n  * @param {object} events\n  * @private\n  */\n\n\n  function _triggerRemainingEvents(events) {\n    try {\n      var currentTime = playbackController.getTime();\n\n      var callback = function callback(event) {\n        var periodDuration = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.duration) ? event.eventStream.period.duration : NaN;\n        var periodStart = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.start) ? event.eventStream.period.start : NaN;\n\n        if (isNaN(periodDuration) || isNaN(periodStart)) {\n          return;\n        }\n\n        var calculatedPresentationTimeInSeconds = event.calculatedPresentationTime;\n\n        if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\n          _startEvent(event, events, _MediaPlayerEvents2.default.EVENT_MODE_ON_START);\n        }\n      };\n\n      _iterateAndTriggerCallback(events, callback());\n    } catch (e) {}\n  }\n  /**\n  * Iterates over the inline/inband event object and triggers a callback for each event\n  * @param {object} events\n  * @param {function} callback\n  * @private\n  */\n\n\n  function _iterateAndTriggerCallback(events, callback) {\n    try {\n      if (events) {\n        var schemeIdUris = Object.keys(events);\n\n        for (var i = 0; i < schemeIdUris.length; i++) {\n          var schemeIdEvents = events[schemeIdUris[i]];\n          schemeIdEvents.forEach(function (event) {\n            if (event !== undefined) {\n              callback(event);\n            }\n          });\n        }\n      }\n    } catch (e) {}\n  }\n  /**\n  * Checks if an event is expired. For instance if the presentationTime + the duration of an event are smaller than the current video time.\n  * @param {number} currentVideoTime\n  * @param {number} threshold\n  * @param {number} calculatedPresentationTimeInSeconds\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _eventHasExpired(currentVideoTime, threshold, calculatedPresentationTimeInSeconds) {\n    try {\n      return currentVideoTime - threshold > calculatedPresentationTimeInSeconds;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Checks if an event is invalid. This is the case if the end time of the parent period is smaller than the presentation time of the event.\n  * @param {object} event\n  * @return {boolean}\n  * @private\n  */\n\n\n  function _eventIsInvalid(event) {\n    try {\n      var periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\n      return event.calculatedPresentationTime > periodEndTime;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n  * Starts an event. Depending on the schemeIdUri we distinguis between\n  * - MPD Reload events\n  * - MPD Callback events\n  * - Events to be dispatched to the application\n  * Events should be removed from the list before beeing triggered. Otherwise the event handler might cause an error and the remove function will not be called.\n  * @param {object} event\n  * @param {object} events\n  * @param {String} mode\n  * @private\n  */\n\n\n  function _startEvent(event, events, mode) {\n    try {\n      var currentVideoTime = playbackController.getTime();\n      var eventId = event.id;\n\n      if (mode === _MediaPlayerEvents2.default.EVENT_MODE_ON_RECEIVE) {\n        logger.debug('Received event ' + eventId);\n        eventBus.trigger(event.eventStream.schemeIdUri, {\n          event: event\n        }, {\n          mode: mode\n        });\n        return;\n      }\n\n      if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\n        if (event.duration !== 0 || event.presentationTimeDelta !== 0) {\n          //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\n          logger.debug('Starting manifest refresh event ' + eventId + ' at ' + currentVideoTime);\n\n          _removeEvent(events, event);\n\n          _refreshManifest();\n        }\n      } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\n        logger.debug('Starting callback event ' + eventId + ' at ' + currentVideoTime);\n\n        _removeEvent(events, event);\n\n        _sendCallbackRequest(event.messageData);\n      } else {\n        logger.debug('Starting event ' + eventId + ' at ' + currentVideoTime);\n\n        _removeEvent(events, event);\n\n        eventBus.trigger(event.eventStream.schemeIdUri, {\n          event: event\n        }, {\n          mode: mode\n        });\n      }\n    } catch (e) {}\n  }\n  /**\n  * Removes an event from the list. If this is the last event of type \"schemeIdUri\"  the corresponding schemeIdUri Object in the list of events is deleted.\n  * @param {object} events\n  * @param {object} event\n  * @private\n  */\n\n\n  function _removeEvent(events, event) {\n    var schemeIdUri = event.eventStream.schemeIdUri;\n    var value = event.eventStream.value;\n    var id = event.id;\n    events[schemeIdUri] = events[schemeIdUri].filter(function (e) {\n      return value && e.eventStream.value && e.eventStream.value !== value || e.id !== id;\n    });\n\n    if (events[schemeIdUri].length === 0) {\n      delete events[schemeIdUri];\n    }\n  }\n  /**\n  * Refresh the manifest\n  * @private\n  */\n\n\n  function _refreshManifest() {\n    try {\n      checkConfig();\n      manifestUpdater.refreshManifest();\n    } catch (e) {}\n  }\n  /**\n  * Send a callback request\n  * @param {String} url\n  * @private\n  */\n\n\n  function _sendCallbackRequest(url) {\n    try {\n      var loader = (0, _XHRLoader2.default)(context).create({});\n      loader.load({\n        method: 'get',\n        url: url,\n        request: {\n          responseType: 'arraybuffer'\n        }\n      });\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Set the config of the EventController\n  * @param {object} config\n  */\n\n\n  function setConfig(config) {\n    try {\n      if (!config) {\n        return;\n      }\n\n      if (config.manifestUpdater) {\n        manifestUpdater = config.manifestUpdater;\n      }\n\n      if (config.playbackController) {\n        playbackController = config.playbackController;\n      }\n\n      if (config.settings) {\n        settings = config.settings;\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n  /**\n  * Returns all inline events that have not been triggered yet\n  * @return {object}\n  */\n\n\n  function getInlineEvents() {\n    return inlineEvents;\n  }\n  /**\n  * Returns all inband events that have not been triggered yet\n  * @return {object}\n  */\n\n\n  function getInbandEvents() {\n    return inbandEvents;\n  }\n  /**\n  * Stop the EventController and reset all initial settings\n  */\n\n\n  function reset() {\n    _stop();\n\n    _resetInitialSettings();\n  }\n\n  instance = {\n    addInlineEvents: addInlineEvents,\n    addInbandEvents: addInbandEvents,\n    getInbandEvents: getInbandEvents,\n    getInlineEvents: getInlineEvents,\n    start: start,\n    setConfig: setConfig,\n    reset: reset\n  };\n\n  _setup();\n\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nEventController.__dashjs_factory_name = 'EventController';\nexports.default = _FactoryMaker2.default.getSingletonFactory(EventController);","map":{"version":3,"sources":["../../../../../src/streaming/controllers/EventController.js"],"names":["MPD_RELOAD_SCHEME","MPD_RELOAD_VALUE","MPD_CALLBACK_SCHEME","MPD_CALLBACK_VALUE","REMAINING_EVENTS_THRESHOLD","EVENT_HANDLED_STATES","DISCARDED","UPDATED","ADDED","context","eventBus","instance","logger","inlineEvents","inbandEvents","eventInterval","lastEventTimerCall","manifestUpdater","playbackController","settings","eventHandlingInProgress","isStarted","_resetInitialSettings","Date","clearInterval","_onStopEventController","checkConfig","refreshDelay","isNaN","setInterval","i","values","event","result","_addOrUpdateEvent","_startEvent","MediaPlayerEvents","_handleManifestReloadEvent","_onEventTimer","shouldOverwriteExistingEvents","schemeIdUri","value","id","eventState","events","indexOfExistingEvent","e","validUntil","newDuration","newManifestValidAfter","NaN","mode","currentVideoTime","presentationTimeThreshold","Math","_triggerEvents","_triggerRemainingEvents","callback","duration","_eventHasExpired","_eventIsInvalid","_removeEvent","_iterateAndTriggerCallback","currentTime","periodDuration","periodStart","calculatedPresentationTimeInSeconds","schemeIdUris","Object","schemeIdEvents","periodEndTime","eventId","_refreshManifest","_sendCallbackRequest","loader","method","url","request","responseType","config","_stop","addInlineEvents","addInbandEvents","getInbandEvents","getInlineEvents","start","setConfig","reset","_setup","EventController","FactoryMaker"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport EventBus from '../../core/EventBus';\nimport MediaPlayerEvents from '../../streaming/MediaPlayerEvents';\nimport XHRLoader from '../net/XHRLoader';\n\nfunction EventController() {\n\n    const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\n    const MPD_RELOAD_VALUE = 1;\n\n    const MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\n    const MPD_CALLBACK_VALUE = 1;\n\n    const REMAINING_EVENTS_THRESHOLD = 300;\n\n    const EVENT_HANDLED_STATES = {\n        DISCARDED: 'discarded',\n        UPDATED: 'updated',\n        ADDED: 'added'\n    };\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        inlineEvents, // Holds all Inline Events not triggered yet\n        inbandEvents, // Holds all Inband Events not triggered yet\n        eventInterval, // variable holding the setInterval\n        lastEventTimerCall,\n        manifestUpdater,\n        playbackController,\n        settings,\n        eventHandlingInProgress,\n        isStarted;\n\n    /**\n     * Internal setup when class is instanced\n     */\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n    }\n\n    /**\n     * Checks if the provded configuration is valid\n     */\n    function checkConfig() {\n        if (!manifestUpdater || !playbackController) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    /**\n     * Reset to initial settings\n     */\n    function _resetInitialSettings() {\n        isStarted = false;\n        inlineEvents = {}; // Format inlineEvents[schemeIdUri]\n        inbandEvents = {}; // Format inlineEvents[schemeIdUri]\n        eventInterval = null;\n        eventHandlingInProgress = false;\n        lastEventTimerCall = Date.now() / 1000;\n    }\n\n    /**\n     * Stops the EventController by clearing the event interval\n     */\n    function _stop() {\n        try {\n            if (eventInterval !== null && isStarted) {\n                clearInterval(eventInterval);\n                eventInterval = null;\n                isStarted = false;\n                _onStopEventController();\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Starts the interval function of the EventController\n     */\n    function start() {\n        try {\n            checkConfig();\n            logger.debug('Start Event Controller');\n            const refreshDelay = settings.get().streaming.eventControllerRefreshDelay;\n            if (!isStarted && !isNaN(refreshDelay)) {\n                isStarted = true;\n                eventInterval = setInterval(_onEventTimer, refreshDelay);\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add MPD events to the list of events.\n     * Events that are not in the MPD anymore but not triggered yet will still be deleted.\n     * Existing events might get updated.\n     * @param {Array.<Object>} values\n     */\n    function addInlineEvents(values) {\n        try {\n            checkConfig();\n\n            if (values) {\n                for (let i = 0; i < values.length; i++) {\n                    let event = values[i];\n                    let result = _addOrUpdateEvent(event, inlineEvents, true);\n\n                    if (result === EVENT_HANDLED_STATES.ADDED) {\n                        logger.debug(`Added inline event with id ${event.id}`);\n                        // If we see the event for the first time we trigger it in onReceive mode\n                        _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                    } else if (result === EVENT_HANDLED_STATES.UPDATED) {\n                        logger.debug(`Updated inline event with id ${event.id}`);\n                    }\n                }\n            }\n            logger.debug(`Added ${values.length} inline events`);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add EMSG events to the list of events\n     * Messages with the same id within the scope of the same scheme_id_uri and value pair are equivalent , i.e. processing of any one event message box with the same id is sufficient.\n     * @param {Array.<Object>} values\n     */\n    function addInbandEvents(values) {\n        try {\n            checkConfig();\n\n            for (let i = 0; i < values.length; i++) {\n                let event = values[i];\n                let result = _addOrUpdateEvent(event, inbandEvents, false);\n\n                if (result === EVENT_HANDLED_STATES.ADDED) {\n                    if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\n                        _handleManifestReloadEvent(event);\n                    }\n                    logger.debug('Added inband event with id ' + event.id);\n                    _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                } else {\n                    logger.debug(`Inband event with scheme_id_uri ${event.eventStream.schemeIdUri}, value ${event.eventStream.value} and id ${event.id} was ignored because it has been added before.`);\n                }\n            }\n            _onEventTimer();\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Adds or updates an event to/in the list of events\n     * @param {object} event\n     * @param {object} events\n     * @param {boolean} shouldOverwriteExistingEvents\n     * @return {string}\n     * @private\n     */\n    function _addOrUpdateEvent(event, events, shouldOverwriteExistingEvents = false) {\n        const schemeIdUri = event.eventStream.schemeIdUri;\n        const value = event.eventStream.value;\n        const id = event.id;\n        let eventState = EVENT_HANDLED_STATES.DISCARDED;\n\n        if (!events[schemeIdUri]) {\n            events[schemeIdUri] = [];\n        }\n\n        const indexOfExistingEvent = events[schemeIdUri].findIndex((e) => {\n            return ((!value || (e.eventStream.value && e.eventStream.value === value)) && (e.id === id));\n        });\n\n        if (indexOfExistingEvent === -1) {\n            events[schemeIdUri].push(event);\n            eventState = EVENT_HANDLED_STATES.ADDED;\n        } else if (shouldOverwriteExistingEvents) {\n            events[schemeIdUri][indexOfExistingEvent] = event;\n            eventState = EVENT_HANDLED_STATES.UPDATED;\n        }\n\n        return eventState;\n    }\n\n    /**\n     * Triggers an MPD reload\n     * @param {object} event\n     * @private\n     */\n    function _handleManifestReloadEvent(event) {\n        try {\n            if (event.eventStream.value == MPD_RELOAD_VALUE) {\n                const validUntil = event.calculatedPresentationTime;\n                let newDuration;\n                if (event.calculatedPresentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown\n                    newDuration = NaN;\n                } else {\n                    newDuration = event.calculatedPresentationTime + event.duration;\n                }\n                //logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\n                eventBus.trigger(MediaPlayerEvents.MANIFEST_VALIDITY_CHANGED, {\n                    id: event.id,\n                    validUntil: validUntil,\n                    newDuration: newDuration,\n                    newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\n                }, {\n                    mode: MediaPlayerEvents.EVENT_MODE_ON_START\n                });\n            }\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Iterate through the eventList and trigger the events\n     */\n    function _onEventTimer() {\n        try {\n            if (!eventHandlingInProgress) {\n                eventHandlingInProgress = true;\n                const currentVideoTime = playbackController.getTime();\n                let presentationTimeThreshold = (currentVideoTime - lastEventTimerCall);\n\n                // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\n                presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\n\n                _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\n                _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\n\n                lastEventTimerCall = currentVideoTime;\n                eventHandlingInProgress = false;\n            }\n        } catch (e) {\n            eventHandlingInProgress = false;\n        }\n    }\n\n    /**\n     * When the EventController is stopped this callback is triggered. Starts the remaining events.\n     * @private\n     */\n    function _onStopEventController() {\n        try {\n            // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\n            _triggerRemainingEvents(inbandEvents);\n            _triggerRemainingEvents(inlineEvents);\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Iterate over a list of events and trigger the ones for which the presentation time is within the current timing interval\n     * @param {object} events\n     * @param {number} presentationTimeThreshold\n     * @param {number} currentVideoTime\n     * @private\n     */\n    function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\n        try {\n            const callback = function (event) {\n                if (event !== undefined) {\n                    const duration = !isNaN(event.duration) ? event.duration : 0;\n                    // The event is either about to start or has already been started and we are within its duration\n                    if ((event.calculatedPresentationTime <= currentVideoTime && event.calculatedPresentationTime + presentationTimeThreshold + duration >= currentVideoTime)) {\n                        _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                    } else if (_eventHasExpired(currentVideoTime, duration + presentationTimeThreshold, event.calculatedPresentationTime) || _eventIsInvalid(event)) {\n                        logger.debug(`Deleting event ${event.id} as it is expired or invalid`);\n                        _removeEvent(events, event);\n                    }\n                }\n            };\n\n            _iterateAndTriggerCallback(events, callback);\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Triggers the remaining events after the EventController has been stopped\n     * @param {object} events\n     * @private\n     */\n    function _triggerRemainingEvents(events) {\n        try {\n            const currentTime = playbackController.getTime();\n            const callback = function (event) {\n                const periodDuration = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.duration) ? event.eventStream.period.duration : NaN;\n                const periodStart = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.start) ? event.eventStream.period.start : NaN;\n\n                if (isNaN(periodDuration) || isNaN(periodStart)) {\n                    return;\n                }\n\n                const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime;\n\n                if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\n                    _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                }\n\n            };\n\n            _iterateAndTriggerCallback(events, callback());\n\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Iterates over the inline/inband event object and triggers a callback for each event\n     * @param {object} events\n     * @param {function} callback\n     * @private\n     */\n    function _iterateAndTriggerCallback(events, callback) {\n        try {\n            if (events) {\n                const schemeIdUris = Object.keys(events);\n                for (let i = 0; i < schemeIdUris.length; i++) {\n                    const schemeIdEvents = events[schemeIdUris[i]];\n                    schemeIdEvents.forEach((event) => {\n                        if (event !== undefined) {\n                            callback(event);\n                        }\n                    });\n                }\n            }\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Checks if an event is expired. For instance if the presentationTime + the duration of an event are smaller than the current video time.\n     * @param {number} currentVideoTime\n     * @param {number} threshold\n     * @param {number} calculatedPresentationTimeInSeconds\n     * @return {boolean}\n     * @private\n     */\n    function _eventHasExpired(currentVideoTime, threshold, calculatedPresentationTimeInSeconds) {\n        try {\n            return currentVideoTime - threshold > calculatedPresentationTimeInSeconds;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if an event is invalid. This is the case if the end time of the parent period is smaller than the presentation time of the event.\n     * @param {object} event\n     * @return {boolean}\n     * @private\n     */\n    function _eventIsInvalid(event) {\n        try {\n            const periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\n\n            return event.calculatedPresentationTime > periodEndTime;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Starts an event. Depending on the schemeIdUri we distinguis between\n     * - MPD Reload events\n     * - MPD Callback events\n     * - Events to be dispatched to the application\n     * Events should be removed from the list before beeing triggered. Otherwise the event handler might cause an error and the remove function will not be called.\n     * @param {object} event\n     * @param {object} events\n     * @param {String} mode\n     * @private\n     */\n    function _startEvent(event, events, mode) {\n        try {\n            const currentVideoTime = playbackController.getTime();\n            const eventId = event.id;\n\n            if (mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE) {\n                logger.debug(`Received event ${eventId}`);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n                return;\n            }\n\n            if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\n                if (event.duration !== 0 || event.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\n                    logger.debug(`Starting manifest refresh event ${eventId} at ${currentVideoTime}`);\n                    _removeEvent(events, event);\n                    _refreshManifest();\n                }\n            } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\n                logger.debug(`Starting callback event ${eventId} at ${currentVideoTime}`);\n                _removeEvent(events, event);\n                _sendCallbackRequest(event.messageData);\n            } else {\n                logger.debug(`Starting event ${eventId} at ${currentVideoTime}`);\n                _removeEvent(events, event);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n            }\n\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Removes an event from the list. If this is the last event of type \"schemeIdUri\"  the corresponding schemeIdUri Object in the list of events is deleted.\n     * @param {object} events\n     * @param {object} event\n     * @private\n     */\n    function _removeEvent(events, event) {\n        const schemeIdUri = event.eventStream.schemeIdUri;\n        const value = event.eventStream.value;\n        const id = event.id;\n\n        events[schemeIdUri] = events[schemeIdUri].filter((e) => {\n            return (value && e.eventStream.value && e.eventStream.value !== value) || (e.id !== id);\n        });\n\n        if (events[schemeIdUri].length === 0) {\n            delete events[schemeIdUri];\n        }\n\n    }\n\n    /**\n     * Refresh the manifest\n     * @private\n     */\n    function _refreshManifest() {\n        try {\n            checkConfig();\n            manifestUpdater.refreshManifest();\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Send a callback request\n     * @param {String} url\n     * @private\n     */\n    function _sendCallbackRequest(url) {\n        try {\n            let loader = XHRLoader(context).create({});\n            loader.load({\n                method: 'get',\n                url: url,\n                request: {\n                    responseType: 'arraybuffer'\n                }\n            });\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Set the config of the EventController\n     * @param {object} config\n     */\n    function setConfig(config) {\n        try {\n            if (!config) {\n                return;\n            }\n            if (config.manifestUpdater) {\n                manifestUpdater = config.manifestUpdater;\n            }\n            if (config.playbackController) {\n                playbackController = config.playbackController;\n            }\n            if (config.settings) {\n                settings = config.settings;\n            }\n\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Returns all inline events that have not been triggered yet\n     * @return {object}\n     */\n    function getInlineEvents() {\n        return inlineEvents;\n    }\n\n    /**\n     * Returns all inband events that have not been triggered yet\n     * @return {object}\n     */\n    function getInbandEvents() {\n        return inbandEvents;\n    }\n\n    /**\n     * Stop the EventController and reset all initial settings\n     */\n    function reset() {\n        _stop();\n        _resetInitialSettings();\n    }\n\n    instance = {\n        addInlineEvents,\n        addInbandEvents,\n        getInbandEvents,\n        getInlineEvents,\n        start,\n        setConfig,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nEventController.__dashjs_factory_name = 'EventController';\nexport default FactoryMaker.getSingletonFactory(EventController);\n"]},"metadata":{},"sourceType":"script"}