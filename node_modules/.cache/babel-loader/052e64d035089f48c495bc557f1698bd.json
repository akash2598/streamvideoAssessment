{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ProtectionKeyController = require('../controllers/ProtectionKeyController');\n\nvar _ProtectionKeyController2 = _interopRequireDefault(_ProtectionKeyController);\n\nvar _NeedKey = require('../vo/NeedKey');\n\nvar _NeedKey2 = _interopRequireDefault(_NeedKey);\n\nvar _ProtectionErrors = require('../errors/ProtectionErrors');\n\nvar _ProtectionErrors2 = _interopRequireDefault(_ProtectionErrors);\n\nvar _DashJSError = require('../../vo/DashJSError');\n\nvar _DashJSError2 = _interopRequireDefault(_DashJSError);\n\nvar _KeyMessage = require('../vo/KeyMessage');\n\nvar _KeyMessage2 = _interopRequireDefault(_KeyMessage);\n\nvar _KeySystemAccess = require('../vo/KeySystemAccess');\n\nvar _KeySystemAccess2 = _interopRequireDefault(_KeySystemAccess);\n\nvar _ProtectionConstants = require('../../constants/ProtectionConstants');\n\nvar _ProtectionConstants2 = _interopRequireDefault(_ProtectionConstants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ProtectionModel_21Jan2015(config) {\n  config = config || {};\n  var context = this.context;\n  var eventBus = config.eventBus; //Need to pass in here so we can use same instance since this is optional module\n\n  var events = config.events;\n  var debug = config.debug;\n  var instance = void 0,\n      logger = void 0,\n      keySystem = void 0,\n      videoElement = void 0,\n      mediaKeys = void 0,\n      sessions = void 0,\n      eventHandler = void 0,\n      protectionKeyController = void 0;\n\n  function setup() {\n    logger = debug.getLogger(instance);\n    keySystem = null;\n    videoElement = null;\n    mediaKeys = null;\n    sessions = [];\n    protectionKeyController = (0, _ProtectionKeyController2.default)(context).getInstance();\n    eventHandler = createEventHandler();\n  }\n\n  function reset() {\n    var numSessions = sessions.length;\n    var session = void 0;\n\n    if (numSessions !== 0) {\n      (function () {\n        // Called when we are done closing a session.  Success or fail\n        var done = function done(session) {\n          removeSession(session);\n\n          if (sessions.length === 0) {\n            if (videoElement) {\n              videoElement.removeEventListener('encrypted', eventHandler);\n              videoElement.setMediaKeys(null).then(function () {\n                eventBus.trigger(events.TEARDOWN_COMPLETE);\n              });\n            } else {\n              eventBus.trigger(events.TEARDOWN_COMPLETE);\n            }\n          }\n        };\n\n        for (var i = 0; i < numSessions; i++) {\n          session = sessions[i];\n\n          (function (s) {\n            // Override closed promise resolver\n            session.session.closed.then(function () {\n              done(s);\n            }); // Close the session and handle errors, otherwise promise\n            // resolver above will be called\n\n            closeKeySessionInternal(session).catch(function () {\n              done(s);\n            });\n          })(session);\n        }\n      })();\n    } else {\n      eventBus.trigger(events.TEARDOWN_COMPLETE);\n    }\n  }\n\n  function stop() {\n    // Close and remove not usable sessions\n    var session = void 0;\n\n    for (var i = 0; i < sessions.length; i++) {\n      session = sessions[i];\n\n      if (!session.getUsable()) {\n        closeKeySessionInternal(session).catch(function () {\n          removeSession(session);\n        });\n      }\n    }\n  }\n\n  function getKeySystem() {\n    return keySystem;\n  }\n\n  function getAllInitData() {\n    var retVal = [];\n\n    for (var i = 0; i < sessions.length; i++) {\n      if (sessions[i].initData) {\n        retVal.push(sessions[i].initData);\n      }\n    }\n\n    return retVal;\n  }\n\n  function requestKeySystemAccess(ksConfigurations) {\n    requestKeySystemAccessInternal(ksConfigurations, 0);\n  }\n\n  function selectKeySystem(keySystemAccess) {\n    keySystemAccess.mksa.createMediaKeys().then(function (mkeys) {\n      keySystem = keySystemAccess.keySystem;\n      mediaKeys = mkeys;\n\n      if (videoElement) {\n        videoElement.setMediaKeys(mediaKeys).then(function () {\n          eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n        });\n      } else {\n        eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n      }\n    }).catch(function () {\n      eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, {\n        error: 'Error selecting keys system (' + keySystemAccess.keySystem.systemString + ')! Could not create MediaKeys -- TODO'\n      });\n    });\n  }\n\n  function setMediaElement(mediaElement) {\n    if (videoElement === mediaElement) return; // Replacing the previous element\n\n    if (videoElement) {\n      videoElement.removeEventListener('encrypted', eventHandler);\n\n      if (videoElement.setMediaKeys) {\n        videoElement.setMediaKeys(null);\n      }\n    }\n\n    videoElement = mediaElement; // Only if we are not detaching from the existing element\n\n    if (videoElement) {\n      videoElement.addEventListener('encrypted', eventHandler);\n\n      if (videoElement.setMediaKeys && mediaKeys) {\n        videoElement.setMediaKeys(mediaKeys);\n      }\n    }\n  }\n\n  function setServerCertificate(serverCertificate) {\n    if (!keySystem || !mediaKeys) {\n      throw new Error('Can not set server certificate until you have selected a key system');\n    }\n\n    mediaKeys.setServerCertificate(serverCertificate).then(function () {\n      logger.info('DRM: License server certificate successfully updated.');\n      eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED);\n    }).catch(function (error) {\n      eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED, {\n        error: new _DashJSError2.default(_ProtectionErrors2.default.SERVER_CERTIFICATE_UPDATED_ERROR_CODE, _ProtectionErrors2.default.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE + error.name)\n      });\n    });\n  }\n\n  function createKeySession(initData, protData, sessionType) {\n    if (!keySystem || !mediaKeys) {\n      throw new Error('Can not create sessions until you have selected a key system');\n    }\n\n    var session = mediaKeys.createSession(sessionType);\n    var sessionToken = createSessionToken(session, initData, sessionType);\n    var ks = this.getKeySystem(); // Generate initial key request.\n    // keyids type is used for clearkey when keys are provided directly in the protection data and then request to a license server is not needed\n\n    var dataType = ks.systemString === _ProtectionConstants2.default.CLEARKEY_KEYSTEM_STRING && (initData || protData && protData.clearkeys) ? 'keyids' : 'cenc';\n    session.generateRequest(dataType, initData).then(function () {\n      logger.debug('DRM: Session created.  SessionID = ' + sessionToken.getSessionID());\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: sessionToken\n      });\n    }).catch(function (error) {\n      // TODO: Better error string\n      removeSession(sessionToken);\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: null,\n        error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Error generating key request -- ' + error.name)\n      });\n    });\n  }\n\n  function updateKeySession(sessionToken, message) {\n    var session = sessionToken.session; // Send our request to the key session\n\n    if (protectionKeyController.isClearKey(keySystem)) {\n      message = message.toJWK();\n    }\n\n    session.update(message).catch(function (error) {\n      eventBus.trigger(events.KEY_ERROR, {\n        data: new _DashJSError2.default(_ProtectionErrors2.default.MEDIA_KEYERR_CODE, 'Error sending update() message! ' + error.name, sessionToken)\n      });\n    });\n  }\n\n  function loadKeySession(sessionID, initData, sessionType) {\n    if (!keySystem || !mediaKeys) {\n      throw new Error('Can not load sessions until you have selected a key system');\n    } // Check if session Id is not already loaded or loading\n\n\n    for (var i = 0; i < sessions.length; i++) {\n      if (sessionID === sessions[i].sessionId) {\n        logger.warn('DRM: Ignoring session ID because we have already seen it!');\n        return;\n      }\n    }\n\n    var session = mediaKeys.createSession(sessionType);\n    var sessionToken = createSessionToken(session, initData, sessionType, sessionID); // Load persisted session data into our newly created session object\n\n    session.load(sessionID).then(function (success) {\n      if (success) {\n        logger.debug('DRM: Session loaded.  SessionID = ' + sessionToken.getSessionID());\n        eventBus.trigger(events.KEY_SESSION_CREATED, {\n          data: sessionToken\n        });\n      } else {\n        removeSession(sessionToken);\n        eventBus.trigger(events.KEY_SESSION_CREATED, {\n          data: null,\n          error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session! Invalid Session ID (' + sessionID + ')')\n        });\n      }\n    }).catch(function (error) {\n      removeSession(sessionToken);\n      eventBus.trigger(events.KEY_SESSION_CREATED, {\n        data: null,\n        error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_CODE, _ProtectionErrors2.default.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session (' + sessionID + ')! ' + error.name)\n      });\n    });\n  }\n\n  function removeKeySession(sessionToken) {\n    var session = sessionToken.session;\n    session.remove().then(function () {\n      logger.debug('DRM: Session removed.  SessionID = ' + sessionToken.getSessionID());\n      eventBus.trigger(events.KEY_SESSION_REMOVED, {\n        data: sessionToken.getSessionID()\n      });\n    }, function (error) {\n      eventBus.trigger(events.KEY_SESSION_REMOVED, {\n        data: null,\n        error: 'Error removing session (' + sessionToken.getSessionID() + '). ' + error.name\n      });\n    });\n  }\n\n  function closeKeySession(sessionToken) {\n    // Send our request to the key session\n    closeKeySessionInternal(sessionToken).catch(function (error) {\n      removeSession(sessionToken);\n      eventBus.trigger(events.KEY_SESSION_CLOSED, {\n        data: null,\n        error: 'Error closing session (' + sessionToken.getSessionID() + ') ' + error.name\n      });\n    });\n  }\n\n  function requestKeySystemAccessInternal(ksConfigurations, idx) {\n    if (navigator.requestMediaKeySystemAccess === undefined || typeof navigator.requestMediaKeySystemAccess !== 'function') {\n      eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n        error: 'Insecure origins are not allowed'\n      });\n      return;\n    }\n\n    (function (i) {\n      var keySystem = ksConfigurations[i].ks;\n      var configs = ksConfigurations[i].configs;\n      var systemString = keySystem.systemString; // PATCH to support persistent licenses on Edge browser (see issue #2658)\n\n      if (systemString === _ProtectionConstants2.default.PLAYREADY_KEYSTEM_STRING && configs[0].persistentState === 'required') {\n        systemString += '.recommendation';\n      }\n\n      navigator.requestMediaKeySystemAccess(systemString, configs).then(function (mediaKeySystemAccess) {\n        // Chrome 40 does not currently implement MediaKeySystemAccess.getConfiguration()\n        var configuration = typeof mediaKeySystemAccess.getConfiguration === 'function' ? mediaKeySystemAccess.getConfiguration() : null;\n        var keySystemAccess = new _KeySystemAccess2.default(keySystem, configuration);\n        keySystemAccess.mksa = mediaKeySystemAccess;\n        eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n          data: keySystemAccess\n        });\n      }).catch(function (error) {\n        if (++i < ksConfigurations.length) {\n          requestKeySystemAccessInternal(ksConfigurations, i);\n        } else {\n          eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {\n            error: 'Key system access denied! ' + error.message\n          });\n        }\n      });\n    })(idx);\n  }\n\n  function closeKeySessionInternal(sessionToken) {\n    var session = sessionToken.session; // Remove event listeners\n\n    session.removeEventListener('keystatuseschange', sessionToken);\n    session.removeEventListener('message', sessionToken); // Send our request to the key session\n\n    return session.close();\n  } // This is our main event handler for all desired HTMLMediaElement events\n  // related to EME.  These events are translated into our API-independent\n  // versions of the same events\n\n\n  function createEventHandler() {\n    return {\n      handleEvent: function handleEvent(event) {\n        switch (event.type) {\n          case 'encrypted':\n            if (event.initData) {\n              var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n              eventBus.trigger(events.NEED_KEY, {\n                key: new _NeedKey2.default(initData, event.initDataType)\n              });\n            }\n\n            break;\n        }\n      }\n    };\n  }\n\n  function removeSession(token) {\n    // Remove from our session list\n    for (var i = 0; i < sessions.length; i++) {\n      if (sessions[i] === token) {\n        sessions.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  function parseKeyStatus(args) {\n    // Edge and Chrome implement different version of keystatues, param are not on same order\n    var status = void 0,\n        keyId = void 0;\n\n    if (args && args.length > 0) {\n      if (args[0]) {\n        if (typeof args[0] === 'string') {\n          status = args[0];\n        } else {\n          keyId = args[0];\n        }\n      }\n\n      if (args[1]) {\n        if (typeof args[1] === 'string') {\n          status = args[1];\n        } else {\n          keyId = args[1];\n        }\n      }\n    }\n\n    return {\n      status: status,\n      keyId: keyId\n    };\n  } // Function to create our session token objects which manage the EME\n  // MediaKeySession and session-specific event handler\n\n\n  function createSessionToken(session, initData, sessionType, sessionID) {\n    var token = {\n      // Implements SessionToken\n      session: session,\n      initData: initData,\n      sessionId: sessionID,\n      // This is our main event handler for all desired MediaKeySession events\n      // These events are translated into our API-independent versions of the\n      // same events\n      handleEvent: function handleEvent(event) {\n        switch (event.type) {\n          case 'keystatuseschange':\n            eventBus.trigger(events.KEY_STATUSES_CHANGED, {\n              data: this\n            });\n            event.target.keyStatuses.forEach(function () {\n              var keyStatus = parseKeyStatus(arguments);\n\n              switch (keyStatus.status) {\n                case 'expired':\n                  eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, {\n                    error: new _DashJSError2.default(_ProtectionErrors2.default.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE, _ProtectionErrors2.default.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE)\n                  });\n                  break;\n\n                default:\n                  eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, keyStatus);\n                  break;\n              }\n            });\n            break;\n\n          case 'message':\n            var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n            eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {\n              data: new _KeyMessage2.default(this, message, undefined, event.messageType)\n            });\n            break;\n        }\n      },\n      getSessionID: function getSessionID() {\n        return session.sessionId;\n      },\n      getExpirationTime: function getExpirationTime() {\n        return session.expiration;\n      },\n      getKeyStatuses: function getKeyStatuses() {\n        return session.keyStatuses;\n      },\n      getUsable: function getUsable() {\n        var usable = false;\n        session.keyStatuses.forEach(function () {\n          var keyStatus = parseKeyStatus(arguments);\n\n          if (keyStatus.status === 'usable') {\n            usable = true;\n          }\n        });\n        return usable;\n      },\n      getSessionType: function getSessionType() {\n        return sessionType;\n      }\n    }; // Add all event listeners\n\n    session.addEventListener('keystatuseschange', token);\n    session.addEventListener('message', token); // Register callback for session closed Promise\n\n    session.closed.then(function () {\n      removeSession(token);\n      logger.debug('DRM: Session closed.  SessionID = ' + token.getSessionID());\n      eventBus.trigger(events.KEY_SESSION_CLOSED, {\n        data: token.getSessionID()\n      });\n    }); // Add to our session list\n\n    sessions.push(token);\n    return token;\n  }\n\n  instance = {\n    getAllInitData: getAllInitData,\n    requestKeySystemAccess: requestKeySystemAccess,\n    getKeySystem: getKeySystem,\n    selectKeySystem: selectKeySystem,\n    setMediaElement: setMediaElement,\n    setServerCertificate: setServerCertificate,\n    createKeySession: createKeySession,\n    updateKeySession: updateKeySession,\n    loadKeySession: loadKeySession,\n    removeKeySession: removeKeySession,\n    closeKeySession: closeKeySession,\n    stop: stop,\n    reset: reset\n  };\n  setup();\n  return instance;\n}\n/**\n* The copyright in this software is being made available under the BSD License,\n* included below. This software may be subject to other third party and contributor\n* rights, including patent rights, and no such rights are granted under this license.\n*\n* Copyright (c) 2013, Dash Industry Forum.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*  * Redistributions of source code must retain the above copyright notice, this\n*  list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*  this list of conditions and the following disclaimer in the documentation and/or\n*  other materials provided with the distribution.\n*  * Neither the name of Dash Industry Forum nor the names of its\n*  contributors may be used to endorse or promote products derived from this software\n*  without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n*  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n*  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n*  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n* Most recent EME implementation\n*\n* Implemented by Google Chrome v36+ (Windows, OSX, Linux)\n*\n* @implements ProtectionModel\n* @class\n*/\n\n\nProtectionModel_21Jan2015.__dashjs_factory_name = 'ProtectionModel_21Jan2015';\nexports.default = dashjs.FactoryMaker.getClassFactory(ProtectionModel_21Jan2015);\n/* jshint ignore:line */","map":{"version":3,"sources":["../../../../../../src/streaming/protection/models/ProtectionModel_21Jan2015.js"],"names":["config","context","eventBus","events","debug","instance","logger","keySystem","videoElement","mediaKeys","sessions","eventHandler","protectionKeyController","createEventHandler","numSessions","session","done","removeSession","i","closeKeySessionInternal","retVal","requestKeySystemAccessInternal","keySystemAccess","error","DashJSError","ProtectionErrors","sessionToken","createSessionToken","ks","dataType","ProtectionConstants","initData","protData","data","message","sessionID","navigator","ksConfigurations","configs","systemString","configuration","mediaKeySystemAccess","KeySystemAccess","handleEvent","event","ArrayBuffer","key","NeedKey","status","keyId","args","token","sessionId","keyStatus","parseKeyStatus","KeyMessage","getSessionID","getExpirationTime","getKeyStatuses","getUsable","usable","getSessionType","getAllInitData","requestKeySystemAccess","getKeySystem","selectKeySystem","setMediaElement","setServerCertificate","createKeySession","updateKeySession","loadKeySession","removeKeySession","closeKeySession","stop","reset","setup","ProtectionModel_21Jan2015","dashjs"],"mappings":"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","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Most recent EME implementation\n *\n * Implemented by Google Chrome v36+ (Windows, OSX, Linux)\n *\n * @implements ProtectionModel\n * @class\n */\nimport ProtectionKeyController from '../controllers/ProtectionKeyController';\nimport NeedKey from '../vo/NeedKey';\nimport ProtectionErrors from '../errors/ProtectionErrors';\nimport DashJSError from '../../vo/DashJSError';\nimport KeyMessage from '../vo/KeyMessage';\nimport KeySystemAccess from '../vo/KeySystemAccess';\nimport ProtectionConstants from '../../constants/ProtectionConstants';\n\nfunction ProtectionModel_21Jan2015(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module\n    const events = config.events;\n    const debug = config.debug;\n\n    let instance,\n        logger,\n        keySystem,\n        videoElement,\n        mediaKeys,\n        sessions,\n        eventHandler,\n        protectionKeyController;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        keySystem = null;\n        videoElement = null;\n        mediaKeys = null;\n        sessions = [];\n        protectionKeyController = ProtectionKeyController(context).getInstance();\n        eventHandler = createEventHandler();\n    }\n\n    function reset() {\n        const numSessions = sessions.length;\n        let session;\n\n        if (numSessions !== 0) {\n            // Called when we are done closing a session.  Success or fail\n            const done = function (session) {\n                removeSession(session);\n                if (sessions.length === 0) {\n                    if (videoElement) {\n                        videoElement.removeEventListener('encrypted', eventHandler);\n                        videoElement.setMediaKeys(null).then(function () {\n                            eventBus.trigger(events.TEARDOWN_COMPLETE);\n                        });\n                    } else {\n                        eventBus.trigger(events.TEARDOWN_COMPLETE);\n                    }\n                }\n            };\n            for (let i = 0; i < numSessions; i++) {\n                session = sessions[i];\n                (function (s) {\n                    // Override closed promise resolver\n                    session.session.closed.then(function () {\n                        done(s);\n                    });\n                    // Close the session and handle errors, otherwise promise\n                    // resolver above will be called\n                    closeKeySessionInternal(session).catch(function () {\n                        done(s);\n                    });\n\n                })(session);\n            }\n        } else {\n            eventBus.trigger(events.TEARDOWN_COMPLETE);\n        }\n    }\n\n    function stop() {\n        // Close and remove not usable sessions\n        let session;\n        for (let i = 0; i < sessions.length; i++) {\n            session = sessions[i];\n            if (!session.getUsable()) {\n                closeKeySessionInternal(session).catch(function () {\n                    removeSession(session);\n                });\n            }\n        }\n    }\n\n    function getKeySystem() {\n        return keySystem;\n    }\n\n    function getAllInitData() {\n        const retVal = [];\n        for (let i = 0; i < sessions.length; i++) {\n            if (sessions[i].initData) {\n                retVal.push(sessions[i].initData);\n            }\n        }\n        return retVal;\n    }\n\n    function requestKeySystemAccess(ksConfigurations) {\n        requestKeySystemAccessInternal(ksConfigurations, 0);\n    }\n\n    function selectKeySystem(keySystemAccess) {\n        keySystemAccess.mksa.createMediaKeys().then(function (mkeys) {\n            keySystem = keySystemAccess.keySystem;\n            mediaKeys = mkeys;\n            if (videoElement) {\n                videoElement.setMediaKeys(mediaKeys).then(function () {\n                    eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n                });\n            } else {\n                eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n            }\n\n        }).catch(function () {\n            eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED, { error: 'Error selecting keys system (' + keySystemAccess.keySystem.systemString + ')! Could not create MediaKeys -- TODO' });\n        });\n    }\n\n    function setMediaElement(mediaElement) {\n        if (videoElement === mediaElement)\n            return;\n\n        // Replacing the previous element\n        if (videoElement) {\n            videoElement.removeEventListener('encrypted', eventHandler);\n            if (videoElement.setMediaKeys) {\n                videoElement.setMediaKeys(null);\n            }\n        }\n\n        videoElement = mediaElement;\n\n        // Only if we are not detaching from the existing element\n        if (videoElement) {\n            videoElement.addEventListener('encrypted', eventHandler);\n            if (videoElement.setMediaKeys && mediaKeys) {\n                videoElement.setMediaKeys(mediaKeys);\n            }\n        }\n    }\n\n    function setServerCertificate(serverCertificate) {\n        if (!keySystem || !mediaKeys) {\n            throw new Error('Can not set server certificate until you have selected a key system');\n        }\n        mediaKeys.setServerCertificate(serverCertificate).then(function () {\n            logger.info('DRM: License server certificate successfully updated.');\n            eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED);\n        }).catch(function (error) {\n            eventBus.trigger(events.SERVER_CERTIFICATE_UPDATED, { error: new DashJSError(ProtectionErrors.SERVER_CERTIFICATE_UPDATED_ERROR_CODE, ProtectionErrors.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE + error.name) });\n        });\n    }\n\n    function createKeySession(initData, protData, sessionType) {\n        if (!keySystem || !mediaKeys) {\n            throw new Error('Can not create sessions until you have selected a key system');\n        }\n\n        const session = mediaKeys.createSession(sessionType);\n        const sessionToken = createSessionToken(session, initData, sessionType);\n        const ks = this.getKeySystem();\n\n        // Generate initial key request.\n        // keyids type is used for clearkey when keys are provided directly in the protection data and then request to a license server is not needed\n        const dataType = ks.systemString === ProtectionConstants.CLEARKEY_KEYSTEM_STRING && (initData ||  (protData && protData.clearkeys)) ? 'keyids' : 'cenc';\n        session.generateRequest(dataType, initData).then(function () {\n            logger.debug('DRM: Session created.  SessionID = ' + sessionToken.getSessionID());\n            eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken });\n        }).catch(function (error) {\n            // TODO: Better error string\n            removeSession(sessionToken);\n            eventBus.trigger(events.KEY_SESSION_CREATED, {\n                data: null,\n                error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Error generating key request -- ' + error.name)\n            });\n        });\n    }\n\n    function updateKeySession(sessionToken, message) {\n        const session = sessionToken.session;\n\n        // Send our request to the key session\n        if (protectionKeyController.isClearKey(keySystem)) {\n            message = message.toJWK();\n        }\n        session.update(message).catch(function (error) {\n            eventBus.trigger(events.KEY_ERROR, { data: new DashJSError(ProtectionErrors.MEDIA_KEYERR_CODE, 'Error sending update() message! ' + error.name, sessionToken) });\n        });\n    }\n\n    function loadKeySession(sessionID, initData, sessionType) {\n        if (!keySystem || !mediaKeys) {\n            throw new Error('Can not load sessions until you have selected a key system');\n        }\n\n        // Check if session Id is not already loaded or loading\n        for (let i = 0; i < sessions.length; i++) {\n            if (sessionID === sessions[i].sessionId) {\n                logger.warn('DRM: Ignoring session ID because we have already seen it!');\n                return;\n            }\n        }\n\n        const session = mediaKeys.createSession(sessionType);\n        const sessionToken = createSessionToken(session, initData, sessionType, sessionID);\n\n        // Load persisted session data into our newly created session object\n        session.load(sessionID).then(function (success) {\n            if (success) {\n                logger.debug('DRM: Session loaded.  SessionID = ' + sessionToken.getSessionID());\n                eventBus.trigger(events.KEY_SESSION_CREATED, { data: sessionToken });\n            } else {\n                removeSession(sessionToken);\n                eventBus.trigger(events.KEY_SESSION_CREATED, {\n                    data: null,\n                    error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session! Invalid Session ID (' + sessionID + ')')\n                });\n            }\n        }).catch(function (error) {\n            removeSession(sessionToken);\n            eventBus.trigger(events.KEY_SESSION_CREATED, {\n                data: null,\n                error: new DashJSError(ProtectionErrors.KEY_SESSION_CREATED_ERROR_CODE, ProtectionErrors.KEY_SESSION_CREATED_ERROR_MESSAGE + 'Could not load session (' + sessionID + ')! ' + error.name)\n            });\n        });\n    }\n\n    function removeKeySession(sessionToken) {\n        const session = sessionToken.session;\n\n        session.remove().then(function () {\n            logger.debug('DRM: Session removed.  SessionID = ' + sessionToken.getSessionID());\n            eventBus.trigger(events.KEY_SESSION_REMOVED, { data: sessionToken.getSessionID() });\n        }, function (error) {\n            eventBus.trigger(events.KEY_SESSION_REMOVED, {\n                data: null,\n                error: 'Error removing session (' + sessionToken.getSessionID() + '). ' + error.name\n            });\n\n        });\n    }\n\n    function closeKeySession(sessionToken) {\n        // Send our request to the key session\n        closeKeySessionInternal(sessionToken).catch(function (error) {\n            removeSession(sessionToken);\n            eventBus.trigger(events.KEY_SESSION_CLOSED, {\n                data: null,\n                error: 'Error closing session (' + sessionToken.getSessionID() + ') ' + error.name\n            });\n        });\n    }\n\n    function requestKeySystemAccessInternal(ksConfigurations, idx) {\n\n        if (navigator.requestMediaKeySystemAccess === undefined ||\n            typeof navigator.requestMediaKeySystemAccess !== 'function') {\n            eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Insecure origins are not allowed' });\n            return;\n        }\n\n        (function (i) {\n            const keySystem = ksConfigurations[i].ks;\n            const configs = ksConfigurations[i].configs;\n            let systemString = keySystem.systemString;\n\n            // PATCH to support persistent licenses on Edge browser (see issue #2658)\n            if (systemString === ProtectionConstants.PLAYREADY_KEYSTEM_STRING && configs[0].persistentState === 'required') {\n                systemString += '.recommendation';\n            }\n\n            navigator.requestMediaKeySystemAccess(systemString, configs).then(function (mediaKeySystemAccess) {\n                // Chrome 40 does not currently implement MediaKeySystemAccess.getConfiguration()\n                const configuration = (typeof mediaKeySystemAccess.getConfiguration === 'function') ?\n                    mediaKeySystemAccess.getConfiguration() : null;\n                const keySystemAccess = new KeySystemAccess(keySystem, configuration);\n                keySystemAccess.mksa = mediaKeySystemAccess;\n                eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: keySystemAccess });\n\n            }).catch(function (error) {\n                if (++i < ksConfigurations.length) {\n                    requestKeySystemAccessInternal(ksConfigurations, i);\n                } else {\n                    eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { error: 'Key system access denied! ' + error.message });\n                }\n            });\n        })(idx);\n    }\n\n    function closeKeySessionInternal(sessionToken) {\n        const session = sessionToken.session;\n\n        // Remove event listeners\n        session.removeEventListener('keystatuseschange', sessionToken);\n        session.removeEventListener('message', sessionToken);\n\n        // Send our request to the key session\n        return session.close();\n    }\n\n    // This is our main event handler for all desired HTMLMediaElement events\n    // related to EME.  These events are translated into our API-independent\n    // versions of the same events\n    function createEventHandler() {\n        return {\n            handleEvent: function (event) {\n                switch (event.type) {\n                    case 'encrypted':\n                        if (event.initData) {\n                            let initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                            eventBus.trigger(events.NEED_KEY, { key: new NeedKey(initData, event.initDataType) });\n                        }\n                        break;\n                }\n            }\n        };\n    }\n\n    function removeSession(token) {\n        // Remove from our session list\n        for (let i = 0; i < sessions.length; i++) {\n            if (sessions[i] === token) {\n                sessions.splice(i, 1);\n                break;\n            }\n        }\n    }\n\n    function parseKeyStatus(args) {\n        // Edge and Chrome implement different version of keystatues, param are not on same order\n        let status, keyId;\n        if (args && args.length > 0) {\n            if (args[0]) {\n                if (typeof args[0] === 'string') {\n                    status = args[0];\n                } else {\n                    keyId = args[0];\n                }\n            }\n\n            if (args[1]) {\n                if (typeof args[1] === 'string') {\n                    status = args[1];\n                } else {\n                    keyId = args[1];\n                }\n            }\n        }\n        return {\n            status: status,\n            keyId: keyId\n        };\n    }\n\n    // Function to create our session token objects which manage the EME\n    // MediaKeySession and session-specific event handler\n    function createSessionToken(session, initData, sessionType, sessionID) {\n        const token = { // Implements SessionToken\n            session: session,\n            initData: initData,\n            sessionId: sessionID,\n\n            // This is our main event handler for all desired MediaKeySession events\n            // These events are translated into our API-independent versions of the\n            // same events\n            handleEvent: function (event) {\n                switch (event.type) {\n                    case 'keystatuseschange':\n                        eventBus.trigger(events.KEY_STATUSES_CHANGED, { data: this });\n                        event.target.keyStatuses.forEach(function () {\n                            let keyStatus = parseKeyStatus(arguments);\n                            switch (keyStatus.status) {\n                                case 'expired':\n                                    eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, { error: new DashJSError(ProtectionErrors.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE, ProtectionErrors.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE) });\n                                    break;\n                                default:\n                                    eventBus.trigger(events.INTERNAL_KEY_STATUS_CHANGED, keyStatus);\n                                    break;\n                            }\n                        });\n                        break;\n\n                    case 'message':\n                        let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n                        eventBus.trigger(events.INTERNAL_KEY_MESSAGE, { data: new KeyMessage(this, message, undefined, event.messageType) });\n                        break;\n                }\n            },\n\n            getSessionID: function () {\n                return session.sessionId;\n            },\n\n            getExpirationTime: function () {\n                return session.expiration;\n            },\n\n            getKeyStatuses: function () {\n                return session.keyStatuses;\n            },\n\n            getUsable: function () {\n                let usable = false;\n                session.keyStatuses.forEach(function () {\n                    let keyStatus = parseKeyStatus(arguments);\n                    if (keyStatus.status === 'usable') {\n                        usable = true;\n                    }\n                });\n                return usable;\n            },\n\n            getSessionType: function () {\n                return sessionType;\n            }\n        };\n\n        // Add all event listeners\n        session.addEventListener('keystatuseschange', token);\n        session.addEventListener('message', token);\n\n        // Register callback for session closed Promise\n        session.closed.then(function () {\n            removeSession(token);\n            logger.debug('DRM: Session closed.  SessionID = ' + token.getSessionID());\n            eventBus.trigger(events.KEY_SESSION_CLOSED, { data: token.getSessionID() });\n        });\n\n        // Add to our session list\n        sessions.push(token);\n\n        return token;\n    }\n\n    instance = {\n        getAllInitData: getAllInitData,\n        requestKeySystemAccess: requestKeySystemAccess,\n        getKeySystem: getKeySystem,\n        selectKeySystem: selectKeySystem,\n        setMediaElement: setMediaElement,\n        setServerCertificate: setServerCertificate,\n        createKeySession: createKeySession,\n        updateKeySession: updateKeySession,\n        loadKeySession: loadKeySession,\n        removeKeySession: removeKeySession,\n        closeKeySession: closeKeySession,\n        stop: stop,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nProtectionModel_21Jan2015.__dashjs_factory_name = 'ProtectionModel_21Jan2015';\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionModel_21Jan2015); /* jshint ignore:line */\n"]},"metadata":{},"sourceType":"script"}